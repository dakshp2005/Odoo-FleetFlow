"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@ai-sdk";
exports.ids = ["vendor-chunks/@ai-sdk"];
exports.modules = {

/***/ "(ssr)/./node_modules/@ai-sdk/gateway/dist/index.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@ai-sdk/gateway/dist/index.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GatewayAuthenticationError: () => (/* binding */ GatewayAuthenticationError),\n/* harmony export */   GatewayError: () => (/* binding */ GatewayError),\n/* harmony export */   GatewayInternalServerError: () => (/* binding */ GatewayInternalServerError),\n/* harmony export */   GatewayInvalidRequestError: () => (/* binding */ GatewayInvalidRequestError),\n/* harmony export */   GatewayModelNotFoundError: () => (/* binding */ GatewayModelNotFoundError),\n/* harmony export */   GatewayRateLimitError: () => (/* binding */ GatewayRateLimitError),\n/* harmony export */   GatewayResponseError: () => (/* binding */ GatewayResponseError),\n/* harmony export */   createGateway: () => (/* binding */ createGatewayProvider),\n/* harmony export */   createGatewayProvider: () => (/* binding */ createGatewayProvider),\n/* harmony export */   gateway: () => (/* binding */ gateway)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(ssr)/./node_modules/@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ai-sdk/provider */ \"(ssr)/./node_modules/@ai-sdk/gateway/node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var zod_v4__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zod/v4 */ \"(ssr)/./node_modules/zod/v4/classic/schemas.js\");\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zod */ \"(ssr)/./node_modules/zod/v3/types.js\");\n/* harmony import */ var _vercel_oidc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @vercel/oidc */ \"(ssr)/./node_modules/@vercel/oidc/dist/index.js\");\n// src/gateway-provider.ts\n\n\n// src/errors/as-gateway-error.ts\n\n\n// src/errors/create-gateway-error.ts\n\n\n// src/errors/gateway-error.ts\nvar marker = \"vercel.ai.gateway.error\";\nvar symbol = Symbol.for(marker);\nvar _a, _b;\nvar GatewayError = class _GatewayError extends (_b = Error, _a = symbol, _b) {\n  constructor({\n    message,\n    statusCode = 500,\n    cause,\n    generationId\n  }) {\n    super(generationId ? `${message} [${generationId}]` : message);\n    this[_a] = true;\n    this.statusCode = statusCode;\n    this.cause = cause;\n    this.generationId = generationId;\n  }\n  /**\n   * Checks if the given error is a Gateway Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is a Gateway Error, false otherwise.\n   */\n  static isInstance(error) {\n    return _GatewayError.hasMarker(error);\n  }\n  static hasMarker(error) {\n    return typeof error === \"object\" && error !== null && symbol in error && error[symbol] === true;\n  }\n};\n\n// src/errors/gateway-authentication-error.ts\nvar name = \"GatewayAuthenticationError\";\nvar marker2 = `vercel.ai.gateway.error.${name}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2, _b2;\nvar GatewayAuthenticationError = class _GatewayAuthenticationError extends (_b2 = GatewayError, _a2 = symbol2, _b2) {\n  constructor({\n    message = \"Authentication failed\",\n    statusCode = 401,\n    cause,\n    generationId\n  } = {}) {\n    super({ message, statusCode, cause, generationId });\n    this[_a2] = true;\n    // used in isInstance\n    this.name = name;\n    this.type = \"authentication_error\";\n  }\n  static isInstance(error) {\n    return GatewayError.hasMarker(error) && symbol2 in error;\n  }\n  /**\n   * Creates a contextual error message when authentication fails\n   */\n  static createContextualError({\n    apiKeyProvided,\n    oidcTokenProvided,\n    message = \"Authentication failed\",\n    statusCode = 401,\n    cause,\n    generationId\n  }) {\n    let contextualMessage;\n    if (apiKeyProvided) {\n      contextualMessage = `AI Gateway authentication failed: Invalid API key.\n\nCreate a new API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys\n\nProvide via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.`;\n    } else if (oidcTokenProvided) {\n      contextualMessage = `AI Gateway authentication failed: Invalid OIDC token.\n\nRun 'npx vercel link' to link your project, then 'vc env pull' to fetch the token.\n\nAlternatively, use an API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys`;\n    } else {\n      contextualMessage = `AI Gateway authentication failed: No authentication provided.\n\nOption 1 - API key:\nCreate an API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys\nProvide via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.\n\nOption 2 - OIDC token:\nRun 'npx vercel link' to link your project, then 'vc env pull' to fetch the token.`;\n    }\n    return new _GatewayAuthenticationError({\n      message: contextualMessage,\n      statusCode,\n      cause,\n      generationId\n    });\n  }\n};\n\n// src/errors/gateway-invalid-request-error.ts\nvar name2 = \"GatewayInvalidRequestError\";\nvar marker3 = `vercel.ai.gateway.error.${name2}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3, _b3;\nvar GatewayInvalidRequestError = class extends (_b3 = GatewayError, _a3 = symbol3, _b3) {\n  constructor({\n    message = \"Invalid request\",\n    statusCode = 400,\n    cause,\n    generationId\n  } = {}) {\n    super({ message, statusCode, cause, generationId });\n    this[_a3] = true;\n    // used in isInstance\n    this.name = name2;\n    this.type = \"invalid_request_error\";\n  }\n  static isInstance(error) {\n    return GatewayError.hasMarker(error) && symbol3 in error;\n  }\n};\n\n// src/errors/gateway-rate-limit-error.ts\nvar name3 = \"GatewayRateLimitError\";\nvar marker4 = `vercel.ai.gateway.error.${name3}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4, _b4;\nvar GatewayRateLimitError = class extends (_b4 = GatewayError, _a4 = symbol4, _b4) {\n  constructor({\n    message = \"Rate limit exceeded\",\n    statusCode = 429,\n    cause,\n    generationId\n  } = {}) {\n    super({ message, statusCode, cause, generationId });\n    this[_a4] = true;\n    // used in isInstance\n    this.name = name3;\n    this.type = \"rate_limit_exceeded\";\n  }\n  static isInstance(error) {\n    return GatewayError.hasMarker(error) && symbol4 in error;\n  }\n};\n\n// src/errors/gateway-model-not-found-error.ts\n\n\nvar name4 = \"GatewayModelNotFoundError\";\nvar marker5 = `vercel.ai.gateway.error.${name4}`;\nvar symbol5 = Symbol.for(marker5);\nvar modelNotFoundParamSchema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.lazySchema)(\n  () => (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.zodSchema)(\n    zod_v4__WEBPACK_IMPORTED_MODULE_1__.object({\n      modelId: zod_v4__WEBPACK_IMPORTED_MODULE_1__.string()\n    })\n  )\n);\nvar _a5, _b5;\nvar GatewayModelNotFoundError = class extends (_b5 = GatewayError, _a5 = symbol5, _b5) {\n  constructor({\n    message = \"Model not found\",\n    statusCode = 404,\n    modelId,\n    cause,\n    generationId\n  } = {}) {\n    super({ message, statusCode, cause, generationId });\n    this[_a5] = true;\n    // used in isInstance\n    this.name = name4;\n    this.type = \"model_not_found\";\n    this.modelId = modelId;\n  }\n  static isInstance(error) {\n    return GatewayError.hasMarker(error) && symbol5 in error;\n  }\n};\n\n// src/errors/gateway-internal-server-error.ts\nvar name5 = \"GatewayInternalServerError\";\nvar marker6 = `vercel.ai.gateway.error.${name5}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6, _b6;\nvar GatewayInternalServerError = class extends (_b6 = GatewayError, _a6 = symbol6, _b6) {\n  constructor({\n    message = \"Internal server error\",\n    statusCode = 500,\n    cause,\n    generationId\n  } = {}) {\n    super({ message, statusCode, cause, generationId });\n    this[_a6] = true;\n    // used in isInstance\n    this.name = name5;\n    this.type = \"internal_server_error\";\n  }\n  static isInstance(error) {\n    return GatewayError.hasMarker(error) && symbol6 in error;\n  }\n};\n\n// src/errors/gateway-response-error.ts\nvar name6 = \"GatewayResponseError\";\nvar marker7 = `vercel.ai.gateway.error.${name6}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7, _b7;\nvar GatewayResponseError = class extends (_b7 = GatewayError, _a7 = symbol7, _b7) {\n  constructor({\n    message = \"Invalid response from Gateway\",\n    statusCode = 502,\n    response,\n    validationError,\n    cause,\n    generationId\n  } = {}) {\n    super({ message, statusCode, cause, generationId });\n    this[_a7] = true;\n    // used in isInstance\n    this.name = name6;\n    this.type = \"response_error\";\n    this.response = response;\n    this.validationError = validationError;\n  }\n  static isInstance(error) {\n    return GatewayError.hasMarker(error) && symbol7 in error;\n  }\n};\n\n// src/errors/create-gateway-error.ts\n\nasync function createGatewayErrorFromResponse({\n  response,\n  statusCode,\n  defaultMessage = \"Gateway request failed\",\n  cause,\n  authMethod\n}) {\n  var _a9;\n  const parseResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.safeValidateTypes)({\n    value: response,\n    schema: gatewayErrorResponseSchema\n  });\n  if (!parseResult.success) {\n    const rawGenerationId = typeof response === \"object\" && response !== null && \"generationId\" in response ? response.generationId : void 0;\n    return new GatewayResponseError({\n      message: `Invalid error response format: ${defaultMessage}`,\n      statusCode,\n      response,\n      validationError: parseResult.error,\n      cause,\n      generationId: rawGenerationId\n    });\n  }\n  const validatedResponse = parseResult.value;\n  const errorType = validatedResponse.error.type;\n  const message = validatedResponse.error.message;\n  const generationId = (_a9 = validatedResponse.generationId) != null ? _a9 : void 0;\n  switch (errorType) {\n    case \"authentication_error\":\n      return GatewayAuthenticationError.createContextualError({\n        apiKeyProvided: authMethod === \"api-key\",\n        oidcTokenProvided: authMethod === \"oidc\",\n        statusCode,\n        cause,\n        generationId\n      });\n    case \"invalid_request_error\":\n      return new GatewayInvalidRequestError({\n        message,\n        statusCode,\n        cause,\n        generationId\n      });\n    case \"rate_limit_exceeded\":\n      return new GatewayRateLimitError({\n        message,\n        statusCode,\n        cause,\n        generationId\n      });\n    case \"model_not_found\": {\n      const modelResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.safeValidateTypes)({\n        value: validatedResponse.error.param,\n        schema: modelNotFoundParamSchema\n      });\n      return new GatewayModelNotFoundError({\n        message,\n        statusCode,\n        modelId: modelResult.success ? modelResult.value.modelId : void 0,\n        cause,\n        generationId\n      });\n    }\n    case \"internal_server_error\":\n      return new GatewayInternalServerError({\n        message,\n        statusCode,\n        cause,\n        generationId\n      });\n    default:\n      return new GatewayInternalServerError({\n        message,\n        statusCode,\n        cause,\n        generationId\n      });\n  }\n}\nvar gatewayErrorResponseSchema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.lazySchema)(\n  () => (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.zodSchema)(\n    zod_v4__WEBPACK_IMPORTED_MODULE_1__.object({\n      error: zod_v4__WEBPACK_IMPORTED_MODULE_1__.object({\n        message: zod_v4__WEBPACK_IMPORTED_MODULE_1__.string(),\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_1__.string().nullish(),\n        param: zod_v4__WEBPACK_IMPORTED_MODULE_1__.unknown().nullish(),\n        code: zod_v4__WEBPACK_IMPORTED_MODULE_1__.union([zod_v4__WEBPACK_IMPORTED_MODULE_1__.string(), zod_v4__WEBPACK_IMPORTED_MODULE_1__.number()]).nullish()\n      }),\n      generationId: zod_v4__WEBPACK_IMPORTED_MODULE_1__.string().nullish()\n    })\n  )\n);\n\n// src/errors/gateway-timeout-error.ts\nvar name7 = \"GatewayTimeoutError\";\nvar marker8 = `vercel.ai.gateway.error.${name7}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8, _b8;\nvar GatewayTimeoutError = class _GatewayTimeoutError extends (_b8 = GatewayError, _a8 = symbol8, _b8) {\n  constructor({\n    message = \"Request timed out\",\n    statusCode = 408,\n    cause,\n    generationId\n  } = {}) {\n    super({ message, statusCode, cause, generationId });\n    this[_a8] = true;\n    // used in isInstance\n    this.name = name7;\n    this.type = \"timeout_error\";\n  }\n  static isInstance(error) {\n    return GatewayError.hasMarker(error) && symbol8 in error;\n  }\n  /**\n   * Creates a helpful timeout error message with troubleshooting guidance\n   */\n  static createTimeoutError({\n    originalMessage,\n    statusCode = 408,\n    cause,\n    generationId\n  }) {\n    const message = `Gateway request timed out: ${originalMessage}\n\n    This is a client-side timeout. To resolve this, increase your timeout configuration: https://vercel.com/docs/ai-gateway/capabilities/video-generation#extending-timeouts-for-node.js`;\n    return new _GatewayTimeoutError({\n      message,\n      statusCode,\n      cause,\n      generationId\n    });\n  }\n};\n\n// src/errors/as-gateway-error.ts\nfunction isTimeoutError(error) {\n  if (!(error instanceof Error)) {\n    return false;\n  }\n  const errorCode = error.code;\n  if (typeof errorCode === \"string\") {\n    const undiciTimeoutCodes = [\n      \"UND_ERR_HEADERS_TIMEOUT\",\n      \"UND_ERR_BODY_TIMEOUT\",\n      \"UND_ERR_CONNECT_TIMEOUT\"\n    ];\n    return undiciTimeoutCodes.includes(errorCode);\n  }\n  return false;\n}\nasync function asGatewayError(error, authMethod) {\n  var _a9;\n  if (GatewayError.isInstance(error)) {\n    return error;\n  }\n  if (isTimeoutError(error)) {\n    return GatewayTimeoutError.createTimeoutError({\n      originalMessage: error instanceof Error ? error.message : \"Unknown error\",\n      cause: error\n    });\n  }\n  if (_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_2__.APICallError.isInstance(error)) {\n    if (error.cause && isTimeoutError(error.cause)) {\n      return GatewayTimeoutError.createTimeoutError({\n        originalMessage: error.message,\n        cause: error\n      });\n    }\n    return await createGatewayErrorFromResponse({\n      response: extractApiCallResponse(error),\n      statusCode: (_a9 = error.statusCode) != null ? _a9 : 500,\n      defaultMessage: \"Gateway request failed\",\n      cause: error,\n      authMethod\n    });\n  }\n  return await createGatewayErrorFromResponse({\n    response: {},\n    statusCode: 500,\n    defaultMessage: error instanceof Error ? `Gateway request failed: ${error.message}` : \"Unknown Gateway error\",\n    cause: error,\n    authMethod\n  });\n}\n\n// src/errors/extract-api-call-response.ts\nfunction extractApiCallResponse(error) {\n  if (error.data !== void 0) {\n    return error.data;\n  }\n  if (error.responseBody != null) {\n    try {\n      return JSON.parse(error.responseBody);\n    } catch (e) {\n      return error.responseBody;\n    }\n  }\n  return {};\n}\n\n// src/errors/parse-auth-method.ts\n\n\nvar GATEWAY_AUTH_METHOD_HEADER = \"ai-gateway-auth-method\";\nasync function parseAuthMethod(headers) {\n  const result = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.safeValidateTypes)({\n    value: headers[GATEWAY_AUTH_METHOD_HEADER],\n    schema: gatewayAuthMethodSchema\n  });\n  return result.success ? result.value : void 0;\n}\nvar gatewayAuthMethodSchema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.lazySchema)(\n  () => (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.zodSchema)(zod_v4__WEBPACK_IMPORTED_MODULE_1__.union([zod_v4__WEBPACK_IMPORTED_MODULE_1__.literal(\"api-key\"), zod_v4__WEBPACK_IMPORTED_MODULE_1__.literal(\"oidc\")]))\n);\n\n// src/gateway-fetch-metadata.ts\n\n\nvar GatewayFetchMetadata = class {\n  constructor(config) {\n    this.config = config;\n  }\n  async getAvailableModels() {\n    try {\n      const { value } = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.getFromApi)({\n        url: `${this.config.baseURL}/config`,\n        headers: await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.resolve)(this.config.headers()),\n        successfulResponseHandler: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createJsonResponseHandler)(\n          gatewayAvailableModelsResponseSchema\n        ),\n        failedResponseHandler: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createJsonErrorResponseHandler)({\n          errorSchema: zod_v4__WEBPACK_IMPORTED_MODULE_1__.any(),\n          errorToMessage: (data) => data\n        }),\n        fetch: this.config.fetch\n      });\n      return value;\n    } catch (error) {\n      throw await asGatewayError(error);\n    }\n  }\n  async getCredits() {\n    try {\n      const baseUrl = new URL(this.config.baseURL);\n      const { value } = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.getFromApi)({\n        url: `${baseUrl.origin}/v1/credits`,\n        headers: await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.resolve)(this.config.headers()),\n        successfulResponseHandler: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createJsonResponseHandler)(\n          gatewayCreditsResponseSchema\n        ),\n        failedResponseHandler: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createJsonErrorResponseHandler)({\n          errorSchema: zod_v4__WEBPACK_IMPORTED_MODULE_1__.any(),\n          errorToMessage: (data) => data\n        }),\n        fetch: this.config.fetch\n      });\n      return value;\n    } catch (error) {\n      throw await asGatewayError(error);\n    }\n  }\n};\nvar gatewayAvailableModelsResponseSchema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.lazySchema)(\n  () => (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.zodSchema)(\n    zod_v4__WEBPACK_IMPORTED_MODULE_1__.object({\n      models: zod_v4__WEBPACK_IMPORTED_MODULE_1__.array(\n        zod_v4__WEBPACK_IMPORTED_MODULE_1__.object({\n          id: zod_v4__WEBPACK_IMPORTED_MODULE_1__.string(),\n          name: zod_v4__WEBPACK_IMPORTED_MODULE_1__.string(),\n          description: zod_v4__WEBPACK_IMPORTED_MODULE_1__.string().nullish(),\n          pricing: zod_v4__WEBPACK_IMPORTED_MODULE_1__.object({\n            input: zod_v4__WEBPACK_IMPORTED_MODULE_1__.string(),\n            output: zod_v4__WEBPACK_IMPORTED_MODULE_1__.string(),\n            input_cache_read: zod_v4__WEBPACK_IMPORTED_MODULE_1__.string().nullish(),\n            input_cache_write: zod_v4__WEBPACK_IMPORTED_MODULE_1__.string().nullish()\n          }).transform(\n            ({ input, output, input_cache_read, input_cache_write }) => ({\n              input,\n              output,\n              ...input_cache_read ? { cachedInputTokens: input_cache_read } : {},\n              ...input_cache_write ? { cacheCreationInputTokens: input_cache_write } : {}\n            })\n          ).nullish(),\n          specification: zod_v4__WEBPACK_IMPORTED_MODULE_1__.object({\n            specificationVersion: zod_v4__WEBPACK_IMPORTED_MODULE_1__.literal(\"v3\"),\n            provider: zod_v4__WEBPACK_IMPORTED_MODULE_1__.string(),\n            modelId: zod_v4__WEBPACK_IMPORTED_MODULE_1__.string()\n          }),\n          modelType: zod_v4__WEBPACK_IMPORTED_MODULE_1__[\"enum\"]([\"embedding\", \"image\", \"language\", \"video\"]).nullish()\n        })\n      )\n    })\n  )\n);\nvar gatewayCreditsResponseSchema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.lazySchema)(\n  () => (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.zodSchema)(\n    zod_v4__WEBPACK_IMPORTED_MODULE_1__.object({\n      balance: zod_v4__WEBPACK_IMPORTED_MODULE_1__.string(),\n      total_used: zod_v4__WEBPACK_IMPORTED_MODULE_1__.string()\n    }).transform(({ balance, total_used }) => ({\n      balance,\n      totalUsed: total_used\n    }))\n  )\n);\n\n// src/gateway-language-model.ts\n\n\nvar GatewayLanguageModel = class {\n  constructor(modelId, config) {\n    this.modelId = modelId;\n    this.config = config;\n    this.specificationVersion = \"v3\";\n    this.supportedUrls = { \"*/*\": [/.*/] };\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async getArgs(options) {\n    const { abortSignal: _abortSignal, ...optionsWithoutSignal } = options;\n    return {\n      args: this.maybeEncodeFileParts(optionsWithoutSignal),\n      warnings: []\n    };\n  }\n  async doGenerate(options) {\n    const { args, warnings } = await this.getArgs(options);\n    const { abortSignal } = options;\n    const resolvedHeaders = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.resolve)(this.config.headers());\n    try {\n      const {\n        responseHeaders,\n        value: responseBody,\n        rawValue: rawResponse\n      } = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.postJsonToApi)({\n        url: this.getUrl(),\n        headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.combineHeaders)(\n          resolvedHeaders,\n          options.headers,\n          this.getModelConfigHeaders(this.modelId, false),\n          await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.resolve)(this.config.o11yHeaders)\n        ),\n        body: args,\n        successfulResponseHandler: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createJsonResponseHandler)(zod_v4__WEBPACK_IMPORTED_MODULE_1__.any()),\n        failedResponseHandler: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createJsonErrorResponseHandler)({\n          errorSchema: zod_v4__WEBPACK_IMPORTED_MODULE_1__.any(),\n          errorToMessage: (data) => data\n        }),\n        ...abortSignal && { abortSignal },\n        fetch: this.config.fetch\n      });\n      return {\n        ...responseBody,\n        request: { body: args },\n        response: { headers: responseHeaders, body: rawResponse },\n        warnings\n      };\n    } catch (error) {\n      throw await asGatewayError(error, await parseAuthMethod(resolvedHeaders));\n    }\n  }\n  async doStream(options) {\n    const { args, warnings } = await this.getArgs(options);\n    const { abortSignal } = options;\n    const resolvedHeaders = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.resolve)(this.config.headers());\n    try {\n      const { value: response, responseHeaders } = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.postJsonToApi)({\n        url: this.getUrl(),\n        headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.combineHeaders)(\n          resolvedHeaders,\n          options.headers,\n          this.getModelConfigHeaders(this.modelId, true),\n          await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.resolve)(this.config.o11yHeaders)\n        ),\n        body: args,\n        successfulResponseHandler: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createEventSourceResponseHandler)(zod_v4__WEBPACK_IMPORTED_MODULE_1__.any()),\n        failedResponseHandler: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createJsonErrorResponseHandler)({\n          errorSchema: zod_v4__WEBPACK_IMPORTED_MODULE_1__.any(),\n          errorToMessage: (data) => data\n        }),\n        ...abortSignal && { abortSignal },\n        fetch: this.config.fetch\n      });\n      return {\n        stream: response.pipeThrough(\n          new TransformStream({\n            start(controller) {\n              if (warnings.length > 0) {\n                controller.enqueue({ type: \"stream-start\", warnings });\n              }\n            },\n            transform(chunk, controller) {\n              if (chunk.success) {\n                const streamPart = chunk.value;\n                if (streamPart.type === \"raw\" && !options.includeRawChunks) {\n                  return;\n                }\n                if (streamPart.type === \"response-metadata\" && streamPart.timestamp && typeof streamPart.timestamp === \"string\") {\n                  streamPart.timestamp = new Date(streamPart.timestamp);\n                }\n                controller.enqueue(streamPart);\n              } else {\n                controller.error(\n                  chunk.error\n                );\n              }\n            }\n          })\n        ),\n        request: { body: args },\n        response: { headers: responseHeaders }\n      };\n    } catch (error) {\n      throw await asGatewayError(error, await parseAuthMethod(resolvedHeaders));\n    }\n  }\n  isFilePart(part) {\n    return part && typeof part === \"object\" && \"type\" in part && part.type === \"file\";\n  }\n  /**\n   * Encodes file parts in the prompt to base64. Mutates the passed options\n   * instance directly to avoid copying the file data.\n   * @param options - The options to encode.\n   * @returns The options with the file parts encoded.\n   */\n  maybeEncodeFileParts(options) {\n    for (const message of options.prompt) {\n      for (const part of message.content) {\n        if (this.isFilePart(part)) {\n          const filePart = part;\n          if (filePart.data instanceof Uint8Array) {\n            const buffer = Uint8Array.from(filePart.data);\n            const base64Data = Buffer.from(buffer).toString(\"base64\");\n            filePart.data = new URL(\n              `data:${filePart.mediaType || \"application/octet-stream\"};base64,${base64Data}`\n            );\n          }\n        }\n      }\n    }\n    return options;\n  }\n  getUrl() {\n    return `${this.config.baseURL}/language-model`;\n  }\n  getModelConfigHeaders(modelId, streaming) {\n    return {\n      \"ai-language-model-specification-version\": \"3\",\n      \"ai-language-model-id\": modelId,\n      \"ai-language-model-streaming\": String(streaming)\n    };\n  }\n};\n\n// src/gateway-embedding-model.ts\n\n\nvar GatewayEmbeddingModel = class {\n  constructor(modelId, config) {\n    this.modelId = modelId;\n    this.config = config;\n    this.specificationVersion = \"v3\";\n    this.maxEmbeddingsPerCall = 2048;\n    this.supportsParallelCalls = true;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async doEmbed({\n    values,\n    headers,\n    abortSignal,\n    providerOptions\n  }) {\n    var _a9;\n    const resolvedHeaders = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.resolve)(this.config.headers());\n    try {\n      const {\n        responseHeaders,\n        value: responseBody,\n        rawValue\n      } = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.postJsonToApi)({\n        url: this.getUrl(),\n        headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.combineHeaders)(\n          resolvedHeaders,\n          headers != null ? headers : {},\n          this.getModelConfigHeaders(),\n          await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.resolve)(this.config.o11yHeaders)\n        ),\n        body: {\n          values,\n          ...providerOptions ? { providerOptions } : {}\n        },\n        successfulResponseHandler: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createJsonResponseHandler)(\n          gatewayEmbeddingResponseSchema\n        ),\n        failedResponseHandler: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createJsonErrorResponseHandler)({\n          errorSchema: zod_v4__WEBPACK_IMPORTED_MODULE_1__.any(),\n          errorToMessage: (data) => data\n        }),\n        ...abortSignal && { abortSignal },\n        fetch: this.config.fetch\n      });\n      return {\n        embeddings: responseBody.embeddings,\n        usage: (_a9 = responseBody.usage) != null ? _a9 : void 0,\n        providerMetadata: responseBody.providerMetadata,\n        response: { headers: responseHeaders, body: rawValue },\n        warnings: []\n      };\n    } catch (error) {\n      throw await asGatewayError(error, await parseAuthMethod(resolvedHeaders));\n    }\n  }\n  getUrl() {\n    return `${this.config.baseURL}/embedding-model`;\n  }\n  getModelConfigHeaders() {\n    return {\n      \"ai-embedding-model-specification-version\": \"3\",\n      \"ai-model-id\": this.modelId\n    };\n  }\n};\nvar gatewayEmbeddingResponseSchema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.lazySchema)(\n  () => (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.zodSchema)(\n    zod_v4__WEBPACK_IMPORTED_MODULE_1__.object({\n      embeddings: zod_v4__WEBPACK_IMPORTED_MODULE_1__.array(zod_v4__WEBPACK_IMPORTED_MODULE_1__.array(zod_v4__WEBPACK_IMPORTED_MODULE_1__.number())),\n      usage: zod_v4__WEBPACK_IMPORTED_MODULE_1__.object({ tokens: zod_v4__WEBPACK_IMPORTED_MODULE_1__.number() }).nullish(),\n      providerMetadata: zod_v4__WEBPACK_IMPORTED_MODULE_1__.record(zod_v4__WEBPACK_IMPORTED_MODULE_1__.string(), zod_v4__WEBPACK_IMPORTED_MODULE_1__.record(zod_v4__WEBPACK_IMPORTED_MODULE_1__.string(), zod_v4__WEBPACK_IMPORTED_MODULE_1__.unknown())).optional()\n    })\n  )\n);\n\n// src/gateway-image-model.ts\n\n\nvar GatewayImageModel = class {\n  constructor(modelId, config) {\n    this.modelId = modelId;\n    this.config = config;\n    this.specificationVersion = \"v3\";\n    // Set a very large number to prevent client-side splitting of requests\n    this.maxImagesPerCall = Number.MAX_SAFE_INTEGER;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async doGenerate({\n    prompt,\n    n,\n    size,\n    aspectRatio,\n    seed,\n    files,\n    mask,\n    providerOptions,\n    headers,\n    abortSignal\n  }) {\n    var _a9, _b9, _c, _d;\n    const resolvedHeaders = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.resolve)(this.config.headers());\n    try {\n      const {\n        responseHeaders,\n        value: responseBody,\n        rawValue\n      } = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.postJsonToApi)({\n        url: this.getUrl(),\n        headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.combineHeaders)(\n          resolvedHeaders,\n          headers != null ? headers : {},\n          this.getModelConfigHeaders(),\n          await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.resolve)(this.config.o11yHeaders)\n        ),\n        body: {\n          prompt,\n          n,\n          ...size && { size },\n          ...aspectRatio && { aspectRatio },\n          ...seed && { seed },\n          ...providerOptions && { providerOptions },\n          ...files && {\n            files: files.map((file) => maybeEncodeImageFile(file))\n          },\n          ...mask && { mask: maybeEncodeImageFile(mask) }\n        },\n        successfulResponseHandler: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createJsonResponseHandler)(\n          gatewayImageResponseSchema\n        ),\n        failedResponseHandler: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createJsonErrorResponseHandler)({\n          errorSchema: zod_v4__WEBPACK_IMPORTED_MODULE_1__.any(),\n          errorToMessage: (data) => data\n        }),\n        ...abortSignal && { abortSignal },\n        fetch: this.config.fetch\n      });\n      return {\n        images: responseBody.images,\n        // Always base64 strings from server\n        warnings: (_a9 = responseBody.warnings) != null ? _a9 : [],\n        providerMetadata: responseBody.providerMetadata,\n        response: {\n          timestamp: /* @__PURE__ */ new Date(),\n          modelId: this.modelId,\n          headers: responseHeaders\n        },\n        ...responseBody.usage != null && {\n          usage: {\n            inputTokens: (_b9 = responseBody.usage.inputTokens) != null ? _b9 : void 0,\n            outputTokens: (_c = responseBody.usage.outputTokens) != null ? _c : void 0,\n            totalTokens: (_d = responseBody.usage.totalTokens) != null ? _d : void 0\n          }\n        }\n      };\n    } catch (error) {\n      throw await asGatewayError(error, await parseAuthMethod(resolvedHeaders));\n    }\n  }\n  getUrl() {\n    return `${this.config.baseURL}/image-model`;\n  }\n  getModelConfigHeaders() {\n    return {\n      \"ai-image-model-specification-version\": \"3\",\n      \"ai-model-id\": this.modelId\n    };\n  }\n};\nfunction maybeEncodeImageFile(file) {\n  if (file.type === \"file\" && file.data instanceof Uint8Array) {\n    return {\n      ...file,\n      data: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.convertUint8ArrayToBase64)(file.data)\n    };\n  }\n  return file;\n}\nvar providerMetadataEntrySchema = zod_v4__WEBPACK_IMPORTED_MODULE_1__.object({\n  images: zod_v4__WEBPACK_IMPORTED_MODULE_1__.array(zod_v4__WEBPACK_IMPORTED_MODULE_1__.unknown()).optional()\n}).catchall(zod_v4__WEBPACK_IMPORTED_MODULE_1__.unknown());\nvar gatewayImageWarningSchema = zod_v4__WEBPACK_IMPORTED_MODULE_1__.discriminatedUnion(\"type\", [\n  zod_v4__WEBPACK_IMPORTED_MODULE_1__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_1__.literal(\"unsupported\"),\n    feature: zod_v4__WEBPACK_IMPORTED_MODULE_1__.string(),\n    details: zod_v4__WEBPACK_IMPORTED_MODULE_1__.string().optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_1__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_1__.literal(\"compatibility\"),\n    feature: zod_v4__WEBPACK_IMPORTED_MODULE_1__.string(),\n    details: zod_v4__WEBPACK_IMPORTED_MODULE_1__.string().optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_1__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_1__.literal(\"other\"),\n    message: zod_v4__WEBPACK_IMPORTED_MODULE_1__.string()\n  })\n]);\nvar gatewayImageUsageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_1__.object({\n  inputTokens: zod_v4__WEBPACK_IMPORTED_MODULE_1__.number().nullish(),\n  outputTokens: zod_v4__WEBPACK_IMPORTED_MODULE_1__.number().nullish(),\n  totalTokens: zod_v4__WEBPACK_IMPORTED_MODULE_1__.number().nullish()\n});\nvar gatewayImageResponseSchema = zod_v4__WEBPACK_IMPORTED_MODULE_1__.object({\n  images: zod_v4__WEBPACK_IMPORTED_MODULE_1__.array(zod_v4__WEBPACK_IMPORTED_MODULE_1__.string()),\n  // Always base64 strings over the wire\n  warnings: zod_v4__WEBPACK_IMPORTED_MODULE_1__.array(gatewayImageWarningSchema).optional(),\n  providerMetadata: zod_v4__WEBPACK_IMPORTED_MODULE_1__.record(zod_v4__WEBPACK_IMPORTED_MODULE_1__.string(), providerMetadataEntrySchema).optional(),\n  usage: gatewayImageUsageSchema.optional()\n});\n\n// src/gateway-video-model.ts\n\n\n\nvar GatewayVideoModel = class {\n  constructor(modelId, config) {\n    this.modelId = modelId;\n    this.config = config;\n    this.specificationVersion = \"v3\";\n    // Set a very large number to prevent client-side splitting of requests\n    this.maxVideosPerCall = Number.MAX_SAFE_INTEGER;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async doGenerate({\n    prompt,\n    n,\n    aspectRatio,\n    resolution,\n    duration,\n    fps,\n    seed,\n    image,\n    providerOptions,\n    headers,\n    abortSignal\n  }) {\n    var _a9;\n    const resolvedHeaders = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.resolve)(this.config.headers());\n    try {\n      const { responseHeaders, value: responseBody } = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.postJsonToApi)({\n        url: this.getUrl(),\n        headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.combineHeaders)(\n          resolvedHeaders,\n          headers != null ? headers : {},\n          this.getModelConfigHeaders(),\n          await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.resolve)(this.config.o11yHeaders),\n          { accept: \"text/event-stream\" }\n        ),\n        body: {\n          prompt,\n          n,\n          ...aspectRatio && { aspectRatio },\n          ...resolution && { resolution },\n          ...duration && { duration },\n          ...fps && { fps },\n          ...seed && { seed },\n          ...providerOptions && { providerOptions },\n          ...image && { image: maybeEncodeVideoFile(image) }\n        },\n        successfulResponseHandler: async ({\n          response,\n          url,\n          requestBodyValues\n        }) => {\n          if (response.body == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_2__.APICallError({\n              message: \"SSE response body is empty\",\n              url,\n              requestBodyValues,\n              statusCode: response.status\n            });\n          }\n          const eventStream = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.parseJsonEventStream)({\n            stream: response.body,\n            schema: gatewayVideoEventSchema\n          });\n          const reader = eventStream.getReader();\n          const { done, value: parseResult } = await reader.read();\n          reader.releaseLock();\n          if (done || !parseResult) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_2__.APICallError({\n              message: \"SSE stream ended without a data event\",\n              url,\n              requestBodyValues,\n              statusCode: response.status\n            });\n          }\n          if (!parseResult.success) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_2__.APICallError({\n              message: \"Failed to parse video SSE event\",\n              cause: parseResult.error,\n              url,\n              requestBodyValues,\n              statusCode: response.status\n            });\n          }\n          const event = parseResult.value;\n          if (event.type === \"error\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_2__.APICallError({\n              message: event.message,\n              statusCode: event.statusCode,\n              url,\n              requestBodyValues,\n              responseHeaders: Object.fromEntries([...response.headers]),\n              responseBody: JSON.stringify(event),\n              data: {\n                error: {\n                  message: event.message,\n                  type: event.errorType,\n                  param: event.param\n                }\n              }\n            });\n          }\n          return {\n            value: {\n              videos: event.videos,\n              warnings: event.warnings,\n              providerMetadata: event.providerMetadata\n            },\n            responseHeaders: Object.fromEntries([...response.headers])\n          };\n        },\n        failedResponseHandler: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createJsonErrorResponseHandler)({\n          errorSchema: zod_v4__WEBPACK_IMPORTED_MODULE_1__.any(),\n          errorToMessage: (data) => data\n        }),\n        ...abortSignal && { abortSignal },\n        fetch: this.config.fetch\n      });\n      return {\n        videos: responseBody.videos,\n        warnings: (_a9 = responseBody.warnings) != null ? _a9 : [],\n        providerMetadata: responseBody.providerMetadata,\n        response: {\n          timestamp: /* @__PURE__ */ new Date(),\n          modelId: this.modelId,\n          headers: responseHeaders\n        }\n      };\n    } catch (error) {\n      throw await asGatewayError(error, await parseAuthMethod(resolvedHeaders));\n    }\n  }\n  getUrl() {\n    return `${this.config.baseURL}/video-model`;\n  }\n  getModelConfigHeaders() {\n    return {\n      \"ai-video-model-specification-version\": \"3\",\n      \"ai-model-id\": this.modelId\n    };\n  }\n};\nfunction maybeEncodeVideoFile(file) {\n  if (file.type === \"file\" && file.data instanceof Uint8Array) {\n    return {\n      ...file,\n      data: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.convertUint8ArrayToBase64)(file.data)\n    };\n  }\n  return file;\n}\nvar providerMetadataEntrySchema2 = zod_v4__WEBPACK_IMPORTED_MODULE_1__.object({\n  videos: zod_v4__WEBPACK_IMPORTED_MODULE_1__.array(zod_v4__WEBPACK_IMPORTED_MODULE_1__.unknown()).optional()\n}).catchall(zod_v4__WEBPACK_IMPORTED_MODULE_1__.unknown());\nvar gatewayVideoDataSchema = zod_v4__WEBPACK_IMPORTED_MODULE_1__.union([\n  zod_v4__WEBPACK_IMPORTED_MODULE_1__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_1__.literal(\"url\"),\n    url: zod_v4__WEBPACK_IMPORTED_MODULE_1__.string(),\n    mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_1__.string()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_1__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_1__.literal(\"base64\"),\n    data: zod_v4__WEBPACK_IMPORTED_MODULE_1__.string(),\n    mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_1__.string()\n  })\n]);\nvar gatewayVideoWarningSchema = zod_v4__WEBPACK_IMPORTED_MODULE_1__.discriminatedUnion(\"type\", [\n  zod_v4__WEBPACK_IMPORTED_MODULE_1__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_1__.literal(\"unsupported\"),\n    feature: zod_v4__WEBPACK_IMPORTED_MODULE_1__.string(),\n    details: zod_v4__WEBPACK_IMPORTED_MODULE_1__.string().optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_1__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_1__.literal(\"compatibility\"),\n    feature: zod_v4__WEBPACK_IMPORTED_MODULE_1__.string(),\n    details: zod_v4__WEBPACK_IMPORTED_MODULE_1__.string().optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_1__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_1__.literal(\"other\"),\n    message: zod_v4__WEBPACK_IMPORTED_MODULE_1__.string()\n  })\n]);\nvar gatewayVideoEventSchema = zod_v4__WEBPACK_IMPORTED_MODULE_1__.discriminatedUnion(\"type\", [\n  zod_v4__WEBPACK_IMPORTED_MODULE_1__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_1__.literal(\"result\"),\n    videos: zod_v4__WEBPACK_IMPORTED_MODULE_1__.array(gatewayVideoDataSchema),\n    warnings: zod_v4__WEBPACK_IMPORTED_MODULE_1__.array(gatewayVideoWarningSchema).optional(),\n    providerMetadata: zod_v4__WEBPACK_IMPORTED_MODULE_1__.record(zod_v4__WEBPACK_IMPORTED_MODULE_1__.string(), providerMetadataEntrySchema2).optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_1__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_1__.literal(\"error\"),\n    message: zod_v4__WEBPACK_IMPORTED_MODULE_1__.string(),\n    errorType: zod_v4__WEBPACK_IMPORTED_MODULE_1__.string(),\n    statusCode: zod_v4__WEBPACK_IMPORTED_MODULE_1__.number(),\n    param: zod_v4__WEBPACK_IMPORTED_MODULE_1__.unknown().nullable()\n  })\n]);\n\n// src/tool/parallel-search.ts\n\n\nvar parallelSearchInputSchema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.lazySchema)(\n  () => (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.zodSchema)(\n    zod__WEBPACK_IMPORTED_MODULE_3__.object({\n      objective: zod__WEBPACK_IMPORTED_MODULE_3__.string().describe(\n        \"Natural-language description of the web research goal, including source or freshness guidance and broader context from the task. Maximum 5000 characters.\"\n      ),\n      search_queries: zod__WEBPACK_IMPORTED_MODULE_3__.array(zod__WEBPACK_IMPORTED_MODULE_3__.string()).optional().describe(\n        \"Optional search queries to supplement the objective. Maximum 200 characters per query.\"\n      ),\n      mode: zod__WEBPACK_IMPORTED_MODULE_3__[\"enum\"]([\"one-shot\", \"agentic\"]).optional().describe(\n        'Mode preset: \"one-shot\" for comprehensive results with longer excerpts (default), \"agentic\" for concise, token-efficient results for multi-step workflows.'\n      ),\n      max_results: zod__WEBPACK_IMPORTED_MODULE_3__.number().optional().describe(\n        \"Maximum number of results to return (1-20). Defaults to 10 if not specified.\"\n      ),\n      source_policy: zod__WEBPACK_IMPORTED_MODULE_3__.object({\n        include_domains: zod__WEBPACK_IMPORTED_MODULE_3__.array(zod__WEBPACK_IMPORTED_MODULE_3__.string()).optional().describe(\"List of domains to include in search results.\"),\n        exclude_domains: zod__WEBPACK_IMPORTED_MODULE_3__.array(zod__WEBPACK_IMPORTED_MODULE_3__.string()).optional().describe(\"List of domains to exclude from search results.\"),\n        after_date: zod__WEBPACK_IMPORTED_MODULE_3__.string().optional().describe(\n          \"Only include results published after this date (ISO 8601 format).\"\n        )\n      }).optional().describe(\n        \"Source policy for controlling which domains to include/exclude and freshness.\"\n      ),\n      excerpts: zod__WEBPACK_IMPORTED_MODULE_3__.object({\n        max_chars_per_result: zod__WEBPACK_IMPORTED_MODULE_3__.number().optional().describe(\"Maximum characters per result.\"),\n        max_chars_total: zod__WEBPACK_IMPORTED_MODULE_3__.number().optional().describe(\"Maximum total characters across all results.\")\n      }).optional().describe(\"Excerpt configuration for controlling result length.\"),\n      fetch_policy: zod__WEBPACK_IMPORTED_MODULE_3__.object({\n        max_age_seconds: zod__WEBPACK_IMPORTED_MODULE_3__.number().optional().describe(\n          \"Maximum age in seconds for cached content. Set to 0 to always fetch fresh content.\"\n        )\n      }).optional().describe(\"Fetch policy for controlling content freshness.\")\n    })\n  )\n);\nvar parallelSearchOutputSchema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.lazySchema)(\n  () => (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.zodSchema)(\n    zod__WEBPACK_IMPORTED_MODULE_3__.union([\n      // Success response\n      zod__WEBPACK_IMPORTED_MODULE_3__.object({\n        searchId: zod__WEBPACK_IMPORTED_MODULE_3__.string(),\n        results: zod__WEBPACK_IMPORTED_MODULE_3__.array(\n          zod__WEBPACK_IMPORTED_MODULE_3__.object({\n            url: zod__WEBPACK_IMPORTED_MODULE_3__.string(),\n            title: zod__WEBPACK_IMPORTED_MODULE_3__.string(),\n            excerpt: zod__WEBPACK_IMPORTED_MODULE_3__.string(),\n            publishDate: zod__WEBPACK_IMPORTED_MODULE_3__.string().nullable().optional(),\n            relevanceScore: zod__WEBPACK_IMPORTED_MODULE_3__.number().optional()\n          })\n        )\n      }),\n      // Error response\n      zod__WEBPACK_IMPORTED_MODULE_3__.object({\n        error: zod__WEBPACK_IMPORTED_MODULE_3__[\"enum\"]([\n          \"api_error\",\n          \"rate_limit\",\n          \"timeout\",\n          \"invalid_input\",\n          \"configuration_error\",\n          \"unknown\"\n        ]),\n        statusCode: zod__WEBPACK_IMPORTED_MODULE_3__.number().optional(),\n        message: zod__WEBPACK_IMPORTED_MODULE_3__.string()\n      })\n    ])\n  )\n);\nvar parallelSearchToolFactory = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createProviderToolFactoryWithOutputSchema)({\n  id: \"gateway.parallel_search\",\n  inputSchema: parallelSearchInputSchema,\n  outputSchema: parallelSearchOutputSchema\n});\nvar parallelSearch = (config = {}) => parallelSearchToolFactory(config);\n\n// src/tool/perplexity-search.ts\n\n\nvar perplexitySearchInputSchema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.lazySchema)(\n  () => (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.zodSchema)(\n    zod__WEBPACK_IMPORTED_MODULE_3__.object({\n      query: zod__WEBPACK_IMPORTED_MODULE_3__.union([zod__WEBPACK_IMPORTED_MODULE_3__.string(), zod__WEBPACK_IMPORTED_MODULE_3__.array(zod__WEBPACK_IMPORTED_MODULE_3__.string())]).describe(\n        \"Search query (string) or multiple queries (array of up to 5 strings). Multi-query searches return combined results from all queries.\"\n      ),\n      max_results: zod__WEBPACK_IMPORTED_MODULE_3__.number().optional().describe(\n        \"Maximum number of search results to return (1-20, default: 10)\"\n      ),\n      max_tokens_per_page: zod__WEBPACK_IMPORTED_MODULE_3__.number().optional().describe(\n        \"Maximum number of tokens to extract per search result page (256-2048, default: 2048)\"\n      ),\n      max_tokens: zod__WEBPACK_IMPORTED_MODULE_3__.number().optional().describe(\n        \"Maximum total tokens across all search results (default: 25000, max: 1000000)\"\n      ),\n      country: zod__WEBPACK_IMPORTED_MODULE_3__.string().optional().describe(\n        \"Two-letter ISO 3166-1 alpha-2 country code for regional search results (e.g., 'US', 'GB', 'FR')\"\n      ),\n      search_domain_filter: zod__WEBPACK_IMPORTED_MODULE_3__.array(zod__WEBPACK_IMPORTED_MODULE_3__.string()).optional().describe(\n        \"List of domains to include or exclude from search results (max 20). To include: ['nature.com', 'science.org']. To exclude: ['-example.com', '-spam.net']\"\n      ),\n      search_language_filter: zod__WEBPACK_IMPORTED_MODULE_3__.array(zod__WEBPACK_IMPORTED_MODULE_3__.string()).optional().describe(\n        \"List of ISO 639-1 language codes to filter results (max 10, lowercase). Examples: ['en', 'fr', 'de']\"\n      ),\n      search_after_date: zod__WEBPACK_IMPORTED_MODULE_3__.string().optional().describe(\n        \"Include only results published after this date. Format: 'MM/DD/YYYY' (e.g., '3/1/2025'). Cannot be used with search_recency_filter.\"\n      ),\n      search_before_date: zod__WEBPACK_IMPORTED_MODULE_3__.string().optional().describe(\n        \"Include only results published before this date. Format: 'MM/DD/YYYY' (e.g., '3/15/2025'). Cannot be used with search_recency_filter.\"\n      ),\n      last_updated_after_filter: zod__WEBPACK_IMPORTED_MODULE_3__.string().optional().describe(\n        \"Include only results last updated after this date. Format: 'MM/DD/YYYY' (e.g., '3/1/2025'). Cannot be used with search_recency_filter.\"\n      ),\n      last_updated_before_filter: zod__WEBPACK_IMPORTED_MODULE_3__.string().optional().describe(\n        \"Include only results last updated before this date. Format: 'MM/DD/YYYY' (e.g., '3/15/2025'). Cannot be used with search_recency_filter.\"\n      ),\n      search_recency_filter: zod__WEBPACK_IMPORTED_MODULE_3__[\"enum\"]([\"day\", \"week\", \"month\", \"year\"]).optional().describe(\n        \"Filter results by relative time period. Cannot be used with search_after_date or search_before_date.\"\n      )\n    })\n  )\n);\nvar perplexitySearchOutputSchema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.lazySchema)(\n  () => (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.zodSchema)(\n    zod__WEBPACK_IMPORTED_MODULE_3__.union([\n      // Success response\n      zod__WEBPACK_IMPORTED_MODULE_3__.object({\n        results: zod__WEBPACK_IMPORTED_MODULE_3__.array(\n          zod__WEBPACK_IMPORTED_MODULE_3__.object({\n            title: zod__WEBPACK_IMPORTED_MODULE_3__.string(),\n            url: zod__WEBPACK_IMPORTED_MODULE_3__.string(),\n            snippet: zod__WEBPACK_IMPORTED_MODULE_3__.string(),\n            date: zod__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n            lastUpdated: zod__WEBPACK_IMPORTED_MODULE_3__.string().optional()\n          })\n        ),\n        id: zod__WEBPACK_IMPORTED_MODULE_3__.string()\n      }),\n      // Error response\n      zod__WEBPACK_IMPORTED_MODULE_3__.object({\n        error: zod__WEBPACK_IMPORTED_MODULE_3__[\"enum\"]([\n          \"api_error\",\n          \"rate_limit\",\n          \"timeout\",\n          \"invalid_input\",\n          \"unknown\"\n        ]),\n        statusCode: zod__WEBPACK_IMPORTED_MODULE_3__.number().optional(),\n        message: zod__WEBPACK_IMPORTED_MODULE_3__.string()\n      })\n    ])\n  )\n);\nvar perplexitySearchToolFactory = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createProviderToolFactoryWithOutputSchema)({\n  id: \"gateway.perplexity_search\",\n  inputSchema: perplexitySearchInputSchema,\n  outputSchema: perplexitySearchOutputSchema\n});\nvar perplexitySearch = (config = {}) => perplexitySearchToolFactory(config);\n\n// src/gateway-tools.ts\nvar gatewayTools = {\n  /**\n   * Search the web using Parallel AI's Search API for LLM-optimized excerpts.\n   *\n   * Takes a natural language objective and returns relevant excerpts,\n   * replacing multiple keyword searches with a single call for broad\n   * or complex queries. Supports different search types for depth vs\n   * breadth tradeoffs.\n   */\n  parallelSearch,\n  /**\n   * Search the web using Perplexity's Search API for real-time information,\n   * news, research papers, and articles.\n   *\n   * Provides ranked search results with advanced filtering options including\n   * domain, language, date range, and recency filters.\n   */\n  perplexitySearch\n};\n\n// src/vercel-environment.ts\n\n\nasync function getVercelRequestId() {\n  var _a9;\n  return (_a9 = (0,_vercel_oidc__WEBPACK_IMPORTED_MODULE_4__.getContext)().headers) == null ? void 0 : _a9[\"x-vercel-id\"];\n}\n\n// src/gateway-provider.ts\n\n\n// src/version.ts\nvar VERSION =  true ? \"3.0.53\" : 0;\n\n// src/gateway-provider.ts\nvar AI_GATEWAY_PROTOCOL_VERSION = \"0.0.1\";\nfunction createGatewayProvider(options = {}) {\n  var _a9, _b9;\n  let pendingMetadata = null;\n  let metadataCache = null;\n  const cacheRefreshMillis = (_a9 = options.metadataCacheRefreshMillis) != null ? _a9 : 1e3 * 60 * 5;\n  let lastFetchTime = 0;\n  const baseURL = (_b9 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.withoutTrailingSlash)(options.baseURL)) != null ? _b9 : \"https://ai-gateway.vercel.sh/v3/ai\";\n  const getHeaders = async () => {\n    try {\n      const auth = await getGatewayAuthToken(options);\n      return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.withUserAgentSuffix)(\n        {\n          Authorization: `Bearer ${auth.token}`,\n          \"ai-gateway-protocol-version\": AI_GATEWAY_PROTOCOL_VERSION,\n          [GATEWAY_AUTH_METHOD_HEADER]: auth.authMethod,\n          ...options.headers\n        },\n        `ai-sdk/gateway/${VERSION}`\n      );\n    } catch (error) {\n      throw GatewayAuthenticationError.createContextualError({\n        apiKeyProvided: false,\n        oidcTokenProvided: false,\n        statusCode: 401,\n        cause: error\n      });\n    }\n  };\n  const createO11yHeaders = () => {\n    const deploymentId = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.loadOptionalSetting)({\n      settingValue: void 0,\n      environmentVariableName: \"VERCEL_DEPLOYMENT_ID\"\n    });\n    const environment = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.loadOptionalSetting)({\n      settingValue: void 0,\n      environmentVariableName: \"VERCEL_ENV\"\n    });\n    const region = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.loadOptionalSetting)({\n      settingValue: void 0,\n      environmentVariableName: \"VERCEL_REGION\"\n    });\n    return async () => {\n      const requestId = await getVercelRequestId();\n      return {\n        ...deploymentId && { \"ai-o11y-deployment-id\": deploymentId },\n        ...environment && { \"ai-o11y-environment\": environment },\n        ...region && { \"ai-o11y-region\": region },\n        ...requestId && { \"ai-o11y-request-id\": requestId }\n      };\n    };\n  };\n  const createLanguageModel = (modelId) => {\n    return new GatewayLanguageModel(modelId, {\n      provider: \"gateway\",\n      baseURL,\n      headers: getHeaders,\n      fetch: options.fetch,\n      o11yHeaders: createO11yHeaders()\n    });\n  };\n  const getAvailableModels = async () => {\n    var _a10, _b10, _c;\n    const now = (_c = (_b10 = (_a10 = options._internal) == null ? void 0 : _a10.currentDate) == null ? void 0 : _b10.call(_a10).getTime()) != null ? _c : Date.now();\n    if (!pendingMetadata || now - lastFetchTime > cacheRefreshMillis) {\n      lastFetchTime = now;\n      pendingMetadata = new GatewayFetchMetadata({\n        baseURL,\n        headers: getHeaders,\n        fetch: options.fetch\n      }).getAvailableModels().then((metadata) => {\n        metadataCache = metadata;\n        return metadata;\n      }).catch(async (error) => {\n        throw await asGatewayError(\n          error,\n          await parseAuthMethod(await getHeaders())\n        );\n      });\n    }\n    return metadataCache ? Promise.resolve(metadataCache) : pendingMetadata;\n  };\n  const getCredits = async () => {\n    return new GatewayFetchMetadata({\n      baseURL,\n      headers: getHeaders,\n      fetch: options.fetch\n    }).getCredits().catch(async (error) => {\n      throw await asGatewayError(\n        error,\n        await parseAuthMethod(await getHeaders())\n      );\n    });\n  };\n  const provider = function(modelId) {\n    if (new.target) {\n      throw new Error(\n        \"The Gateway Provider model function cannot be called with the new keyword.\"\n      );\n    }\n    return createLanguageModel(modelId);\n  };\n  provider.specificationVersion = \"v3\";\n  provider.getAvailableModels = getAvailableModels;\n  provider.getCredits = getCredits;\n  provider.imageModel = (modelId) => {\n    return new GatewayImageModel(modelId, {\n      provider: \"gateway\",\n      baseURL,\n      headers: getHeaders,\n      fetch: options.fetch,\n      o11yHeaders: createO11yHeaders()\n    });\n  };\n  provider.languageModel = createLanguageModel;\n  const createEmbeddingModel = (modelId) => {\n    return new GatewayEmbeddingModel(modelId, {\n      provider: \"gateway\",\n      baseURL,\n      headers: getHeaders,\n      fetch: options.fetch,\n      o11yHeaders: createO11yHeaders()\n    });\n  };\n  provider.embeddingModel = createEmbeddingModel;\n  provider.textEmbeddingModel = createEmbeddingModel;\n  provider.videoModel = (modelId) => {\n    return new GatewayVideoModel(modelId, {\n      provider: \"gateway\",\n      baseURL,\n      headers: getHeaders,\n      fetch: options.fetch,\n      o11yHeaders: createO11yHeaders()\n    });\n  };\n  provider.chat = provider.languageModel;\n  provider.embedding = provider.embeddingModel;\n  provider.image = provider.imageModel;\n  provider.video = provider.videoModel;\n  provider.tools = gatewayTools;\n  return provider;\n}\nvar gateway = createGatewayProvider();\nasync function getGatewayAuthToken(options) {\n  const apiKey = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.loadOptionalSetting)({\n    settingValue: options.apiKey,\n    environmentVariableName: \"AI_GATEWAY_API_KEY\"\n  });\n  if (apiKey) {\n    return {\n      token: apiKey,\n      authMethod: \"api-key\"\n    };\n  }\n  const oidcToken = await (0,_vercel_oidc__WEBPACK_IMPORTED_MODULE_4__.getVercelOidcToken)();\n  return {\n    token: oidcToken,\n    authMethod: \"oidc\"\n  };\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9nYXRld2F5L2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBSWdDOztBQUVoQztBQUNnRDs7QUFFaEQ7QUFDaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDRCQUE0QixTQUFTLEdBQUcsYUFBYTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDLEtBQUs7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSLFlBQVksMENBQTBDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxNQUFNO0FBQ047O0FBRUE7O0FBRUE7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDLE1BQU07QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSLFlBQVksMENBQTBDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDLE1BQU07QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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RSw0QkFBNEIsb0NBQW9DO0FBQ2hFLHVCQUF1QiwwQkFBMEI7QUFDakQsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkVBQW1CO0FBQ3BDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdFQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsZWV0Zmxvdy8uL25vZGVfbW9kdWxlcy9AYWktc2RrL2dhdGV3YXkvZGlzdC9pbmRleC5tanM/YjRjMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvZ2F0ZXdheS1wcm92aWRlci50c1xuaW1wb3J0IHtcbiAgbG9hZE9wdGlvbmFsU2V0dGluZyxcbiAgd2l0aG91dFRyYWlsaW5nU2xhc2hcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL2Vycm9ycy9hcy1nYXRld2F5LWVycm9yLnRzXG5pbXBvcnQgeyBBUElDYWxsRXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuXG4vLyBzcmMvZXJyb3JzL2NyZWF0ZS1nYXRld2F5LWVycm9yLnRzXG5pbXBvcnQgeyB6IGFzIHoyIH0gZnJvbSBcInpvZC92NFwiO1xuXG4vLyBzcmMvZXJyb3JzL2dhdGV3YXktZXJyb3IudHNcbnZhciBtYXJrZXIgPSBcInZlcmNlbC5haS5nYXRld2F5LmVycm9yXCI7XG52YXIgc3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIpO1xudmFyIF9hLCBfYjtcbnZhciBHYXRld2F5RXJyb3IgPSBjbGFzcyBfR2F0ZXdheUVycm9yIGV4dGVuZHMgKF9iID0gRXJyb3IsIF9hID0gc3ltYm9sLCBfYikge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSxcbiAgICBzdGF0dXNDb2RlID0gNTAwLFxuICAgIGNhdXNlLFxuICAgIGdlbmVyYXRpb25JZFxuICB9KSB7XG4gICAgc3VwZXIoZ2VuZXJhdGlvbklkID8gYCR7bWVzc2FnZX0gWyR7Z2VuZXJhdGlvbklkfV1gIDogbWVzc2FnZSk7XG4gICAgdGhpc1tfYV0gPSB0cnVlO1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuZ2VuZXJhdGlvbklkID0gZ2VuZXJhdGlvbklkO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGVycm9yIGlzIGEgR2F0ZXdheSBFcnJvci5cbiAgICogQHBhcmFtIHt1bmtub3dufSBlcnJvciAtIFRoZSBlcnJvciB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGVycm9yIGlzIGEgR2F0ZXdheSBFcnJvciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gX0dhdGV3YXlFcnJvci5oYXNNYXJrZXIoZXJyb3IpO1xuICB9XG4gIHN0YXRpYyBoYXNNYXJrZXIoZXJyb3IpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiICYmIGVycm9yICE9PSBudWxsICYmIHN5bWJvbCBpbiBlcnJvciAmJiBlcnJvcltzeW1ib2xdID09PSB0cnVlO1xuICB9XG59O1xuXG4vLyBzcmMvZXJyb3JzL2dhdGV3YXktYXV0aGVudGljYXRpb24tZXJyb3IudHNcbnZhciBuYW1lID0gXCJHYXRld2F5QXV0aGVudGljYXRpb25FcnJvclwiO1xudmFyIG1hcmtlcjIgPSBgdmVyY2VsLmFpLmdhdGV3YXkuZXJyb3IuJHtuYW1lfWA7XG52YXIgc3ltYm9sMiA9IFN5bWJvbC5mb3IobWFya2VyMik7XG52YXIgX2EyLCBfYjI7XG52YXIgR2F0ZXdheUF1dGhlbnRpY2F0aW9uRXJyb3IgPSBjbGFzcyBfR2F0ZXdheUF1dGhlbnRpY2F0aW9uRXJyb3IgZXh0ZW5kcyAoX2IyID0gR2F0ZXdheUVycm9yLCBfYTIgPSBzeW1ib2wyLCBfYjIpIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UgPSBcIkF1dGhlbnRpY2F0aW9uIGZhaWxlZFwiLFxuICAgIHN0YXR1c0NvZGUgPSA0MDEsXG4gICAgY2F1c2UsXG4gICAgZ2VuZXJhdGlvbklkXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKHsgbWVzc2FnZSwgc3RhdHVzQ29kZSwgY2F1c2UsIGdlbmVyYXRpb25JZCB9KTtcbiAgICB0aGlzW19hMl0gPSB0cnVlO1xuICAgIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy50eXBlID0gXCJhdXRoZW50aWNhdGlvbl9lcnJvclwiO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEdhdGV3YXlFcnJvci5oYXNNYXJrZXIoZXJyb3IpICYmIHN5bWJvbDIgaW4gZXJyb3I7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjb250ZXh0dWFsIGVycm9yIG1lc3NhZ2Ugd2hlbiBhdXRoZW50aWNhdGlvbiBmYWlsc1xuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUNvbnRleHR1YWxFcnJvcih7XG4gICAgYXBpS2V5UHJvdmlkZWQsXG4gICAgb2lkY1Rva2VuUHJvdmlkZWQsXG4gICAgbWVzc2FnZSA9IFwiQXV0aGVudGljYXRpb24gZmFpbGVkXCIsXG4gICAgc3RhdHVzQ29kZSA9IDQwMSxcbiAgICBjYXVzZSxcbiAgICBnZW5lcmF0aW9uSWRcbiAgfSkge1xuICAgIGxldCBjb250ZXh0dWFsTWVzc2FnZTtcbiAgICBpZiAoYXBpS2V5UHJvdmlkZWQpIHtcbiAgICAgIGNvbnRleHR1YWxNZXNzYWdlID0gYEFJIEdhdGV3YXkgYXV0aGVudGljYXRpb24gZmFpbGVkOiBJbnZhbGlkIEFQSSBrZXkuXG5cbkNyZWF0ZSBhIG5ldyBBUEkga2V5OiBodHRwczovL3ZlcmNlbC5jb20vZD90bz0lMkYlNUJ0ZWFtJTVEJTJGJTdFJTJGYWklMkZhcGkta2V5c1xuXG5Qcm92aWRlIHZpYSAnYXBpS2V5JyBvcHRpb24gb3IgJ0FJX0dBVEVXQVlfQVBJX0tFWScgZW52aXJvbm1lbnQgdmFyaWFibGUuYDtcbiAgICB9IGVsc2UgaWYgKG9pZGNUb2tlblByb3ZpZGVkKSB7XG4gICAgICBjb250ZXh0dWFsTWVzc2FnZSA9IGBBSSBHYXRld2F5IGF1dGhlbnRpY2F0aW9uIGZhaWxlZDogSW52YWxpZCBPSURDIHRva2VuLlxuXG5SdW4gJ25weCB2ZXJjZWwgbGluaycgdG8gbGluayB5b3VyIHByb2plY3QsIHRoZW4gJ3ZjIGVudiBwdWxsJyB0byBmZXRjaCB0aGUgdG9rZW4uXG5cbkFsdGVybmF0aXZlbHksIHVzZSBhbiBBUEkga2V5OiBodHRwczovL3ZlcmNlbC5jb20vZD90bz0lMkYlNUJ0ZWFtJTVEJTJGJTdFJTJGYWklMkZhcGkta2V5c2A7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHR1YWxNZXNzYWdlID0gYEFJIEdhdGV3YXkgYXV0aGVudGljYXRpb24gZmFpbGVkOiBObyBhdXRoZW50aWNhdGlvbiBwcm92aWRlZC5cblxuT3B0aW9uIDEgLSBBUEkga2V5OlxuQ3JlYXRlIGFuIEFQSSBrZXk6IGh0dHBzOi8vdmVyY2VsLmNvbS9kP3RvPSUyRiU1QnRlYW0lNUQlMkYlN0UlMkZhaSUyRmFwaS1rZXlzXG5Qcm92aWRlIHZpYSAnYXBpS2V5JyBvcHRpb24gb3IgJ0FJX0dBVEVXQVlfQVBJX0tFWScgZW52aXJvbm1lbnQgdmFyaWFibGUuXG5cbk9wdGlvbiAyIC0gT0lEQyB0b2tlbjpcblJ1biAnbnB4IHZlcmNlbCBsaW5rJyB0byBsaW5rIHlvdXIgcHJvamVjdCwgdGhlbiAndmMgZW52IHB1bGwnIHRvIGZldGNoIHRoZSB0b2tlbi5gO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9HYXRld2F5QXV0aGVudGljYXRpb25FcnJvcih7XG4gICAgICBtZXNzYWdlOiBjb250ZXh0dWFsTWVzc2FnZSxcbiAgICAgIHN0YXR1c0NvZGUsXG4gICAgICBjYXVzZSxcbiAgICAgIGdlbmVyYXRpb25JZFxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvZXJyb3JzL2dhdGV3YXktaW52YWxpZC1yZXF1ZXN0LWVycm9yLnRzXG52YXIgbmFtZTIgPSBcIkdhdGV3YXlJbnZhbGlkUmVxdWVzdEVycm9yXCI7XG52YXIgbWFya2VyMyA9IGB2ZXJjZWwuYWkuZ2F0ZXdheS5lcnJvci4ke25hbWUyfWA7XG52YXIgc3ltYm9sMyA9IFN5bWJvbC5mb3IobWFya2VyMyk7XG52YXIgX2EzLCBfYjM7XG52YXIgR2F0ZXdheUludmFsaWRSZXF1ZXN0RXJyb3IgPSBjbGFzcyBleHRlbmRzIChfYjMgPSBHYXRld2F5RXJyb3IsIF9hMyA9IHN5bWJvbDMsIF9iMykge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSA9IFwiSW52YWxpZCByZXF1ZXN0XCIsXG4gICAgc3RhdHVzQ29kZSA9IDQwMCxcbiAgICBjYXVzZSxcbiAgICBnZW5lcmF0aW9uSWRcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyBtZXNzYWdlLCBzdGF0dXNDb2RlLCBjYXVzZSwgZ2VuZXJhdGlvbklkIH0pO1xuICAgIHRoaXNbX2EzXSA9IHRydWU7XG4gICAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gICAgdGhpcy5uYW1lID0gbmFtZTI7XG4gICAgdGhpcy50eXBlID0gXCJpbnZhbGlkX3JlcXVlc3RfZXJyb3JcIjtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBHYXRld2F5RXJyb3IuaGFzTWFya2VyKGVycm9yKSAmJiBzeW1ib2wzIGluIGVycm9yO1xuICB9XG59O1xuXG4vLyBzcmMvZXJyb3JzL2dhdGV3YXktcmF0ZS1saW1pdC1lcnJvci50c1xudmFyIG5hbWUzID0gXCJHYXRld2F5UmF0ZUxpbWl0RXJyb3JcIjtcbnZhciBtYXJrZXI0ID0gYHZlcmNlbC5haS5nYXRld2F5LmVycm9yLiR7bmFtZTN9YDtcbnZhciBzeW1ib2w0ID0gU3ltYm9sLmZvcihtYXJrZXI0KTtcbnZhciBfYTQsIF9iNDtcbnZhciBHYXRld2F5UmF0ZUxpbWl0RXJyb3IgPSBjbGFzcyBleHRlbmRzIChfYjQgPSBHYXRld2F5RXJyb3IsIF9hNCA9IHN5bWJvbDQsIF9iNCkge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSA9IFwiUmF0ZSBsaW1pdCBleGNlZWRlZFwiLFxuICAgIHN0YXR1c0NvZGUgPSA0MjksXG4gICAgY2F1c2UsXG4gICAgZ2VuZXJhdGlvbklkXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKHsgbWVzc2FnZSwgc3RhdHVzQ29kZSwgY2F1c2UsIGdlbmVyYXRpb25JZCB9KTtcbiAgICB0aGlzW19hNF0gPSB0cnVlO1xuICAgIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICAgIHRoaXMubmFtZSA9IG5hbWUzO1xuICAgIHRoaXMudHlwZSA9IFwicmF0ZV9saW1pdF9leGNlZWRlZFwiO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEdhdGV3YXlFcnJvci5oYXNNYXJrZXIoZXJyb3IpICYmIHN5bWJvbDQgaW4gZXJyb3I7XG4gIH1cbn07XG5cbi8vIHNyYy9lcnJvcnMvZ2F0ZXdheS1tb2RlbC1ub3QtZm91bmQtZXJyb3IudHNcbmltcG9ydCB7IHogfSBmcm9tIFwiem9kL3Y0XCI7XG5pbXBvcnQgeyBsYXp5U2NoZW1hLCB6b2RTY2hlbWEgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xudmFyIG5hbWU0ID0gXCJHYXRld2F5TW9kZWxOb3RGb3VuZEVycm9yXCI7XG52YXIgbWFya2VyNSA9IGB2ZXJjZWwuYWkuZ2F0ZXdheS5lcnJvci4ke25hbWU0fWA7XG52YXIgc3ltYm9sNSA9IFN5bWJvbC5mb3IobWFya2VyNSk7XG52YXIgbW9kZWxOb3RGb3VuZFBhcmFtU2NoZW1hID0gbGF6eVNjaGVtYShcbiAgKCkgPT4gem9kU2NoZW1hKFxuICAgIHoub2JqZWN0KHtcbiAgICAgIG1vZGVsSWQ6IHouc3RyaW5nKClcbiAgICB9KVxuICApXG4pO1xudmFyIF9hNSwgX2I1O1xudmFyIEdhdGV3YXlNb2RlbE5vdEZvdW5kRXJyb3IgPSBjbGFzcyBleHRlbmRzIChfYjUgPSBHYXRld2F5RXJyb3IsIF9hNSA9IHN5bWJvbDUsIF9iNSkge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSA9IFwiTW9kZWwgbm90IGZvdW5kXCIsXG4gICAgc3RhdHVzQ29kZSA9IDQwNCxcbiAgICBtb2RlbElkLFxuICAgIGNhdXNlLFxuICAgIGdlbmVyYXRpb25JZFxuICB9ID0ge30pIHtcbiAgICBzdXBlcih7IG1lc3NhZ2UsIHN0YXR1c0NvZGUsIGNhdXNlLCBnZW5lcmF0aW9uSWQgfSk7XG4gICAgdGhpc1tfYTVdID0gdHJ1ZTtcbiAgICAvLyB1c2VkIGluIGlzSW5zdGFuY2VcbiAgICB0aGlzLm5hbWUgPSBuYW1lNDtcbiAgICB0aGlzLnR5cGUgPSBcIm1vZGVsX25vdF9mb3VuZFwiO1xuICAgIHRoaXMubW9kZWxJZCA9IG1vZGVsSWQ7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gR2F0ZXdheUVycm9yLmhhc01hcmtlcihlcnJvcikgJiYgc3ltYm9sNSBpbiBlcnJvcjtcbiAgfVxufTtcblxuLy8gc3JjL2Vycm9ycy9nYXRld2F5LWludGVybmFsLXNlcnZlci1lcnJvci50c1xudmFyIG5hbWU1ID0gXCJHYXRld2F5SW50ZXJuYWxTZXJ2ZXJFcnJvclwiO1xudmFyIG1hcmtlcjYgPSBgdmVyY2VsLmFpLmdhdGV3YXkuZXJyb3IuJHtuYW1lNX1gO1xudmFyIHN5bWJvbDYgPSBTeW1ib2wuZm9yKG1hcmtlcjYpO1xudmFyIF9hNiwgX2I2O1xudmFyIEdhdGV3YXlJbnRlcm5hbFNlcnZlckVycm9yID0gY2xhc3MgZXh0ZW5kcyAoX2I2ID0gR2F0ZXdheUVycm9yLCBfYTYgPSBzeW1ib2w2LCBfYjYpIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UgPSBcIkludGVybmFsIHNlcnZlciBlcnJvclwiLFxuICAgIHN0YXR1c0NvZGUgPSA1MDAsXG4gICAgY2F1c2UsXG4gICAgZ2VuZXJhdGlvbklkXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKHsgbWVzc2FnZSwgc3RhdHVzQ29kZSwgY2F1c2UsIGdlbmVyYXRpb25JZCB9KTtcbiAgICB0aGlzW19hNl0gPSB0cnVlO1xuICAgIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICAgIHRoaXMubmFtZSA9IG5hbWU1O1xuICAgIHRoaXMudHlwZSA9IFwiaW50ZXJuYWxfc2VydmVyX2Vycm9yXCI7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gR2F0ZXdheUVycm9yLmhhc01hcmtlcihlcnJvcikgJiYgc3ltYm9sNiBpbiBlcnJvcjtcbiAgfVxufTtcblxuLy8gc3JjL2Vycm9ycy9nYXRld2F5LXJlc3BvbnNlLWVycm9yLnRzXG52YXIgbmFtZTYgPSBcIkdhdGV3YXlSZXNwb25zZUVycm9yXCI7XG52YXIgbWFya2VyNyA9IGB2ZXJjZWwuYWkuZ2F0ZXdheS5lcnJvci4ke25hbWU2fWA7XG52YXIgc3ltYm9sNyA9IFN5bWJvbC5mb3IobWFya2VyNyk7XG52YXIgX2E3LCBfYjc7XG52YXIgR2F0ZXdheVJlc3BvbnNlRXJyb3IgPSBjbGFzcyBleHRlbmRzIChfYjcgPSBHYXRld2F5RXJyb3IsIF9hNyA9IHN5bWJvbDcsIF9iNykge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSA9IFwiSW52YWxpZCByZXNwb25zZSBmcm9tIEdhdGV3YXlcIixcbiAgICBzdGF0dXNDb2RlID0gNTAyLFxuICAgIHJlc3BvbnNlLFxuICAgIHZhbGlkYXRpb25FcnJvcixcbiAgICBjYXVzZSxcbiAgICBnZW5lcmF0aW9uSWRcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyBtZXNzYWdlLCBzdGF0dXNDb2RlLCBjYXVzZSwgZ2VuZXJhdGlvbklkIH0pO1xuICAgIHRoaXNbX2E3XSA9IHRydWU7XG4gICAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gICAgdGhpcy5uYW1lID0gbmFtZTY7XG4gICAgdGhpcy50eXBlID0gXCJyZXNwb25zZV9lcnJvclwiO1xuICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB0aGlzLnZhbGlkYXRpb25FcnJvciA9IHZhbGlkYXRpb25FcnJvcjtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBHYXRld2F5RXJyb3IuaGFzTWFya2VyKGVycm9yKSAmJiBzeW1ib2w3IGluIGVycm9yO1xuICB9XG59O1xuXG4vLyBzcmMvZXJyb3JzL2NyZWF0ZS1nYXRld2F5LWVycm9yLnRzXG5pbXBvcnQge1xuICBsYXp5U2NoZW1hIGFzIGxhenlTY2hlbWEyLFxuICBzYWZlVmFsaWRhdGVUeXBlcyxcbiAgem9kU2NoZW1hIGFzIHpvZFNjaGVtYTJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUdhdGV3YXlFcnJvckZyb21SZXNwb25zZSh7XG4gIHJlc3BvbnNlLFxuICBzdGF0dXNDb2RlLFxuICBkZWZhdWx0TWVzc2FnZSA9IFwiR2F0ZXdheSByZXF1ZXN0IGZhaWxlZFwiLFxuICBjYXVzZSxcbiAgYXV0aE1ldGhvZFxufSkge1xuICB2YXIgX2E5O1xuICBjb25zdCBwYXJzZVJlc3VsdCA9IGF3YWl0IHNhZmVWYWxpZGF0ZVR5cGVzKHtcbiAgICB2YWx1ZTogcmVzcG9uc2UsXG4gICAgc2NoZW1hOiBnYXRld2F5RXJyb3JSZXNwb25zZVNjaGVtYVxuICB9KTtcbiAgaWYgKCFwYXJzZVJlc3VsdC5zdWNjZXNzKSB7XG4gICAgY29uc3QgcmF3R2VuZXJhdGlvbklkID0gdHlwZW9mIHJlc3BvbnNlID09PSBcIm9iamVjdFwiICYmIHJlc3BvbnNlICE9PSBudWxsICYmIFwiZ2VuZXJhdGlvbklkXCIgaW4gcmVzcG9uc2UgPyByZXNwb25zZS5nZW5lcmF0aW9uSWQgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG5ldyBHYXRld2F5UmVzcG9uc2VFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgSW52YWxpZCBlcnJvciByZXNwb25zZSBmb3JtYXQ6ICR7ZGVmYXVsdE1lc3NhZ2V9YCxcbiAgICAgIHN0YXR1c0NvZGUsXG4gICAgICByZXNwb25zZSxcbiAgICAgIHZhbGlkYXRpb25FcnJvcjogcGFyc2VSZXN1bHQuZXJyb3IsXG4gICAgICBjYXVzZSxcbiAgICAgIGdlbmVyYXRpb25JZDogcmF3R2VuZXJhdGlvbklkXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgdmFsaWRhdGVkUmVzcG9uc2UgPSBwYXJzZVJlc3VsdC52YWx1ZTtcbiAgY29uc3QgZXJyb3JUeXBlID0gdmFsaWRhdGVkUmVzcG9uc2UuZXJyb3IudHlwZTtcbiAgY29uc3QgbWVzc2FnZSA9IHZhbGlkYXRlZFJlc3BvbnNlLmVycm9yLm1lc3NhZ2U7XG4gIGNvbnN0IGdlbmVyYXRpb25JZCA9IChfYTkgPSB2YWxpZGF0ZWRSZXNwb25zZS5nZW5lcmF0aW9uSWQpICE9IG51bGwgPyBfYTkgOiB2b2lkIDA7XG4gIHN3aXRjaCAoZXJyb3JUeXBlKSB7XG4gICAgY2FzZSBcImF1dGhlbnRpY2F0aW9uX2Vycm9yXCI6XG4gICAgICByZXR1cm4gR2F0ZXdheUF1dGhlbnRpY2F0aW9uRXJyb3IuY3JlYXRlQ29udGV4dHVhbEVycm9yKHtcbiAgICAgICAgYXBpS2V5UHJvdmlkZWQ6IGF1dGhNZXRob2QgPT09IFwiYXBpLWtleVwiLFxuICAgICAgICBvaWRjVG9rZW5Qcm92aWRlZDogYXV0aE1ldGhvZCA9PT0gXCJvaWRjXCIsXG4gICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgIGNhdXNlLFxuICAgICAgICBnZW5lcmF0aW9uSWRcbiAgICAgIH0pO1xuICAgIGNhc2UgXCJpbnZhbGlkX3JlcXVlc3RfZXJyb3JcIjpcbiAgICAgIHJldHVybiBuZXcgR2F0ZXdheUludmFsaWRSZXF1ZXN0RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBzdGF0dXNDb2RlLFxuICAgICAgICBjYXVzZSxcbiAgICAgICAgZ2VuZXJhdGlvbklkXG4gICAgICB9KTtcbiAgICBjYXNlIFwicmF0ZV9saW1pdF9leGNlZWRlZFwiOlxuICAgICAgcmV0dXJuIG5ldyBHYXRld2F5UmF0ZUxpbWl0RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBzdGF0dXNDb2RlLFxuICAgICAgICBjYXVzZSxcbiAgICAgICAgZ2VuZXJhdGlvbklkXG4gICAgICB9KTtcbiAgICBjYXNlIFwibW9kZWxfbm90X2ZvdW5kXCI6IHtcbiAgICAgIGNvbnN0IG1vZGVsUmVzdWx0ID0gYXdhaXQgc2FmZVZhbGlkYXRlVHlwZXMoe1xuICAgICAgICB2YWx1ZTogdmFsaWRhdGVkUmVzcG9uc2UuZXJyb3IucGFyYW0sXG4gICAgICAgIHNjaGVtYTogbW9kZWxOb3RGb3VuZFBhcmFtU2NoZW1hXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgR2F0ZXdheU1vZGVsTm90Rm91bmRFcnJvcih7XG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgIG1vZGVsSWQ6IG1vZGVsUmVzdWx0LnN1Y2Nlc3MgPyBtb2RlbFJlc3VsdC52YWx1ZS5tb2RlbElkIDogdm9pZCAwLFxuICAgICAgICBjYXVzZSxcbiAgICAgICAgZ2VuZXJhdGlvbklkXG4gICAgICB9KTtcbiAgICB9XG4gICAgY2FzZSBcImludGVybmFsX3NlcnZlcl9lcnJvclwiOlxuICAgICAgcmV0dXJuIG5ldyBHYXRld2F5SW50ZXJuYWxTZXJ2ZXJFcnJvcih7XG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgIGNhdXNlLFxuICAgICAgICBnZW5lcmF0aW9uSWRcbiAgICAgIH0pO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbmV3IEdhdGV3YXlJbnRlcm5hbFNlcnZlckVycm9yKHtcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgc3RhdHVzQ29kZSxcbiAgICAgICAgY2F1c2UsXG4gICAgICAgIGdlbmVyYXRpb25JZFxuICAgICAgfSk7XG4gIH1cbn1cbnZhciBnYXRld2F5RXJyb3JSZXNwb25zZVNjaGVtYSA9IGxhenlTY2hlbWEyKFxuICAoKSA9PiB6b2RTY2hlbWEyKFxuICAgIHoyLm9iamVjdCh7XG4gICAgICBlcnJvcjogejIub2JqZWN0KHtcbiAgICAgICAgbWVzc2FnZTogejIuc3RyaW5nKCksXG4gICAgICAgIHR5cGU6IHoyLnN0cmluZygpLm51bGxpc2goKSxcbiAgICAgICAgcGFyYW06IHoyLnVua25vd24oKS5udWxsaXNoKCksXG4gICAgICAgIGNvZGU6IHoyLnVuaW9uKFt6Mi5zdHJpbmcoKSwgejIubnVtYmVyKCldKS5udWxsaXNoKClcbiAgICAgIH0pLFxuICAgICAgZ2VuZXJhdGlvbklkOiB6Mi5zdHJpbmcoKS5udWxsaXNoKClcbiAgICB9KVxuICApXG4pO1xuXG4vLyBzcmMvZXJyb3JzL2dhdGV3YXktdGltZW91dC1lcnJvci50c1xudmFyIG5hbWU3ID0gXCJHYXRld2F5VGltZW91dEVycm9yXCI7XG52YXIgbWFya2VyOCA9IGB2ZXJjZWwuYWkuZ2F0ZXdheS5lcnJvci4ke25hbWU3fWA7XG52YXIgc3ltYm9sOCA9IFN5bWJvbC5mb3IobWFya2VyOCk7XG52YXIgX2E4LCBfYjg7XG52YXIgR2F0ZXdheVRpbWVvdXRFcnJvciA9IGNsYXNzIF9HYXRld2F5VGltZW91dEVycm9yIGV4dGVuZHMgKF9iOCA9IEdhdGV3YXlFcnJvciwgX2E4ID0gc3ltYm9sOCwgX2I4KSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlID0gXCJSZXF1ZXN0IHRpbWVkIG91dFwiLFxuICAgIHN0YXR1c0NvZGUgPSA0MDgsXG4gICAgY2F1c2UsXG4gICAgZ2VuZXJhdGlvbklkXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKHsgbWVzc2FnZSwgc3RhdHVzQ29kZSwgY2F1c2UsIGdlbmVyYXRpb25JZCB9KTtcbiAgICB0aGlzW19hOF0gPSB0cnVlO1xuICAgIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICAgIHRoaXMubmFtZSA9IG5hbWU3O1xuICAgIHRoaXMudHlwZSA9IFwidGltZW91dF9lcnJvclwiO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEdhdGV3YXlFcnJvci5oYXNNYXJrZXIoZXJyb3IpICYmIHN5bWJvbDggaW4gZXJyb3I7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBoZWxwZnVsIHRpbWVvdXQgZXJyb3IgbWVzc2FnZSB3aXRoIHRyb3VibGVzaG9vdGluZyBndWlkYW5jZVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZVRpbWVvdXRFcnJvcih7XG4gICAgb3JpZ2luYWxNZXNzYWdlLFxuICAgIHN0YXR1c0NvZGUgPSA0MDgsXG4gICAgY2F1c2UsXG4gICAgZ2VuZXJhdGlvbklkXG4gIH0pIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYEdhdGV3YXkgcmVxdWVzdCB0aW1lZCBvdXQ6ICR7b3JpZ2luYWxNZXNzYWdlfVxuXG4gICAgVGhpcyBpcyBhIGNsaWVudC1zaWRlIHRpbWVvdXQuIFRvIHJlc29sdmUgdGhpcywgaW5jcmVhc2UgeW91ciB0aW1lb3V0IGNvbmZpZ3VyYXRpb246IGh0dHBzOi8vdmVyY2VsLmNvbS9kb2NzL2FpLWdhdGV3YXkvY2FwYWJpbGl0aWVzL3ZpZGVvLWdlbmVyYXRpb24jZXh0ZW5kaW5nLXRpbWVvdXRzLWZvci1ub2RlLmpzYDtcbiAgICByZXR1cm4gbmV3IF9HYXRld2F5VGltZW91dEVycm9yKHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBzdGF0dXNDb2RlLFxuICAgICAgY2F1c2UsXG4gICAgICBnZW5lcmF0aW9uSWRcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL2Vycm9ycy9hcy1nYXRld2F5LWVycm9yLnRzXG5mdW5jdGlvbiBpc1RpbWVvdXRFcnJvcihlcnJvcikge1xuICBpZiAoIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBlcnJvckNvZGUgPSBlcnJvci5jb2RlO1xuICBpZiAodHlwZW9mIGVycm9yQ29kZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IHVuZGljaVRpbWVvdXRDb2RlcyA9IFtcbiAgICAgIFwiVU5EX0VSUl9IRUFERVJTX1RJTUVPVVRcIixcbiAgICAgIFwiVU5EX0VSUl9CT0RZX1RJTUVPVVRcIixcbiAgICAgIFwiVU5EX0VSUl9DT05ORUNUX1RJTUVPVVRcIlxuICAgIF07XG4gICAgcmV0dXJuIHVuZGljaVRpbWVvdXRDb2Rlcy5pbmNsdWRlcyhlcnJvckNvZGUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGFzR2F0ZXdheUVycm9yKGVycm9yLCBhdXRoTWV0aG9kKSB7XG4gIHZhciBfYTk7XG4gIGlmIChHYXRld2F5RXJyb3IuaXNJbnN0YW5jZShlcnJvcikpIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgaWYgKGlzVGltZW91dEVycm9yKGVycm9yKSkge1xuICAgIHJldHVybiBHYXRld2F5VGltZW91dEVycm9yLmNyZWF0ZVRpbWVvdXRFcnJvcih7XG4gICAgICBvcmlnaW5hbE1lc3NhZ2U6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCIsXG4gICAgICBjYXVzZTogZXJyb3JcbiAgICB9KTtcbiAgfVxuICBpZiAoQVBJQ2FsbEVycm9yLmlzSW5zdGFuY2UoZXJyb3IpKSB7XG4gICAgaWYgKGVycm9yLmNhdXNlICYmIGlzVGltZW91dEVycm9yKGVycm9yLmNhdXNlKSkge1xuICAgICAgcmV0dXJuIEdhdGV3YXlUaW1lb3V0RXJyb3IuY3JlYXRlVGltZW91dEVycm9yKHtcbiAgICAgICAgb3JpZ2luYWxNZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICBjYXVzZTogZXJyb3JcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgY3JlYXRlR2F0ZXdheUVycm9yRnJvbVJlc3BvbnNlKHtcbiAgICAgIHJlc3BvbnNlOiBleHRyYWN0QXBpQ2FsbFJlc3BvbnNlKGVycm9yKSxcbiAgICAgIHN0YXR1c0NvZGU6IChfYTkgPSBlcnJvci5zdGF0dXNDb2RlKSAhPSBudWxsID8gX2E5IDogNTAwLFxuICAgICAgZGVmYXVsdE1lc3NhZ2U6IFwiR2F0ZXdheSByZXF1ZXN0IGZhaWxlZFwiLFxuICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgYXV0aE1ldGhvZFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBhd2FpdCBjcmVhdGVHYXRld2F5RXJyb3JGcm9tUmVzcG9uc2Uoe1xuICAgIHJlc3BvbnNlOiB7fSxcbiAgICBzdGF0dXNDb2RlOiA1MDAsXG4gICAgZGVmYXVsdE1lc3NhZ2U6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBgR2F0ZXdheSByZXF1ZXN0IGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWAgOiBcIlVua25vd24gR2F0ZXdheSBlcnJvclwiLFxuICAgIGNhdXNlOiBlcnJvcixcbiAgICBhdXRoTWV0aG9kXG4gIH0pO1xufVxuXG4vLyBzcmMvZXJyb3JzL2V4dHJhY3QtYXBpLWNhbGwtcmVzcG9uc2UudHNcbmZ1bmN0aW9uIGV4dHJhY3RBcGlDYWxsUmVzcG9uc2UoZXJyb3IpIHtcbiAgaWYgKGVycm9yLmRhdGEgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBlcnJvci5kYXRhO1xuICB9XG4gIGlmIChlcnJvci5yZXNwb25zZUJvZHkgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShlcnJvci5yZXNwb25zZUJvZHkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBlcnJvci5yZXNwb25zZUJvZHk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7fTtcbn1cblxuLy8gc3JjL2Vycm9ycy9wYXJzZS1hdXRoLW1ldGhvZC50c1xuaW1wb3J0IHsgeiBhcyB6MyB9IGZyb20gXCJ6b2QvdjRcIjtcbmltcG9ydCB7XG4gIGxhenlTY2hlbWEgYXMgbGF6eVNjaGVtYTMsXG4gIHNhZmVWYWxpZGF0ZVR5cGVzIGFzIHNhZmVWYWxpZGF0ZVR5cGVzMixcbiAgem9kU2NoZW1hIGFzIHpvZFNjaGVtYTNcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbnZhciBHQVRFV0FZX0FVVEhfTUVUSE9EX0hFQURFUiA9IFwiYWktZ2F0ZXdheS1hdXRoLW1ldGhvZFwiO1xuYXN5bmMgZnVuY3Rpb24gcGFyc2VBdXRoTWV0aG9kKGhlYWRlcnMpIHtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2FmZVZhbGlkYXRlVHlwZXMyKHtcbiAgICB2YWx1ZTogaGVhZGVyc1tHQVRFV0FZX0FVVEhfTUVUSE9EX0hFQURFUl0sXG4gICAgc2NoZW1hOiBnYXRld2F5QXV0aE1ldGhvZFNjaGVtYVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdC5zdWNjZXNzID8gcmVzdWx0LnZhbHVlIDogdm9pZCAwO1xufVxudmFyIGdhdGV3YXlBdXRoTWV0aG9kU2NoZW1hID0gbGF6eVNjaGVtYTMoXG4gICgpID0+IHpvZFNjaGVtYTMoejMudW5pb24oW3ozLmxpdGVyYWwoXCJhcGkta2V5XCIpLCB6My5saXRlcmFsKFwib2lkY1wiKV0pKVxuKTtcblxuLy8gc3JjL2dhdGV3YXktZmV0Y2gtbWV0YWRhdGEudHNcbmltcG9ydCB7XG4gIGNyZWF0ZUpzb25FcnJvclJlc3BvbnNlSGFuZGxlcixcbiAgY3JlYXRlSnNvblJlc3BvbnNlSGFuZGxlcixcbiAgZ2V0RnJvbUFwaSxcbiAgbGF6eVNjaGVtYSBhcyBsYXp5U2NoZW1hNCxcbiAgcmVzb2x2ZSxcbiAgem9kU2NoZW1hIGFzIHpvZFNjaGVtYTRcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IHogYXMgejQgfSBmcm9tIFwiem9kL3Y0XCI7XG52YXIgR2F0ZXdheUZldGNoTWV0YWRhdGEgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB9XG4gIGFzeW5jIGdldEF2YWlsYWJsZU1vZGVscygpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyB2YWx1ZSB9ID0gYXdhaXQgZ2V0RnJvbUFwaSh7XG4gICAgICAgIHVybDogYCR7dGhpcy5jb25maWcuYmFzZVVSTH0vY29uZmlnYCxcbiAgICAgICAgaGVhZGVyczogYXdhaXQgcmVzb2x2ZSh0aGlzLmNvbmZpZy5oZWFkZXJzKCkpLFxuICAgICAgICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyOiBjcmVhdGVKc29uUmVzcG9uc2VIYW5kbGVyKFxuICAgICAgICAgIGdhdGV3YXlBdmFpbGFibGVNb2RlbHNSZXNwb25zZVNjaGVtYVxuICAgICAgICApLFxuICAgICAgICBmYWlsZWRSZXNwb25zZUhhbmRsZXI6IGNyZWF0ZUpzb25FcnJvclJlc3BvbnNlSGFuZGxlcih7XG4gICAgICAgICAgZXJyb3JTY2hlbWE6IHo0LmFueSgpLFxuICAgICAgICAgIGVycm9yVG9NZXNzYWdlOiAoZGF0YSkgPT4gZGF0YVxuICAgICAgICB9KSxcbiAgICAgICAgZmV0Y2g6IHRoaXMuY29uZmlnLmZldGNoXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgYXdhaXQgYXNHYXRld2F5RXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRDcmVkaXRzKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBiYXNlVXJsID0gbmV3IFVSTCh0aGlzLmNvbmZpZy5iYXNlVVJMKTtcbiAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IGF3YWl0IGdldEZyb21BcGkoe1xuICAgICAgICB1cmw6IGAke2Jhc2VVcmwub3JpZ2lufS92MS9jcmVkaXRzYCxcbiAgICAgICAgaGVhZGVyczogYXdhaXQgcmVzb2x2ZSh0aGlzLmNvbmZpZy5oZWFkZXJzKCkpLFxuICAgICAgICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyOiBjcmVhdGVKc29uUmVzcG9uc2VIYW5kbGVyKFxuICAgICAgICAgIGdhdGV3YXlDcmVkaXRzUmVzcG9uc2VTY2hlbWFcbiAgICAgICAgKSxcbiAgICAgICAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyOiBjcmVhdGVKc29uRXJyb3JSZXNwb25zZUhhbmRsZXIoe1xuICAgICAgICAgIGVycm9yU2NoZW1hOiB6NC5hbnkoKSxcbiAgICAgICAgICBlcnJvclRvTWVzc2FnZTogKGRhdGEpID0+IGRhdGFcbiAgICAgICAgfSksXG4gICAgICAgIGZldGNoOiB0aGlzLmNvbmZpZy5mZXRjaFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGF3YWl0IGFzR2F0ZXdheUVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cbn07XG52YXIgZ2F0ZXdheUF2YWlsYWJsZU1vZGVsc1Jlc3BvbnNlU2NoZW1hID0gbGF6eVNjaGVtYTQoXG4gICgpID0+IHpvZFNjaGVtYTQoXG4gICAgejQub2JqZWN0KHtcbiAgICAgIG1vZGVsczogejQuYXJyYXkoXG4gICAgICAgIHo0Lm9iamVjdCh7XG4gICAgICAgICAgaWQ6IHo0LnN0cmluZygpLFxuICAgICAgICAgIG5hbWU6IHo0LnN0cmluZygpLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiB6NC5zdHJpbmcoKS5udWxsaXNoKCksXG4gICAgICAgICAgcHJpY2luZzogejQub2JqZWN0KHtcbiAgICAgICAgICAgIGlucHV0OiB6NC5zdHJpbmcoKSxcbiAgICAgICAgICAgIG91dHB1dDogejQuc3RyaW5nKCksXG4gICAgICAgICAgICBpbnB1dF9jYWNoZV9yZWFkOiB6NC5zdHJpbmcoKS5udWxsaXNoKCksXG4gICAgICAgICAgICBpbnB1dF9jYWNoZV93cml0ZTogejQuc3RyaW5nKCkubnVsbGlzaCgpXG4gICAgICAgICAgfSkudHJhbnNmb3JtKFxuICAgICAgICAgICAgKHsgaW5wdXQsIG91dHB1dCwgaW5wdXRfY2FjaGVfcmVhZCwgaW5wdXRfY2FjaGVfd3JpdGUgfSkgPT4gKHtcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgICAgICAgLi4uaW5wdXRfY2FjaGVfcmVhZCA/IHsgY2FjaGVkSW5wdXRUb2tlbnM6IGlucHV0X2NhY2hlX3JlYWQgfSA6IHt9LFxuICAgICAgICAgICAgICAuLi5pbnB1dF9jYWNoZV93cml0ZSA/IHsgY2FjaGVDcmVhdGlvbklucHV0VG9rZW5zOiBpbnB1dF9jYWNoZV93cml0ZSB9IDoge31cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKS5udWxsaXNoKCksXG4gICAgICAgICAgc3BlY2lmaWNhdGlvbjogejQub2JqZWN0KHtcbiAgICAgICAgICAgIHNwZWNpZmljYXRpb25WZXJzaW9uOiB6NC5saXRlcmFsKFwidjNcIiksXG4gICAgICAgICAgICBwcm92aWRlcjogejQuc3RyaW5nKCksXG4gICAgICAgICAgICBtb2RlbElkOiB6NC5zdHJpbmcoKVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIG1vZGVsVHlwZTogejQuZW51bShbXCJlbWJlZGRpbmdcIiwgXCJpbWFnZVwiLCBcImxhbmd1YWdlXCIsIFwidmlkZW9cIl0pLm51bGxpc2goKVxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH0pXG4gIClcbik7XG52YXIgZ2F0ZXdheUNyZWRpdHNSZXNwb25zZVNjaGVtYSA9IGxhenlTY2hlbWE0KFxuICAoKSA9PiB6b2RTY2hlbWE0KFxuICAgIHo0Lm9iamVjdCh7XG4gICAgICBiYWxhbmNlOiB6NC5zdHJpbmcoKSxcbiAgICAgIHRvdGFsX3VzZWQ6IHo0LnN0cmluZygpXG4gICAgfSkudHJhbnNmb3JtKCh7IGJhbGFuY2UsIHRvdGFsX3VzZWQgfSkgPT4gKHtcbiAgICAgIGJhbGFuY2UsXG4gICAgICB0b3RhbFVzZWQ6IHRvdGFsX3VzZWRcbiAgICB9KSlcbiAgKVxuKTtcblxuLy8gc3JjL2dhdGV3YXktbGFuZ3VhZ2UtbW9kZWwudHNcbmltcG9ydCB7XG4gIGNvbWJpbmVIZWFkZXJzLFxuICBjcmVhdGVFdmVudFNvdXJjZVJlc3BvbnNlSGFuZGxlcixcbiAgY3JlYXRlSnNvbkVycm9yUmVzcG9uc2VIYW5kbGVyIGFzIGNyZWF0ZUpzb25FcnJvclJlc3BvbnNlSGFuZGxlcjIsXG4gIGNyZWF0ZUpzb25SZXNwb25zZUhhbmRsZXIgYXMgY3JlYXRlSnNvblJlc3BvbnNlSGFuZGxlcjIsXG4gIHBvc3RKc29uVG9BcGksXG4gIHJlc29sdmUgYXMgcmVzb2x2ZTJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IHogYXMgejUgfSBmcm9tIFwiem9kL3Y0XCI7XG52YXIgR2F0ZXdheUxhbmd1YWdlTW9kZWwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG1vZGVsSWQsIGNvbmZpZykge1xuICAgIHRoaXMubW9kZWxJZCA9IG1vZGVsSWQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5zcGVjaWZpY2F0aW9uVmVyc2lvbiA9IFwidjNcIjtcbiAgICB0aGlzLnN1cHBvcnRlZFVybHMgPSB7IFwiKi8qXCI6IFsvLiovXSB9O1xuICB9XG4gIGdldCBwcm92aWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcucHJvdmlkZXI7XG4gIH1cbiAgYXN5bmMgZ2V0QXJncyhvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhYm9ydFNpZ25hbDogX2Fib3J0U2lnbmFsLCAuLi5vcHRpb25zV2l0aG91dFNpZ25hbCB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4ge1xuICAgICAgYXJnczogdGhpcy5tYXliZUVuY29kZUZpbGVQYXJ0cyhvcHRpb25zV2l0aG91dFNpZ25hbCksXG4gICAgICB3YXJuaW5nczogW11cbiAgICB9O1xuICB9XG4gIGFzeW5jIGRvR2VuZXJhdGUob3B0aW9ucykge1xuICAgIGNvbnN0IHsgYXJncywgd2FybmluZ3MgfSA9IGF3YWl0IHRoaXMuZ2V0QXJncyhvcHRpb25zKTtcbiAgICBjb25zdCB7IGFib3J0U2lnbmFsIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHJlc29sdmVkSGVhZGVycyA9IGF3YWl0IHJlc29sdmUyKHRoaXMuY29uZmlnLmhlYWRlcnMoKSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICB2YWx1ZTogcmVzcG9uc2VCb2R5LFxuICAgICAgICByYXdWYWx1ZTogcmF3UmVzcG9uc2VcbiAgICAgIH0gPSBhd2FpdCBwb3N0SnNvblRvQXBpKHtcbiAgICAgICAgdXJsOiB0aGlzLmdldFVybCgpLFxuICAgICAgICBoZWFkZXJzOiBjb21iaW5lSGVhZGVycyhcbiAgICAgICAgICByZXNvbHZlZEhlYWRlcnMsXG4gICAgICAgICAgb3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICAgIHRoaXMuZ2V0TW9kZWxDb25maWdIZWFkZXJzKHRoaXMubW9kZWxJZCwgZmFsc2UpLFxuICAgICAgICAgIGF3YWl0IHJlc29sdmUyKHRoaXMuY29uZmlnLm8xMXlIZWFkZXJzKVxuICAgICAgICApLFxuICAgICAgICBib2R5OiBhcmdzLFxuICAgICAgICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyOiBjcmVhdGVKc29uUmVzcG9uc2VIYW5kbGVyMih6NS5hbnkoKSksXG4gICAgICAgIGZhaWxlZFJlc3BvbnNlSGFuZGxlcjogY3JlYXRlSnNvbkVycm9yUmVzcG9uc2VIYW5kbGVyMih7XG4gICAgICAgICAgZXJyb3JTY2hlbWE6IHo1LmFueSgpLFxuICAgICAgICAgIGVycm9yVG9NZXNzYWdlOiAoZGF0YSkgPT4gZGF0YVxuICAgICAgICB9KSxcbiAgICAgICAgLi4uYWJvcnRTaWduYWwgJiYgeyBhYm9ydFNpZ25hbCB9LFxuICAgICAgICBmZXRjaDogdGhpcy5jb25maWcuZmV0Y2hcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucmVzcG9uc2VCb2R5LFxuICAgICAgICByZXF1ZXN0OiB7IGJvZHk6IGFyZ3MgfSxcbiAgICAgICAgcmVzcG9uc2U6IHsgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLCBib2R5OiByYXdSZXNwb25zZSB9LFxuICAgICAgICB3YXJuaW5nc1xuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgYXdhaXQgYXNHYXRld2F5RXJyb3IoZXJyb3IsIGF3YWl0IHBhcnNlQXV0aE1ldGhvZChyZXNvbHZlZEhlYWRlcnMpKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZG9TdHJlYW0ob3B0aW9ucykge1xuICAgIGNvbnN0IHsgYXJncywgd2FybmluZ3MgfSA9IGF3YWl0IHRoaXMuZ2V0QXJncyhvcHRpb25zKTtcbiAgICBjb25zdCB7IGFib3J0U2lnbmFsIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHJlc29sdmVkSGVhZGVycyA9IGF3YWl0IHJlc29sdmUyKHRoaXMuY29uZmlnLmhlYWRlcnMoKSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgdmFsdWU6IHJlc3BvbnNlLCByZXNwb25zZUhlYWRlcnMgfSA9IGF3YWl0IHBvc3RKc29uVG9BcGkoe1xuICAgICAgICB1cmw6IHRoaXMuZ2V0VXJsKCksXG4gICAgICAgIGhlYWRlcnM6IGNvbWJpbmVIZWFkZXJzKFxuICAgICAgICAgIHJlc29sdmVkSGVhZGVycyxcbiAgICAgICAgICBvcHRpb25zLmhlYWRlcnMsXG4gICAgICAgICAgdGhpcy5nZXRNb2RlbENvbmZpZ0hlYWRlcnModGhpcy5tb2RlbElkLCB0cnVlKSxcbiAgICAgICAgICBhd2FpdCByZXNvbHZlMih0aGlzLmNvbmZpZy5vMTF5SGVhZGVycylcbiAgICAgICAgKSxcbiAgICAgICAgYm9keTogYXJncyxcbiAgICAgICAgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcjogY3JlYXRlRXZlbnRTb3VyY2VSZXNwb25zZUhhbmRsZXIoejUuYW55KCkpLFxuICAgICAgICBmYWlsZWRSZXNwb25zZUhhbmRsZXI6IGNyZWF0ZUpzb25FcnJvclJlc3BvbnNlSGFuZGxlcjIoe1xuICAgICAgICAgIGVycm9yU2NoZW1hOiB6NS5hbnkoKSxcbiAgICAgICAgICBlcnJvclRvTWVzc2FnZTogKGRhdGEpID0+IGRhdGFcbiAgICAgICAgfSksXG4gICAgICAgIC4uLmFib3J0U2lnbmFsICYmIHsgYWJvcnRTaWduYWwgfSxcbiAgICAgICAgZmV0Y2g6IHRoaXMuY29uZmlnLmZldGNoXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0cmVhbTogcmVzcG9uc2UucGlwZVRocm91Z2goXG4gICAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgIGlmICh3YXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJzdHJlYW0tc3RhcnRcIiwgd2FybmluZ3MgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgaWYgKGNodW5rLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJlYW1QYXJ0ID0gY2h1bmsudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbVBhcnQudHlwZSA9PT0gXCJyYXdcIiAmJiAhb3B0aW9ucy5pbmNsdWRlUmF3Q2h1bmtzKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdHJlYW1QYXJ0LnR5cGUgPT09IFwicmVzcG9uc2UtbWV0YWRhdGFcIiAmJiBzdHJlYW1QYXJ0LnRpbWVzdGFtcCAmJiB0eXBlb2Ygc3RyZWFtUGFydC50aW1lc3RhbXAgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgIHN0cmVhbVBhcnQudGltZXN0YW1wID0gbmV3IERhdGUoc3RyZWFtUGFydC50aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoc3RyZWFtUGFydCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihcbiAgICAgICAgICAgICAgICAgIGNodW5rLmVycm9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICksXG4gICAgICAgIHJlcXVlc3Q6IHsgYm9keTogYXJncyB9LFxuICAgICAgICByZXNwb25zZTogeyBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMgfVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgYXdhaXQgYXNHYXRld2F5RXJyb3IoZXJyb3IsIGF3YWl0IHBhcnNlQXV0aE1ldGhvZChyZXNvbHZlZEhlYWRlcnMpKTtcbiAgICB9XG4gIH1cbiAgaXNGaWxlUGFydChwYXJ0KSB7XG4gICAgcmV0dXJuIHBhcnQgJiYgdHlwZW9mIHBhcnQgPT09IFwib2JqZWN0XCIgJiYgXCJ0eXBlXCIgaW4gcGFydCAmJiBwYXJ0LnR5cGUgPT09IFwiZmlsZVwiO1xuICB9XG4gIC8qKlxuICAgKiBFbmNvZGVzIGZpbGUgcGFydHMgaW4gdGhlIHByb21wdCB0byBiYXNlNjQuIE11dGF0ZXMgdGhlIHBhc3NlZCBvcHRpb25zXG4gICAqIGluc3RhbmNlIGRpcmVjdGx5IHRvIGF2b2lkIGNvcHlpbmcgdGhlIGZpbGUgZGF0YS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBlbmNvZGUuXG4gICAqIEByZXR1cm5zIFRoZSBvcHRpb25zIHdpdGggdGhlIGZpbGUgcGFydHMgZW5jb2RlZC5cbiAgICovXG4gIG1heWJlRW5jb2RlRmlsZVBhcnRzKG9wdGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2Ygb3B0aW9ucy5wcm9tcHQpIHtcbiAgICAgIGZvciAoY29uc3QgcGFydCBvZiBtZXNzYWdlLmNvbnRlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGaWxlUGFydChwYXJ0KSkge1xuICAgICAgICAgIGNvbnN0IGZpbGVQYXJ0ID0gcGFydDtcbiAgICAgICAgICBpZiAoZmlsZVBhcnQuZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IFVpbnQ4QXJyYXkuZnJvbShmaWxlUGFydC5kYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGJhc2U2NERhdGEgPSBCdWZmZXIuZnJvbShidWZmZXIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgICAgICAgICAgZmlsZVBhcnQuZGF0YSA9IG5ldyBVUkwoXG4gICAgICAgICAgICAgIGBkYXRhOiR7ZmlsZVBhcnQubWVkaWFUeXBlIHx8IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJ9O2Jhc2U2NCwke2Jhc2U2NERhdGF9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cbiAgZ2V0VXJsKCkge1xuICAgIHJldHVybiBgJHt0aGlzLmNvbmZpZy5iYXNlVVJMfS9sYW5ndWFnZS1tb2RlbGA7XG4gIH1cbiAgZ2V0TW9kZWxDb25maWdIZWFkZXJzKG1vZGVsSWQsIHN0cmVhbWluZykge1xuICAgIHJldHVybiB7XG4gICAgICBcImFpLWxhbmd1YWdlLW1vZGVsLXNwZWNpZmljYXRpb24tdmVyc2lvblwiOiBcIjNcIixcbiAgICAgIFwiYWktbGFuZ3VhZ2UtbW9kZWwtaWRcIjogbW9kZWxJZCxcbiAgICAgIFwiYWktbGFuZ3VhZ2UtbW9kZWwtc3RyZWFtaW5nXCI6IFN0cmluZyhzdHJlYW1pbmcpXG4gICAgfTtcbiAgfVxufTtcblxuLy8gc3JjL2dhdGV3YXktZW1iZWRkaW5nLW1vZGVsLnRzXG5pbXBvcnQge1xuICBjb21iaW5lSGVhZGVycyBhcyBjb21iaW5lSGVhZGVyczIsXG4gIGNyZWF0ZUpzb25FcnJvclJlc3BvbnNlSGFuZGxlciBhcyBjcmVhdGVKc29uRXJyb3JSZXNwb25zZUhhbmRsZXIzLFxuICBjcmVhdGVKc29uUmVzcG9uc2VIYW5kbGVyIGFzIGNyZWF0ZUpzb25SZXNwb25zZUhhbmRsZXIzLFxuICBsYXp5U2NoZW1hIGFzIGxhenlTY2hlbWE1LFxuICBwb3N0SnNvblRvQXBpIGFzIHBvc3RKc29uVG9BcGkyLFxuICByZXNvbHZlIGFzIHJlc29sdmUzLFxuICB6b2RTY2hlbWEgYXMgem9kU2NoZW1hNVxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuaW1wb3J0IHsgeiBhcyB6NiB9IGZyb20gXCJ6b2QvdjRcIjtcbnZhciBHYXRld2F5RW1iZWRkaW5nTW9kZWwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG1vZGVsSWQsIGNvbmZpZykge1xuICAgIHRoaXMubW9kZWxJZCA9IG1vZGVsSWQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5zcGVjaWZpY2F0aW9uVmVyc2lvbiA9IFwidjNcIjtcbiAgICB0aGlzLm1heEVtYmVkZGluZ3NQZXJDYWxsID0gMjA0ODtcbiAgICB0aGlzLnN1cHBvcnRzUGFyYWxsZWxDYWxscyA9IHRydWU7XG4gIH1cbiAgZ2V0IHByb3ZpZGVyKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5wcm92aWRlcjtcbiAgfVxuICBhc3luYyBkb0VtYmVkKHtcbiAgICB2YWx1ZXMsXG4gICAgaGVhZGVycyxcbiAgICBhYm9ydFNpZ25hbCxcbiAgICBwcm92aWRlck9wdGlvbnNcbiAgfSkge1xuICAgIHZhciBfYTk7XG4gICAgY29uc3QgcmVzb2x2ZWRIZWFkZXJzID0gYXdhaXQgcmVzb2x2ZTModGhpcy5jb25maWcuaGVhZGVycygpKTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIHZhbHVlOiByZXNwb25zZUJvZHksXG4gICAgICAgIHJhd1ZhbHVlXG4gICAgICB9ID0gYXdhaXQgcG9zdEpzb25Ub0FwaTIoe1xuICAgICAgICB1cmw6IHRoaXMuZ2V0VXJsKCksXG4gICAgICAgIGhlYWRlcnM6IGNvbWJpbmVIZWFkZXJzMihcbiAgICAgICAgICByZXNvbHZlZEhlYWRlcnMsXG4gICAgICAgICAgaGVhZGVycyAhPSBudWxsID8gaGVhZGVycyA6IHt9LFxuICAgICAgICAgIHRoaXMuZ2V0TW9kZWxDb25maWdIZWFkZXJzKCksXG4gICAgICAgICAgYXdhaXQgcmVzb2x2ZTModGhpcy5jb25maWcubzExeUhlYWRlcnMpXG4gICAgICAgICksXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICB2YWx1ZXMsXG4gICAgICAgICAgLi4ucHJvdmlkZXJPcHRpb25zID8geyBwcm92aWRlck9wdGlvbnMgfSA6IHt9XG4gICAgICAgIH0sXG4gICAgICAgIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXI6IGNyZWF0ZUpzb25SZXNwb25zZUhhbmRsZXIzKFxuICAgICAgICAgIGdhdGV3YXlFbWJlZGRpbmdSZXNwb25zZVNjaGVtYVxuICAgICAgICApLFxuICAgICAgICBmYWlsZWRSZXNwb25zZUhhbmRsZXI6IGNyZWF0ZUpzb25FcnJvclJlc3BvbnNlSGFuZGxlcjMoe1xuICAgICAgICAgIGVycm9yU2NoZW1hOiB6Ni5hbnkoKSxcbiAgICAgICAgICBlcnJvclRvTWVzc2FnZTogKGRhdGEpID0+IGRhdGFcbiAgICAgICAgfSksXG4gICAgICAgIC4uLmFib3J0U2lnbmFsICYmIHsgYWJvcnRTaWduYWwgfSxcbiAgICAgICAgZmV0Y2g6IHRoaXMuY29uZmlnLmZldGNoXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVtYmVkZGluZ3M6IHJlc3BvbnNlQm9keS5lbWJlZGRpbmdzLFxuICAgICAgICB1c2FnZTogKF9hOSA9IHJlc3BvbnNlQm9keS51c2FnZSkgIT0gbnVsbCA/IF9hOSA6IHZvaWQgMCxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcmVzcG9uc2VCb2R5LnByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgIHJlc3BvbnNlOiB7IGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycywgYm9keTogcmF3VmFsdWUgfSxcbiAgICAgICAgd2FybmluZ3M6IFtdXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBhd2FpdCBhc0dhdGV3YXlFcnJvcihlcnJvciwgYXdhaXQgcGFyc2VBdXRoTWV0aG9kKHJlc29sdmVkSGVhZGVycykpO1xuICAgIH1cbiAgfVxuICBnZXRVcmwoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuY29uZmlnLmJhc2VVUkx9L2VtYmVkZGluZy1tb2RlbGA7XG4gIH1cbiAgZ2V0TW9kZWxDb25maWdIZWFkZXJzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBcImFpLWVtYmVkZGluZy1tb2RlbC1zcGVjaWZpY2F0aW9uLXZlcnNpb25cIjogXCIzXCIsXG4gICAgICBcImFpLW1vZGVsLWlkXCI6IHRoaXMubW9kZWxJZFxuICAgIH07XG4gIH1cbn07XG52YXIgZ2F0ZXdheUVtYmVkZGluZ1Jlc3BvbnNlU2NoZW1hID0gbGF6eVNjaGVtYTUoXG4gICgpID0+IHpvZFNjaGVtYTUoXG4gICAgejYub2JqZWN0KHtcbiAgICAgIGVtYmVkZGluZ3M6IHo2LmFycmF5KHo2LmFycmF5KHo2Lm51bWJlcigpKSksXG4gICAgICB1c2FnZTogejYub2JqZWN0KHsgdG9rZW5zOiB6Ni5udW1iZXIoKSB9KS5udWxsaXNoKCksXG4gICAgICBwcm92aWRlck1ldGFkYXRhOiB6Ni5yZWNvcmQoejYuc3RyaW5nKCksIHo2LnJlY29yZCh6Ni5zdHJpbmcoKSwgejYudW5rbm93bigpKSkub3B0aW9uYWwoKVxuICAgIH0pXG4gIClcbik7XG5cbi8vIHNyYy9nYXRld2F5LWltYWdlLW1vZGVsLnRzXG5pbXBvcnQge1xuICBjb21iaW5lSGVhZGVycyBhcyBjb21iaW5lSGVhZGVyczMsXG4gIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQsXG4gIGNyZWF0ZUpzb25SZXNwb25zZUhhbmRsZXIgYXMgY3JlYXRlSnNvblJlc3BvbnNlSGFuZGxlcjQsXG4gIGNyZWF0ZUpzb25FcnJvclJlc3BvbnNlSGFuZGxlciBhcyBjcmVhdGVKc29uRXJyb3JSZXNwb25zZUhhbmRsZXI0LFxuICBwb3N0SnNvblRvQXBpIGFzIHBvc3RKc29uVG9BcGkzLFxuICByZXNvbHZlIGFzIHJlc29sdmU0XG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgeyB6IGFzIHo3IH0gZnJvbSBcInpvZC92NFwiO1xudmFyIEdhdGV3YXlJbWFnZU1vZGVsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihtb2RlbElkLCBjb25maWcpIHtcbiAgICB0aGlzLm1vZGVsSWQgPSBtb2RlbElkO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuc3BlY2lmaWNhdGlvblZlcnNpb24gPSBcInYzXCI7XG4gICAgLy8gU2V0IGEgdmVyeSBsYXJnZSBudW1iZXIgdG8gcHJldmVudCBjbGllbnQtc2lkZSBzcGxpdHRpbmcgb2YgcmVxdWVzdHNcbiAgICB0aGlzLm1heEltYWdlc1BlckNhbGwgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgfVxuICBnZXQgcHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnByb3ZpZGVyO1xuICB9XG4gIGFzeW5jIGRvR2VuZXJhdGUoe1xuICAgIHByb21wdCxcbiAgICBuLFxuICAgIHNpemUsXG4gICAgYXNwZWN0UmF0aW8sXG4gICAgc2VlZCxcbiAgICBmaWxlcyxcbiAgICBtYXNrLFxuICAgIHByb3ZpZGVyT3B0aW9ucyxcbiAgICBoZWFkZXJzLFxuICAgIGFib3J0U2lnbmFsXG4gIH0pIHtcbiAgICB2YXIgX2E5LCBfYjksIF9jLCBfZDtcbiAgICBjb25zdCByZXNvbHZlZEhlYWRlcnMgPSBhd2FpdCByZXNvbHZlNCh0aGlzLmNvbmZpZy5oZWFkZXJzKCkpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgdmFsdWU6IHJlc3BvbnNlQm9keSxcbiAgICAgICAgcmF3VmFsdWVcbiAgICAgIH0gPSBhd2FpdCBwb3N0SnNvblRvQXBpMyh7XG4gICAgICAgIHVybDogdGhpcy5nZXRVcmwoKSxcbiAgICAgICAgaGVhZGVyczogY29tYmluZUhlYWRlcnMzKFxuICAgICAgICAgIHJlc29sdmVkSGVhZGVycyxcbiAgICAgICAgICBoZWFkZXJzICE9IG51bGwgPyBoZWFkZXJzIDoge30sXG4gICAgICAgICAgdGhpcy5nZXRNb2RlbENvbmZpZ0hlYWRlcnMoKSxcbiAgICAgICAgICBhd2FpdCByZXNvbHZlNCh0aGlzLmNvbmZpZy5vMTF5SGVhZGVycylcbiAgICAgICAgKSxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICBuLFxuICAgICAgICAgIC4uLnNpemUgJiYgeyBzaXplIH0sXG4gICAgICAgICAgLi4uYXNwZWN0UmF0aW8gJiYgeyBhc3BlY3RSYXRpbyB9LFxuICAgICAgICAgIC4uLnNlZWQgJiYgeyBzZWVkIH0sXG4gICAgICAgICAgLi4ucHJvdmlkZXJPcHRpb25zICYmIHsgcHJvdmlkZXJPcHRpb25zIH0sXG4gICAgICAgICAgLi4uZmlsZXMgJiYge1xuICAgICAgICAgICAgZmlsZXM6IGZpbGVzLm1hcCgoZmlsZSkgPT4gbWF5YmVFbmNvZGVJbWFnZUZpbGUoZmlsZSkpXG4gICAgICAgICAgfSxcbiAgICAgICAgICAuLi5tYXNrICYmIHsgbWFzazogbWF5YmVFbmNvZGVJbWFnZUZpbGUobWFzaykgfVxuICAgICAgICB9LFxuICAgICAgICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyOiBjcmVhdGVKc29uUmVzcG9uc2VIYW5kbGVyNChcbiAgICAgICAgICBnYXRld2F5SW1hZ2VSZXNwb25zZVNjaGVtYVxuICAgICAgICApLFxuICAgICAgICBmYWlsZWRSZXNwb25zZUhhbmRsZXI6IGNyZWF0ZUpzb25FcnJvclJlc3BvbnNlSGFuZGxlcjQoe1xuICAgICAgICAgIGVycm9yU2NoZW1hOiB6Ny5hbnkoKSxcbiAgICAgICAgICBlcnJvclRvTWVzc2FnZTogKGRhdGEpID0+IGRhdGFcbiAgICAgICAgfSksXG4gICAgICAgIC4uLmFib3J0U2lnbmFsICYmIHsgYWJvcnRTaWduYWwgfSxcbiAgICAgICAgZmV0Y2g6IHRoaXMuY29uZmlnLmZldGNoXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGltYWdlczogcmVzcG9uc2VCb2R5LmltYWdlcyxcbiAgICAgICAgLy8gQWx3YXlzIGJhc2U2NCBzdHJpbmdzIGZyb20gc2VydmVyXG4gICAgICAgIHdhcm5pbmdzOiAoX2E5ID0gcmVzcG9uc2VCb2R5Lndhcm5pbmdzKSAhPSBudWxsID8gX2E5IDogW10sXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHJlc3BvbnNlQm9keS5wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgIHRpbWVzdGFtcDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICAgICAgbW9kZWxJZDogdGhpcy5tb2RlbElkLFxuICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVyc1xuICAgICAgICB9LFxuICAgICAgICAuLi5yZXNwb25zZUJvZHkudXNhZ2UgIT0gbnVsbCAmJiB7XG4gICAgICAgICAgdXNhZ2U6IHtcbiAgICAgICAgICAgIGlucHV0VG9rZW5zOiAoX2I5ID0gcmVzcG9uc2VCb2R5LnVzYWdlLmlucHV0VG9rZW5zKSAhPSBudWxsID8gX2I5IDogdm9pZCAwLFxuICAgICAgICAgICAgb3V0cHV0VG9rZW5zOiAoX2MgPSByZXNwb25zZUJvZHkudXNhZ2Uub3V0cHV0VG9rZW5zKSAhPSBudWxsID8gX2MgOiB2b2lkIDAsXG4gICAgICAgICAgICB0b3RhbFRva2VuczogKF9kID0gcmVzcG9uc2VCb2R5LnVzYWdlLnRvdGFsVG9rZW5zKSAhPSBudWxsID8gX2QgOiB2b2lkIDBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGF3YWl0IGFzR2F0ZXdheUVycm9yKGVycm9yLCBhd2FpdCBwYXJzZUF1dGhNZXRob2QocmVzb2x2ZWRIZWFkZXJzKSk7XG4gICAgfVxuICB9XG4gIGdldFVybCgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5jb25maWcuYmFzZVVSTH0vaW1hZ2UtbW9kZWxgO1xuICB9XG4gIGdldE1vZGVsQ29uZmlnSGVhZGVycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJhaS1pbWFnZS1tb2RlbC1zcGVjaWZpY2F0aW9uLXZlcnNpb25cIjogXCIzXCIsXG4gICAgICBcImFpLW1vZGVsLWlkXCI6IHRoaXMubW9kZWxJZFxuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBtYXliZUVuY29kZUltYWdlRmlsZShmaWxlKSB7XG4gIGlmIChmaWxlLnR5cGUgPT09IFwiZmlsZVwiICYmIGZpbGUuZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZmlsZSxcbiAgICAgIGRhdGE6IGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQoZmlsZS5kYXRhKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZpbGU7XG59XG52YXIgcHJvdmlkZXJNZXRhZGF0YUVudHJ5U2NoZW1hID0gejcub2JqZWN0KHtcbiAgaW1hZ2VzOiB6Ny5hcnJheSh6Ny51bmtub3duKCkpLm9wdGlvbmFsKClcbn0pLmNhdGNoYWxsKHo3LnVua25vd24oKSk7XG52YXIgZ2F0ZXdheUltYWdlV2FybmluZ1NjaGVtYSA9IHo3LmRpc2NyaW1pbmF0ZWRVbmlvbihcInR5cGVcIiwgW1xuICB6Ny5vYmplY3Qoe1xuICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJ1bnN1cHBvcnRlZFwiKSxcbiAgICBmZWF0dXJlOiB6Ny5zdHJpbmcoKSxcbiAgICBkZXRhaWxzOiB6Ny5zdHJpbmcoKS5vcHRpb25hbCgpXG4gIH0pLFxuICB6Ny5vYmplY3Qoe1xuICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJjb21wYXRpYmlsaXR5XCIpLFxuICAgIGZlYXR1cmU6IHo3LnN0cmluZygpLFxuICAgIGRldGFpbHM6IHo3LnN0cmluZygpLm9wdGlvbmFsKClcbiAgfSksXG4gIHo3Lm9iamVjdCh7XG4gICAgdHlwZTogejcubGl0ZXJhbChcIm90aGVyXCIpLFxuICAgIG1lc3NhZ2U6IHo3LnN0cmluZygpXG4gIH0pXG5dKTtcbnZhciBnYXRld2F5SW1hZ2VVc2FnZVNjaGVtYSA9IHo3Lm9iamVjdCh7XG4gIGlucHV0VG9rZW5zOiB6Ny5udW1iZXIoKS5udWxsaXNoKCksXG4gIG91dHB1dFRva2VuczogejcubnVtYmVyKCkubnVsbGlzaCgpLFxuICB0b3RhbFRva2VuczogejcubnVtYmVyKCkubnVsbGlzaCgpXG59KTtcbnZhciBnYXRld2F5SW1hZ2VSZXNwb25zZVNjaGVtYSA9IHo3Lm9iamVjdCh7XG4gIGltYWdlczogejcuYXJyYXkoejcuc3RyaW5nKCkpLFxuICAvLyBBbHdheXMgYmFzZTY0IHN0cmluZ3Mgb3ZlciB0aGUgd2lyZVxuICB3YXJuaW5nczogejcuYXJyYXkoZ2F0ZXdheUltYWdlV2FybmluZ1NjaGVtYSkub3B0aW9uYWwoKSxcbiAgcHJvdmlkZXJNZXRhZGF0YTogejcucmVjb3JkKHo3LnN0cmluZygpLCBwcm92aWRlck1ldGFkYXRhRW50cnlTY2hlbWEpLm9wdGlvbmFsKCksXG4gIHVzYWdlOiBnYXRld2F5SW1hZ2VVc2FnZVNjaGVtYS5vcHRpb25hbCgpXG59KTtcblxuLy8gc3JjL2dhdGV3YXktdmlkZW8tbW9kZWwudHNcbmltcG9ydCB7IEFQSUNhbGxFcnJvciBhcyBBUElDYWxsRXJyb3IyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7XG4gIGNvbWJpbmVIZWFkZXJzIGFzIGNvbWJpbmVIZWFkZXJzNCxcbiAgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NCBhcyBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0MixcbiAgY3JlYXRlSnNvbkVycm9yUmVzcG9uc2VIYW5kbGVyIGFzIGNyZWF0ZUpzb25FcnJvclJlc3BvbnNlSGFuZGxlcjUsXG4gIHBhcnNlSnNvbkV2ZW50U3RyZWFtLFxuICBwb3N0SnNvblRvQXBpIGFzIHBvc3RKc29uVG9BcGk0LFxuICByZXNvbHZlIGFzIHJlc29sdmU1XG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgeyB6IGFzIHo4IH0gZnJvbSBcInpvZC92NFwiO1xudmFyIEdhdGV3YXlWaWRlb01vZGVsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihtb2RlbElkLCBjb25maWcpIHtcbiAgICB0aGlzLm1vZGVsSWQgPSBtb2RlbElkO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuc3BlY2lmaWNhdGlvblZlcnNpb24gPSBcInYzXCI7XG4gICAgLy8gU2V0IGEgdmVyeSBsYXJnZSBudW1iZXIgdG8gcHJldmVudCBjbGllbnQtc2lkZSBzcGxpdHRpbmcgb2YgcmVxdWVzdHNcbiAgICB0aGlzLm1heFZpZGVvc1BlckNhbGwgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgfVxuICBnZXQgcHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnByb3ZpZGVyO1xuICB9XG4gIGFzeW5jIGRvR2VuZXJhdGUoe1xuICAgIHByb21wdCxcbiAgICBuLFxuICAgIGFzcGVjdFJhdGlvLFxuICAgIHJlc29sdXRpb24sXG4gICAgZHVyYXRpb24sXG4gICAgZnBzLFxuICAgIHNlZWQsXG4gICAgaW1hZ2UsXG4gICAgcHJvdmlkZXJPcHRpb25zLFxuICAgIGhlYWRlcnMsXG4gICAgYWJvcnRTaWduYWxcbiAgfSkge1xuICAgIHZhciBfYTk7XG4gICAgY29uc3QgcmVzb2x2ZWRIZWFkZXJzID0gYXdhaXQgcmVzb2x2ZTUodGhpcy5jb25maWcuaGVhZGVycygpKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyByZXNwb25zZUhlYWRlcnMsIHZhbHVlOiByZXNwb25zZUJvZHkgfSA9IGF3YWl0IHBvc3RKc29uVG9BcGk0KHtcbiAgICAgICAgdXJsOiB0aGlzLmdldFVybCgpLFxuICAgICAgICBoZWFkZXJzOiBjb21iaW5lSGVhZGVyczQoXG4gICAgICAgICAgcmVzb2x2ZWRIZWFkZXJzLFxuICAgICAgICAgIGhlYWRlcnMgIT0gbnVsbCA/IGhlYWRlcnMgOiB7fSxcbiAgICAgICAgICB0aGlzLmdldE1vZGVsQ29uZmlnSGVhZGVycygpLFxuICAgICAgICAgIGF3YWl0IHJlc29sdmU1KHRoaXMuY29uZmlnLm8xMXlIZWFkZXJzKSxcbiAgICAgICAgICB7IGFjY2VwdDogXCJ0ZXh0L2V2ZW50LXN0cmVhbVwiIH1cbiAgICAgICAgKSxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICBuLFxuICAgICAgICAgIC4uLmFzcGVjdFJhdGlvICYmIHsgYXNwZWN0UmF0aW8gfSxcbiAgICAgICAgICAuLi5yZXNvbHV0aW9uICYmIHsgcmVzb2x1dGlvbiB9LFxuICAgICAgICAgIC4uLmR1cmF0aW9uICYmIHsgZHVyYXRpb24gfSxcbiAgICAgICAgICAuLi5mcHMgJiYgeyBmcHMgfSxcbiAgICAgICAgICAuLi5zZWVkICYmIHsgc2VlZCB9LFxuICAgICAgICAgIC4uLnByb3ZpZGVyT3B0aW9ucyAmJiB7IHByb3ZpZGVyT3B0aW9ucyB9LFxuICAgICAgICAgIC4uLmltYWdlICYmIHsgaW1hZ2U6IG1heWJlRW5jb2RlVmlkZW9GaWxlKGltYWdlKSB9XG4gICAgICAgIH0sXG4gICAgICAgIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXI6IGFzeW5jICh7XG4gICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzXG4gICAgICAgIH0pID0+IHtcbiAgICAgICAgICBpZiAocmVzcG9uc2UuYm9keSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQVBJQ2FsbEVycm9yMih7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IFwiU1NFIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHlcIixcbiAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICByZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICAgICAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZXZlbnRTdHJlYW0gPSBwYXJzZUpzb25FdmVudFN0cmVhbSh7XG4gICAgICAgICAgICBzdHJlYW06IHJlc3BvbnNlLmJvZHksXG4gICAgICAgICAgICBzY2hlbWE6IGdhdGV3YXlWaWRlb0V2ZW50U2NoZW1hXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgcmVhZGVyID0gZXZlbnRTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZTogcGFyc2VSZXN1bHQgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgaWYgKGRvbmUgfHwgIXBhcnNlUmVzdWx0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQVBJQ2FsbEVycm9yMih7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IFwiU1NFIHN0cmVhbSBlbmRlZCB3aXRob3V0IGEgZGF0YSBldmVudFwiLFxuICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgICAgICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXBhcnNlUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBUElDYWxsRXJyb3IyKHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogXCJGYWlsZWQgdG8gcGFyc2UgdmlkZW8gU1NFIGV2ZW50XCIsXG4gICAgICAgICAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvcixcbiAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICByZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICAgICAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZXZlbnQgPSBwYXJzZVJlc3VsdC52YWx1ZTtcbiAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQVBJQ2FsbEVycm9yMih7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGV2ZW50Lm1lc3NhZ2UsXG4gICAgICAgICAgICAgIHN0YXR1c0NvZGU6IGV2ZW50LnN0YXR1c0NvZGUsXG4gICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczogT2JqZWN0LmZyb21FbnRyaWVzKFsuLi5yZXNwb25zZS5oZWFkZXJzXSksXG4gICAgICAgICAgICAgIHJlc3BvbnNlQm9keTogSlNPTi5zdHJpbmdpZnkoZXZlbnQpLFxuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGV2ZW50Lm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICB0eXBlOiBldmVudC5lcnJvclR5cGUsXG4gICAgICAgICAgICAgICAgICBwYXJhbTogZXZlbnQucGFyYW1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgdmlkZW9zOiBldmVudC52aWRlb3MsXG4gICAgICAgICAgICAgIHdhcm5pbmdzOiBldmVudC53YXJuaW5ncyxcbiAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogZXZlbnQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczogT2JqZWN0LmZyb21FbnRyaWVzKFsuLi5yZXNwb25zZS5oZWFkZXJzXSlcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBmYWlsZWRSZXNwb25zZUhhbmRsZXI6IGNyZWF0ZUpzb25FcnJvclJlc3BvbnNlSGFuZGxlcjUoe1xuICAgICAgICAgIGVycm9yU2NoZW1hOiB6OC5hbnkoKSxcbiAgICAgICAgICBlcnJvclRvTWVzc2FnZTogKGRhdGEpID0+IGRhdGFcbiAgICAgICAgfSksXG4gICAgICAgIC4uLmFib3J0U2lnbmFsICYmIHsgYWJvcnRTaWduYWwgfSxcbiAgICAgICAgZmV0Y2g6IHRoaXMuY29uZmlnLmZldGNoXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZpZGVvczogcmVzcG9uc2VCb2R5LnZpZGVvcyxcbiAgICAgICAgd2FybmluZ3M6IChfYTkgPSByZXNwb25zZUJvZHkud2FybmluZ3MpICE9IG51bGwgPyBfYTkgOiBbXSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcmVzcG9uc2VCb2R5LnByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgdGltZXN0YW1wOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgICAgICAgICBtb2RlbElkOiB0aGlzLm1vZGVsSWQsXG4gICAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGF3YWl0IGFzR2F0ZXdheUVycm9yKGVycm9yLCBhd2FpdCBwYXJzZUF1dGhNZXRob2QocmVzb2x2ZWRIZWFkZXJzKSk7XG4gICAgfVxuICB9XG4gIGdldFVybCgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5jb25maWcuYmFzZVVSTH0vdmlkZW8tbW9kZWxgO1xuICB9XG4gIGdldE1vZGVsQ29uZmlnSGVhZGVycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJhaS12aWRlby1tb2RlbC1zcGVjaWZpY2F0aW9uLXZlcnNpb25cIjogXCIzXCIsXG4gICAgICBcImFpLW1vZGVsLWlkXCI6IHRoaXMubW9kZWxJZFxuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBtYXliZUVuY29kZVZpZGVvRmlsZShmaWxlKSB7XG4gIGlmIChmaWxlLnR5cGUgPT09IFwiZmlsZVwiICYmIGZpbGUuZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZmlsZSxcbiAgICAgIGRhdGE6IGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQyKGZpbGUuZGF0YSlcbiAgICB9O1xuICB9XG4gIHJldHVybiBmaWxlO1xufVxudmFyIHByb3ZpZGVyTWV0YWRhdGFFbnRyeVNjaGVtYTIgPSB6OC5vYmplY3Qoe1xuICB2aWRlb3M6IHo4LmFycmF5KHo4LnVua25vd24oKSkub3B0aW9uYWwoKVxufSkuY2F0Y2hhbGwoejgudW5rbm93bigpKTtcbnZhciBnYXRld2F5VmlkZW9EYXRhU2NoZW1hID0gejgudW5pb24oW1xuICB6OC5vYmplY3Qoe1xuICAgIHR5cGU6IHo4LmxpdGVyYWwoXCJ1cmxcIiksXG4gICAgdXJsOiB6OC5zdHJpbmcoKSxcbiAgICBtZWRpYVR5cGU6IHo4LnN0cmluZygpXG4gIH0pLFxuICB6OC5vYmplY3Qoe1xuICAgIHR5cGU6IHo4LmxpdGVyYWwoXCJiYXNlNjRcIiksXG4gICAgZGF0YTogejguc3RyaW5nKCksXG4gICAgbWVkaWFUeXBlOiB6OC5zdHJpbmcoKVxuICB9KVxuXSk7XG52YXIgZ2F0ZXdheVZpZGVvV2FybmluZ1NjaGVtYSA9IHo4LmRpc2NyaW1pbmF0ZWRVbmlvbihcInR5cGVcIiwgW1xuICB6OC5vYmplY3Qoe1xuICAgIHR5cGU6IHo4LmxpdGVyYWwoXCJ1bnN1cHBvcnRlZFwiKSxcbiAgICBmZWF0dXJlOiB6OC5zdHJpbmcoKSxcbiAgICBkZXRhaWxzOiB6OC5zdHJpbmcoKS5vcHRpb25hbCgpXG4gIH0pLFxuICB6OC5vYmplY3Qoe1xuICAgIHR5cGU6IHo4LmxpdGVyYWwoXCJjb21wYXRpYmlsaXR5XCIpLFxuICAgIGZlYXR1cmU6IHo4LnN0cmluZygpLFxuICAgIGRldGFpbHM6IHo4LnN0cmluZygpLm9wdGlvbmFsKClcbiAgfSksXG4gIHo4Lm9iamVjdCh7XG4gICAgdHlwZTogejgubGl0ZXJhbChcIm90aGVyXCIpLFxuICAgIG1lc3NhZ2U6IHo4LnN0cmluZygpXG4gIH0pXG5dKTtcbnZhciBnYXRld2F5VmlkZW9FdmVudFNjaGVtYSA9IHo4LmRpc2NyaW1pbmF0ZWRVbmlvbihcInR5cGVcIiwgW1xuICB6OC5vYmplY3Qoe1xuICAgIHR5cGU6IHo4LmxpdGVyYWwoXCJyZXN1bHRcIiksXG4gICAgdmlkZW9zOiB6OC5hcnJheShnYXRld2F5VmlkZW9EYXRhU2NoZW1hKSxcbiAgICB3YXJuaW5nczogejguYXJyYXkoZ2F0ZXdheVZpZGVvV2FybmluZ1NjaGVtYSkub3B0aW9uYWwoKSxcbiAgICBwcm92aWRlck1ldGFkYXRhOiB6OC5yZWNvcmQoejguc3RyaW5nKCksIHByb3ZpZGVyTWV0YWRhdGFFbnRyeVNjaGVtYTIpLm9wdGlvbmFsKClcbiAgfSksXG4gIHo4Lm9iamVjdCh7XG4gICAgdHlwZTogejgubGl0ZXJhbChcImVycm9yXCIpLFxuICAgIG1lc3NhZ2U6IHo4LnN0cmluZygpLFxuICAgIGVycm9yVHlwZTogejguc3RyaW5nKCksXG4gICAgc3RhdHVzQ29kZTogejgubnVtYmVyKCksXG4gICAgcGFyYW06IHo4LnVua25vd24oKS5udWxsYWJsZSgpXG4gIH0pXG5dKTtcblxuLy8gc3JjL3Rvb2wvcGFyYWxsZWwtc2VhcmNoLnRzXG5pbXBvcnQge1xuICBjcmVhdGVQcm92aWRlclRvb2xGYWN0b3J5V2l0aE91dHB1dFNjaGVtYSxcbiAgbGF6eVNjaGVtYSBhcyBsYXp5U2NoZW1hNixcbiAgem9kU2NoZW1hIGFzIHpvZFNjaGVtYTZcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IHogYXMgejkgfSBmcm9tIFwiem9kXCI7XG52YXIgcGFyYWxsZWxTZWFyY2hJbnB1dFNjaGVtYSA9IGxhenlTY2hlbWE2KFxuICAoKSA9PiB6b2RTY2hlbWE2KFxuICAgIHo5Lm9iamVjdCh7XG4gICAgICBvYmplY3RpdmU6IHo5LnN0cmluZygpLmRlc2NyaWJlKFxuICAgICAgICBcIk5hdHVyYWwtbGFuZ3VhZ2UgZGVzY3JpcHRpb24gb2YgdGhlIHdlYiByZXNlYXJjaCBnb2FsLCBpbmNsdWRpbmcgc291cmNlIG9yIGZyZXNobmVzcyBndWlkYW5jZSBhbmQgYnJvYWRlciBjb250ZXh0IGZyb20gdGhlIHRhc2suIE1heGltdW0gNTAwMCBjaGFyYWN0ZXJzLlwiXG4gICAgICApLFxuICAgICAgc2VhcmNoX3F1ZXJpZXM6IHo5LmFycmF5KHo5LnN0cmluZygpKS5vcHRpb25hbCgpLmRlc2NyaWJlKFxuICAgICAgICBcIk9wdGlvbmFsIHNlYXJjaCBxdWVyaWVzIHRvIHN1cHBsZW1lbnQgdGhlIG9iamVjdGl2ZS4gTWF4aW11bSAyMDAgY2hhcmFjdGVycyBwZXIgcXVlcnkuXCJcbiAgICAgICksXG4gICAgICBtb2RlOiB6OS5lbnVtKFtcIm9uZS1zaG90XCIsIFwiYWdlbnRpY1wiXSkub3B0aW9uYWwoKS5kZXNjcmliZShcbiAgICAgICAgJ01vZGUgcHJlc2V0OiBcIm9uZS1zaG90XCIgZm9yIGNvbXByZWhlbnNpdmUgcmVzdWx0cyB3aXRoIGxvbmdlciBleGNlcnB0cyAoZGVmYXVsdCksIFwiYWdlbnRpY1wiIGZvciBjb25jaXNlLCB0b2tlbi1lZmZpY2llbnQgcmVzdWx0cyBmb3IgbXVsdGktc3RlcCB3b3JrZmxvd3MuJ1xuICAgICAgKSxcbiAgICAgIG1heF9yZXN1bHRzOiB6OS5udW1iZXIoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFxuICAgICAgICBcIk1heGltdW0gbnVtYmVyIG9mIHJlc3VsdHMgdG8gcmV0dXJuICgxLTIwKS4gRGVmYXVsdHMgdG8gMTAgaWYgbm90IHNwZWNpZmllZC5cIlxuICAgICAgKSxcbiAgICAgIHNvdXJjZV9wb2xpY3k6IHo5Lm9iamVjdCh7XG4gICAgICAgIGluY2x1ZGVfZG9tYWluczogejkuYXJyYXkoejkuc3RyaW5nKCkpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJMaXN0IG9mIGRvbWFpbnMgdG8gaW5jbHVkZSBpbiBzZWFyY2ggcmVzdWx0cy5cIiksXG4gICAgICAgIGV4Y2x1ZGVfZG9tYWluczogejkuYXJyYXkoejkuc3RyaW5nKCkpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJMaXN0IG9mIGRvbWFpbnMgdG8gZXhjbHVkZSBmcm9tIHNlYXJjaCByZXN1bHRzLlwiKSxcbiAgICAgICAgYWZ0ZXJfZGF0ZTogejkuc3RyaW5nKCkub3B0aW9uYWwoKS5kZXNjcmliZShcbiAgICAgICAgICBcIk9ubHkgaW5jbHVkZSByZXN1bHRzIHB1Ymxpc2hlZCBhZnRlciB0aGlzIGRhdGUgKElTTyA4NjAxIGZvcm1hdCkuXCJcbiAgICAgICAgKVxuICAgICAgfSkub3B0aW9uYWwoKS5kZXNjcmliZShcbiAgICAgICAgXCJTb3VyY2UgcG9saWN5IGZvciBjb250cm9sbGluZyB3aGljaCBkb21haW5zIHRvIGluY2x1ZGUvZXhjbHVkZSBhbmQgZnJlc2huZXNzLlwiXG4gICAgICApLFxuICAgICAgZXhjZXJwdHM6IHo5Lm9iamVjdCh7XG4gICAgICAgIG1heF9jaGFyc19wZXJfcmVzdWx0OiB6OS5udW1iZXIoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiTWF4aW11bSBjaGFyYWN0ZXJzIHBlciByZXN1bHQuXCIpLFxuICAgICAgICBtYXhfY2hhcnNfdG90YWw6IHo5Lm51bWJlcigpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJNYXhpbXVtIHRvdGFsIGNoYXJhY3RlcnMgYWNyb3NzIGFsbCByZXN1bHRzLlwiKVxuICAgICAgfSkub3B0aW9uYWwoKS5kZXNjcmliZShcIkV4Y2VycHQgY29uZmlndXJhdGlvbiBmb3IgY29udHJvbGxpbmcgcmVzdWx0IGxlbmd0aC5cIiksXG4gICAgICBmZXRjaF9wb2xpY3k6IHo5Lm9iamVjdCh7XG4gICAgICAgIG1heF9hZ2Vfc2Vjb25kczogejkubnVtYmVyKCkub3B0aW9uYWwoKS5kZXNjcmliZShcbiAgICAgICAgICBcIk1heGltdW0gYWdlIGluIHNlY29uZHMgZm9yIGNhY2hlZCBjb250ZW50LiBTZXQgdG8gMCB0byBhbHdheXMgZmV0Y2ggZnJlc2ggY29udGVudC5cIlxuICAgICAgICApXG4gICAgICB9KS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiRmV0Y2ggcG9saWN5IGZvciBjb250cm9sbGluZyBjb250ZW50IGZyZXNobmVzcy5cIilcbiAgICB9KVxuICApXG4pO1xudmFyIHBhcmFsbGVsU2VhcmNoT3V0cHV0U2NoZW1hID0gbGF6eVNjaGVtYTYoXG4gICgpID0+IHpvZFNjaGVtYTYoXG4gICAgejkudW5pb24oW1xuICAgICAgLy8gU3VjY2VzcyByZXNwb25zZVxuICAgICAgejkub2JqZWN0KHtcbiAgICAgICAgc2VhcmNoSWQ6IHo5LnN0cmluZygpLFxuICAgICAgICByZXN1bHRzOiB6OS5hcnJheShcbiAgICAgICAgICB6OS5vYmplY3Qoe1xuICAgICAgICAgICAgdXJsOiB6OS5zdHJpbmcoKSxcbiAgICAgICAgICAgIHRpdGxlOiB6OS5zdHJpbmcoKSxcbiAgICAgICAgICAgIGV4Y2VycHQ6IHo5LnN0cmluZygpLFxuICAgICAgICAgICAgcHVibGlzaERhdGU6IHo5LnN0cmluZygpLm51bGxhYmxlKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgIHJlbGV2YW5jZVNjb3JlOiB6OS5udW1iZXIoKS5vcHRpb25hbCgpXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgfSksXG4gICAgICAvLyBFcnJvciByZXNwb25zZVxuICAgICAgejkub2JqZWN0KHtcbiAgICAgICAgZXJyb3I6IHo5LmVudW0oW1xuICAgICAgICAgIFwiYXBpX2Vycm9yXCIsXG4gICAgICAgICAgXCJyYXRlX2xpbWl0XCIsXG4gICAgICAgICAgXCJ0aW1lb3V0XCIsXG4gICAgICAgICAgXCJpbnZhbGlkX2lucHV0XCIsXG4gICAgICAgICAgXCJjb25maWd1cmF0aW9uX2Vycm9yXCIsXG4gICAgICAgICAgXCJ1bmtub3duXCJcbiAgICAgICAgXSksXG4gICAgICAgIHN0YXR1c0NvZGU6IHo5Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gICAgICAgIG1lc3NhZ2U6IHo5LnN0cmluZygpXG4gICAgICB9KVxuICAgIF0pXG4gIClcbik7XG52YXIgcGFyYWxsZWxTZWFyY2hUb29sRmFjdG9yeSA9IGNyZWF0ZVByb3ZpZGVyVG9vbEZhY3RvcnlXaXRoT3V0cHV0U2NoZW1hKHtcbiAgaWQ6IFwiZ2F0ZXdheS5wYXJhbGxlbF9zZWFyY2hcIixcbiAgaW5wdXRTY2hlbWE6IHBhcmFsbGVsU2VhcmNoSW5wdXRTY2hlbWEsXG4gIG91dHB1dFNjaGVtYTogcGFyYWxsZWxTZWFyY2hPdXRwdXRTY2hlbWFcbn0pO1xudmFyIHBhcmFsbGVsU2VhcmNoID0gKGNvbmZpZyA9IHt9KSA9PiBwYXJhbGxlbFNlYXJjaFRvb2xGYWN0b3J5KGNvbmZpZyk7XG5cbi8vIHNyYy90b29sL3BlcnBsZXhpdHktc2VhcmNoLnRzXG5pbXBvcnQge1xuICBjcmVhdGVQcm92aWRlclRvb2xGYWN0b3J5V2l0aE91dHB1dFNjaGVtYSBhcyBjcmVhdGVQcm92aWRlclRvb2xGYWN0b3J5V2l0aE91dHB1dFNjaGVtYTIsXG4gIGxhenlTY2hlbWEgYXMgbGF6eVNjaGVtYTcsXG4gIHpvZFNjaGVtYSBhcyB6b2RTY2hlbWE3XG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgeyB6IGFzIHoxMCB9IGZyb20gXCJ6b2RcIjtcbnZhciBwZXJwbGV4aXR5U2VhcmNoSW5wdXRTY2hlbWEgPSBsYXp5U2NoZW1hNyhcbiAgKCkgPT4gem9kU2NoZW1hNyhcbiAgICB6MTAub2JqZWN0KHtcbiAgICAgIHF1ZXJ5OiB6MTAudW5pb24oW3oxMC5zdHJpbmcoKSwgejEwLmFycmF5KHoxMC5zdHJpbmcoKSldKS5kZXNjcmliZShcbiAgICAgICAgXCJTZWFyY2ggcXVlcnkgKHN0cmluZykgb3IgbXVsdGlwbGUgcXVlcmllcyAoYXJyYXkgb2YgdXAgdG8gNSBzdHJpbmdzKS4gTXVsdGktcXVlcnkgc2VhcmNoZXMgcmV0dXJuIGNvbWJpbmVkIHJlc3VsdHMgZnJvbSBhbGwgcXVlcmllcy5cIlxuICAgICAgKSxcbiAgICAgIG1heF9yZXN1bHRzOiB6MTAubnVtYmVyKCkub3B0aW9uYWwoKS5kZXNjcmliZShcbiAgICAgICAgXCJNYXhpbXVtIG51bWJlciBvZiBzZWFyY2ggcmVzdWx0cyB0byByZXR1cm4gKDEtMjAsIGRlZmF1bHQ6IDEwKVwiXG4gICAgICApLFxuICAgICAgbWF4X3Rva2Vuc19wZXJfcGFnZTogejEwLm51bWJlcigpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXG4gICAgICAgIFwiTWF4aW11bSBudW1iZXIgb2YgdG9rZW5zIHRvIGV4dHJhY3QgcGVyIHNlYXJjaCByZXN1bHQgcGFnZSAoMjU2LTIwNDgsIGRlZmF1bHQ6IDIwNDgpXCJcbiAgICAgICksXG4gICAgICBtYXhfdG9rZW5zOiB6MTAubnVtYmVyKCkub3B0aW9uYWwoKS5kZXNjcmliZShcbiAgICAgICAgXCJNYXhpbXVtIHRvdGFsIHRva2VucyBhY3Jvc3MgYWxsIHNlYXJjaCByZXN1bHRzIChkZWZhdWx0OiAyNTAwMCwgbWF4OiAxMDAwMDAwKVwiXG4gICAgICApLFxuICAgICAgY291bnRyeTogejEwLnN0cmluZygpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXG4gICAgICAgIFwiVHdvLWxldHRlciBJU08gMzE2Ni0xIGFscGhhLTIgY291bnRyeSBjb2RlIGZvciByZWdpb25hbCBzZWFyY2ggcmVzdWx0cyAoZS5nLiwgJ1VTJywgJ0dCJywgJ0ZSJylcIlxuICAgICAgKSxcbiAgICAgIHNlYXJjaF9kb21haW5fZmlsdGVyOiB6MTAuYXJyYXkoejEwLnN0cmluZygpKS5vcHRpb25hbCgpLmRlc2NyaWJlKFxuICAgICAgICBcIkxpc3Qgb2YgZG9tYWlucyB0byBpbmNsdWRlIG9yIGV4Y2x1ZGUgZnJvbSBzZWFyY2ggcmVzdWx0cyAobWF4IDIwKS4gVG8gaW5jbHVkZTogWyduYXR1cmUuY29tJywgJ3NjaWVuY2Uub3JnJ10uIFRvIGV4Y2x1ZGU6IFsnLWV4YW1wbGUuY29tJywgJy1zcGFtLm5ldCddXCJcbiAgICAgICksXG4gICAgICBzZWFyY2hfbGFuZ3VhZ2VfZmlsdGVyOiB6MTAuYXJyYXkoejEwLnN0cmluZygpKS5vcHRpb25hbCgpLmRlc2NyaWJlKFxuICAgICAgICBcIkxpc3Qgb2YgSVNPIDYzOS0xIGxhbmd1YWdlIGNvZGVzIHRvIGZpbHRlciByZXN1bHRzIChtYXggMTAsIGxvd2VyY2FzZSkuIEV4YW1wbGVzOiBbJ2VuJywgJ2ZyJywgJ2RlJ11cIlxuICAgICAgKSxcbiAgICAgIHNlYXJjaF9hZnRlcl9kYXRlOiB6MTAuc3RyaW5nKCkub3B0aW9uYWwoKS5kZXNjcmliZShcbiAgICAgICAgXCJJbmNsdWRlIG9ubHkgcmVzdWx0cyBwdWJsaXNoZWQgYWZ0ZXIgdGhpcyBkYXRlLiBGb3JtYXQ6ICdNTS9ERC9ZWVlZJyAoZS5nLiwgJzMvMS8yMDI1JykuIENhbm5vdCBiZSB1c2VkIHdpdGggc2VhcmNoX3JlY2VuY3lfZmlsdGVyLlwiXG4gICAgICApLFxuICAgICAgc2VhcmNoX2JlZm9yZV9kYXRlOiB6MTAuc3RyaW5nKCkub3B0aW9uYWwoKS5kZXNjcmliZShcbiAgICAgICAgXCJJbmNsdWRlIG9ubHkgcmVzdWx0cyBwdWJsaXNoZWQgYmVmb3JlIHRoaXMgZGF0ZS4gRm9ybWF0OiAnTU0vREQvWVlZWScgKGUuZy4sICczLzE1LzIwMjUnKS4gQ2Fubm90IGJlIHVzZWQgd2l0aCBzZWFyY2hfcmVjZW5jeV9maWx0ZXIuXCJcbiAgICAgICksXG4gICAgICBsYXN0X3VwZGF0ZWRfYWZ0ZXJfZmlsdGVyOiB6MTAuc3RyaW5nKCkub3B0aW9uYWwoKS5kZXNjcmliZShcbiAgICAgICAgXCJJbmNsdWRlIG9ubHkgcmVzdWx0cyBsYXN0IHVwZGF0ZWQgYWZ0ZXIgdGhpcyBkYXRlLiBGb3JtYXQ6ICdNTS9ERC9ZWVlZJyAoZS5nLiwgJzMvMS8yMDI1JykuIENhbm5vdCBiZSB1c2VkIHdpdGggc2VhcmNoX3JlY2VuY3lfZmlsdGVyLlwiXG4gICAgICApLFxuICAgICAgbGFzdF91cGRhdGVkX2JlZm9yZV9maWx0ZXI6IHoxMC5zdHJpbmcoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFxuICAgICAgICBcIkluY2x1ZGUgb25seSByZXN1bHRzIGxhc3QgdXBkYXRlZCBiZWZvcmUgdGhpcyBkYXRlLiBGb3JtYXQ6ICdNTS9ERC9ZWVlZJyAoZS5nLiwgJzMvMTUvMjAyNScpLiBDYW5ub3QgYmUgdXNlZCB3aXRoIHNlYXJjaF9yZWNlbmN5X2ZpbHRlci5cIlxuICAgICAgKSxcbiAgICAgIHNlYXJjaF9yZWNlbmN5X2ZpbHRlcjogejEwLmVudW0oW1wiZGF5XCIsIFwid2Vla1wiLCBcIm1vbnRoXCIsIFwieWVhclwiXSkub3B0aW9uYWwoKS5kZXNjcmliZShcbiAgICAgICAgXCJGaWx0ZXIgcmVzdWx0cyBieSByZWxhdGl2ZSB0aW1lIHBlcmlvZC4gQ2Fubm90IGJlIHVzZWQgd2l0aCBzZWFyY2hfYWZ0ZXJfZGF0ZSBvciBzZWFyY2hfYmVmb3JlX2RhdGUuXCJcbiAgICAgIClcbiAgICB9KVxuICApXG4pO1xudmFyIHBlcnBsZXhpdHlTZWFyY2hPdXRwdXRTY2hlbWEgPSBsYXp5U2NoZW1hNyhcbiAgKCkgPT4gem9kU2NoZW1hNyhcbiAgICB6MTAudW5pb24oW1xuICAgICAgLy8gU3VjY2VzcyByZXNwb25zZVxuICAgICAgejEwLm9iamVjdCh7XG4gICAgICAgIHJlc3VsdHM6IHoxMC5hcnJheShcbiAgICAgICAgICB6MTAub2JqZWN0KHtcbiAgICAgICAgICAgIHRpdGxlOiB6MTAuc3RyaW5nKCksXG4gICAgICAgICAgICB1cmw6IHoxMC5zdHJpbmcoKSxcbiAgICAgICAgICAgIHNuaXBwZXQ6IHoxMC5zdHJpbmcoKSxcbiAgICAgICAgICAgIGRhdGU6IHoxMC5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgbGFzdFVwZGF0ZWQ6IHoxMC5zdHJpbmcoKS5vcHRpb25hbCgpXG4gICAgICAgICAgfSlcbiAgICAgICAgKSxcbiAgICAgICAgaWQ6IHoxMC5zdHJpbmcoKVxuICAgICAgfSksXG4gICAgICAvLyBFcnJvciByZXNwb25zZVxuICAgICAgejEwLm9iamVjdCh7XG4gICAgICAgIGVycm9yOiB6MTAuZW51bShbXG4gICAgICAgICAgXCJhcGlfZXJyb3JcIixcbiAgICAgICAgICBcInJhdGVfbGltaXRcIixcbiAgICAgICAgICBcInRpbWVvdXRcIixcbiAgICAgICAgICBcImludmFsaWRfaW5wdXRcIixcbiAgICAgICAgICBcInVua25vd25cIlxuICAgICAgICBdKSxcbiAgICAgICAgc3RhdHVzQ29kZTogejEwLm51bWJlcigpLm9wdGlvbmFsKCksXG4gICAgICAgIG1lc3NhZ2U6IHoxMC5zdHJpbmcoKVxuICAgICAgfSlcbiAgICBdKVxuICApXG4pO1xudmFyIHBlcnBsZXhpdHlTZWFyY2hUb29sRmFjdG9yeSA9IGNyZWF0ZVByb3ZpZGVyVG9vbEZhY3RvcnlXaXRoT3V0cHV0U2NoZW1hMih7XG4gIGlkOiBcImdhdGV3YXkucGVycGxleGl0eV9zZWFyY2hcIixcbiAgaW5wdXRTY2hlbWE6IHBlcnBsZXhpdHlTZWFyY2hJbnB1dFNjaGVtYSxcbiAgb3V0cHV0U2NoZW1hOiBwZXJwbGV4aXR5U2VhcmNoT3V0cHV0U2NoZW1hXG59KTtcbnZhciBwZXJwbGV4aXR5U2VhcmNoID0gKGNvbmZpZyA9IHt9KSA9PiBwZXJwbGV4aXR5U2VhcmNoVG9vbEZhY3RvcnkoY29uZmlnKTtcblxuLy8gc3JjL2dhdGV3YXktdG9vbHMudHNcbnZhciBnYXRld2F5VG9vbHMgPSB7XG4gIC8qKlxuICAgKiBTZWFyY2ggdGhlIHdlYiB1c2luZyBQYXJhbGxlbCBBSSdzIFNlYXJjaCBBUEkgZm9yIExMTS1vcHRpbWl6ZWQgZXhjZXJwdHMuXG4gICAqXG4gICAqIFRha2VzIGEgbmF0dXJhbCBsYW5ndWFnZSBvYmplY3RpdmUgYW5kIHJldHVybnMgcmVsZXZhbnQgZXhjZXJwdHMsXG4gICAqIHJlcGxhY2luZyBtdWx0aXBsZSBrZXl3b3JkIHNlYXJjaGVzIHdpdGggYSBzaW5nbGUgY2FsbCBmb3IgYnJvYWRcbiAgICogb3IgY29tcGxleCBxdWVyaWVzLiBTdXBwb3J0cyBkaWZmZXJlbnQgc2VhcmNoIHR5cGVzIGZvciBkZXB0aCB2c1xuICAgKiBicmVhZHRoIHRyYWRlb2Zmcy5cbiAgICovXG4gIHBhcmFsbGVsU2VhcmNoLFxuICAvKipcbiAgICogU2VhcmNoIHRoZSB3ZWIgdXNpbmcgUGVycGxleGl0eSdzIFNlYXJjaCBBUEkgZm9yIHJlYWwtdGltZSBpbmZvcm1hdGlvbixcbiAgICogbmV3cywgcmVzZWFyY2ggcGFwZXJzLCBhbmQgYXJ0aWNsZXMuXG4gICAqXG4gICAqIFByb3ZpZGVzIHJhbmtlZCBzZWFyY2ggcmVzdWx0cyB3aXRoIGFkdmFuY2VkIGZpbHRlcmluZyBvcHRpb25zIGluY2x1ZGluZ1xuICAgKiBkb21haW4sIGxhbmd1YWdlLCBkYXRlIHJhbmdlLCBhbmQgcmVjZW5jeSBmaWx0ZXJzLlxuICAgKi9cbiAgcGVycGxleGl0eVNlYXJjaFxufTtcblxuLy8gc3JjL3ZlcmNlbC1lbnZpcm9ubWVudC50c1xuaW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gXCJAdmVyY2VsL29pZGNcIjtcbmltcG9ydCB7IGdldFZlcmNlbE9pZGNUb2tlbiB9IGZyb20gXCJAdmVyY2VsL29pZGNcIjtcbmFzeW5jIGZ1bmN0aW9uIGdldFZlcmNlbFJlcXVlc3RJZCgpIHtcbiAgdmFyIF9hOTtcbiAgcmV0dXJuIChfYTkgPSBnZXRDb250ZXh0KCkuaGVhZGVycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hOVtcIngtdmVyY2VsLWlkXCJdO1xufVxuXG4vLyBzcmMvZ2F0ZXdheS1wcm92aWRlci50c1xuaW1wb3J0IHsgd2l0aFVzZXJBZ2VudFN1ZmZpeCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy92ZXJzaW9uLnRzXG52YXIgVkVSU0lPTiA9IHRydWUgPyBcIjMuMC41M1wiIDogXCIwLjAuMC10ZXN0XCI7XG5cbi8vIHNyYy9nYXRld2F5LXByb3ZpZGVyLnRzXG52YXIgQUlfR0FURVdBWV9QUk9UT0NPTF9WRVJTSU9OID0gXCIwLjAuMVwiO1xuZnVuY3Rpb24gY3JlYXRlR2F0ZXdheVByb3ZpZGVyKG9wdGlvbnMgPSB7fSkge1xuICB2YXIgX2E5LCBfYjk7XG4gIGxldCBwZW5kaW5nTWV0YWRhdGEgPSBudWxsO1xuICBsZXQgbWV0YWRhdGFDYWNoZSA9IG51bGw7XG4gIGNvbnN0IGNhY2hlUmVmcmVzaE1pbGxpcyA9IChfYTkgPSBvcHRpb25zLm1ldGFkYXRhQ2FjaGVSZWZyZXNoTWlsbGlzKSAhPSBudWxsID8gX2E5IDogMWUzICogNjAgKiA1O1xuICBsZXQgbGFzdEZldGNoVGltZSA9IDA7XG4gIGNvbnN0IGJhc2VVUkwgPSAoX2I5ID0gd2l0aG91dFRyYWlsaW5nU2xhc2gob3B0aW9ucy5iYXNlVVJMKSkgIT0gbnVsbCA/IF9iOSA6IFwiaHR0cHM6Ly9haS1nYXRld2F5LnZlcmNlbC5zaC92My9haVwiO1xuICBjb25zdCBnZXRIZWFkZXJzID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhdXRoID0gYXdhaXQgZ2V0R2F0ZXdheUF1dGhUb2tlbihvcHRpb25zKTtcbiAgICAgIHJldHVybiB3aXRoVXNlckFnZW50U3VmZml4KFxuICAgICAgICB7XG4gICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2F1dGgudG9rZW59YCxcbiAgICAgICAgICBcImFpLWdhdGV3YXktcHJvdG9jb2wtdmVyc2lvblwiOiBBSV9HQVRFV0FZX1BST1RPQ09MX1ZFUlNJT04sXG4gICAgICAgICAgW0dBVEVXQVlfQVVUSF9NRVRIT0RfSEVBREVSXTogYXV0aC5hdXRoTWV0aG9kLFxuICAgICAgICAgIC4uLm9wdGlvbnMuaGVhZGVyc1xuICAgICAgICB9LFxuICAgICAgICBgYWktc2RrL2dhdGV3YXkvJHtWRVJTSU9OfWBcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IEdhdGV3YXlBdXRoZW50aWNhdGlvbkVycm9yLmNyZWF0ZUNvbnRleHR1YWxFcnJvcih7XG4gICAgICAgIGFwaUtleVByb3ZpZGVkOiBmYWxzZSxcbiAgICAgICAgb2lkY1Rva2VuUHJvdmlkZWQ6IGZhbHNlLFxuICAgICAgICBzdGF0dXNDb2RlOiA0MDEsXG4gICAgICAgIGNhdXNlOiBlcnJvclxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBjcmVhdGVPMTF5SGVhZGVycyA9ICgpID0+IHtcbiAgICBjb25zdCBkZXBsb3ltZW50SWQgPSBsb2FkT3B0aW9uYWxTZXR0aW5nKHtcbiAgICAgIHNldHRpbmdWYWx1ZTogdm9pZCAwLFxuICAgICAgZW52aXJvbm1lbnRWYXJpYWJsZU5hbWU6IFwiVkVSQ0VMX0RFUExPWU1FTlRfSURcIlxuICAgIH0pO1xuICAgIGNvbnN0IGVudmlyb25tZW50ID0gbG9hZE9wdGlvbmFsU2V0dGluZyh7XG4gICAgICBzZXR0aW5nVmFsdWU6IHZvaWQgMCxcbiAgICAgIGVudmlyb25tZW50VmFyaWFibGVOYW1lOiBcIlZFUkNFTF9FTlZcIlxuICAgIH0pO1xuICAgIGNvbnN0IHJlZ2lvbiA9IGxvYWRPcHRpb25hbFNldHRpbmcoe1xuICAgICAgc2V0dGluZ1ZhbHVlOiB2b2lkIDAsXG4gICAgICBlbnZpcm9ubWVudFZhcmlhYmxlTmFtZTogXCJWRVJDRUxfUkVHSU9OXCJcbiAgICB9KTtcbiAgICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdElkID0gYXdhaXQgZ2V0VmVyY2VsUmVxdWVzdElkKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5kZXBsb3ltZW50SWQgJiYgeyBcImFpLW8xMXktZGVwbG95bWVudC1pZFwiOiBkZXBsb3ltZW50SWQgfSxcbiAgICAgICAgLi4uZW52aXJvbm1lbnQgJiYgeyBcImFpLW8xMXktZW52aXJvbm1lbnRcIjogZW52aXJvbm1lbnQgfSxcbiAgICAgICAgLi4ucmVnaW9uICYmIHsgXCJhaS1vMTF5LXJlZ2lvblwiOiByZWdpb24gfSxcbiAgICAgICAgLi4ucmVxdWVzdElkICYmIHsgXCJhaS1vMTF5LXJlcXVlc3QtaWRcIjogcmVxdWVzdElkIH1cbiAgICAgIH07XG4gICAgfTtcbiAgfTtcbiAgY29uc3QgY3JlYXRlTGFuZ3VhZ2VNb2RlbCA9IChtb2RlbElkKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBHYXRld2F5TGFuZ3VhZ2VNb2RlbChtb2RlbElkLCB7XG4gICAgICBwcm92aWRlcjogXCJnYXRld2F5XCIsXG4gICAgICBiYXNlVVJMLFxuICAgICAgaGVhZGVyczogZ2V0SGVhZGVycyxcbiAgICAgIGZldGNoOiBvcHRpb25zLmZldGNoLFxuICAgICAgbzExeUhlYWRlcnM6IGNyZWF0ZU8xMXlIZWFkZXJzKClcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgZ2V0QXZhaWxhYmxlTW9kZWxzID0gYXN5bmMgKCkgPT4ge1xuICAgIHZhciBfYTEwLCBfYjEwLCBfYztcbiAgICBjb25zdCBub3cgPSAoX2MgPSAoX2IxMCA9IChfYTEwID0gb3B0aW9ucy5faW50ZXJuYWwpID09IG51bGwgPyB2b2lkIDAgOiBfYTEwLmN1cnJlbnREYXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2IxMC5jYWxsKF9hMTApLmdldFRpbWUoKSkgIT0gbnVsbCA/IF9jIDogRGF0ZS5ub3coKTtcbiAgICBpZiAoIXBlbmRpbmdNZXRhZGF0YSB8fCBub3cgLSBsYXN0RmV0Y2hUaW1lID4gY2FjaGVSZWZyZXNoTWlsbGlzKSB7XG4gICAgICBsYXN0RmV0Y2hUaW1lID0gbm93O1xuICAgICAgcGVuZGluZ01ldGFkYXRhID0gbmV3IEdhdGV3YXlGZXRjaE1ldGFkYXRhKHtcbiAgICAgICAgYmFzZVVSTCxcbiAgICAgICAgaGVhZGVyczogZ2V0SGVhZGVycyxcbiAgICAgICAgZmV0Y2g6IG9wdGlvbnMuZmV0Y2hcbiAgICAgIH0pLmdldEF2YWlsYWJsZU1vZGVscygpLnRoZW4oKG1ldGFkYXRhKSA9PiB7XG4gICAgICAgIG1ldGFkYXRhQ2FjaGUgPSBtZXRhZGF0YTtcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgICAgfSkuY2F0Y2goYXN5bmMgKGVycm9yKSA9PiB7XG4gICAgICAgIHRocm93IGF3YWl0IGFzR2F0ZXdheUVycm9yKFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIGF3YWl0IHBhcnNlQXV0aE1ldGhvZChhd2FpdCBnZXRIZWFkZXJzKCkpXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGFkYXRhQ2FjaGUgPyBQcm9taXNlLnJlc29sdmUobWV0YWRhdGFDYWNoZSkgOiBwZW5kaW5nTWV0YWRhdGE7XG4gIH07XG4gIGNvbnN0IGdldENyZWRpdHMgPSBhc3luYyAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBHYXRld2F5RmV0Y2hNZXRhZGF0YSh7XG4gICAgICBiYXNlVVJMLFxuICAgICAgaGVhZGVyczogZ2V0SGVhZGVycyxcbiAgICAgIGZldGNoOiBvcHRpb25zLmZldGNoXG4gICAgfSkuZ2V0Q3JlZGl0cygpLmNhdGNoKGFzeW5jIChlcnJvcikgPT4ge1xuICAgICAgdGhyb3cgYXdhaXQgYXNHYXRld2F5RXJyb3IoXG4gICAgICAgIGVycm9yLFxuICAgICAgICBhd2FpdCBwYXJzZUF1dGhNZXRob2QoYXdhaXQgZ2V0SGVhZGVycygpKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgcHJvdmlkZXIgPSBmdW5jdGlvbihtb2RlbElkKSB7XG4gICAgaWYgKG5ldy50YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJUaGUgR2F0ZXdheSBQcm92aWRlciBtb2RlbCBmdW5jdGlvbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBrZXl3b3JkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlTGFuZ3VhZ2VNb2RlbChtb2RlbElkKTtcbiAgfTtcbiAgcHJvdmlkZXIuc3BlY2lmaWNhdGlvblZlcnNpb24gPSBcInYzXCI7XG4gIHByb3ZpZGVyLmdldEF2YWlsYWJsZU1vZGVscyA9IGdldEF2YWlsYWJsZU1vZGVscztcbiAgcHJvdmlkZXIuZ2V0Q3JlZGl0cyA9IGdldENyZWRpdHM7XG4gIHByb3ZpZGVyLmltYWdlTW9kZWwgPSAobW9kZWxJZCkgPT4ge1xuICAgIHJldHVybiBuZXcgR2F0ZXdheUltYWdlTW9kZWwobW9kZWxJZCwge1xuICAgICAgcHJvdmlkZXI6IFwiZ2F0ZXdheVwiLFxuICAgICAgYmFzZVVSTCxcbiAgICAgIGhlYWRlcnM6IGdldEhlYWRlcnMsXG4gICAgICBmZXRjaDogb3B0aW9ucy5mZXRjaCxcbiAgICAgIG8xMXlIZWFkZXJzOiBjcmVhdGVPMTF5SGVhZGVycygpXG4gICAgfSk7XG4gIH07XG4gIHByb3ZpZGVyLmxhbmd1YWdlTW9kZWwgPSBjcmVhdGVMYW5ndWFnZU1vZGVsO1xuICBjb25zdCBjcmVhdGVFbWJlZGRpbmdNb2RlbCA9IChtb2RlbElkKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBHYXRld2F5RW1iZWRkaW5nTW9kZWwobW9kZWxJZCwge1xuICAgICAgcHJvdmlkZXI6IFwiZ2F0ZXdheVwiLFxuICAgICAgYmFzZVVSTCxcbiAgICAgIGhlYWRlcnM6IGdldEhlYWRlcnMsXG4gICAgICBmZXRjaDogb3B0aW9ucy5mZXRjaCxcbiAgICAgIG8xMXlIZWFkZXJzOiBjcmVhdGVPMTF5SGVhZGVycygpXG4gICAgfSk7XG4gIH07XG4gIHByb3ZpZGVyLmVtYmVkZGluZ01vZGVsID0gY3JlYXRlRW1iZWRkaW5nTW9kZWw7XG4gIHByb3ZpZGVyLnRleHRFbWJlZGRpbmdNb2RlbCA9IGNyZWF0ZUVtYmVkZGluZ01vZGVsO1xuICBwcm92aWRlci52aWRlb01vZGVsID0gKG1vZGVsSWQpID0+IHtcbiAgICByZXR1cm4gbmV3IEdhdGV3YXlWaWRlb01vZGVsKG1vZGVsSWQsIHtcbiAgICAgIHByb3ZpZGVyOiBcImdhdGV3YXlcIixcbiAgICAgIGJhc2VVUkwsXG4gICAgICBoZWFkZXJzOiBnZXRIZWFkZXJzLFxuICAgICAgZmV0Y2g6IG9wdGlvbnMuZmV0Y2gsXG4gICAgICBvMTF5SGVhZGVyczogY3JlYXRlTzExeUhlYWRlcnMoKVxuICAgIH0pO1xuICB9O1xuICBwcm92aWRlci5jaGF0ID0gcHJvdmlkZXIubGFuZ3VhZ2VNb2RlbDtcbiAgcHJvdmlkZXIuZW1iZWRkaW5nID0gcHJvdmlkZXIuZW1iZWRkaW5nTW9kZWw7XG4gIHByb3ZpZGVyLmltYWdlID0gcHJvdmlkZXIuaW1hZ2VNb2RlbDtcbiAgcHJvdmlkZXIudmlkZW8gPSBwcm92aWRlci52aWRlb01vZGVsO1xuICBwcm92aWRlci50b29scyA9IGdhdGV3YXlUb29scztcbiAgcmV0dXJuIHByb3ZpZGVyO1xufVxudmFyIGdhdGV3YXkgPSBjcmVhdGVHYXRld2F5UHJvdmlkZXIoKTtcbmFzeW5jIGZ1bmN0aW9uIGdldEdhdGV3YXlBdXRoVG9rZW4ob3B0aW9ucykge1xuICBjb25zdCBhcGlLZXkgPSBsb2FkT3B0aW9uYWxTZXR0aW5nKHtcbiAgICBzZXR0aW5nVmFsdWU6IG9wdGlvbnMuYXBpS2V5LFxuICAgIGVudmlyb25tZW50VmFyaWFibGVOYW1lOiBcIkFJX0dBVEVXQVlfQVBJX0tFWVwiXG4gIH0pO1xuICBpZiAoYXBpS2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuOiBhcGlLZXksXG4gICAgICBhdXRoTWV0aG9kOiBcImFwaS1rZXlcIlxuICAgIH07XG4gIH1cbiAgY29uc3Qgb2lkY1Rva2VuID0gYXdhaXQgZ2V0VmVyY2VsT2lkY1Rva2VuKCk7XG4gIHJldHVybiB7XG4gICAgdG9rZW46IG9pZGNUb2tlbixcbiAgICBhdXRoTWV0aG9kOiBcIm9pZGNcIlxuICB9O1xufVxuZXhwb3J0IHtcbiAgR2F0ZXdheUF1dGhlbnRpY2F0aW9uRXJyb3IsXG4gIEdhdGV3YXlFcnJvcixcbiAgR2F0ZXdheUludGVybmFsU2VydmVyRXJyb3IsXG4gIEdhdGV3YXlJbnZhbGlkUmVxdWVzdEVycm9yLFxuICBHYXRld2F5TW9kZWxOb3RGb3VuZEVycm9yLFxuICBHYXRld2F5UmF0ZUxpbWl0RXJyb3IsXG4gIEdhdGV3YXlSZXNwb25zZUVycm9yLFxuICBjcmVhdGVHYXRld2F5UHJvdmlkZXIgYXMgY3JlYXRlR2F0ZXdheSxcbiAgY3JlYXRlR2F0ZXdheVByb3ZpZGVyLFxuICBnYXRld2F5XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ai-sdk/gateway/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/dist/index.mjs":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/dist/index.mjs ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_MAX_DOWNLOAD_SIZE: () => (/* binding */ DEFAULT_MAX_DOWNLOAD_SIZE),\n/* harmony export */   DelayedPromise: () => (/* binding */ DelayedPromise),\n/* harmony export */   DownloadError: () => (/* binding */ DownloadError),\n/* harmony export */   EventSourceParserStream: () => (/* reexport safe */ eventsource_parser_stream__WEBPACK_IMPORTED_MODULE_4__.EventSourceParserStream),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   asSchema: () => (/* binding */ asSchema),\n/* harmony export */   combineHeaders: () => (/* binding */ combineHeaders),\n/* harmony export */   convertAsyncIteratorToReadableStream: () => (/* binding */ convertAsyncIteratorToReadableStream),\n/* harmony export */   convertBase64ToUint8Array: () => (/* binding */ convertBase64ToUint8Array),\n/* harmony export */   convertImageModelFileToDataUri: () => (/* binding */ convertImageModelFileToDataUri),\n/* harmony export */   convertToBase64: () => (/* binding */ convertToBase64),\n/* harmony export */   convertToFormData: () => (/* binding */ convertToFormData),\n/* harmony export */   convertUint8ArrayToBase64: () => (/* binding */ convertUint8ArrayToBase64),\n/* harmony export */   createBinaryResponseHandler: () => (/* binding */ createBinaryResponseHandler),\n/* harmony export */   createEventSourceResponseHandler: () => (/* binding */ createEventSourceResponseHandler),\n/* harmony export */   createIdGenerator: () => (/* binding */ createIdGenerator),\n/* harmony export */   createJsonErrorResponseHandler: () => (/* binding */ createJsonErrorResponseHandler),\n/* harmony export */   createJsonResponseHandler: () => (/* binding */ createJsonResponseHandler),\n/* harmony export */   createProviderToolFactory: () => (/* binding */ createProviderToolFactory),\n/* harmony export */   createProviderToolFactoryWithOutputSchema: () => (/* binding */ createProviderToolFactoryWithOutputSchema),\n/* harmony export */   createStatusCodeErrorResponseHandler: () => (/* binding */ createStatusCodeErrorResponseHandler),\n/* harmony export */   createToolNameMapping: () => (/* binding */ createToolNameMapping),\n/* harmony export */   delay: () => (/* binding */ delay),\n/* harmony export */   downloadBlob: () => (/* binding */ downloadBlob),\n/* harmony export */   dynamicTool: () => (/* binding */ dynamicTool),\n/* harmony export */   executeTool: () => (/* binding */ executeTool),\n/* harmony export */   extractResponseHeaders: () => (/* binding */ extractResponseHeaders),\n/* harmony export */   generateId: () => (/* binding */ generateId),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   getFromApi: () => (/* binding */ getFromApi),\n/* harmony export */   getRuntimeEnvironmentUserAgent: () => (/* binding */ getRuntimeEnvironmentUserAgent),\n/* harmony export */   injectJsonInstructionIntoMessages: () => (/* binding */ injectJsonInstructionIntoMessages),\n/* harmony export */   isAbortError: () => (/* binding */ isAbortError),\n/* harmony export */   isNonNullable: () => (/* binding */ isNonNullable),\n/* harmony export */   isParsableJson: () => (/* binding */ isParsableJson),\n/* harmony export */   isUrlSupported: () => (/* binding */ isUrlSupported),\n/* harmony export */   jsonSchema: () => (/* binding */ jsonSchema),\n/* harmony export */   lazySchema: () => (/* binding */ lazySchema),\n/* harmony export */   loadApiKey: () => (/* binding */ loadApiKey),\n/* harmony export */   loadOptionalSetting: () => (/* binding */ loadOptionalSetting),\n/* harmony export */   loadSetting: () => (/* binding */ loadSetting),\n/* harmony export */   mediaTypeToExtension: () => (/* binding */ mediaTypeToExtension),\n/* harmony export */   normalizeHeaders: () => (/* binding */ normalizeHeaders),\n/* harmony export */   parseJSON: () => (/* binding */ parseJSON),\n/* harmony export */   parseJsonEventStream: () => (/* binding */ parseJsonEventStream),\n/* harmony export */   parseProviderOptions: () => (/* binding */ parseProviderOptions),\n/* harmony export */   postFormDataToApi: () => (/* binding */ postFormDataToApi),\n/* harmony export */   postJsonToApi: () => (/* binding */ postJsonToApi),\n/* harmony export */   postToApi: () => (/* binding */ postToApi),\n/* harmony export */   readResponseWithSizeLimit: () => (/* binding */ readResponseWithSizeLimit),\n/* harmony export */   removeUndefinedEntries: () => (/* binding */ removeUndefinedEntries),\n/* harmony export */   resolve: () => (/* binding */ resolve),\n/* harmony export */   safeParseJSON: () => (/* binding */ safeParseJSON),\n/* harmony export */   safeValidateTypes: () => (/* binding */ safeValidateTypes),\n/* harmony export */   tool: () => (/* binding */ tool),\n/* harmony export */   validateTypes: () => (/* binding */ validateTypes),\n/* harmony export */   withUserAgentSuffix: () => (/* binding */ withUserAgentSuffix),\n/* harmony export */   withoutTrailingSlash: () => (/* binding */ withoutTrailingSlash),\n/* harmony export */   zodSchema: () => (/* binding */ zodSchema)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/provider */ \"(ssr)/./node_modules/@ai-sdk/gateway/node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var zod_v4__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zod/v4 */ \"(ssr)/./node_modules/zod/v4/core/to-json-schema.js\");\n/* harmony import */ var zod_v4__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zod/v4 */ \"(ssr)/./node_modules/zod/v4/classic/parse.js\");\n/* harmony import */ var zod_v3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zod/v3 */ \"(ssr)/./node_modules/zod/v3/types.js\");\n/* harmony import */ var eventsource_parser_stream__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! eventsource-parser/stream */ \"(ssr)/./node_modules/eventsource-parser/dist/stream.js\");\n// src/combine-headers.ts\nfunction combineHeaders(...headers) {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => ({\n      ...combinedHeaders,\n      ...currentHeaders != null ? currentHeaders : {}\n    }),\n    {}\n  );\n}\n\n// src/convert-async-iterator-to-readable-stream.ts\nfunction convertAsyncIteratorToReadableStream(iterator) {\n  let cancelled = false;\n  return new ReadableStream({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      if (cancelled) return;\n      try {\n        const { value, done } = await iterator.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    async cancel(reason) {\n      cancelled = true;\n      if (iterator.return) {\n        try {\n          await iterator.return(reason);\n        } catch (e) {\n        }\n      }\n    }\n  });\n}\n\n// src/create-tool-name-mapping.ts\nfunction createToolNameMapping({\n  tools = [],\n  providerToolNames\n}) {\n  const customToolNameToProviderToolName = {};\n  const providerToolNameToCustomToolName = {};\n  for (const tool2 of tools) {\n    if (tool2.type === \"provider\" && tool2.id in providerToolNames) {\n      const providerToolName = providerToolNames[tool2.id];\n      customToolNameToProviderToolName[tool2.name] = providerToolName;\n      providerToolNameToCustomToolName[providerToolName] = tool2.name;\n    }\n  }\n  return {\n    toProviderToolName: (customToolName) => {\n      var _a2;\n      return (_a2 = customToolNameToProviderToolName[customToolName]) != null ? _a2 : customToolName;\n    },\n    toCustomToolName: (providerToolName) => {\n      var _a2;\n      return (_a2 = providerToolNameToCustomToolName[providerToolName]) != null ? _a2 : providerToolName;\n    }\n  };\n}\n\n// src/delay.ts\nasync function delay(delayInMs, options) {\n  if (delayInMs == null) {\n    return Promise.resolve();\n  }\n  const signal = options == null ? void 0 : options.abortSignal;\n  return new Promise((resolve2, reject) => {\n    if (signal == null ? void 0 : signal.aborted) {\n      reject(createAbortError());\n      return;\n    }\n    const timeoutId = setTimeout(() => {\n      cleanup();\n      resolve2();\n    }, delayInMs);\n    const cleanup = () => {\n      clearTimeout(timeoutId);\n      signal == null ? void 0 : signal.removeEventListener(\"abort\", onAbort);\n    };\n    const onAbort = () => {\n      cleanup();\n      reject(createAbortError());\n    };\n    signal == null ? void 0 : signal.addEventListener(\"abort\", onAbort);\n  });\n}\nfunction createAbortError() {\n  return new DOMException(\"Delay was aborted\", \"AbortError\");\n}\n\n// src/delayed-promise.ts\nvar DelayedPromise = class {\n  constructor() {\n    this.status = { type: \"pending\" };\n    this._resolve = void 0;\n    this._reject = void 0;\n  }\n  get promise() {\n    if (this._promise) {\n      return this._promise;\n    }\n    this._promise = new Promise((resolve2, reject) => {\n      if (this.status.type === \"resolved\") {\n        resolve2(this.status.value);\n      } else if (this.status.type === \"rejected\") {\n        reject(this.status.error);\n      }\n      this._resolve = resolve2;\n      this._reject = reject;\n    });\n    return this._promise;\n  }\n  resolve(value) {\n    var _a2;\n    this.status = { type: \"resolved\", value };\n    if (this._promise) {\n      (_a2 = this._resolve) == null ? void 0 : _a2.call(this, value);\n    }\n  }\n  reject(error) {\n    var _a2;\n    this.status = { type: \"rejected\", error };\n    if (this._promise) {\n      (_a2 = this._reject) == null ? void 0 : _a2.call(this, error);\n    }\n  }\n  isResolved() {\n    return this.status.type === \"resolved\";\n  }\n  isRejected() {\n    return this.status.type === \"rejected\";\n  }\n  isPending() {\n    return this.status.type === \"pending\";\n  }\n};\n\n// src/extract-response-headers.ts\nfunction extractResponseHeaders(response) {\n  return Object.fromEntries([...response.headers]);\n}\n\n// src/uint8-utils.ts\nvar { btoa, atob } = globalThis;\nfunction convertBase64ToUint8Array(base64String) {\n  const base64Url = base64String.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const latin1string = atob(base64Url);\n  return Uint8Array.from(latin1string, (byte) => byte.codePointAt(0));\n}\nfunction convertUint8ArrayToBase64(array) {\n  let latin1string = \"\";\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n  return btoa(latin1string);\n}\nfunction convertToBase64(value) {\n  return value instanceof Uint8Array ? convertUint8ArrayToBase64(value) : value;\n}\n\n// src/convert-image-model-file-to-data-uri.ts\nfunction convertImageModelFileToDataUri(file) {\n  if (file.type === \"url\") return file.url;\n  return `data:${file.mediaType};base64,${typeof file.data === \"string\" ? file.data : convertUint8ArrayToBase64(file.data)}`;\n}\n\n// src/convert-to-form-data.ts\nfunction convertToFormData(input, options = {}) {\n  const { useArrayBrackets = true } = options;\n  const formData = new FormData();\n  for (const [key, value] of Object.entries(input)) {\n    if (value == null) {\n      continue;\n    }\n    if (Array.isArray(value)) {\n      if (value.length === 1) {\n        formData.append(key, value[0]);\n        continue;\n      }\n      const arrayKey = useArrayBrackets ? `${key}[]` : key;\n      for (const item of value) {\n        formData.append(arrayKey, item);\n      }\n      continue;\n    }\n    formData.append(key, value);\n  }\n  return formData;\n}\n\n// src/download-error.ts\n\nvar name = \"AI_DownloadError\";\nvar marker = `vercel.ai.error.${name}`;\nvar symbol = Symbol.for(marker);\nvar _a, _b;\nvar DownloadError = class extends (_b = _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError, _a = symbol, _b) {\n  constructor({\n    url,\n    statusCode,\n    statusText,\n    cause,\n    message = cause == null ? `Failed to download ${url}: ${statusCode} ${statusText}` : `Failed to download ${url}: ${cause}`\n  }) {\n    super({ name, message, cause });\n    this[_a] = true;\n    this.url = url;\n    this.statusCode = statusCode;\n    this.statusText = statusText;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker);\n  }\n};\n\n// src/read-response-with-size-limit.ts\nvar DEFAULT_MAX_DOWNLOAD_SIZE = 2 * 1024 * 1024 * 1024;\nasync function readResponseWithSizeLimit({\n  response,\n  url,\n  maxBytes = DEFAULT_MAX_DOWNLOAD_SIZE\n}) {\n  const contentLength = response.headers.get(\"content-length\");\n  if (contentLength != null) {\n    const length = parseInt(contentLength, 10);\n    if (!isNaN(length) && length > maxBytes) {\n      throw new DownloadError({\n        url,\n        message: `Download of ${url} exceeded maximum size of ${maxBytes} bytes (Content-Length: ${length}).`\n      });\n    }\n  }\n  const body = response.body;\n  if (body == null) {\n    return new Uint8Array(0);\n  }\n  const reader = body.getReader();\n  const chunks = [];\n  let totalBytes = 0;\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) {\n        break;\n      }\n      totalBytes += value.length;\n      if (totalBytes > maxBytes) {\n        throw new DownloadError({\n          url,\n          message: `Download of ${url} exceeded maximum size of ${maxBytes} bytes.`\n        });\n      }\n      chunks.push(value);\n    }\n  } finally {\n    try {\n      await reader.cancel();\n    } finally {\n      reader.releaseLock();\n    }\n  }\n  const result = new Uint8Array(totalBytes);\n  let offset = 0;\n  for (const chunk of chunks) {\n    result.set(chunk, offset);\n    offset += chunk.length;\n  }\n  return result;\n}\n\n// src/download-blob.ts\nasync function downloadBlob(url, options) {\n  var _a2, _b2;\n  try {\n    const response = await fetch(url, {\n      signal: options == null ? void 0 : options.abortSignal\n    });\n    if (!response.ok) {\n      throw new DownloadError({\n        url,\n        statusCode: response.status,\n        statusText: response.statusText\n      });\n    }\n    const data = await readResponseWithSizeLimit({\n      response,\n      url,\n      maxBytes: (_a2 = options == null ? void 0 : options.maxBytes) != null ? _a2 : DEFAULT_MAX_DOWNLOAD_SIZE\n    });\n    const contentType = (_b2 = response.headers.get(\"content-type\")) != null ? _b2 : void 0;\n    return new Blob([data], contentType ? { type: contentType } : void 0);\n  } catch (error) {\n    if (DownloadError.isInstance(error)) {\n      throw error;\n    }\n    throw new DownloadError({ url, cause: error });\n  }\n}\n\n// src/generate-id.ts\n\nvar createIdGenerator = ({\n  prefix,\n  size = 16,\n  alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  separator = \"-\"\n} = {}) => {\n  const generator = () => {\n    const alphabetLength = alphabet.length;\n    const chars = new Array(size);\n    for (let i = 0; i < size; i++) {\n      chars[i] = alphabet[Math.random() * alphabetLength | 0];\n    }\n    return chars.join(\"\");\n  };\n  if (prefix == null) {\n    return generator;\n  }\n  if (alphabet.includes(separator)) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError({\n      argument: \"separator\",\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`\n    });\n  }\n  return () => `${prefix}${separator}${generator()}`;\n};\nvar generateId = createIdGenerator();\n\n// src/get-error-message.ts\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\n\n// src/get-from-api.ts\n\n\n// src/handle-fetch-error.ts\n\n\n// src/is-abort-error.ts\nfunction isAbortError(error) {\n  return (error instanceof Error || error instanceof DOMException) && (error.name === \"AbortError\" || error.name === \"ResponseAborted\" || // Next.js\n  error.name === \"TimeoutError\");\n}\n\n// src/handle-fetch-error.ts\nvar FETCH_FAILED_ERROR_MESSAGES = [\"fetch failed\", \"failed to fetch\"];\nvar BUN_ERROR_CODES = [\n  \"ConnectionRefused\",\n  \"ConnectionClosed\",\n  \"FailedToOpenSocket\",\n  \"ECONNRESET\",\n  \"ECONNREFUSED\",\n  \"ETIMEDOUT\",\n  \"EPIPE\"\n];\nfunction isBunNetworkError(error) {\n  if (!(error instanceof Error)) {\n    return false;\n  }\n  const code = error.code;\n  if (typeof code === \"string\" && BUN_ERROR_CODES.includes(code)) {\n    return true;\n  }\n  return false;\n}\nfunction handleFetchError({\n  error,\n  url,\n  requestBodyValues\n}) {\n  if (isAbortError(error)) {\n    return error;\n  }\n  if (error instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES.includes(error.message.toLowerCase())) {\n    const cause = error.cause;\n    if (cause != null) {\n      return new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n        message: `Cannot connect to API: ${cause.message}`,\n        cause,\n        url,\n        requestBodyValues,\n        isRetryable: true\n        // retry when network error\n      });\n    }\n  }\n  if (isBunNetworkError(error)) {\n    return new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n      message: `Cannot connect to API: ${error.message}`,\n      cause: error,\n      url,\n      requestBodyValues,\n      isRetryable: true\n    });\n  }\n  return error;\n}\n\n// src/get-runtime-environment-user-agent.ts\nfunction getRuntimeEnvironmentUserAgent(globalThisAny = globalThis) {\n  var _a2, _b2, _c;\n  if (globalThisAny.window) {\n    return `runtime/browser`;\n  }\n  if ((_a2 = globalThisAny.navigator) == null ? void 0 : _a2.userAgent) {\n    return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;\n  }\n  if ((_c = (_b2 = globalThisAny.process) == null ? void 0 : _b2.versions) == null ? void 0 : _c.node) {\n    return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;\n  }\n  if (globalThisAny.EdgeRuntime) {\n    return `runtime/vercel-edge`;\n  }\n  return \"runtime/unknown\";\n}\n\n// src/normalize-headers.ts\nfunction normalizeHeaders(headers) {\n  if (headers == null) {\n    return {};\n  }\n  const normalized = {};\n  if (headers instanceof Headers) {\n    headers.forEach((value, key) => {\n      normalized[key.toLowerCase()] = value;\n    });\n  } else {\n    if (!Array.isArray(headers)) {\n      headers = Object.entries(headers);\n    }\n    for (const [key, value] of headers) {\n      if (value != null) {\n        normalized[key.toLowerCase()] = value;\n      }\n    }\n  }\n  return normalized;\n}\n\n// src/with-user-agent-suffix.ts\nfunction withUserAgentSuffix(headers, ...userAgentSuffixParts) {\n  const normalizedHeaders = new Headers(normalizeHeaders(headers));\n  const currentUserAgentHeader = normalizedHeaders.get(\"user-agent\") || \"\";\n  normalizedHeaders.set(\n    \"user-agent\",\n    [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(\" \")\n  );\n  return Object.fromEntries(normalizedHeaders.entries());\n}\n\n// src/version.ts\nvar VERSION =  true ? \"4.0.15\" : 0;\n\n// src/get-from-api.ts\nvar getOriginalFetch = () => globalThis.fetch;\nvar getFromApi = async ({\n  url,\n  headers = {},\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch: fetch2 = getOriginalFetch()\n}) => {\n  try {\n    const response = await fetch2(url, {\n      method: \"GET\",\n      headers: withUserAgentSuffix(\n        headers,\n        `ai-sdk/provider-utils/${VERSION}`,\n        getRuntimeEnvironmentUserAgent()\n      ),\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: {}\n        });\n      } catch (error) {\n        if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError.isInstance(error)) {\n          throw error;\n        }\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n          message: \"Failed to process error response\",\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: {}\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: {}\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n        message: \"Failed to process successful response\",\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: {}\n      });\n    }\n  } catch (error) {\n    throw handleFetchError({ error, url, requestBodyValues: {} });\n  }\n};\n\n// src/inject-json-instruction.ts\nvar DEFAULT_SCHEMA_PREFIX = \"JSON schema:\";\nvar DEFAULT_SCHEMA_SUFFIX = \"You MUST answer with a JSON object that matches the JSON schema above.\";\nvar DEFAULT_GENERIC_SUFFIX = \"You MUST answer with JSON.\";\nfunction injectJsonInstruction({\n  prompt,\n  schema,\n  schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX : void 0,\n  schemaSuffix = schema != null ? DEFAULT_SCHEMA_SUFFIX : DEFAULT_GENERIC_SUFFIX\n}) {\n  return [\n    prompt != null && prompt.length > 0 ? prompt : void 0,\n    prompt != null && prompt.length > 0 ? \"\" : void 0,\n    // add a newline if prompt is not null\n    schemaPrefix,\n    schema != null ? JSON.stringify(schema) : void 0,\n    schemaSuffix\n  ].filter((line) => line != null).join(\"\\n\");\n}\nfunction injectJsonInstructionIntoMessages({\n  messages,\n  schema,\n  schemaPrefix,\n  schemaSuffix\n}) {\n  var _a2, _b2;\n  const systemMessage = ((_a2 = messages[0]) == null ? void 0 : _a2.role) === \"system\" ? { ...messages[0] } : { role: \"system\", content: \"\" };\n  systemMessage.content = injectJsonInstruction({\n    prompt: systemMessage.content,\n    schema,\n    schemaPrefix,\n    schemaSuffix\n  });\n  return [\n    systemMessage,\n    ...((_b2 = messages[0]) == null ? void 0 : _b2.role) === \"system\" ? messages.slice(1) : messages\n  ];\n}\n\n// src/is-non-nullable.ts\nfunction isNonNullable(value) {\n  return value != null;\n}\n\n// src/is-url-supported.ts\nfunction isUrlSupported({\n  mediaType,\n  url,\n  supportedUrls\n}) {\n  url = url.toLowerCase();\n  mediaType = mediaType.toLowerCase();\n  return Object.entries(supportedUrls).map(([key, value]) => {\n    const mediaType2 = key.toLowerCase();\n    return mediaType2 === \"*\" || mediaType2 === \"*/*\" ? { mediaTypePrefix: \"\", regexes: value } : { mediaTypePrefix: mediaType2.replace(/\\*/, \"\"), regexes: value };\n  }).filter(({ mediaTypePrefix }) => mediaType.startsWith(mediaTypePrefix)).flatMap(({ regexes }) => regexes).some((pattern) => pattern.test(url));\n}\n\n// src/load-api-key.ts\n\nfunction loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = \"apiKey\",\n  description\n}) {\n  if (typeof apiKey === \"string\") {\n    return apiKey;\n  }\n  if (apiKey != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadAPIKeyError({\n      message: `${description} API key must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  apiKey = process.env[environmentVariableName];\n  if (apiKey == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof apiKey !== \"string\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return apiKey;\n}\n\n// src/load-optional-setting.ts\nfunction loadOptionalSetting({\n  settingValue,\n  environmentVariableName\n}) {\n  if (typeof settingValue === \"string\") {\n    return settingValue;\n  }\n  if (settingValue != null || typeof process === \"undefined\") {\n    return void 0;\n  }\n  settingValue = process.env[environmentVariableName];\n  if (settingValue == null || typeof settingValue !== \"string\") {\n    return void 0;\n  }\n  return settingValue;\n}\n\n// src/load-setting.ts\n\nfunction loadSetting({\n  settingValue,\n  environmentVariableName,\n  settingName,\n  description\n}) {\n  if (typeof settingValue === \"string\") {\n    return settingValue;\n  }\n  if (settingValue != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadSettingError({\n      message: `${description} setting must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  settingValue = process.env[environmentVariableName];\n  if (settingValue == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof settingValue !== \"string\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadSettingError({\n      message: `${description} setting must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return settingValue;\n}\n\n// src/media-type-to-extension.ts\nfunction mediaTypeToExtension(mediaType) {\n  var _a2;\n  const [_type, subtype = \"\"] = mediaType.toLowerCase().split(\"/\");\n  return (_a2 = {\n    mpeg: \"mp3\",\n    \"x-wav\": \"wav\",\n    opus: \"ogg\",\n    mp4: \"m4a\",\n    \"x-m4a\": \"m4a\"\n  }[subtype]) != null ? _a2 : subtype;\n}\n\n// src/parse-json.ts\n\n\n// src/secure-json-parse.ts\nvar suspectProtoRx = /\"__proto__\"\\s*:/;\nvar suspectConstructorRx = /\"constructor\"\\s*:/;\nfunction _parse(text) {\n  const obj = JSON.parse(text);\n  if (obj === null || typeof obj !== \"object\") {\n    return obj;\n  }\n  if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {\n    return obj;\n  }\n  return filter(obj);\n}\nfunction filter(obj) {\n  let next = [obj];\n  while (next.length) {\n    const nodes = next;\n    next = [];\n    for (const node of nodes) {\n      if (Object.prototype.hasOwnProperty.call(node, \"__proto__\")) {\n        throw new SyntaxError(\"Object contains forbidden prototype property\");\n      }\n      if (Object.prototype.hasOwnProperty.call(node, \"constructor\") && Object.prototype.hasOwnProperty.call(node.constructor, \"prototype\")) {\n        throw new SyntaxError(\"Object contains forbidden prototype property\");\n      }\n      for (const key in node) {\n        const value = node[key];\n        if (value && typeof value === \"object\") {\n          next.push(value);\n        }\n      }\n    }\n  }\n  return obj;\n}\nfunction secureJsonParse(text) {\n  const { stackTraceLimit } = Error;\n  try {\n    Error.stackTraceLimit = 0;\n  } catch (e) {\n    return _parse(text);\n  }\n  try {\n    return _parse(text);\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit;\n  }\n}\n\n// src/validate-types.ts\n\n\n// src/schema.ts\n\n\n\n// src/add-additional-properties-to-json-schema.ts\nfunction addAdditionalPropertiesToJsonSchema(jsonSchema2) {\n  if (jsonSchema2.type === \"object\" || Array.isArray(jsonSchema2.type) && jsonSchema2.type.includes(\"object\")) {\n    jsonSchema2.additionalProperties = false;\n    const { properties } = jsonSchema2;\n    if (properties != null) {\n      for (const key of Object.keys(properties)) {\n        properties[key] = visit(properties[key]);\n      }\n    }\n  }\n  if (jsonSchema2.items != null) {\n    jsonSchema2.items = Array.isArray(jsonSchema2.items) ? jsonSchema2.items.map(visit) : visit(jsonSchema2.items);\n  }\n  if (jsonSchema2.anyOf != null) {\n    jsonSchema2.anyOf = jsonSchema2.anyOf.map(visit);\n  }\n  if (jsonSchema2.allOf != null) {\n    jsonSchema2.allOf = jsonSchema2.allOf.map(visit);\n  }\n  if (jsonSchema2.oneOf != null) {\n    jsonSchema2.oneOf = jsonSchema2.oneOf.map(visit);\n  }\n  const { definitions } = jsonSchema2;\n  if (definitions != null) {\n    for (const key of Object.keys(definitions)) {\n      definitions[key] = visit(definitions[key]);\n    }\n  }\n  return jsonSchema2;\n}\nfunction visit(def) {\n  if (typeof def === \"boolean\") return def;\n  return addAdditionalPropertiesToJsonSchema(def);\n}\n\n// src/to-json-schema/zod3-to-json-schema/options.ts\nvar ignoreOverride = Symbol(\n  \"Let zodToJsonSchema decide on which parser to use\"\n);\nvar defaultOptions = {\n  name: void 0,\n  $refStrategy: \"root\",\n  basePath: [\"#\"],\n  effectStrategy: \"input\",\n  pipeStrategy: \"all\",\n  dateStrategy: \"format:date-time\",\n  mapStrategy: \"entries\",\n  removeAdditionalStrategy: \"passthrough\",\n  allowedAdditionalProperties: true,\n  rejectedAdditionalProperties: false,\n  definitionPath: \"definitions\",\n  strictUnions: false,\n  definitions: {},\n  errorMessages: false,\n  patternStrategy: \"escape\",\n  applyRegexFlags: false,\n  emailStrategy: \"format:email\",\n  base64Strategy: \"contentEncoding:base64\",\n  nameStrategy: \"ref\"\n};\nvar getDefaultOptions = (options) => typeof options === \"string\" ? {\n  ...defaultOptions,\n  name: options\n} : {\n  ...defaultOptions,\n  ...options\n};\n\n// src/to-json-schema/zod3-to-json-schema/select-parser.ts\n\n\n// src/to-json-schema/zod3-to-json-schema/parsers/any.ts\nfunction parseAnyDef() {\n  return {};\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/array.ts\n\nfunction parseArrayDef(def, refs) {\n  var _a2, _b2, _c;\n  const res = {\n    type: \"array\"\n  };\n  if (((_a2 = def.type) == null ? void 0 : _a2._def) && ((_c = (_b2 = def.type) == null ? void 0 : _b2._def) == null ? void 0 : _c.typeName) !== zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodAny) {\n    res.items = parseDef(def.type._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"items\"]\n    });\n  }\n  if (def.minLength) {\n    res.minItems = def.minLength.value;\n  }\n  if (def.maxLength) {\n    res.maxItems = def.maxLength.value;\n  }\n  if (def.exactLength) {\n    res.minItems = def.exactLength.value;\n    res.maxItems = def.exactLength.value;\n  }\n  return res;\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/bigint.ts\nfunction parseBigintDef(def) {\n  const res = {\n    type: \"integer\",\n    format: \"int64\"\n  };\n  if (!def.checks) return res;\n  for (const check of def.checks) {\n    switch (check.kind) {\n      case \"min\":\n        if (check.inclusive) {\n          res.minimum = check.value;\n        } else {\n          res.exclusiveMinimum = check.value;\n        }\n        break;\n      case \"max\":\n        if (check.inclusive) {\n          res.maximum = check.value;\n        } else {\n          res.exclusiveMaximum = check.value;\n        }\n        break;\n      case \"multipleOf\":\n        res.multipleOf = check.value;\n        break;\n    }\n  }\n  return res;\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/boolean.ts\nfunction parseBooleanDef() {\n  return { type: \"boolean\" };\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/branded.ts\nfunction parseBrandedDef(_def, refs) {\n  return parseDef(_def.type._def, refs);\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/catch.ts\nvar parseCatchDef = (def, refs) => {\n  return parseDef(def.innerType._def, refs);\n};\n\n// src/to-json-schema/zod3-to-json-schema/parsers/date.ts\nfunction parseDateDef(def, refs, overrideDateStrategy) {\n  const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;\n  if (Array.isArray(strategy)) {\n    return {\n      anyOf: strategy.map((item, i) => parseDateDef(def, refs, item))\n    };\n  }\n  switch (strategy) {\n    case \"string\":\n    case \"format:date-time\":\n      return {\n        type: \"string\",\n        format: \"date-time\"\n      };\n    case \"format:date\":\n      return {\n        type: \"string\",\n        format: \"date\"\n      };\n    case \"integer\":\n      return integerDateParser(def);\n  }\n}\nvar integerDateParser = (def) => {\n  const res = {\n    type: \"integer\",\n    format: \"unix-time\"\n  };\n  for (const check of def.checks) {\n    switch (check.kind) {\n      case \"min\":\n        res.minimum = check.value;\n        break;\n      case \"max\":\n        res.maximum = check.value;\n        break;\n    }\n  }\n  return res;\n};\n\n// src/to-json-schema/zod3-to-json-schema/parsers/default.ts\nfunction parseDefaultDef(_def, refs) {\n  return {\n    ...parseDef(_def.innerType._def, refs),\n    default: _def.defaultValue()\n  };\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/effects.ts\nfunction parseEffectsDef(_def, refs) {\n  return refs.effectStrategy === \"input\" ? parseDef(_def.schema._def, refs) : parseAnyDef();\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/enum.ts\nfunction parseEnumDef(def) {\n  return {\n    type: \"string\",\n    enum: Array.from(def.values)\n  };\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/intersection.ts\nvar isJsonSchema7AllOfType = (type) => {\n  if (\"type\" in type && type.type === \"string\") return false;\n  return \"allOf\" in type;\n};\nfunction parseIntersectionDef(def, refs) {\n  const allOf = [\n    parseDef(def.left._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"allOf\", \"0\"]\n    }),\n    parseDef(def.right._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"allOf\", \"1\"]\n    })\n  ].filter((x) => !!x);\n  const mergedAllOf = [];\n  allOf.forEach((schema) => {\n    if (isJsonSchema7AllOfType(schema)) {\n      mergedAllOf.push(...schema.allOf);\n    } else {\n      let nestedSchema = schema;\n      if (\"additionalProperties\" in schema && schema.additionalProperties === false) {\n        const { additionalProperties, ...rest } = schema;\n        nestedSchema = rest;\n      }\n      mergedAllOf.push(nestedSchema);\n    }\n  });\n  return mergedAllOf.length ? { allOf: mergedAllOf } : void 0;\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/literal.ts\nfunction parseLiteralDef(def) {\n  const parsedType = typeof def.value;\n  if (parsedType !== \"bigint\" && parsedType !== \"number\" && parsedType !== \"boolean\" && parsedType !== \"string\") {\n    return {\n      type: Array.isArray(def.value) ? \"array\" : \"object\"\n    };\n  }\n  return {\n    type: parsedType === \"bigint\" ? \"integer\" : parsedType,\n    const: def.value\n  };\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/record.ts\n\n\n// src/to-json-schema/zod3-to-json-schema/parsers/string.ts\nvar emojiRegex = void 0;\nvar zodPatterns = {\n  /**\n   * `c` was changed to `[cC]` to replicate /i flag\n   */\n  cuid: /^[cC][^\\s-]{8,}$/,\n  cuid2: /^[0-9a-z]+$/,\n  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,\n  /**\n   * `a-z` was added to replicate /i flag\n   */\n  email: /^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_'+\\-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$/,\n  /**\n   * Constructed a valid Unicode RegExp\n   *\n   * Lazily instantiate since this type of regex isn't supported\n   * in all envs (e.g. React Native).\n   *\n   * See:\n   * https://github.com/colinhacks/zod/issues/2433\n   * Fix in Zod:\n   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b\n   */\n  emoji: () => {\n    if (emojiRegex === void 0) {\n      emojiRegex = RegExp(\n        \"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\",\n        \"u\"\n      );\n    }\n    return emojiRegex;\n  },\n  /**\n   * Unused\n   */\n  uuid: /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/,\n  /**\n   * Unused\n   */\n  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,\n  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/,\n  /**\n   * Unused\n   */\n  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,\n  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,\n  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,\n  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,\n  nanoid: /^[a-zA-Z0-9_-]{21}$/,\n  jwt: /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/\n};\nfunction parseStringDef(def, refs) {\n  const res = {\n    type: \"string\"\n  };\n  if (def.checks) {\n    for (const check of def.checks) {\n      switch (check.kind) {\n        case \"min\":\n          res.minLength = typeof res.minLength === \"number\" ? Math.max(res.minLength, check.value) : check.value;\n          break;\n        case \"max\":\n          res.maxLength = typeof res.maxLength === \"number\" ? Math.min(res.maxLength, check.value) : check.value;\n          break;\n        case \"email\":\n          switch (refs.emailStrategy) {\n            case \"format:email\":\n              addFormat(res, \"email\", check.message, refs);\n              break;\n            case \"format:idn-email\":\n              addFormat(res, \"idn-email\", check.message, refs);\n              break;\n            case \"pattern:zod\":\n              addPattern(res, zodPatterns.email, check.message, refs);\n              break;\n          }\n          break;\n        case \"url\":\n          addFormat(res, \"uri\", check.message, refs);\n          break;\n        case \"uuid\":\n          addFormat(res, \"uuid\", check.message, refs);\n          break;\n        case \"regex\":\n          addPattern(res, check.regex, check.message, refs);\n          break;\n        case \"cuid\":\n          addPattern(res, zodPatterns.cuid, check.message, refs);\n          break;\n        case \"cuid2\":\n          addPattern(res, zodPatterns.cuid2, check.message, refs);\n          break;\n        case \"startsWith\":\n          addPattern(\n            res,\n            RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`),\n            check.message,\n            refs\n          );\n          break;\n        case \"endsWith\":\n          addPattern(\n            res,\n            RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`),\n            check.message,\n            refs\n          );\n          break;\n        case \"datetime\":\n          addFormat(res, \"date-time\", check.message, refs);\n          break;\n        case \"date\":\n          addFormat(res, \"date\", check.message, refs);\n          break;\n        case \"time\":\n          addFormat(res, \"time\", check.message, refs);\n          break;\n        case \"duration\":\n          addFormat(res, \"duration\", check.message, refs);\n          break;\n        case \"length\":\n          res.minLength = typeof res.minLength === \"number\" ? Math.max(res.minLength, check.value) : check.value;\n          res.maxLength = typeof res.maxLength === \"number\" ? Math.min(res.maxLength, check.value) : check.value;\n          break;\n        case \"includes\": {\n          addPattern(\n            res,\n            RegExp(escapeLiteralCheckValue(check.value, refs)),\n            check.message,\n            refs\n          );\n          break;\n        }\n        case \"ip\": {\n          if (check.version !== \"v6\") {\n            addFormat(res, \"ipv4\", check.message, refs);\n          }\n          if (check.version !== \"v4\") {\n            addFormat(res, \"ipv6\", check.message, refs);\n          }\n          break;\n        }\n        case \"base64url\":\n          addPattern(res, zodPatterns.base64url, check.message, refs);\n          break;\n        case \"jwt\":\n          addPattern(res, zodPatterns.jwt, check.message, refs);\n          break;\n        case \"cidr\": {\n          if (check.version !== \"v6\") {\n            addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);\n          }\n          if (check.version !== \"v4\") {\n            addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);\n          }\n          break;\n        }\n        case \"emoji\":\n          addPattern(res, zodPatterns.emoji(), check.message, refs);\n          break;\n        case \"ulid\": {\n          addPattern(res, zodPatterns.ulid, check.message, refs);\n          break;\n        }\n        case \"base64\": {\n          switch (refs.base64Strategy) {\n            case \"format:binary\": {\n              addFormat(res, \"binary\", check.message, refs);\n              break;\n            }\n            case \"contentEncoding:base64\": {\n              res.contentEncoding = \"base64\";\n              break;\n            }\n            case \"pattern:zod\": {\n              addPattern(res, zodPatterns.base64, check.message, refs);\n              break;\n            }\n          }\n          break;\n        }\n        case \"nanoid\": {\n          addPattern(res, zodPatterns.nanoid, check.message, refs);\n        }\n        case \"toLowerCase\":\n        case \"toUpperCase\":\n        case \"trim\":\n          break;\n        default:\n          /* @__PURE__ */ ((_) => {\n          })(check);\n      }\n    }\n  }\n  return res;\n}\nfunction escapeLiteralCheckValue(literal, refs) {\n  return refs.patternStrategy === \"escape\" ? escapeNonAlphaNumeric(literal) : literal;\n}\nvar ALPHA_NUMERIC = new Set(\n  \"ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789\"\n);\nfunction escapeNonAlphaNumeric(source) {\n  let result = \"\";\n  for (let i = 0; i < source.length; i++) {\n    if (!ALPHA_NUMERIC.has(source[i])) {\n      result += \"\\\\\";\n    }\n    result += source[i];\n  }\n  return result;\n}\nfunction addFormat(schema, value, message, refs) {\n  var _a2;\n  if (schema.format || ((_a2 = schema.anyOf) == null ? void 0 : _a2.some((x) => x.format))) {\n    if (!schema.anyOf) {\n      schema.anyOf = [];\n    }\n    if (schema.format) {\n      schema.anyOf.push({\n        format: schema.format\n      });\n      delete schema.format;\n    }\n    schema.anyOf.push({\n      format: value,\n      ...message && refs.errorMessages && { errorMessage: { format: message } }\n    });\n  } else {\n    schema.format = value;\n  }\n}\nfunction addPattern(schema, regex, message, refs) {\n  var _a2;\n  if (schema.pattern || ((_a2 = schema.allOf) == null ? void 0 : _a2.some((x) => x.pattern))) {\n    if (!schema.allOf) {\n      schema.allOf = [];\n    }\n    if (schema.pattern) {\n      schema.allOf.push({\n        pattern: schema.pattern\n      });\n      delete schema.pattern;\n    }\n    schema.allOf.push({\n      pattern: stringifyRegExpWithFlags(regex, refs),\n      ...message && refs.errorMessages && { errorMessage: { pattern: message } }\n    });\n  } else {\n    schema.pattern = stringifyRegExpWithFlags(regex, refs);\n  }\n}\nfunction stringifyRegExpWithFlags(regex, refs) {\n  var _a2;\n  if (!refs.applyRegexFlags || !regex.flags) {\n    return regex.source;\n  }\n  const flags = {\n    i: regex.flags.includes(\"i\"),\n    // Case-insensitive\n    m: regex.flags.includes(\"m\"),\n    // `^` and `$` matches adjacent to newline characters\n    s: regex.flags.includes(\"s\")\n    // `.` matches newlines\n  };\n  const source = flags.i ? regex.source.toLowerCase() : regex.source;\n  let pattern = \"\";\n  let isEscaped = false;\n  let inCharGroup = false;\n  let inCharRange = false;\n  for (let i = 0; i < source.length; i++) {\n    if (isEscaped) {\n      pattern += source[i];\n      isEscaped = false;\n      continue;\n    }\n    if (flags.i) {\n      if (inCharGroup) {\n        if (source[i].match(/[a-z]/)) {\n          if (inCharRange) {\n            pattern += source[i];\n            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();\n            inCharRange = false;\n          } else if (source[i + 1] === \"-\" && ((_a2 = source[i + 2]) == null ? void 0 : _a2.match(/[a-z]/))) {\n            pattern += source[i];\n            inCharRange = true;\n          } else {\n            pattern += `${source[i]}${source[i].toUpperCase()}`;\n          }\n          continue;\n        }\n      } else if (source[i].match(/[a-z]/)) {\n        pattern += `[${source[i]}${source[i].toUpperCase()}]`;\n        continue;\n      }\n    }\n    if (flags.m) {\n      if (source[i] === \"^\") {\n        pattern += `(^|(?<=[\\r\n]))`;\n        continue;\n      } else if (source[i] === \"$\") {\n        pattern += `($|(?=[\\r\n]))`;\n        continue;\n      }\n    }\n    if (flags.s && source[i] === \".\") {\n      pattern += inCharGroup ? `${source[i]}\\r\n` : `[${source[i]}\\r\n]`;\n      continue;\n    }\n    pattern += source[i];\n    if (source[i] === \"\\\\\") {\n      isEscaped = true;\n    } else if (inCharGroup && source[i] === \"]\") {\n      inCharGroup = false;\n    } else if (!inCharGroup && source[i] === \"[\") {\n      inCharGroup = true;\n    }\n  }\n  try {\n    new RegExp(pattern);\n  } catch (e) {\n    console.warn(\n      `Could not convert regex pattern at ${refs.currentPath.join(\n        \"/\"\n      )} to a flag-independent form! Falling back to the flag-ignorant source`\n    );\n    return regex.source;\n  }\n  return pattern;\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/record.ts\nfunction parseRecordDef(def, refs) {\n  var _a2, _b2, _c, _d, _e, _f;\n  const schema = {\n    type: \"object\",\n    additionalProperties: (_a2 = parseDef(def.valueType._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"additionalProperties\"]\n    })) != null ? _a2 : refs.allowedAdditionalProperties\n  };\n  if (((_b2 = def.keyType) == null ? void 0 : _b2._def.typeName) === zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {\n    const { type, ...keyType } = parseStringDef(def.keyType._def, refs);\n    return {\n      ...schema,\n      propertyNames: keyType\n    };\n  } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodEnum) {\n    return {\n      ...schema,\n      propertyNames: {\n        enum: def.keyType._def.values\n      }\n    };\n  } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {\n    const { type, ...keyType } = parseBrandedDef(\n      def.keyType._def,\n      refs\n    );\n    return {\n      ...schema,\n      propertyNames: keyType\n    };\n  }\n  return schema;\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/map.ts\nfunction parseMapDef(def, refs) {\n  if (refs.mapStrategy === \"record\") {\n    return parseRecordDef(def, refs);\n  }\n  const keys = parseDef(def.keyType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"items\", \"items\", \"0\"]\n  }) || parseAnyDef();\n  const values = parseDef(def.valueType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"items\", \"items\", \"1\"]\n  }) || parseAnyDef();\n  return {\n    type: \"array\",\n    maxItems: 125,\n    items: {\n      type: \"array\",\n      items: [keys, values],\n      minItems: 2,\n      maxItems: 2\n    }\n  };\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/native-enum.ts\nfunction parseNativeEnumDef(def) {\n  const object = def.values;\n  const actualKeys = Object.keys(def.values).filter((key) => {\n    return typeof object[object[key]] !== \"number\";\n  });\n  const actualValues = actualKeys.map((key) => object[key]);\n  const parsedTypes = Array.from(\n    new Set(actualValues.map((values) => typeof values))\n  );\n  return {\n    type: parsedTypes.length === 1 ? parsedTypes[0] === \"string\" ? \"string\" : \"number\" : [\"string\", \"number\"],\n    enum: actualValues\n  };\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/never.ts\nfunction parseNeverDef() {\n  return { not: parseAnyDef() };\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/null.ts\nfunction parseNullDef() {\n  return {\n    type: \"null\"\n  };\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/union.ts\nvar primitiveMappings = {\n  ZodString: \"string\",\n  ZodNumber: \"number\",\n  ZodBigInt: \"integer\",\n  ZodBoolean: \"boolean\",\n  ZodNull: \"null\"\n};\nfunction parseUnionDef(def, refs) {\n  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;\n  if (options.every(\n    (x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length)\n  )) {\n    const types = options.reduce((types2, x) => {\n      const type = primitiveMappings[x._def.typeName];\n      return type && !types2.includes(type) ? [...types2, type] : types2;\n    }, []);\n    return {\n      type: types.length > 1 ? types : types[0]\n    };\n  } else if (options.every((x) => x._def.typeName === \"ZodLiteral\" && !x.description)) {\n    const types = options.reduce(\n      (acc, x) => {\n        const type = typeof x._def.value;\n        switch (type) {\n          case \"string\":\n          case \"number\":\n          case \"boolean\":\n            return [...acc, type];\n          case \"bigint\":\n            return [...acc, \"integer\"];\n          case \"object\":\n            if (x._def.value === null) return [...acc, \"null\"];\n          case \"symbol\":\n          case \"undefined\":\n          case \"function\":\n          default:\n            return acc;\n        }\n      },\n      []\n    );\n    if (types.length === options.length) {\n      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);\n      return {\n        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],\n        enum: options.reduce(\n          (acc, x) => {\n            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];\n          },\n          []\n        )\n      };\n    }\n  } else if (options.every((x) => x._def.typeName === \"ZodEnum\")) {\n    return {\n      type: \"string\",\n      enum: options.reduce(\n        (acc, x) => [\n          ...acc,\n          ...x._def.values.filter((x2) => !acc.includes(x2))\n        ],\n        []\n      )\n    };\n  }\n  return asAnyOf(def, refs);\n}\nvar asAnyOf = (def, refs) => {\n  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map(\n    (x, i) => parseDef(x._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"anyOf\", `${i}`]\n    })\n  ).filter(\n    (x) => !!x && (!refs.strictUnions || typeof x === \"object\" && Object.keys(x).length > 0)\n  );\n  return anyOf.length ? { anyOf } : void 0;\n};\n\n// src/to-json-schema/zod3-to-json-schema/parsers/nullable.ts\nfunction parseNullableDef(def, refs) {\n  if ([\"ZodString\", \"ZodNumber\", \"ZodBigInt\", \"ZodBoolean\", \"ZodNull\"].includes(\n    def.innerType._def.typeName\n  ) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {\n    return {\n      type: [\n        primitiveMappings[def.innerType._def.typeName],\n        \"null\"\n      ]\n    };\n  }\n  const base = parseDef(def.innerType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"anyOf\", \"0\"]\n  });\n  return base && { anyOf: [base, { type: \"null\" }] };\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/number.ts\nfunction parseNumberDef(def) {\n  const res = {\n    type: \"number\"\n  };\n  if (!def.checks) return res;\n  for (const check of def.checks) {\n    switch (check.kind) {\n      case \"int\":\n        res.type = \"integer\";\n        break;\n      case \"min\":\n        if (check.inclusive) {\n          res.minimum = check.value;\n        } else {\n          res.exclusiveMinimum = check.value;\n        }\n        break;\n      case \"max\":\n        if (check.inclusive) {\n          res.maximum = check.value;\n        } else {\n          res.exclusiveMaximum = check.value;\n        }\n        break;\n      case \"multipleOf\":\n        res.multipleOf = check.value;\n        break;\n    }\n  }\n  return res;\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/object.ts\nfunction parseObjectDef(def, refs) {\n  const result = {\n    type: \"object\",\n    properties: {}\n  };\n  const required = [];\n  const shape = def.shape();\n  for (const propName in shape) {\n    let propDef = shape[propName];\n    if (propDef === void 0 || propDef._def === void 0) {\n      continue;\n    }\n    const propOptional = safeIsOptional(propDef);\n    const parsedDef = parseDef(propDef._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"properties\", propName],\n      propertyPath: [...refs.currentPath, \"properties\", propName]\n    });\n    if (parsedDef === void 0) {\n      continue;\n    }\n    result.properties[propName] = parsedDef;\n    if (!propOptional) {\n      required.push(propName);\n    }\n  }\n  if (required.length) {\n    result.required = required;\n  }\n  const additionalProperties = decideAdditionalProperties(def, refs);\n  if (additionalProperties !== void 0) {\n    result.additionalProperties = additionalProperties;\n  }\n  return result;\n}\nfunction decideAdditionalProperties(def, refs) {\n  if (def.catchall._def.typeName !== \"ZodNever\") {\n    return parseDef(def.catchall._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"additionalProperties\"]\n    });\n  }\n  switch (def.unknownKeys) {\n    case \"passthrough\":\n      return refs.allowedAdditionalProperties;\n    case \"strict\":\n      return refs.rejectedAdditionalProperties;\n    case \"strip\":\n      return refs.removeAdditionalStrategy === \"strict\" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;\n  }\n}\nfunction safeIsOptional(schema) {\n  try {\n    return schema.isOptional();\n  } catch (e) {\n    return true;\n  }\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/optional.ts\nvar parseOptionalDef = (def, refs) => {\n  var _a2;\n  if (refs.currentPath.toString() === ((_a2 = refs.propertyPath) == null ? void 0 : _a2.toString())) {\n    return parseDef(def.innerType._def, refs);\n  }\n  const innerSchema = parseDef(def.innerType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"anyOf\", \"1\"]\n  });\n  return innerSchema ? { anyOf: [{ not: parseAnyDef() }, innerSchema] } : parseAnyDef();\n};\n\n// src/to-json-schema/zod3-to-json-schema/parsers/pipeline.ts\nvar parsePipelineDef = (def, refs) => {\n  if (refs.pipeStrategy === \"input\") {\n    return parseDef(def.in._def, refs);\n  } else if (refs.pipeStrategy === \"output\") {\n    return parseDef(def.out._def, refs);\n  }\n  const a = parseDef(def.in._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"allOf\", \"0\"]\n  });\n  const b = parseDef(def.out._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"allOf\", a ? \"1\" : \"0\"]\n  });\n  return {\n    allOf: [a, b].filter((x) => x !== void 0)\n  };\n};\n\n// src/to-json-schema/zod3-to-json-schema/parsers/promise.ts\nfunction parsePromiseDef(def, refs) {\n  return parseDef(def.type._def, refs);\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/set.ts\nfunction parseSetDef(def, refs) {\n  const items = parseDef(def.valueType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"items\"]\n  });\n  const schema = {\n    type: \"array\",\n    uniqueItems: true,\n    items\n  };\n  if (def.minSize) {\n    schema.minItems = def.minSize.value;\n  }\n  if (def.maxSize) {\n    schema.maxItems = def.maxSize.value;\n  }\n  return schema;\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/tuple.ts\nfunction parseTupleDef(def, refs) {\n  if (def.rest) {\n    return {\n      type: \"array\",\n      minItems: def.items.length,\n      items: def.items.map(\n        (x, i) => parseDef(x._def, {\n          ...refs,\n          currentPath: [...refs.currentPath, \"items\", `${i}`]\n        })\n      ).reduce(\n        (acc, x) => x === void 0 ? acc : [...acc, x],\n        []\n      ),\n      additionalItems: parseDef(def.rest._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"additionalItems\"]\n      })\n    };\n  } else {\n    return {\n      type: \"array\",\n      minItems: def.items.length,\n      maxItems: def.items.length,\n      items: def.items.map(\n        (x, i) => parseDef(x._def, {\n          ...refs,\n          currentPath: [...refs.currentPath, \"items\", `${i}`]\n        })\n      ).reduce(\n        (acc, x) => x === void 0 ? acc : [...acc, x],\n        []\n      )\n    };\n  }\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/undefined.ts\nfunction parseUndefinedDef() {\n  return {\n    not: parseAnyDef()\n  };\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/unknown.ts\nfunction parseUnknownDef() {\n  return parseAnyDef();\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/readonly.ts\nvar parseReadonlyDef = (def, refs) => {\n  return parseDef(def.innerType._def, refs);\n};\n\n// src/to-json-schema/zod3-to-json-schema/select-parser.ts\nvar selectParser = (def, typeName, refs) => {\n  switch (typeName) {\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodString:\n      return parseStringDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodNumber:\n      return parseNumberDef(def);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodObject:\n      return parseObjectDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodBigInt:\n      return parseBigintDef(def);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodBoolean:\n      return parseBooleanDef();\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodDate:\n      return parseDateDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodUndefined:\n      return parseUndefinedDef();\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodNull:\n      return parseNullDef();\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodArray:\n      return parseArrayDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodUnion:\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:\n      return parseUnionDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodIntersection:\n      return parseIntersectionDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodTuple:\n      return parseTupleDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodRecord:\n      return parseRecordDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodLiteral:\n      return parseLiteralDef(def);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodEnum:\n      return parseEnumDef(def);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodNativeEnum:\n      return parseNativeEnumDef(def);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodNullable:\n      return parseNullableDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodOptional:\n      return parseOptionalDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodMap:\n      return parseMapDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodSet:\n      return parseSetDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodLazy:\n      return () => def.getter()._def;\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodPromise:\n      return parsePromiseDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodNaN:\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodNever:\n      return parseNeverDef();\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodEffects:\n      return parseEffectsDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodAny:\n      return parseAnyDef();\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodUnknown:\n      return parseUnknownDef();\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodDefault:\n      return parseDefaultDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodBranded:\n      return parseBrandedDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodReadonly:\n      return parseReadonlyDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodCatch:\n      return parseCatchDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodPipeline:\n      return parsePipelineDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodFunction:\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodVoid:\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodSymbol:\n      return void 0;\n    default:\n      return /* @__PURE__ */ ((_) => void 0)(typeName);\n  }\n};\n\n// src/to-json-schema/zod3-to-json-schema/get-relative-path.ts\nvar getRelativePath = (pathA, pathB) => {\n  let i = 0;\n  for (; i < pathA.length && i < pathB.length; i++) {\n    if (pathA[i] !== pathB[i]) break;\n  }\n  return [(pathA.length - i).toString(), ...pathB.slice(i)].join(\"/\");\n};\n\n// src/to-json-schema/zod3-to-json-schema/parse-def.ts\nfunction parseDef(def, refs, forceResolution = false) {\n  var _a2;\n  const seenItem = refs.seen.get(def);\n  if (refs.override) {\n    const overrideResult = (_a2 = refs.override) == null ? void 0 : _a2.call(\n      refs,\n      def,\n      refs,\n      seenItem,\n      forceResolution\n    );\n    if (overrideResult !== ignoreOverride) {\n      return overrideResult;\n    }\n  }\n  if (seenItem && !forceResolution) {\n    const seenSchema = get$ref(seenItem, refs);\n    if (seenSchema !== void 0) {\n      return seenSchema;\n    }\n  }\n  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };\n  refs.seen.set(def, newItem);\n  const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);\n  const jsonSchema2 = typeof jsonSchemaOrGetter === \"function\" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;\n  if (jsonSchema2) {\n    addMeta(def, refs, jsonSchema2);\n  }\n  if (refs.postProcess) {\n    const postProcessResult = refs.postProcess(jsonSchema2, def, refs);\n    newItem.jsonSchema = jsonSchema2;\n    return postProcessResult;\n  }\n  newItem.jsonSchema = jsonSchema2;\n  return jsonSchema2;\n}\nvar get$ref = (item, refs) => {\n  switch (refs.$refStrategy) {\n    case \"root\":\n      return { $ref: item.path.join(\"/\") };\n    case \"relative\":\n      return { $ref: getRelativePath(refs.currentPath, item.path) };\n    case \"none\":\n    case \"seen\": {\n      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {\n        console.warn(\n          `Recursive reference detected at ${refs.currentPath.join(\n            \"/\"\n          )}! Defaulting to any`\n        );\n        return parseAnyDef();\n      }\n      return refs.$refStrategy === \"seen\" ? parseAnyDef() : void 0;\n    }\n  }\n};\nvar addMeta = (def, refs, jsonSchema2) => {\n  if (def.description) {\n    jsonSchema2.description = def.description;\n  }\n  return jsonSchema2;\n};\n\n// src/to-json-schema/zod3-to-json-schema/refs.ts\nvar getRefs = (options) => {\n  const _options = getDefaultOptions(options);\n  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;\n  return {\n    ..._options,\n    currentPath,\n    propertyPath: void 0,\n    seen: new Map(\n      Object.entries(_options.definitions).map(([name2, def]) => [\n        def._def,\n        {\n          def: def._def,\n          path: [..._options.basePath, _options.definitionPath, name2],\n          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.\n          jsonSchema: void 0\n        }\n      ])\n    )\n  };\n};\n\n// src/to-json-schema/zod3-to-json-schema/zod3-to-json-schema.ts\nvar zod3ToJsonSchema = (schema, options) => {\n  var _a2;\n  const refs = getRefs(options);\n  let definitions = typeof options === \"object\" && options.definitions ? Object.entries(options.definitions).reduce(\n    (acc, [name3, schema2]) => {\n      var _a3;\n      return {\n        ...acc,\n        [name3]: (_a3 = parseDef(\n          schema2._def,\n          {\n            ...refs,\n            currentPath: [...refs.basePath, refs.definitionPath, name3]\n          },\n          true\n        )) != null ? _a3 : parseAnyDef()\n      };\n    },\n    {}\n  ) : void 0;\n  const name2 = typeof options === \"string\" ? options : (options == null ? void 0 : options.nameStrategy) === \"title\" ? void 0 : options == null ? void 0 : options.name;\n  const main = (_a2 = parseDef(\n    schema._def,\n    name2 === void 0 ? refs : {\n      ...refs,\n      currentPath: [...refs.basePath, refs.definitionPath, name2]\n    },\n    false\n  )) != null ? _a2 : parseAnyDef();\n  const title = typeof options === \"object\" && options.name !== void 0 && options.nameStrategy === \"title\" ? options.name : void 0;\n  if (title !== void 0) {\n    main.title = title;\n  }\n  const combined = name2 === void 0 ? definitions ? {\n    ...main,\n    [refs.definitionPath]: definitions\n  } : main : {\n    $ref: [\n      ...refs.$refStrategy === \"relative\" ? [] : refs.basePath,\n      refs.definitionPath,\n      name2\n    ].join(\"/\"),\n    [refs.definitionPath]: {\n      ...definitions,\n      [name2]: main\n    }\n  };\n  combined.$schema = \"http://json-schema.org/draft-07/schema#\";\n  return combined;\n};\n\n// src/schema.ts\nvar schemaSymbol = Symbol.for(\"vercel.ai.schema\");\nfunction lazySchema(createSchema) {\n  let schema;\n  return () => {\n    if (schema == null) {\n      schema = createSchema();\n    }\n    return schema;\n  };\n}\nfunction jsonSchema(jsonSchema2, {\n  validate\n} = {}) {\n  return {\n    [schemaSymbol]: true,\n    _type: void 0,\n    // should never be used directly\n    get jsonSchema() {\n      if (typeof jsonSchema2 === \"function\") {\n        jsonSchema2 = jsonSchema2();\n      }\n      return jsonSchema2;\n    },\n    validate\n  };\n}\nfunction isSchema(value) {\n  return typeof value === \"object\" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && \"jsonSchema\" in value && \"validate\" in value;\n}\nfunction asSchema(schema) {\n  return schema == null ? jsonSchema({ properties: {}, additionalProperties: false }) : isSchema(schema) ? schema : \"~standard\" in schema ? schema[\"~standard\"].vendor === \"zod\" ? zodSchema(schema) : standardSchema(schema) : schema();\n}\nfunction standardSchema(standardSchema2) {\n  return jsonSchema(\n    () => addAdditionalPropertiesToJsonSchema(\n      standardSchema2[\"~standard\"].jsonSchema.input({\n        target: \"draft-07\"\n      })\n    ),\n    {\n      validate: async (value) => {\n        const result = await standardSchema2[\"~standard\"].validate(value);\n        return \"value\" in result ? { success: true, value: result.value } : {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: result.issues\n          })\n        };\n      }\n    }\n  );\n}\nfunction zod3Schema(zodSchema2, options) {\n  var _a2;\n  const useReferences = (_a2 = options == null ? void 0 : options.useReferences) != null ? _a2 : false;\n  return jsonSchema(\n    // defer json schema creation to avoid unnecessary computation when only validation is needed\n    () => zod3ToJsonSchema(zodSchema2, {\n      $refStrategy: useReferences ? \"root\" : \"none\"\n    }),\n    {\n      validate: async (value) => {\n        const result = await zodSchema2.safeParseAsync(value);\n        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };\n      }\n    }\n  );\n}\nfunction zod4Schema(zodSchema2, options) {\n  var _a2;\n  const useReferences = (_a2 = options == null ? void 0 : options.useReferences) != null ? _a2 : false;\n  return jsonSchema(\n    // defer json schema creation to avoid unnecessary computation when only validation is needed\n    () => addAdditionalPropertiesToJsonSchema(\n      zod_v4__WEBPACK_IMPORTED_MODULE_2__.toJSONSchema(zodSchema2, {\n        target: \"draft-7\",\n        io: \"input\",\n        reused: useReferences ? \"ref\" : \"inline\"\n      })\n    ),\n    {\n      validate: async (value) => {\n        const result = await zod_v4__WEBPACK_IMPORTED_MODULE_3__.safeParseAsync(zodSchema2, value);\n        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };\n      }\n    }\n  );\n}\nfunction isZod4Schema(zodSchema2) {\n  return \"_zod\" in zodSchema2;\n}\nfunction zodSchema(zodSchema2, options) {\n  if (isZod4Schema(zodSchema2)) {\n    return zod4Schema(zodSchema2, options);\n  } else {\n    return zod3Schema(zodSchema2, options);\n  }\n}\n\n// src/validate-types.ts\nasync function validateTypes({\n  value,\n  schema,\n  context\n}) {\n  const result = await safeValidateTypes({ value, schema, context });\n  if (!result.success) {\n    throw _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError.wrap({ value, cause: result.error, context });\n  }\n  return result.value;\n}\nasync function safeValidateTypes({\n  value,\n  schema,\n  context\n}) {\n  const actualSchema = asSchema(schema);\n  try {\n    if (actualSchema.validate == null) {\n      return { success: true, value, rawValue: value };\n    }\n    const result = await actualSchema.validate(value);\n    if (result.success) {\n      return { success: true, value: result.value, rawValue: value };\n    }\n    return {\n      success: false,\n      error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError.wrap({ value, cause: result.error, context }),\n      rawValue: value\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError.wrap({ value, cause: error, context }),\n      rawValue: value\n    };\n  }\n}\n\n// src/parse-json.ts\nasync function parseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secureJsonParse(text);\n    if (schema == null) {\n      return value;\n    }\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError.isInstance(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError.isInstance(error)) {\n      throw error;\n    }\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError({ text, cause: error });\n  }\n}\nasync function safeParseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secureJsonParse(text);\n    if (schema == null) {\n      return { success: true, value, rawValue: value };\n    }\n    return await safeValidateTypes({ value, schema });\n  } catch (error) {\n    return {\n      success: false,\n      error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError.isInstance(error) ? error : new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError({ text, cause: error }),\n      rawValue: void 0\n    };\n  }\n}\nfunction isParsableJson(input) {\n  try {\n    secureJsonParse(input);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n// src/parse-json-event-stream.ts\n\nfunction parseJsonEventStream({\n  stream,\n  schema\n}) {\n  return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new eventsource_parser_stream__WEBPACK_IMPORTED_MODULE_4__.EventSourceParserStream()).pipeThrough(\n    new TransformStream({\n      async transform({ data }, controller) {\n        if (data === \"[DONE]\") {\n          return;\n        }\n        controller.enqueue(await safeParseJSON({ text: data, schema }));\n      }\n    })\n  );\n}\n\n// src/parse-provider-options.ts\n\nasync function parseProviderOptions({\n  provider,\n  providerOptions,\n  schema\n}) {\n  if ((providerOptions == null ? void 0 : providerOptions[provider]) == null) {\n    return void 0;\n  }\n  const parsedProviderOptions = await safeValidateTypes({\n    value: providerOptions[provider],\n    schema\n  });\n  if (!parsedProviderOptions.success) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError({\n      argument: \"providerOptions\",\n      message: `invalid ${provider} provider options`,\n      cause: parsedProviderOptions.error\n    });\n  }\n  return parsedProviderOptions.value;\n}\n\n// src/post-to-api.ts\n\nvar getOriginalFetch2 = () => globalThis.fetch;\nvar postJsonToApi = async ({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch: fetch2\n}) => postToApi({\n  url,\n  headers: {\n    \"Content-Type\": \"application/json\",\n    ...headers\n  },\n  body: {\n    content: JSON.stringify(body),\n    values: body\n  },\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch: fetch2\n});\nvar postFormDataToApi = async ({\n  url,\n  headers,\n  formData,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch: fetch2\n}) => postToApi({\n  url,\n  headers,\n  body: {\n    content: formData,\n    values: Object.fromEntries(formData.entries())\n  },\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch: fetch2\n});\nvar postToApi = async ({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch: fetch2 = getOriginalFetch2()\n}) => {\n  try {\n    const response = await fetch2(url, {\n      method: \"POST\",\n      headers: withUserAgentSuffix(\n        headers,\n        `ai-sdk/provider-utils/${VERSION}`,\n        getRuntimeEnvironmentUserAgent()\n      ),\n      body: body.content,\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values\n        });\n      } catch (error) {\n        if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError.isInstance(error)) {\n          throw error;\n        }\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n          message: \"Failed to process error response\",\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n        message: \"Failed to process successful response\",\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values\n      });\n    }\n  } catch (error) {\n    throw handleFetchError({ error, url, requestBodyValues: body.values });\n  }\n};\n\n// src/types/tool.ts\nfunction tool(tool2) {\n  return tool2;\n}\nfunction dynamicTool(tool2) {\n  return { ...tool2, type: \"dynamic\" };\n}\n\n// src/provider-tool-factory.ts\nfunction createProviderToolFactory({\n  id,\n  inputSchema\n}) {\n  return ({\n    execute,\n    outputSchema,\n    needsApproval,\n    toModelOutput,\n    onInputStart,\n    onInputDelta,\n    onInputAvailable,\n    ...args\n  }) => tool({\n    type: \"provider\",\n    id,\n    args,\n    inputSchema,\n    outputSchema,\n    execute,\n    needsApproval,\n    toModelOutput,\n    onInputStart,\n    onInputDelta,\n    onInputAvailable\n  });\n}\nfunction createProviderToolFactoryWithOutputSchema({\n  id,\n  inputSchema,\n  outputSchema,\n  supportsDeferredResults\n}) {\n  return ({\n    execute,\n    needsApproval,\n    toModelOutput,\n    onInputStart,\n    onInputDelta,\n    onInputAvailable,\n    ...args\n  }) => tool({\n    type: \"provider\",\n    id,\n    args,\n    inputSchema,\n    outputSchema,\n    execute,\n    needsApproval,\n    toModelOutput,\n    onInputStart,\n    onInputDelta,\n    onInputAvailable,\n    supportsDeferredResults\n  });\n}\n\n// src/remove-undefined-entries.ts\nfunction removeUndefinedEntries(record) {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null)\n  );\n}\n\n// src/resolve.ts\nasync function resolve(value) {\n  if (typeof value === \"function\") {\n    value = value();\n  }\n  return Promise.resolve(value);\n}\n\n// src/response-handler.ts\n\nvar createJsonErrorResponseHandler = ({\n  errorSchema,\n  errorToMessage,\n  isRetryable\n}) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const responseHeaders = extractResponseHeaders(response);\n  if (responseBody.trim() === \"\") {\n    return {\n      responseHeaders,\n      value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n  try {\n    const parsedError = await parseJSON({\n      text: responseBody,\n      schema: errorSchema\n    });\n    return {\n      responseHeaders,\n      value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n        message: errorToMessage(parsedError),\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        data: parsedError,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)\n      })\n    };\n  } catch (parseError) {\n    return {\n      responseHeaders,\n      value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n};\nvar createEventSourceResponseHandler = (chunkSchema) => async ({ response }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.EmptyResponseBodyError({});\n  }\n  return {\n    responseHeaders,\n    value: parseJsonEventStream({\n      stream: response.body,\n      schema: chunkSchema\n    })\n  };\n};\nvar createJsonResponseHandler = (responseSchema) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const parsedResult = await safeParseJSON({\n    text: responseBody,\n    schema: responseSchema\n  });\n  const responseHeaders = extractResponseHeaders(response);\n  if (!parsedResult.success) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n      message: \"Invalid JSON response\",\n      cause: parsedResult.error,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody,\n      url,\n      requestBodyValues\n    });\n  }\n  return {\n    responseHeaders,\n    value: parsedResult.value,\n    rawValue: parsedResult.rawValue\n  };\n};\nvar createBinaryResponseHandler = () => async ({ response, url, requestBodyValues }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (!response.body) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n      message: \"Response body is empty\",\n      url,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody: void 0\n    });\n  }\n  try {\n    const buffer = await response.arrayBuffer();\n    return {\n      responseHeaders,\n      value: new Uint8Array(buffer)\n    };\n  } catch (error) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n      message: \"Failed to read response as array buffer\",\n      url,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody: void 0,\n      cause: error\n    });\n  }\n};\nvar createStatusCodeErrorResponseHandler = () => async ({ response, url, requestBodyValues }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  const responseBody = await response.text();\n  return {\n    responseHeaders,\n    value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n      message: response.statusText,\n      url,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody\n    })\n  };\n};\n\n// src/without-trailing-slash.ts\nfunction withoutTrailingSlash(url) {\n  return url == null ? void 0 : url.replace(/\\/$/, \"\");\n}\n\n// src/is-async-iterable.ts\nfunction isAsyncIterable(obj) {\n  return obj != null && typeof obj[Symbol.asyncIterator] === \"function\";\n}\n\n// src/types/execute-tool.ts\nasync function* executeTool({\n  execute,\n  input,\n  options\n}) {\n  const result = execute(input, options);\n  if (isAsyncIterable(result)) {\n    let lastOutput;\n    for await (const output of result) {\n      lastOutput = output;\n      yield { type: \"preliminary\", output };\n    }\n    yield { type: \"final\", output: lastOutput };\n  } else {\n    yield { type: \"final\", output: await result };\n  }\n}\n\n// src/index.ts\n\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9nYXRld2F5L25vZGVfbW9kdWxlcy9AYWktc2RrL3Byb3ZpZGVyLXV0aWxzL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ3lFOztBQUV6RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUMrQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUpBQWlKLHlEQUFxQjtBQUN0SztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlEQUFzQjtBQUMvQjtBQUNBLFNBQVMseURBQXNCO0FBQy9CO0FBQ0EsU0FBUyx5REFBc0I7QUFDL0I7QUFDQSxTQUFTLHlEQUFzQjtBQUMvQjtBQUNBLFNBQVMseURBQXNCO0FBQy9CO0FBQ0EsU0FBUyx5REFBc0I7QUFDL0I7QUFDQSxTQUFTLHlEQUFzQjtBQUMvQjtBQUNBLFNBQVMseURBQXNCO0FBQy9CO0FBQ0EsU0FBUyx5REFBc0I7QUFDL0I7QUFDQSxTQUFTLHlEQUFzQjtBQUMvQixTQUFTLHlEQUFzQjtBQUMvQjtBQUNBLFNBQVMseURBQXNCO0FBQy9CO0FBQ0EsU0FBUyx5REFBc0I7QUFDL0I7QUFDQSxTQUFTLHlEQUFzQjtBQUMvQjtBQUNBLFNBQVMseURBQXNCO0FBQy9CO0FBQ0EsU0FBUyx5REFBc0I7QUFDL0I7QUFDQSxTQUFTLHlEQUFzQjtBQUMvQjtBQUNBLFNBQVMseURBQXNCO0FBQy9CO0FBQ0EsU0FBUyx5REFBc0I7QUFDL0I7QUFDQSxTQUFTLHlEQUFzQjtBQUMvQjtBQUNBLFNBQVMseURBQXNCO0FBQy9CO0FBQ0EsU0FBUyx5REFBc0I7QUFDL0I7QUFDQSxTQUFTLHlEQUFzQjtBQUMvQjtBQUNBLFNBQVMseURBQXNCO0FBQy9CLFNBQVMseURBQXNCO0FBQy9CO0FBQ0EsU0FBUyx5REFBc0I7QUFDL0I7QUFDQSxTQUFTLHlEQUFzQjtBQUMvQjtBQUNBLFNBQVMseURBQXNCO0FBQy9CO0FBQ0EsU0FBUyx5REFBc0I7QUFDL0I7QUFDQSxTQUFTLHlEQUFzQjtBQUMvQjtBQUNBLFNBQVMseURBQXNCO0FBQy9CO0FBQ0EsU0FBUyx5REFBc0I7QUFDL0I7QUFDQSxTQUFTLHlEQUFzQjtBQUMvQjtBQUNBLFNBQVMseURBQXNCO0FBQy9CLFNBQVMseURBQXNCO0FBQy9CLFNBQVMseURBQXNCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxzQ0FBc0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjtBQUNB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QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsWUFBWTtBQUNaLElBQUk7QUFDSixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUdtQztBQTZEakM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsZWV0Zmxvdy8uL25vZGVfbW9kdWxlcy9AYWktc2RrL2dhdGV3YXkvbm9kZV9tb2R1bGVzL0BhaS1zZGsvcHJvdmlkZXItdXRpbHMvZGlzdC9pbmRleC5tanM/ZTNiOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvY29tYmluZS1oZWFkZXJzLnRzXG5mdW5jdGlvbiBjb21iaW5lSGVhZGVycyguLi5oZWFkZXJzKSB7XG4gIHJldHVybiBoZWFkZXJzLnJlZHVjZShcbiAgICAoY29tYmluZWRIZWFkZXJzLCBjdXJyZW50SGVhZGVycykgPT4gKHtcbiAgICAgIC4uLmNvbWJpbmVkSGVhZGVycyxcbiAgICAgIC4uLmN1cnJlbnRIZWFkZXJzICE9IG51bGwgPyBjdXJyZW50SGVhZGVycyA6IHt9XG4gICAgfSksXG4gICAge31cbiAgKTtcbn1cblxuLy8gc3JjL2NvbnZlcnQtYXN5bmMtaXRlcmF0b3ItdG8tcmVhZGFibGUtc3RyZWFtLnRzXG5mdW5jdGlvbiBjb252ZXJ0QXN5bmNJdGVyYXRvclRvUmVhZGFibGVTdHJlYW0oaXRlcmF0b3IpIHtcbiAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29uc3VtZXIgd2FudHMgdG8gcHVsbCBtb3JlIGRhdGEgZnJvbSB0aGUgc3RyZWFtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFQ+fSBjb250cm9sbGVyIC0gVGhlIGNvbnRyb2xsZXIgdG8gZW5xdWV1ZSBkYXRhIGludG8gdGhlIHN0cmVhbS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIGlmIChjYW5jZWxsZWQpIHJldHVybjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29udHJvbGxlci5lcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29uc3VtZXIgY2FuY2VscyB0aGUgc3RyZWFtLlxuICAgICAqL1xuICAgIGFzeW5jIGNhbmNlbChyZWFzb24pIHtcbiAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICBpZiAoaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgaXRlcmF0b3IucmV0dXJuKHJlYXNvbik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9jcmVhdGUtdG9vbC1uYW1lLW1hcHBpbmcudHNcbmZ1bmN0aW9uIGNyZWF0ZVRvb2xOYW1lTWFwcGluZyh7XG4gIHRvb2xzID0gW10sXG4gIHByb3ZpZGVyVG9vbE5hbWVzXG59KSB7XG4gIGNvbnN0IGN1c3RvbVRvb2xOYW1lVG9Qcm92aWRlclRvb2xOYW1lID0ge307XG4gIGNvbnN0IHByb3ZpZGVyVG9vbE5hbWVUb0N1c3RvbVRvb2xOYW1lID0ge307XG4gIGZvciAoY29uc3QgdG9vbDIgb2YgdG9vbHMpIHtcbiAgICBpZiAodG9vbDIudHlwZSA9PT0gXCJwcm92aWRlclwiICYmIHRvb2wyLmlkIGluIHByb3ZpZGVyVG9vbE5hbWVzKSB7XG4gICAgICBjb25zdCBwcm92aWRlclRvb2xOYW1lID0gcHJvdmlkZXJUb29sTmFtZXNbdG9vbDIuaWRdO1xuICAgICAgY3VzdG9tVG9vbE5hbWVUb1Byb3ZpZGVyVG9vbE5hbWVbdG9vbDIubmFtZV0gPSBwcm92aWRlclRvb2xOYW1lO1xuICAgICAgcHJvdmlkZXJUb29sTmFtZVRvQ3VzdG9tVG9vbE5hbWVbcHJvdmlkZXJUb29sTmFtZV0gPSB0b29sMi5uYW1lO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHRvUHJvdmlkZXJUb29sTmFtZTogKGN1c3RvbVRvb2xOYW1lKSA9PiB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgcmV0dXJuIChfYTIgPSBjdXN0b21Ub29sTmFtZVRvUHJvdmlkZXJUb29sTmFtZVtjdXN0b21Ub29sTmFtZV0pICE9IG51bGwgPyBfYTIgOiBjdXN0b21Ub29sTmFtZTtcbiAgICB9LFxuICAgIHRvQ3VzdG9tVG9vbE5hbWU6IChwcm92aWRlclRvb2xOYW1lKSA9PiB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgcmV0dXJuIChfYTIgPSBwcm92aWRlclRvb2xOYW1lVG9DdXN0b21Ub29sTmFtZVtwcm92aWRlclRvb2xOYW1lXSkgIT0gbnVsbCA/IF9hMiA6IHByb3ZpZGVyVG9vbE5hbWU7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvZGVsYXkudHNcbmFzeW5jIGZ1bmN0aW9uIGRlbGF5KGRlbGF5SW5Ncywgb3B0aW9ucykge1xuICBpZiAoZGVsYXlJbk1zID09IG51bGwpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbiAgY29uc3Qgc2lnbmFsID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5hYm9ydFNpZ25hbDtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlMiwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKHNpZ25hbCA9PSBudWxsID8gdm9pZCAwIDogc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJlamVjdChjcmVhdGVBYm9ydEVycm9yKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICAgIHJlc29sdmUyKCk7XG4gICAgfSwgZGVsYXlJbk1zKTtcbiAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICBzaWduYWwgPT0gbnVsbCA/IHZvaWQgMCA6IHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG4gICAgfTtcbiAgICBjb25zdCBvbkFib3J0ID0gKCkgPT4ge1xuICAgICAgY2xlYW51cCgpO1xuICAgICAgcmVqZWN0KGNyZWF0ZUFib3J0RXJyb3IoKSk7XG4gICAgfTtcbiAgICBzaWduYWwgPT0gbnVsbCA/IHZvaWQgMCA6IHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQWJvcnRFcnJvcigpIHtcbiAgcmV0dXJuIG5ldyBET01FeGNlcHRpb24oXCJEZWxheSB3YXMgYWJvcnRlZFwiLCBcIkFib3J0RXJyb3JcIik7XG59XG5cbi8vIHNyYy9kZWxheWVkLXByb21pc2UudHNcbnZhciBEZWxheWVkUHJvbWlzZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdGF0dXMgPSB7IHR5cGU6IFwicGVuZGluZ1wiIH07XG4gICAgdGhpcy5fcmVzb2x2ZSA9IHZvaWQgMDtcbiAgICB0aGlzLl9yZWplY3QgPSB2b2lkIDA7XG4gIH1cbiAgZ2V0IHByb21pc2UoKSB7XG4gICAgaWYgKHRoaXMuX3Byb21pc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcm9taXNlO1xuICAgIH1cbiAgICB0aGlzLl9wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUyLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh0aGlzLnN0YXR1cy50eXBlID09PSBcInJlc29sdmVkXCIpIHtcbiAgICAgICAgcmVzb2x2ZTIodGhpcy5zdGF0dXMudmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXR1cy50eXBlID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgICAgcmVqZWN0KHRoaXMuc3RhdHVzLmVycm9yKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlMjtcbiAgICAgIHRoaXMuX3JlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbiAgfVxuICByZXNvbHZlKHZhbHVlKSB7XG4gICAgdmFyIF9hMjtcbiAgICB0aGlzLnN0YXR1cyA9IHsgdHlwZTogXCJyZXNvbHZlZFwiLCB2YWx1ZSB9O1xuICAgIGlmICh0aGlzLl9wcm9taXNlKSB7XG4gICAgICAoX2EyID0gdGhpcy5fcmVzb2x2ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmVqZWN0KGVycm9yKSB7XG4gICAgdmFyIF9hMjtcbiAgICB0aGlzLnN0YXR1cyA9IHsgdHlwZTogXCJyZWplY3RlZFwiLCBlcnJvciB9O1xuICAgIGlmICh0aGlzLl9wcm9taXNlKSB7XG4gICAgICAoX2EyID0gdGhpcy5fcmVqZWN0KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNhbGwodGhpcywgZXJyb3IpO1xuICAgIH1cbiAgfVxuICBpc1Jlc29sdmVkKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXR1cy50eXBlID09PSBcInJlc29sdmVkXCI7XG4gIH1cbiAgaXNSZWplY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXMudHlwZSA9PT0gXCJyZWplY3RlZFwiO1xuICB9XG4gIGlzUGVuZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXMudHlwZSA9PT0gXCJwZW5kaW5nXCI7XG4gIH1cbn07XG5cbi8vIHNyYy9leHRyYWN0LXJlc3BvbnNlLWhlYWRlcnMudHNcbmZ1bmN0aW9uIGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhbLi4ucmVzcG9uc2UuaGVhZGVyc10pO1xufVxuXG4vLyBzcmMvdWludDgtdXRpbHMudHNcbnZhciB7IGJ0b2EsIGF0b2IgfSA9IGdsb2JhbFRoaXM7XG5mdW5jdGlvbiBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5KGJhc2U2NFN0cmluZykge1xuICBjb25zdCBiYXNlNjRVcmwgPSBiYXNlNjRTdHJpbmcucmVwbGFjZSgvLS9nLCBcIitcIikucmVwbGFjZSgvXy9nLCBcIi9cIik7XG4gIGNvbnN0IGxhdGluMXN0cmluZyA9IGF0b2IoYmFzZTY0VXJsKTtcbiAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShsYXRpbjFzdHJpbmcsIChieXRlKSA9PiBieXRlLmNvZGVQb2ludEF0KDApKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQoYXJyYXkpIHtcbiAgbGV0IGxhdGluMXN0cmluZyA9IFwiXCI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBsYXRpbjFzdHJpbmcgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQoYXJyYXlbaV0pO1xuICB9XG4gIHJldHVybiBidG9hKGxhdGluMXN0cmluZyk7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9CYXNlNjQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSA/IGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQodmFsdWUpIDogdmFsdWU7XG59XG5cbi8vIHNyYy9jb252ZXJ0LWltYWdlLW1vZGVsLWZpbGUtdG8tZGF0YS11cmkudHNcbmZ1bmN0aW9uIGNvbnZlcnRJbWFnZU1vZGVsRmlsZVRvRGF0YVVyaShmaWxlKSB7XG4gIGlmIChmaWxlLnR5cGUgPT09IFwidXJsXCIpIHJldHVybiBmaWxlLnVybDtcbiAgcmV0dXJuIGBkYXRhOiR7ZmlsZS5tZWRpYVR5cGV9O2Jhc2U2NCwke3R5cGVvZiBmaWxlLmRhdGEgPT09IFwic3RyaW5nXCIgPyBmaWxlLmRhdGEgOiBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0KGZpbGUuZGF0YSl9YDtcbn1cblxuLy8gc3JjL2NvbnZlcnQtdG8tZm9ybS1kYXRhLnRzXG5mdW5jdGlvbiBjb252ZXJ0VG9Gb3JtRGF0YShpbnB1dCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgdXNlQXJyYXlCcmFja2V0cyA9IHRydWUgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGlucHV0KSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChrZXksIHZhbHVlWzBdKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBhcnJheUtleSA9IHVzZUFycmF5QnJhY2tldHMgPyBgJHtrZXl9W11gIDoga2V5O1xuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChhcnJheUtleSwgaXRlbSk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZm9ybURhdGEuYXBwZW5kKGtleSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmb3JtRGF0YTtcbn1cblxuLy8gc3JjL2Rvd25sb2FkLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lID0gXCJBSV9Eb3dubG9hZEVycm9yXCI7XG52YXIgbWFya2VyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWV9YDtcbnZhciBzeW1ib2wgPSBTeW1ib2wuZm9yKG1hcmtlcik7XG52YXIgX2EsIF9iO1xudmFyIERvd25sb2FkRXJyb3IgPSBjbGFzcyBleHRlbmRzIChfYiA9IEFJU0RLRXJyb3IsIF9hID0gc3ltYm9sLCBfYikge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdXJsLFxuICAgIHN0YXR1c0NvZGUsXG4gICAgc3RhdHVzVGV4dCxcbiAgICBjYXVzZSxcbiAgICBtZXNzYWdlID0gY2F1c2UgPT0gbnVsbCA/IGBGYWlsZWQgdG8gZG93bmxvYWQgJHt1cmx9OiAke3N0YXR1c0NvZGV9ICR7c3RhdHVzVGV4dH1gIDogYEZhaWxlZCB0byBkb3dubG9hZCAke3VybH06ICR7Y2F1c2V9YFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lLCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hXSA9IHRydWU7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICB0aGlzLnN0YXR1c1RleHQgPSBzdGF0dXNUZXh0O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIpO1xuICB9XG59O1xuXG4vLyBzcmMvcmVhZC1yZXNwb25zZS13aXRoLXNpemUtbGltaXQudHNcbnZhciBERUZBVUxUX01BWF9ET1dOTE9BRF9TSVpFID0gMiAqIDEwMjQgKiAxMDI0ICogMTAyNDtcbmFzeW5jIGZ1bmN0aW9uIHJlYWRSZXNwb25zZVdpdGhTaXplTGltaXQoe1xuICByZXNwb25zZSxcbiAgdXJsLFxuICBtYXhCeXRlcyA9IERFRkFVTFRfTUFYX0RPV05MT0FEX1NJWkVcbn0pIHtcbiAgY29uc3QgY29udGVudExlbmd0aCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC1sZW5ndGhcIik7XG4gIGlmIChjb250ZW50TGVuZ3RoICE9IG51bGwpIHtcbiAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChjb250ZW50TGVuZ3RoLCAxMCk7XG4gICAgaWYgKCFpc05hTihsZW5ndGgpICYmIGxlbmd0aCA+IG1heEJ5dGVzKSB7XG4gICAgICB0aHJvdyBuZXcgRG93bmxvYWRFcnJvcih7XG4gICAgICAgIHVybCxcbiAgICAgICAgbWVzc2FnZTogYERvd25sb2FkIG9mICR7dXJsfSBleGNlZWRlZCBtYXhpbXVtIHNpemUgb2YgJHttYXhCeXRlc30gYnl0ZXMgKENvbnRlbnQtTGVuZ3RoOiAke2xlbmd0aH0pLmBcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb25zdCBib2R5ID0gcmVzcG9uc2UuYm9keTtcbiAgaWYgKGJvZHkgPT0gbnVsbCkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgfVxuICBjb25zdCByZWFkZXIgPSBib2R5LmdldFJlYWRlcigpO1xuICBjb25zdCBjaHVua3MgPSBbXTtcbiAgbGV0IHRvdGFsQnl0ZXMgPSAwO1xuICB0cnkge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0b3RhbEJ5dGVzICs9IHZhbHVlLmxlbmd0aDtcbiAgICAgIGlmICh0b3RhbEJ5dGVzID4gbWF4Qnl0ZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IERvd25sb2FkRXJyb3Ioe1xuICAgICAgICAgIHVybCxcbiAgICAgICAgICBtZXNzYWdlOiBgRG93bmxvYWQgb2YgJHt1cmx9IGV4Y2VlZGVkIG1heGltdW0gc2l6ZSBvZiAke21heEJ5dGVzfSBieXRlcy5gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY2h1bmtzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgcmVhZGVyLmNhbmNlbCgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxCeXRlcyk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuICAgIHJlc3VsdC5zZXQoY2h1bmssIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGNodW5rLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBzcmMvZG93bmxvYWQtYmxvYi50c1xuYXN5bmMgZnVuY3Rpb24gZG93bmxvYWRCbG9iKHVybCwgb3B0aW9ucykge1xuICB2YXIgX2EyLCBfYjI7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5hYm9ydFNpZ25hbFxuICAgIH0pO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBEb3dubG9hZEVycm9yKHtcbiAgICAgICAgdXJsLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVhZFJlc3BvbnNlV2l0aFNpemVMaW1pdCh7XG4gICAgICByZXNwb25zZSxcbiAgICAgIHVybCxcbiAgICAgIG1heEJ5dGVzOiAoX2EyID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5tYXhCeXRlcykgIT0gbnVsbCA/IF9hMiA6IERFRkFVTFRfTUFYX0RPV05MT0FEX1NJWkVcbiAgICB9KTtcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IChfYjIgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKSkgIT0gbnVsbCA/IF9iMiA6IHZvaWQgMDtcbiAgICByZXR1cm4gbmV3IEJsb2IoW2RhdGFdLCBjb250ZW50VHlwZSA/IHsgdHlwZTogY29udGVudFR5cGUgfSA6IHZvaWQgMCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKERvd25sb2FkRXJyb3IuaXNJbnN0YW5jZShlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRG93bmxvYWRFcnJvcih7IHVybCwgY2F1c2U6IGVycm9yIH0pO1xuICB9XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS1pZC50c1xuaW1wb3J0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIGNyZWF0ZUlkR2VuZXJhdG9yID0gKHtcbiAgcHJlZml4LFxuICBzaXplID0gMTYsXG4gIGFscGhhYmV0ID0gXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiLFxuICBzZXBhcmF0b3IgPSBcIi1cIlxufSA9IHt9KSA9PiB7XG4gIGNvbnN0IGdlbmVyYXRvciA9ICgpID0+IHtcbiAgICBjb25zdCBhbHBoYWJldExlbmd0aCA9IGFscGhhYmV0Lmxlbmd0aDtcbiAgICBjb25zdCBjaGFycyA9IG5ldyBBcnJheShzaXplKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgY2hhcnNbaV0gPSBhbHBoYWJldFtNYXRoLnJhbmRvbSgpICogYWxwaGFiZXRMZW5ndGggfCAwXTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oXCJcIik7XG4gIH07XG4gIGlmIChwcmVmaXggPT0gbnVsbCkge1xuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgaWYgKGFscGhhYmV0LmluY2x1ZGVzKHNlcGFyYXRvcikpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgYXJndW1lbnQ6IFwic2VwYXJhdG9yXCIsXG4gICAgICBtZXNzYWdlOiBgVGhlIHNlcGFyYXRvciBcIiR7c2VwYXJhdG9yfVwiIG11c3Qgbm90IGJlIHBhcnQgb2YgdGhlIGFscGhhYmV0IFwiJHthbHBoYWJldH1cIi5gXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuICgpID0+IGAke3ByZWZpeH0ke3NlcGFyYXRvcn0ke2dlbmVyYXRvcigpfWA7XG59O1xudmFyIGdlbmVyYXRlSWQgPSBjcmVhdGVJZEdlbmVyYXRvcigpO1xuXG4vLyBzcmMvZ2V0LWVycm9yLW1lc3NhZ2UudHNcbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShlcnJvcikge1xuICBpZiAoZXJyb3IgPT0gbnVsbCkge1xuICAgIHJldHVybiBcInVua25vd24gZXJyb3JcIjtcbiAgfVxuICBpZiAodHlwZW9mIGVycm9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gIH1cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbn1cblxuLy8gc3JjL2dldC1mcm9tLWFwaS50c1xuaW1wb3J0IHsgQVBJQ2FsbEVycm9yIGFzIEFQSUNhbGxFcnJvcjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuXG4vLyBzcmMvaGFuZGxlLWZldGNoLWVycm9yLnRzXG5pbXBvcnQgeyBBUElDYWxsRXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuXG4vLyBzcmMvaXMtYWJvcnQtZXJyb3IudHNcbmZ1bmN0aW9uIGlzQWJvcnRFcnJvcihlcnJvcikge1xuICByZXR1cm4gKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBET01FeGNlcHRpb24pICYmIChlcnJvci5uYW1lID09PSBcIkFib3J0RXJyb3JcIiB8fCBlcnJvci5uYW1lID09PSBcIlJlc3BvbnNlQWJvcnRlZFwiIHx8IC8vIE5leHQuanNcbiAgZXJyb3IubmFtZSA9PT0gXCJUaW1lb3V0RXJyb3JcIik7XG59XG5cbi8vIHNyYy9oYW5kbGUtZmV0Y2gtZXJyb3IudHNcbnZhciBGRVRDSF9GQUlMRURfRVJST1JfTUVTU0FHRVMgPSBbXCJmZXRjaCBmYWlsZWRcIiwgXCJmYWlsZWQgdG8gZmV0Y2hcIl07XG52YXIgQlVOX0VSUk9SX0NPREVTID0gW1xuICBcIkNvbm5lY3Rpb25SZWZ1c2VkXCIsXG4gIFwiQ29ubmVjdGlvbkNsb3NlZFwiLFxuICBcIkZhaWxlZFRvT3BlblNvY2tldFwiLFxuICBcIkVDT05OUkVTRVRcIixcbiAgXCJFQ09OTlJFRlVTRURcIixcbiAgXCJFVElNRURPVVRcIixcbiAgXCJFUElQRVwiXG5dO1xuZnVuY3Rpb24gaXNCdW5OZXR3b3JrRXJyb3IoZXJyb3IpIHtcbiAgaWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgY29kZSA9IGVycm9yLmNvZGU7XG4gIGlmICh0eXBlb2YgY29kZSA9PT0gXCJzdHJpbmdcIiAmJiBCVU5fRVJST1JfQ09ERVMuaW5jbHVkZXMoY29kZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBoYW5kbGVGZXRjaEVycm9yKHtcbiAgZXJyb3IsXG4gIHVybCxcbiAgcmVxdWVzdEJvZHlWYWx1ZXNcbn0pIHtcbiAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikpIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIEZFVENIX0ZBSUxFRF9FUlJPUl9NRVNTQUdFUy5pbmNsdWRlcyhlcnJvci5tZXNzYWdlLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgY29uc3QgY2F1c2UgPSBlcnJvci5jYXVzZTtcbiAgICBpZiAoY2F1c2UgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBBUElDYWxsRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBgQ2Fubm90IGNvbm5lY3QgdG8gQVBJOiAke2NhdXNlLm1lc3NhZ2V9YCxcbiAgICAgICAgY2F1c2UsXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgICAgIGlzUmV0cnlhYmxlOiB0cnVlXG4gICAgICAgIC8vIHJldHJ5IHdoZW4gbmV0d29yayBlcnJvclxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChpc0J1bk5ldHdvcmtFcnJvcihlcnJvcikpIHtcbiAgICByZXR1cm4gbmV3IEFQSUNhbGxFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgQ2Fubm90IGNvbm5lY3QgdG8gQVBJOiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgIHVybCxcbiAgICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgICAgaXNSZXRyeWFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZXJyb3I7XG59XG5cbi8vIHNyYy9nZXQtcnVudGltZS1lbnZpcm9ubWVudC11c2VyLWFnZW50LnRzXG5mdW5jdGlvbiBnZXRSdW50aW1lRW52aXJvbm1lbnRVc2VyQWdlbnQoZ2xvYmFsVGhpc0FueSA9IGdsb2JhbFRoaXMpIHtcbiAgdmFyIF9hMiwgX2IyLCBfYztcbiAgaWYgKGdsb2JhbFRoaXNBbnkud2luZG93KSB7XG4gICAgcmV0dXJuIGBydW50aW1lL2Jyb3dzZXJgO1xuICB9XG4gIGlmICgoX2EyID0gZ2xvYmFsVGhpc0FueS5uYXZpZ2F0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfYTIudXNlckFnZW50KSB7XG4gICAgcmV0dXJuIGBydW50aW1lLyR7Z2xvYmFsVGhpc0FueS5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCl9YDtcbiAgfVxuICBpZiAoKF9jID0gKF9iMiA9IGdsb2JhbFRoaXNBbnkucHJvY2VzcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi52ZXJzaW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLm5vZGUpIHtcbiAgICByZXR1cm4gYHJ1bnRpbWUvbm9kZS5qcy8ke2dsb2JhbFRoaXNBbnkucHJvY2Vzcy52ZXJzaW9uLnN1YnN0cmluZygwKX1gO1xuICB9XG4gIGlmIChnbG9iYWxUaGlzQW55LkVkZ2VSdW50aW1lKSB7XG4gICAgcmV0dXJuIGBydW50aW1lL3ZlcmNlbC1lZGdlYDtcbiAgfVxuICByZXR1cm4gXCJydW50aW1lL3Vua25vd25cIjtcbn1cblxuLy8gc3JjL25vcm1hbGl6ZS1oZWFkZXJzLnRzXG5mdW5jdGlvbiBub3JtYWxpemVIZWFkZXJzKGhlYWRlcnMpIHtcbiAgaWYgKGhlYWRlcnMgPT0gbnVsbCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBjb25zdCBub3JtYWxpemVkID0ge307XG4gIGlmIChoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgIGhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgbm9ybWFsaXplZFtrZXkudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICAgIGhlYWRlcnMgPSBPYmplY3QuZW50cmllcyhoZWFkZXJzKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgaGVhZGVycykge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgbm9ybWFsaXplZFtrZXkudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5cbi8vIHNyYy93aXRoLXVzZXItYWdlbnQtc3VmZml4LnRzXG5mdW5jdGlvbiB3aXRoVXNlckFnZW50U3VmZml4KGhlYWRlcnMsIC4uLnVzZXJBZ2VudFN1ZmZpeFBhcnRzKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRIZWFkZXJzID0gbmV3IEhlYWRlcnMobm9ybWFsaXplSGVhZGVycyhoZWFkZXJzKSk7XG4gIGNvbnN0IGN1cnJlbnRVc2VyQWdlbnRIZWFkZXIgPSBub3JtYWxpemVkSGVhZGVycy5nZXQoXCJ1c2VyLWFnZW50XCIpIHx8IFwiXCI7XG4gIG5vcm1hbGl6ZWRIZWFkZXJzLnNldChcbiAgICBcInVzZXItYWdlbnRcIixcbiAgICBbY3VycmVudFVzZXJBZ2VudEhlYWRlciwgLi4udXNlckFnZW50U3VmZml4UGFydHNdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKVxuICApO1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKG5vcm1hbGl6ZWRIZWFkZXJzLmVudHJpZXMoKSk7XG59XG5cbi8vIHNyYy92ZXJzaW9uLnRzXG52YXIgVkVSU0lPTiA9IHRydWUgPyBcIjQuMC4xNVwiIDogXCIwLjAuMC10ZXN0XCI7XG5cbi8vIHNyYy9nZXQtZnJvbS1hcGkudHNcbnZhciBnZXRPcmlnaW5hbEZldGNoID0gKCkgPT4gZ2xvYmFsVGhpcy5mZXRjaDtcbnZhciBnZXRGcm9tQXBpID0gYXN5bmMgKHtcbiAgdXJsLFxuICBoZWFkZXJzID0ge30sXG4gIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXIsXG4gIGZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgYWJvcnRTaWduYWwsXG4gIGZldGNoOiBmZXRjaDIgPSBnZXRPcmlnaW5hbEZldGNoKClcbn0pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoMih1cmwsIHtcbiAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgIGhlYWRlcnM6IHdpdGhVc2VyQWdlbnRTdWZmaXgoXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGBhaS1zZGsvcHJvdmlkZXItdXRpbHMvJHtWRVJTSU9OfWAsXG4gICAgICAgIGdldFJ1bnRpbWVFbnZpcm9ubWVudFVzZXJBZ2VudCgpXG4gICAgICApLFxuICAgICAgc2lnbmFsOiBhYm9ydFNpZ25hbFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGxldCBlcnJvckluZm9ybWF0aW9uO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXJyb3JJbmZvcm1hdGlvbiA9IGF3YWl0IGZhaWxlZFJlc3BvbnNlSGFuZGxlcih7XG4gICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiB7fVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpIHx8IEFQSUNhbGxFcnJvcjIuaXNJbnN0YW5jZShlcnJvcikpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgQVBJQ2FsbEVycm9yMih7XG4gICAgICAgICAgbWVzc2FnZTogXCJGYWlsZWQgdG8gcHJvY2VzcyBlcnJvciByZXNwb25zZVwiLFxuICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgICByZXF1ZXN0Qm9keVZhbHVlczoge31cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvckluZm9ybWF0aW9uLnZhbHVlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXIoe1xuICAgICAgICByZXNwb25zZSxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXF1ZXN0Qm9keVZhbHVlczoge31cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBpZiAoaXNBYm9ydEVycm9yKGVycm9yKSB8fCBBUElDYWxsRXJyb3IyLmlzSW5zdGFuY2UoZXJyb3IpKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBBUElDYWxsRXJyb3IyKHtcbiAgICAgICAgbWVzc2FnZTogXCJGYWlsZWQgdG8gcHJvY2VzcyBzdWNjZXNzZnVsIHJlc3BvbnNlXCIsXG4gICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IHt9XG4gICAgICB9KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgaGFuZGxlRmV0Y2hFcnJvcih7IGVycm9yLCB1cmwsIHJlcXVlc3RCb2R5VmFsdWVzOiB7fSB9KTtcbiAgfVxufTtcblxuLy8gc3JjL2luamVjdC1qc29uLWluc3RydWN0aW9uLnRzXG52YXIgREVGQVVMVF9TQ0hFTUFfUFJFRklYID0gXCJKU09OIHNjaGVtYTpcIjtcbnZhciBERUZBVUxUX1NDSEVNQV9TVUZGSVggPSBcIllvdSBNVVNUIGFuc3dlciB3aXRoIGEgSlNPTiBvYmplY3QgdGhhdCBtYXRjaGVzIHRoZSBKU09OIHNjaGVtYSBhYm92ZS5cIjtcbnZhciBERUZBVUxUX0dFTkVSSUNfU1VGRklYID0gXCJZb3UgTVVTVCBhbnN3ZXIgd2l0aCBKU09OLlwiO1xuZnVuY3Rpb24gaW5qZWN0SnNvbkluc3RydWN0aW9uKHtcbiAgcHJvbXB0LFxuICBzY2hlbWEsXG4gIHNjaGVtYVByZWZpeCA9IHNjaGVtYSAhPSBudWxsID8gREVGQVVMVF9TQ0hFTUFfUFJFRklYIDogdm9pZCAwLFxuICBzY2hlbWFTdWZmaXggPSBzY2hlbWEgIT0gbnVsbCA/IERFRkFVTFRfU0NIRU1BX1NVRkZJWCA6IERFRkFVTFRfR0VORVJJQ19TVUZGSVhcbn0pIHtcbiAgcmV0dXJuIFtcbiAgICBwcm9tcHQgIT0gbnVsbCAmJiBwcm9tcHQubGVuZ3RoID4gMCA/IHByb21wdCA6IHZvaWQgMCxcbiAgICBwcm9tcHQgIT0gbnVsbCAmJiBwcm9tcHQubGVuZ3RoID4gMCA/IFwiXCIgOiB2b2lkIDAsXG4gICAgLy8gYWRkIGEgbmV3bGluZSBpZiBwcm9tcHQgaXMgbm90IG51bGxcbiAgICBzY2hlbWFQcmVmaXgsXG4gICAgc2NoZW1hICE9IG51bGwgPyBKU09OLnN0cmluZ2lmeShzY2hlbWEpIDogdm9pZCAwLFxuICAgIHNjaGVtYVN1ZmZpeFxuICBdLmZpbHRlcigobGluZSkgPT4gbGluZSAhPSBudWxsKS5qb2luKFwiXFxuXCIpO1xufVxuZnVuY3Rpb24gaW5qZWN0SnNvbkluc3RydWN0aW9uSW50b01lc3NhZ2VzKHtcbiAgbWVzc2FnZXMsXG4gIHNjaGVtYSxcbiAgc2NoZW1hUHJlZml4LFxuICBzY2hlbWFTdWZmaXhcbn0pIHtcbiAgdmFyIF9hMiwgX2IyO1xuICBjb25zdCBzeXN0ZW1NZXNzYWdlID0gKChfYTIgPSBtZXNzYWdlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5yb2xlKSA9PT0gXCJzeXN0ZW1cIiA/IHsgLi4ubWVzc2FnZXNbMF0gfSA6IHsgcm9sZTogXCJzeXN0ZW1cIiwgY29udGVudDogXCJcIiB9O1xuICBzeXN0ZW1NZXNzYWdlLmNvbnRlbnQgPSBpbmplY3RKc29uSW5zdHJ1Y3Rpb24oe1xuICAgIHByb21wdDogc3lzdGVtTWVzc2FnZS5jb250ZW50LFxuICAgIHNjaGVtYSxcbiAgICBzY2hlbWFQcmVmaXgsXG4gICAgc2NoZW1hU3VmZml4XG4gIH0pO1xuICByZXR1cm4gW1xuICAgIHN5c3RlbU1lc3NhZ2UsXG4gICAgLi4uKChfYjIgPSBtZXNzYWdlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5yb2xlKSA9PT0gXCJzeXN0ZW1cIiA/IG1lc3NhZ2VzLnNsaWNlKDEpIDogbWVzc2FnZXNcbiAgXTtcbn1cblxuLy8gc3JjL2lzLW5vbi1udWxsYWJsZS50c1xuZnVuY3Rpb24gaXNOb25OdWxsYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbDtcbn1cblxuLy8gc3JjL2lzLXVybC1zdXBwb3J0ZWQudHNcbmZ1bmN0aW9uIGlzVXJsU3VwcG9ydGVkKHtcbiAgbWVkaWFUeXBlLFxuICB1cmwsXG4gIHN1cHBvcnRlZFVybHNcbn0pIHtcbiAgdXJsID0gdXJsLnRvTG93ZXJDYXNlKCk7XG4gIG1lZGlhVHlwZSA9IG1lZGlhVHlwZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoc3VwcG9ydGVkVXJscykubWFwKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBjb25zdCBtZWRpYVR5cGUyID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIG1lZGlhVHlwZTIgPT09IFwiKlwiIHx8IG1lZGlhVHlwZTIgPT09IFwiKi8qXCIgPyB7IG1lZGlhVHlwZVByZWZpeDogXCJcIiwgcmVnZXhlczogdmFsdWUgfSA6IHsgbWVkaWFUeXBlUHJlZml4OiBtZWRpYVR5cGUyLnJlcGxhY2UoL1xcKi8sIFwiXCIpLCByZWdleGVzOiB2YWx1ZSB9O1xuICB9KS5maWx0ZXIoKHsgbWVkaWFUeXBlUHJlZml4IH0pID0+IG1lZGlhVHlwZS5zdGFydHNXaXRoKG1lZGlhVHlwZVByZWZpeCkpLmZsYXRNYXAoKHsgcmVnZXhlcyB9KSA9PiByZWdleGVzKS5zb21lKChwYXR0ZXJuKSA9PiBwYXR0ZXJuLnRlc3QodXJsKSk7XG59XG5cbi8vIHNyYy9sb2FkLWFwaS1rZXkudHNcbmltcG9ydCB7IExvYWRBUElLZXlFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5mdW5jdGlvbiBsb2FkQXBpS2V5KHtcbiAgYXBpS2V5LFxuICBlbnZpcm9ubWVudFZhcmlhYmxlTmFtZSxcbiAgYXBpS2V5UGFyYW1ldGVyTmFtZSA9IFwiYXBpS2V5XCIsXG4gIGRlc2NyaXB0aW9uXG59KSB7XG4gIGlmICh0eXBlb2YgYXBpS2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGFwaUtleTtcbiAgfVxuICBpZiAoYXBpS2V5ICE9IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTG9hZEFQSUtleUVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBBUEkga2V5IG11c3QgYmUgYSBzdHJpbmcuYFxuICAgIH0pO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBMb2FkQVBJS2V5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IEFQSSBrZXkgaXMgbWlzc2luZy4gUGFzcyBpdCB1c2luZyB0aGUgJyR7YXBpS2V5UGFyYW1ldGVyTmFtZX0nIHBhcmFtZXRlci4gRW52aXJvbm1lbnQgdmFyaWFibGVzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudC5gXG4gICAgfSk7XG4gIH1cbiAgYXBpS2V5ID0gcHJvY2Vzcy5lbnZbZW52aXJvbm1lbnRWYXJpYWJsZU5hbWVdO1xuICBpZiAoYXBpS2V5ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTG9hZEFQSUtleUVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBBUEkga2V5IGlzIG1pc3NpbmcuIFBhc3MgaXQgdXNpbmcgdGhlICcke2FwaUtleVBhcmFtZXRlck5hbWV9JyBwYXJhbWV0ZXIgb3IgdGhlICR7ZW52aXJvbm1lbnRWYXJpYWJsZU5hbWV9IGVudmlyb25tZW50IHZhcmlhYmxlLmBcbiAgICB9KTtcbiAgfVxuICBpZiAodHlwZW9mIGFwaUtleSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBMb2FkQVBJS2V5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IEFQSSBrZXkgbXVzdCBiZSBhIHN0cmluZy4gVGhlIHZhbHVlIG9mIHRoZSAke2Vudmlyb25tZW50VmFyaWFibGVOYW1lfSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBub3QgYSBzdHJpbmcuYFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBhcGlLZXk7XG59XG5cbi8vIHNyYy9sb2FkLW9wdGlvbmFsLXNldHRpbmcudHNcbmZ1bmN0aW9uIGxvYWRPcHRpb25hbFNldHRpbmcoe1xuICBzZXR0aW5nVmFsdWUsXG4gIGVudmlyb25tZW50VmFyaWFibGVOYW1lXG59KSB7XG4gIGlmICh0eXBlb2Ygc2V0dGluZ1ZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHNldHRpbmdWYWx1ZTtcbiAgfVxuICBpZiAoc2V0dGluZ1ZhbHVlICE9IG51bGwgfHwgdHlwZW9mIHByb2Nlc3MgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHNldHRpbmdWYWx1ZSA9IHByb2Nlc3MuZW52W2Vudmlyb25tZW50VmFyaWFibGVOYW1lXTtcbiAgaWYgKHNldHRpbmdWYWx1ZSA9PSBudWxsIHx8IHR5cGVvZiBzZXR0aW5nVmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBzZXR0aW5nVmFsdWU7XG59XG5cbi8vIHNyYy9sb2FkLXNldHRpbmcudHNcbmltcG9ydCB7IExvYWRTZXR0aW5nRXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuZnVuY3Rpb24gbG9hZFNldHRpbmcoe1xuICBzZXR0aW5nVmFsdWUsXG4gIGVudmlyb25tZW50VmFyaWFibGVOYW1lLFxuICBzZXR0aW5nTmFtZSxcbiAgZGVzY3JpcHRpb25cbn0pIHtcbiAgaWYgKHR5cGVvZiBzZXR0aW5nVmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gc2V0dGluZ1ZhbHVlO1xuICB9XG4gIGlmIChzZXR0aW5nVmFsdWUgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBMb2FkU2V0dGluZ0Vycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBzZXR0aW5nIG11c3QgYmUgYSBzdHJpbmcuYFxuICAgIH0pO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBMb2FkU2V0dGluZ0Vycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBzZXR0aW5nIGlzIG1pc3NpbmcuIFBhc3MgaXQgdXNpbmcgdGhlICcke3NldHRpbmdOYW1lfScgcGFyYW1ldGVyLiBFbnZpcm9ubWVudCB2YXJpYWJsZXMgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50LmBcbiAgICB9KTtcbiAgfVxuICBzZXR0aW5nVmFsdWUgPSBwcm9jZXNzLmVudltlbnZpcm9ubWVudFZhcmlhYmxlTmFtZV07XG4gIGlmIChzZXR0aW5nVmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBMb2FkU2V0dGluZ0Vycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBzZXR0aW5nIGlzIG1pc3NpbmcuIFBhc3MgaXQgdXNpbmcgdGhlICcke3NldHRpbmdOYW1lfScgcGFyYW1ldGVyIG9yIHRoZSAke2Vudmlyb25tZW50VmFyaWFibGVOYW1lfSBlbnZpcm9ubWVudCB2YXJpYWJsZS5gXG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzZXR0aW5nVmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgTG9hZFNldHRpbmdFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgJHtkZXNjcmlwdGlvbn0gc2V0dGluZyBtdXN0IGJlIGEgc3RyaW5nLiBUaGUgdmFsdWUgb2YgdGhlICR7ZW52aXJvbm1lbnRWYXJpYWJsZU5hbWV9IGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG5vdCBhIHN0cmluZy5gXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHNldHRpbmdWYWx1ZTtcbn1cblxuLy8gc3JjL21lZGlhLXR5cGUtdG8tZXh0ZW5zaW9uLnRzXG5mdW5jdGlvbiBtZWRpYVR5cGVUb0V4dGVuc2lvbihtZWRpYVR5cGUpIHtcbiAgdmFyIF9hMjtcbiAgY29uc3QgW190eXBlLCBzdWJ0eXBlID0gXCJcIl0gPSBtZWRpYVR5cGUudG9Mb3dlckNhc2UoKS5zcGxpdChcIi9cIik7XG4gIHJldHVybiAoX2EyID0ge1xuICAgIG1wZWc6IFwibXAzXCIsXG4gICAgXCJ4LXdhdlwiOiBcIndhdlwiLFxuICAgIG9wdXM6IFwib2dnXCIsXG4gICAgbXA0OiBcIm00YVwiLFxuICAgIFwieC1tNGFcIjogXCJtNGFcIlxuICB9W3N1YnR5cGVdKSAhPSBudWxsID8gX2EyIDogc3VidHlwZTtcbn1cblxuLy8gc3JjL3BhcnNlLWpzb24udHNcbmltcG9ydCB7XG4gIEpTT05QYXJzZUVycm9yLFxuICBUeXBlVmFsaWRhdGlvbkVycm9yIGFzIFR5cGVWYWxpZGF0aW9uRXJyb3IzXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5cbi8vIHNyYy9zZWN1cmUtanNvbi1wYXJzZS50c1xudmFyIHN1c3BlY3RQcm90b1J4ID0gL1wiX19wcm90b19fXCJcXHMqOi87XG52YXIgc3VzcGVjdENvbnN0cnVjdG9yUnggPSAvXCJjb25zdHJ1Y3RvclwiXFxzKjovO1xuZnVuY3Rpb24gX3BhcnNlKHRleHQpIHtcbiAgY29uc3Qgb2JqID0gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBpZiAoc3VzcGVjdFByb3RvUngudGVzdCh0ZXh0KSA9PT0gZmFsc2UgJiYgc3VzcGVjdENvbnN0cnVjdG9yUngudGVzdCh0ZXh0KSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIHJldHVybiBmaWx0ZXIob2JqKTtcbn1cbmZ1bmN0aW9uIGZpbHRlcihvYmopIHtcbiAgbGV0IG5leHQgPSBbb2JqXTtcbiAgd2hpbGUgKG5leHQubGVuZ3RoKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBuZXh0O1xuICAgIG5leHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZSwgXCJfX3Byb3RvX19cIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiT2JqZWN0IGNvbnRhaW5zIGZvcmJpZGRlbiBwcm90b3R5cGUgcHJvcGVydHlcIik7XG4gICAgICB9XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGUsIFwiY29uc3RydWN0b3JcIikgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGUuY29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIk9iamVjdCBjb250YWlucyBmb3JiaWRkZW4gcHJvdG90eXBlIHByb3BlcnR5XCIpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gbm9kZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG5vZGVba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIG5leHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIHNlY3VyZUpzb25QYXJzZSh0ZXh0KSB7XG4gIGNvbnN0IHsgc3RhY2tUcmFjZUxpbWl0IH0gPSBFcnJvcjtcbiAgdHJ5IHtcbiAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSAwO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIF9wYXJzZSh0ZXh0KTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBfcGFyc2UodGV4dCk7XG4gIH0gZmluYWxseSB7XG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gc3RhY2tUcmFjZUxpbWl0O1xuICB9XG59XG5cbi8vIHNyYy92YWxpZGF0ZS10eXBlcy50c1xuaW1wb3J0IHsgVHlwZVZhbGlkYXRpb25FcnJvciBhcyBUeXBlVmFsaWRhdGlvbkVycm9yMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5cbi8vIHNyYy9zY2hlbWEudHNcbmltcG9ydCB7IFR5cGVWYWxpZGF0aW9uRXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0ICogYXMgejQgZnJvbSBcInpvZC92NFwiO1xuXG4vLyBzcmMvYWRkLWFkZGl0aW9uYWwtcHJvcGVydGllcy10by1qc29uLXNjaGVtYS50c1xuZnVuY3Rpb24gYWRkQWRkaXRpb25hbFByb3BlcnRpZXNUb0pzb25TY2hlbWEoanNvblNjaGVtYTIpIHtcbiAgaWYgKGpzb25TY2hlbWEyLnR5cGUgPT09IFwib2JqZWN0XCIgfHwgQXJyYXkuaXNBcnJheShqc29uU2NoZW1hMi50eXBlKSAmJiBqc29uU2NoZW1hMi50eXBlLmluY2x1ZGVzKFwib2JqZWN0XCIpKSB7XG4gICAganNvblNjaGVtYTIuYWRkaXRpb25hbFByb3BlcnRpZXMgPSBmYWxzZTtcbiAgICBjb25zdCB7IHByb3BlcnRpZXMgfSA9IGpzb25TY2hlbWEyO1xuICAgIGlmIChwcm9wZXJ0aWVzICE9IG51bGwpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHByb3BlcnRpZXMpKSB7XG4gICAgICAgIHByb3BlcnRpZXNba2V5XSA9IHZpc2l0KHByb3BlcnRpZXNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChqc29uU2NoZW1hMi5pdGVtcyAhPSBudWxsKSB7XG4gICAganNvblNjaGVtYTIuaXRlbXMgPSBBcnJheS5pc0FycmF5KGpzb25TY2hlbWEyLml0ZW1zKSA/IGpzb25TY2hlbWEyLml0ZW1zLm1hcCh2aXNpdCkgOiB2aXNpdChqc29uU2NoZW1hMi5pdGVtcyk7XG4gIH1cbiAgaWYgKGpzb25TY2hlbWEyLmFueU9mICE9IG51bGwpIHtcbiAgICBqc29uU2NoZW1hMi5hbnlPZiA9IGpzb25TY2hlbWEyLmFueU9mLm1hcCh2aXNpdCk7XG4gIH1cbiAgaWYgKGpzb25TY2hlbWEyLmFsbE9mICE9IG51bGwpIHtcbiAgICBqc29uU2NoZW1hMi5hbGxPZiA9IGpzb25TY2hlbWEyLmFsbE9mLm1hcCh2aXNpdCk7XG4gIH1cbiAgaWYgKGpzb25TY2hlbWEyLm9uZU9mICE9IG51bGwpIHtcbiAgICBqc29uU2NoZW1hMi5vbmVPZiA9IGpzb25TY2hlbWEyLm9uZU9mLm1hcCh2aXNpdCk7XG4gIH1cbiAgY29uc3QgeyBkZWZpbml0aW9ucyB9ID0ganNvblNjaGVtYTI7XG4gIGlmIChkZWZpbml0aW9ucyAhPSBudWxsKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoZGVmaW5pdGlvbnMpKSB7XG4gICAgICBkZWZpbml0aW9uc1trZXldID0gdmlzaXQoZGVmaW5pdGlvbnNba2V5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBqc29uU2NoZW1hMjtcbn1cbmZ1bmN0aW9uIHZpc2l0KGRlZikge1xuICBpZiAodHlwZW9mIGRlZiA9PT0gXCJib29sZWFuXCIpIHJldHVybiBkZWY7XG4gIHJldHVybiBhZGRBZGRpdGlvbmFsUHJvcGVydGllc1RvSnNvblNjaGVtYShkZWYpO1xufVxuXG4vLyBzcmMvdG8tanNvbi1zY2hlbWEvem9kMy10by1qc29uLXNjaGVtYS9vcHRpb25zLnRzXG52YXIgaWdub3JlT3ZlcnJpZGUgPSBTeW1ib2woXG4gIFwiTGV0IHpvZFRvSnNvblNjaGVtYSBkZWNpZGUgb24gd2hpY2ggcGFyc2VyIHRvIHVzZVwiXG4pO1xudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBuYW1lOiB2b2lkIDAsXG4gICRyZWZTdHJhdGVneTogXCJyb290XCIsXG4gIGJhc2VQYXRoOiBbXCIjXCJdLFxuICBlZmZlY3RTdHJhdGVneTogXCJpbnB1dFwiLFxuICBwaXBlU3RyYXRlZ3k6IFwiYWxsXCIsXG4gIGRhdGVTdHJhdGVneTogXCJmb3JtYXQ6ZGF0ZS10aW1lXCIsXG4gIG1hcFN0cmF0ZWd5OiBcImVudHJpZXNcIixcbiAgcmVtb3ZlQWRkaXRpb25hbFN0cmF0ZWd5OiBcInBhc3N0aHJvdWdoXCIsXG4gIGFsbG93ZWRBZGRpdGlvbmFsUHJvcGVydGllczogdHJ1ZSxcbiAgcmVqZWN0ZWRBZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2UsXG4gIGRlZmluaXRpb25QYXRoOiBcImRlZmluaXRpb25zXCIsXG4gIHN0cmljdFVuaW9uczogZmFsc2UsXG4gIGRlZmluaXRpb25zOiB7fSxcbiAgZXJyb3JNZXNzYWdlczogZmFsc2UsXG4gIHBhdHRlcm5TdHJhdGVneTogXCJlc2NhcGVcIixcbiAgYXBwbHlSZWdleEZsYWdzOiBmYWxzZSxcbiAgZW1haWxTdHJhdGVneTogXCJmb3JtYXQ6ZW1haWxcIixcbiAgYmFzZTY0U3RyYXRlZ3k6IFwiY29udGVudEVuY29kaW5nOmJhc2U2NFwiLFxuICBuYW1lU3RyYXRlZ3k6IFwicmVmXCJcbn07XG52YXIgZ2V0RGVmYXVsdE9wdGlvbnMgPSAob3B0aW9ucykgPT4gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgPyB7XG4gIC4uLmRlZmF1bHRPcHRpb25zLFxuICBuYW1lOiBvcHRpb25zXG59IDoge1xuICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgLi4ub3B0aW9uc1xufTtcblxuLy8gc3JjL3RvLWpzb24tc2NoZW1hL3pvZDMtdG8tanNvbi1zY2hlbWEvc2VsZWN0LXBhcnNlci50c1xuaW1wb3J0IHsgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kIGFzIFpvZEZpcnN0UGFydHlUeXBlS2luZDMgfSBmcm9tIFwiem9kL3YzXCI7XG5cbi8vIHNyYy90by1qc29uLXNjaGVtYS96b2QzLXRvLWpzb24tc2NoZW1hL3BhcnNlcnMvYW55LnRzXG5mdW5jdGlvbiBwYXJzZUFueURlZigpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG4vLyBzcmMvdG8tanNvbi1zY2hlbWEvem9kMy10by1qc29uLXNjaGVtYS9wYXJzZXJzL2FycmF5LnRzXG5pbXBvcnQgeyBab2RGaXJzdFBhcnR5VHlwZUtpbmQgfSBmcm9tIFwiem9kL3YzXCI7XG5mdW5jdGlvbiBwYXJzZUFycmF5RGVmKGRlZiwgcmVmcykge1xuICB2YXIgX2EyLCBfYjIsIF9jO1xuICBjb25zdCByZXMgPSB7XG4gICAgdHlwZTogXCJhcnJheVwiXG4gIH07XG4gIGlmICgoKF9hMiA9IGRlZi50eXBlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLl9kZWYpICYmICgoX2MgPSAoX2IyID0gZGVmLnR5cGUpID09IG51bGwgPyB2b2lkIDAgOiBfYjIuX2RlZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnR5cGVOYW1lKSAhPT0gWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEFueSkge1xuICAgIHJlcy5pdGVtcyA9IHBhcnNlRGVmKGRlZi50eXBlLl9kZWYsIHtcbiAgICAgIC4uLnJlZnMsXG4gICAgICBjdXJyZW50UGF0aDogWy4uLnJlZnMuY3VycmVudFBhdGgsIFwiaXRlbXNcIl1cbiAgICB9KTtcbiAgfVxuICBpZiAoZGVmLm1pbkxlbmd0aCkge1xuICAgIHJlcy5taW5JdGVtcyA9IGRlZi5taW5MZW5ndGgudmFsdWU7XG4gIH1cbiAgaWYgKGRlZi5tYXhMZW5ndGgpIHtcbiAgICByZXMubWF4SXRlbXMgPSBkZWYubWF4TGVuZ3RoLnZhbHVlO1xuICB9XG4gIGlmIChkZWYuZXhhY3RMZW5ndGgpIHtcbiAgICByZXMubWluSXRlbXMgPSBkZWYuZXhhY3RMZW5ndGgudmFsdWU7XG4gICAgcmVzLm1heEl0ZW1zID0gZGVmLmV4YWN0TGVuZ3RoLnZhbHVlO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIHNyYy90by1qc29uLXNjaGVtYS96b2QzLXRvLWpzb24tc2NoZW1hL3BhcnNlcnMvYmlnaW50LnRzXG5mdW5jdGlvbiBwYXJzZUJpZ2ludERlZihkZWYpIHtcbiAgY29uc3QgcmVzID0ge1xuICAgIHR5cGU6IFwiaW50ZWdlclwiLFxuICAgIGZvcm1hdDogXCJpbnQ2NFwiXG4gIH07XG4gIGlmICghZGVmLmNoZWNrcykgcmV0dXJuIHJlcztcbiAgZm9yIChjb25zdCBjaGVjayBvZiBkZWYuY2hlY2tzKSB7XG4gICAgc3dpdGNoIChjaGVjay5raW5kKSB7XG4gICAgICBjYXNlIFwibWluXCI6XG4gICAgICAgIGlmIChjaGVjay5pbmNsdXNpdmUpIHtcbiAgICAgICAgICByZXMubWluaW11bSA9IGNoZWNrLnZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcy5leGNsdXNpdmVNaW5pbXVtID0gY2hlY2sudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibWF4XCI6XG4gICAgICAgIGlmIChjaGVjay5pbmNsdXNpdmUpIHtcbiAgICAgICAgICByZXMubWF4aW11bSA9IGNoZWNrLnZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcy5leGNsdXNpdmVNYXhpbXVtID0gY2hlY2sudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibXVsdGlwbGVPZlwiOlxuICAgICAgICByZXMubXVsdGlwbGVPZiA9IGNoZWNrLnZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3RvLWpzb24tc2NoZW1hL3pvZDMtdG8tanNvbi1zY2hlbWEvcGFyc2Vycy9ib29sZWFuLnRzXG5mdW5jdGlvbiBwYXJzZUJvb2xlYW5EZWYoKSB7XG4gIHJldHVybiB7IHR5cGU6IFwiYm9vbGVhblwiIH07XG59XG5cbi8vIHNyYy90by1qc29uLXNjaGVtYS96b2QzLXRvLWpzb24tc2NoZW1hL3BhcnNlcnMvYnJhbmRlZC50c1xuZnVuY3Rpb24gcGFyc2VCcmFuZGVkRGVmKF9kZWYsIHJlZnMpIHtcbiAgcmV0dXJuIHBhcnNlRGVmKF9kZWYudHlwZS5fZGVmLCByZWZzKTtcbn1cblxuLy8gc3JjL3RvLWpzb24tc2NoZW1hL3pvZDMtdG8tanNvbi1zY2hlbWEvcGFyc2Vycy9jYXRjaC50c1xudmFyIHBhcnNlQ2F0Y2hEZWYgPSAoZGVmLCByZWZzKSA9PiB7XG4gIHJldHVybiBwYXJzZURlZihkZWYuaW5uZXJUeXBlLl9kZWYsIHJlZnMpO1xufTtcblxuLy8gc3JjL3RvLWpzb24tc2NoZW1hL3pvZDMtdG8tanNvbi1zY2hlbWEvcGFyc2Vycy9kYXRlLnRzXG5mdW5jdGlvbiBwYXJzZURhdGVEZWYoZGVmLCByZWZzLCBvdmVycmlkZURhdGVTdHJhdGVneSkge1xuICBjb25zdCBzdHJhdGVneSA9IG92ZXJyaWRlRGF0ZVN0cmF0ZWd5ICE9IG51bGwgPyBvdmVycmlkZURhdGVTdHJhdGVneSA6IHJlZnMuZGF0ZVN0cmF0ZWd5O1xuICBpZiAoQXJyYXkuaXNBcnJheShzdHJhdGVneSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYW55T2Y6IHN0cmF0ZWd5Lm1hcCgoaXRlbSwgaSkgPT4gcGFyc2VEYXRlRGVmKGRlZiwgcmVmcywgaXRlbSkpXG4gICAgfTtcbiAgfVxuICBzd2l0Y2ggKHN0cmF0ZWd5KSB7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgIGNhc2UgXCJmb3JtYXQ6ZGF0ZS10aW1lXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwiZGF0ZS10aW1lXCJcbiAgICAgIH07XG4gICAgY2FzZSBcImZvcm1hdDpkYXRlXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwiZGF0ZVwiXG4gICAgICB9O1xuICAgIGNhc2UgXCJpbnRlZ2VyXCI6XG4gICAgICByZXR1cm4gaW50ZWdlckRhdGVQYXJzZXIoZGVmKTtcbiAgfVxufVxudmFyIGludGVnZXJEYXRlUGFyc2VyID0gKGRlZikgPT4ge1xuICBjb25zdCByZXMgPSB7XG4gICAgdHlwZTogXCJpbnRlZ2VyXCIsXG4gICAgZm9ybWF0OiBcInVuaXgtdGltZVwiXG4gIH07XG4gIGZvciAoY29uc3QgY2hlY2sgb2YgZGVmLmNoZWNrcykge1xuICAgIHN3aXRjaCAoY2hlY2sua2luZCkge1xuICAgICAgY2FzZSBcIm1pblwiOlxuICAgICAgICByZXMubWluaW11bSA9IGNoZWNrLnZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtYXhcIjpcbiAgICAgICAgcmVzLm1heGltdW0gPSBjaGVjay52YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG4vLyBzcmMvdG8tanNvbi1zY2hlbWEvem9kMy10by1qc29uLXNjaGVtYS9wYXJzZXJzL2RlZmF1bHQudHNcbmZ1bmN0aW9uIHBhcnNlRGVmYXVsdERlZihfZGVmLCByZWZzKSB7XG4gIHJldHVybiB7XG4gICAgLi4ucGFyc2VEZWYoX2RlZi5pbm5lclR5cGUuX2RlZiwgcmVmcyksXG4gICAgZGVmYXVsdDogX2RlZi5kZWZhdWx0VmFsdWUoKVxuICB9O1xufVxuXG4vLyBzcmMvdG8tanNvbi1zY2hlbWEvem9kMy10by1qc29uLXNjaGVtYS9wYXJzZXJzL2VmZmVjdHMudHNcbmZ1bmN0aW9uIHBhcnNlRWZmZWN0c0RlZihfZGVmLCByZWZzKSB7XG4gIHJldHVybiByZWZzLmVmZmVjdFN0cmF0ZWd5ID09PSBcImlucHV0XCIgPyBwYXJzZURlZihfZGVmLnNjaGVtYS5fZGVmLCByZWZzKSA6IHBhcnNlQW55RGVmKCk7XG59XG5cbi8vIHNyYy90by1qc29uLXNjaGVtYS96b2QzLXRvLWpzb24tc2NoZW1hL3BhcnNlcnMvZW51bS50c1xuZnVuY3Rpb24gcGFyc2VFbnVtRGVmKGRlZikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgZW51bTogQXJyYXkuZnJvbShkZWYudmFsdWVzKVxuICB9O1xufVxuXG4vLyBzcmMvdG8tanNvbi1zY2hlbWEvem9kMy10by1qc29uLXNjaGVtYS9wYXJzZXJzL2ludGVyc2VjdGlvbi50c1xudmFyIGlzSnNvblNjaGVtYTdBbGxPZlR5cGUgPSAodHlwZSkgPT4ge1xuICBpZiAoXCJ0eXBlXCIgaW4gdHlwZSAmJiB0eXBlLnR5cGUgPT09IFwic3RyaW5nXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFwiYWxsT2ZcIiBpbiB0eXBlO1xufTtcbmZ1bmN0aW9uIHBhcnNlSW50ZXJzZWN0aW9uRGVmKGRlZiwgcmVmcykge1xuICBjb25zdCBhbGxPZiA9IFtcbiAgICBwYXJzZURlZihkZWYubGVmdC5fZGVmLCB7XG4gICAgICAuLi5yZWZzLFxuICAgICAgY3VycmVudFBhdGg6IFsuLi5yZWZzLmN1cnJlbnRQYXRoLCBcImFsbE9mXCIsIFwiMFwiXVxuICAgIH0pLFxuICAgIHBhcnNlRGVmKGRlZi5yaWdodC5fZGVmLCB7XG4gICAgICAuLi5yZWZzLFxuICAgICAgY3VycmVudFBhdGg6IFsuLi5yZWZzLmN1cnJlbnRQYXRoLCBcImFsbE9mXCIsIFwiMVwiXVxuICAgIH0pXG4gIF0uZmlsdGVyKCh4KSA9PiAhIXgpO1xuICBjb25zdCBtZXJnZWRBbGxPZiA9IFtdO1xuICBhbGxPZi5mb3JFYWNoKChzY2hlbWEpID0+IHtcbiAgICBpZiAoaXNKc29uU2NoZW1hN0FsbE9mVHlwZShzY2hlbWEpKSB7XG4gICAgICBtZXJnZWRBbGxPZi5wdXNoKC4uLnNjaGVtYS5hbGxPZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBuZXN0ZWRTY2hlbWEgPSBzY2hlbWE7XG4gICAgICBpZiAoXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiIGluIHNjaGVtYSAmJiBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHsgYWRkaXRpb25hbFByb3BlcnRpZXMsIC4uLnJlc3QgfSA9IHNjaGVtYTtcbiAgICAgICAgbmVzdGVkU2NoZW1hID0gcmVzdDtcbiAgICAgIH1cbiAgICAgIG1lcmdlZEFsbE9mLnB1c2gobmVzdGVkU2NoZW1hKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbWVyZ2VkQWxsT2YubGVuZ3RoID8geyBhbGxPZjogbWVyZ2VkQWxsT2YgfSA6IHZvaWQgMDtcbn1cblxuLy8gc3JjL3RvLWpzb24tc2NoZW1hL3pvZDMtdG8tanNvbi1zY2hlbWEvcGFyc2Vycy9saXRlcmFsLnRzXG5mdW5jdGlvbiBwYXJzZUxpdGVyYWxEZWYoZGVmKSB7XG4gIGNvbnN0IHBhcnNlZFR5cGUgPSB0eXBlb2YgZGVmLnZhbHVlO1xuICBpZiAocGFyc2VkVHlwZSAhPT0gXCJiaWdpbnRcIiAmJiBwYXJzZWRUeXBlICE9PSBcIm51bWJlclwiICYmIHBhcnNlZFR5cGUgIT09IFwiYm9vbGVhblwiICYmIHBhcnNlZFR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogQXJyYXkuaXNBcnJheShkZWYudmFsdWUpID8gXCJhcnJheVwiIDogXCJvYmplY3RcIlxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBwYXJzZWRUeXBlID09PSBcImJpZ2ludFwiID8gXCJpbnRlZ2VyXCIgOiBwYXJzZWRUeXBlLFxuICAgIGNvbnN0OiBkZWYudmFsdWVcbiAgfTtcbn1cblxuLy8gc3JjL3RvLWpzb24tc2NoZW1hL3pvZDMtdG8tanNvbi1zY2hlbWEvcGFyc2Vycy9yZWNvcmQudHNcbmltcG9ydCB7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZCBhcyBab2RGaXJzdFBhcnR5VHlwZUtpbmQyXG59IGZyb20gXCJ6b2QvdjNcIjtcblxuLy8gc3JjL3RvLWpzb24tc2NoZW1hL3pvZDMtdG8tanNvbi1zY2hlbWEvcGFyc2Vycy9zdHJpbmcudHNcbnZhciBlbW9qaVJlZ2V4ID0gdm9pZCAwO1xudmFyIHpvZFBhdHRlcm5zID0ge1xuICAvKipcbiAgICogYGNgIHdhcyBjaGFuZ2VkIHRvIGBbY0NdYCB0byByZXBsaWNhdGUgL2kgZmxhZ1xuICAgKi9cbiAgY3VpZDogL15bY0NdW15cXHMtXXs4LH0kLyxcbiAgY3VpZDI6IC9eWzAtOWEtel0rJC8sXG4gIHVsaWQ6IC9eWzAtOUEtSEpLTU5QLVRWLVpdezI2fSQvLFxuICAvKipcbiAgICogYGEtemAgd2FzIGFkZGVkIHRvIHJlcGxpY2F0ZSAvaSBmbGFnXG4gICAqL1xuICBlbWFpbDogL14oPyFcXC4pKD8hLipcXC5cXC4pKFthLXpBLVowLTlfJytcXC1cXC5dKilbYS16QS1aMC05XystXUAoW2EtekEtWjAtOV1bYS16QS1aMC05XFwtXSpcXC4pK1thLXpBLVpdezIsfSQvLFxuICAvKipcbiAgICogQ29uc3RydWN0ZWQgYSB2YWxpZCBVbmljb2RlIFJlZ0V4cFxuICAgKlxuICAgKiBMYXppbHkgaW5zdGFudGlhdGUgc2luY2UgdGhpcyB0eXBlIG9mIHJlZ2V4IGlzbid0IHN1cHBvcnRlZFxuICAgKiBpbiBhbGwgZW52cyAoZS5nLiBSZWFjdCBOYXRpdmUpLlxuICAgKlxuICAgKiBTZWU6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2xpbmhhY2tzL3pvZC9pc3N1ZXMvMjQzM1xuICAgKiBGaXggaW4gWm9kOlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vY29saW5oYWNrcy96b2QvY29tbWl0LzkzNDBmZDUxZTQ4NTc2YTc1YWRjOTE5YmZmNjVkYmM0YTVkNGM5OWJcbiAgICovXG4gIGVtb2ppOiAoKSA9PiB7XG4gICAgaWYgKGVtb2ppUmVnZXggPT09IHZvaWQgMCkge1xuICAgICAgZW1vamlSZWdleCA9IFJlZ0V4cChcbiAgICAgICAgXCJeKFxcXFxwe0V4dGVuZGVkX1BpY3RvZ3JhcGhpY318XFxcXHB7RW1vamlfQ29tcG9uZW50fSkrJFwiLFxuICAgICAgICBcInVcIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGVtb2ppUmVnZXg7XG4gIH0sXG4gIC8qKlxuICAgKiBVbnVzZWRcbiAgICovXG4gIHV1aWQ6IC9eWzAtOWEtZkEtRl17OH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17MTJ9JC8sXG4gIC8qKlxuICAgKiBVbnVzZWRcbiAgICovXG4gIGlwdjQ6IC9eKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pJC8sXG4gIGlwdjRDaWRyOiAvXig/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLygzWzAtMl18WzEyXT9bMC05XSkkLyxcbiAgLyoqXG4gICAqIFVudXNlZFxuICAgKi9cbiAgaXB2NjogL14oKFthLWYwLTldezEsNH06KXs3fXw6OihbYS1mMC05XXsxLDR9Oil7MCw2fXwoW2EtZjAtOV17MSw0fTopezF9OihbYS1mMC05XXsxLDR9Oil7MCw1fXwoW2EtZjAtOV17MSw0fTopezJ9OihbYS1mMC05XXsxLDR9Oil7MCw0fXwoW2EtZjAtOV17MSw0fTopezN9OihbYS1mMC05XXsxLDR9Oil7MCwzfXwoW2EtZjAtOV17MSw0fTopezR9OihbYS1mMC05XXsxLDR9Oil7MCwyfXwoW2EtZjAtOV17MSw0fTopezV9OihbYS1mMC05XXsxLDR9Oil7MCwxfSkoW2EtZjAtOV17MSw0fXwoKCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXC4pezN9KCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSkpJC8sXG4gIGlwdjZDaWRyOiAvXigoWzAtOWEtZkEtRl17MSw0fTopezcsN31bMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw3fTp8KFswLTlhLWZBLUZdezEsNH06KXsxLDZ9OlswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDV9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDJ9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwzfXwoWzAtOWEtZkEtRl17MSw0fTopezEsM30oOlswLTlhLWZBLUZdezEsNH0pezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDJ9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDV9fFswLTlhLWZBLUZdezEsNH06KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw2fSl8OigoOlswLTlhLWZBLUZdezEsNH0pezEsN318Oil8ZmU4MDooOlswLTlhLWZBLUZdezAsNH0pezAsNH0lWzAtOWEtekEtWl17MSx9fDo6KGZmZmYoOjB7MSw0fSl7MCwxfTopezAsMX0oKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSl8KFswLTlhLWZBLUZdezEsNH06KXsxLDR9OigoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKSlcXC8oMTJbMC04XXwxWzAxXVswLTldfFsxLTldP1swLTldKSQvLFxuICBiYXNlNjQ6IC9eKFswLTlhLXpBLVorL117NH0pKigoWzAtOWEtekEtWisvXXsyfT09KXwoWzAtOWEtekEtWisvXXszfT0pKT8kLyxcbiAgYmFzZTY0dXJsOiAvXihbMC05YS16QS1aLV9dezR9KSooKFswLTlhLXpBLVotX117Mn0oPT0pPyl8KFswLTlhLXpBLVotX117M30oPSk/KSk/JC8sXG4gIG5hbm9pZDogL15bYS16QS1aMC05Xy1dezIxfSQvLFxuICBqd3Q6IC9eW0EtWmEtejAtOS1fXStcXC5bQS1aYS16MC05LV9dK1xcLltBLVphLXowLTktX10qJC9cbn07XG5mdW5jdGlvbiBwYXJzZVN0cmluZ0RlZihkZWYsIHJlZnMpIHtcbiAgY29uc3QgcmVzID0ge1xuICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgfTtcbiAgaWYgKGRlZi5jaGVja3MpIHtcbiAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIGRlZi5jaGVja3MpIHtcbiAgICAgIHN3aXRjaCAoY2hlY2sua2luZCkge1xuICAgICAgICBjYXNlIFwibWluXCI6XG4gICAgICAgICAgcmVzLm1pbkxlbmd0aCA9IHR5cGVvZiByZXMubWluTGVuZ3RoID09PSBcIm51bWJlclwiID8gTWF0aC5tYXgocmVzLm1pbkxlbmd0aCwgY2hlY2sudmFsdWUpIDogY2hlY2sudmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtYXhcIjpcbiAgICAgICAgICByZXMubWF4TGVuZ3RoID0gdHlwZW9mIHJlcy5tYXhMZW5ndGggPT09IFwibnVtYmVyXCIgPyBNYXRoLm1pbihyZXMubWF4TGVuZ3RoLCBjaGVjay52YWx1ZSkgOiBjaGVjay52YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImVtYWlsXCI6XG4gICAgICAgICAgc3dpdGNoIChyZWZzLmVtYWlsU3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIGNhc2UgXCJmb3JtYXQ6ZW1haWxcIjpcbiAgICAgICAgICAgICAgYWRkRm9ybWF0KHJlcywgXCJlbWFpbFwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZm9ybWF0Omlkbi1lbWFpbFwiOlxuICAgICAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcImlkbi1lbWFpbFwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicGF0dGVybjp6b2RcIjpcbiAgICAgICAgICAgICAgYWRkUGF0dGVybihyZXMsIHpvZFBhdHRlcm5zLmVtYWlsLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidXJsXCI6XG4gICAgICAgICAgYWRkRm9ybWF0KHJlcywgXCJ1cmlcIiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ1dWlkXCI6XG4gICAgICAgICAgYWRkRm9ybWF0KHJlcywgXCJ1dWlkXCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmVnZXhcIjpcbiAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgY2hlY2sucmVnZXgsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY3VpZFwiOlxuICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCB6b2RQYXR0ZXJucy5jdWlkLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImN1aWQyXCI6XG4gICAgICAgICAgYWRkUGF0dGVybihyZXMsIHpvZFBhdHRlcm5zLmN1aWQyLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInN0YXJ0c1dpdGhcIjpcbiAgICAgICAgICBhZGRQYXR0ZXJuKFxuICAgICAgICAgICAgcmVzLFxuICAgICAgICAgICAgUmVnRXhwKGBeJHtlc2NhcGVMaXRlcmFsQ2hlY2tWYWx1ZShjaGVjay52YWx1ZSwgcmVmcyl9YCksXG4gICAgICAgICAgICBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgcmVmc1xuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlbmRzV2l0aFwiOlxuICAgICAgICAgIGFkZFBhdHRlcm4oXG4gICAgICAgICAgICByZXMsXG4gICAgICAgICAgICBSZWdFeHAoYCR7ZXNjYXBlTGl0ZXJhbENoZWNrVmFsdWUoY2hlY2sudmFsdWUsIHJlZnMpfSRgKSxcbiAgICAgICAgICAgIGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICByZWZzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRhdGV0aW1lXCI6XG4gICAgICAgICAgYWRkRm9ybWF0KHJlcywgXCJkYXRlLXRpbWVcIiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkYXRlXCI6XG4gICAgICAgICAgYWRkRm9ybWF0KHJlcywgXCJkYXRlXCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidGltZVwiOlxuICAgICAgICAgIGFkZEZvcm1hdChyZXMsIFwidGltZVwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImR1cmF0aW9uXCI6XG4gICAgICAgICAgYWRkRm9ybWF0KHJlcywgXCJkdXJhdGlvblwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImxlbmd0aFwiOlxuICAgICAgICAgIHJlcy5taW5MZW5ndGggPSB0eXBlb2YgcmVzLm1pbkxlbmd0aCA9PT0gXCJudW1iZXJcIiA/IE1hdGgubWF4KHJlcy5taW5MZW5ndGgsIGNoZWNrLnZhbHVlKSA6IGNoZWNrLnZhbHVlO1xuICAgICAgICAgIHJlcy5tYXhMZW5ndGggPSB0eXBlb2YgcmVzLm1heExlbmd0aCA9PT0gXCJudW1iZXJcIiA/IE1hdGgubWluKHJlcy5tYXhMZW5ndGgsIGNoZWNrLnZhbHVlKSA6IGNoZWNrLnZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaW5jbHVkZXNcIjoge1xuICAgICAgICAgIGFkZFBhdHRlcm4oXG4gICAgICAgICAgICByZXMsXG4gICAgICAgICAgICBSZWdFeHAoZXNjYXBlTGl0ZXJhbENoZWNrVmFsdWUoY2hlY2sudmFsdWUsIHJlZnMpKSxcbiAgICAgICAgICAgIGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICByZWZzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiaXBcIjoge1xuICAgICAgICAgIGlmIChjaGVjay52ZXJzaW9uICE9PSBcInY2XCIpIHtcbiAgICAgICAgICAgIGFkZEZvcm1hdChyZXMsIFwiaXB2NFwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoZWNrLnZlcnNpb24gIT09IFwidjRcIikge1xuICAgICAgICAgICAgYWRkRm9ybWF0KHJlcywgXCJpcHY2XCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiYmFzZTY0dXJsXCI6XG4gICAgICAgICAgYWRkUGF0dGVybihyZXMsIHpvZFBhdHRlcm5zLmJhc2U2NHVybCwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJqd3RcIjpcbiAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgem9kUGF0dGVybnMuand0LCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNpZHJcIjoge1xuICAgICAgICAgIGlmIChjaGVjay52ZXJzaW9uICE9PSBcInY2XCIpIHtcbiAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCB6b2RQYXR0ZXJucy5pcHY0Q2lkciwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaGVjay52ZXJzaW9uICE9PSBcInY0XCIpIHtcbiAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCB6b2RQYXR0ZXJucy5pcHY2Q2lkciwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJlbW9qaVwiOlxuICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCB6b2RQYXR0ZXJucy5lbW9qaSgpLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInVsaWRcIjoge1xuICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCB6b2RQYXR0ZXJucy51bGlkLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiYmFzZTY0XCI6IHtcbiAgICAgICAgICBzd2l0Y2ggKHJlZnMuYmFzZTY0U3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIGNhc2UgXCJmb3JtYXQ6YmluYXJ5XCI6IHtcbiAgICAgICAgICAgICAgYWRkRm9ybWF0KHJlcywgXCJiaW5hcnlcIiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImNvbnRlbnRFbmNvZGluZzpiYXNlNjRcIjoge1xuICAgICAgICAgICAgICByZXMuY29udGVudEVuY29kaW5nID0gXCJiYXNlNjRcIjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwicGF0dGVybjp6b2RcIjoge1xuICAgICAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgem9kUGF0dGVybnMuYmFzZTY0LCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJuYW5vaWRcIjoge1xuICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCB6b2RQYXR0ZXJucy5uYW5vaWQsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ0b0xvd2VyQ2FzZVwiOlxuICAgICAgICBjYXNlIFwidG9VcHBlckNhc2VcIjpcbiAgICAgICAgY2FzZSBcInRyaW1cIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKChfKSA9PiB7XG4gICAgICAgICAgfSkoY2hlY2spO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZXNjYXBlTGl0ZXJhbENoZWNrVmFsdWUobGl0ZXJhbCwgcmVmcykge1xuICByZXR1cm4gcmVmcy5wYXR0ZXJuU3RyYXRlZ3kgPT09IFwiZXNjYXBlXCIgPyBlc2NhcGVOb25BbHBoYU51bWVyaWMobGl0ZXJhbCkgOiBsaXRlcmFsO1xufVxudmFyIEFMUEhBX05VTUVSSUMgPSBuZXcgU2V0KFxuICBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2eHl6MDEyMzQ1Njc4OVwiXG4pO1xuZnVuY3Rpb24gZXNjYXBlTm9uQWxwaGFOdW1lcmljKHNvdXJjZSkge1xuICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIUFMUEhBX05VTUVSSUMuaGFzKHNvdXJjZVtpXSkpIHtcbiAgICAgIHJlc3VsdCArPSBcIlxcXFxcIjtcbiAgICB9XG4gICAgcmVzdWx0ICs9IHNvdXJjZVtpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYWRkRm9ybWF0KHNjaGVtYSwgdmFsdWUsIG1lc3NhZ2UsIHJlZnMpIHtcbiAgdmFyIF9hMjtcbiAgaWYgKHNjaGVtYS5mb3JtYXQgfHwgKChfYTIgPSBzY2hlbWEuYW55T2YpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuc29tZSgoeCkgPT4geC5mb3JtYXQpKSkge1xuICAgIGlmICghc2NoZW1hLmFueU9mKSB7XG4gICAgICBzY2hlbWEuYW55T2YgPSBbXTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYS5mb3JtYXQpIHtcbiAgICAgIHNjaGVtYS5hbnlPZi5wdXNoKHtcbiAgICAgICAgZm9ybWF0OiBzY2hlbWEuZm9ybWF0XG4gICAgICB9KTtcbiAgICAgIGRlbGV0ZSBzY2hlbWEuZm9ybWF0O1xuICAgIH1cbiAgICBzY2hlbWEuYW55T2YucHVzaCh7XG4gICAgICBmb3JtYXQ6IHZhbHVlLFxuICAgICAgLi4ubWVzc2FnZSAmJiByZWZzLmVycm9yTWVzc2FnZXMgJiYgeyBlcnJvck1lc3NhZ2U6IHsgZm9ybWF0OiBtZXNzYWdlIH0gfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHNjaGVtYS5mb3JtYXQgPSB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gYWRkUGF0dGVybihzY2hlbWEsIHJlZ2V4LCBtZXNzYWdlLCByZWZzKSB7XG4gIHZhciBfYTI7XG4gIGlmIChzY2hlbWEucGF0dGVybiB8fCAoKF9hMiA9IHNjaGVtYS5hbGxPZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5zb21lKCh4KSA9PiB4LnBhdHRlcm4pKSkge1xuICAgIGlmICghc2NoZW1hLmFsbE9mKSB7XG4gICAgICBzY2hlbWEuYWxsT2YgPSBbXTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYS5wYXR0ZXJuKSB7XG4gICAgICBzY2hlbWEuYWxsT2YucHVzaCh7XG4gICAgICAgIHBhdHRlcm46IHNjaGVtYS5wYXR0ZXJuXG4gICAgICB9KTtcbiAgICAgIGRlbGV0ZSBzY2hlbWEucGF0dGVybjtcbiAgICB9XG4gICAgc2NoZW1hLmFsbE9mLnB1c2goe1xuICAgICAgcGF0dGVybjogc3RyaW5naWZ5UmVnRXhwV2l0aEZsYWdzKHJlZ2V4LCByZWZzKSxcbiAgICAgIC4uLm1lc3NhZ2UgJiYgcmVmcy5lcnJvck1lc3NhZ2VzICYmIHsgZXJyb3JNZXNzYWdlOiB7IHBhdHRlcm46IG1lc3NhZ2UgfSB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgc2NoZW1hLnBhdHRlcm4gPSBzdHJpbmdpZnlSZWdFeHBXaXRoRmxhZ3MocmVnZXgsIHJlZnMpO1xuICB9XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlSZWdFeHBXaXRoRmxhZ3MocmVnZXgsIHJlZnMpIHtcbiAgdmFyIF9hMjtcbiAgaWYgKCFyZWZzLmFwcGx5UmVnZXhGbGFncyB8fCAhcmVnZXguZmxhZ3MpIHtcbiAgICByZXR1cm4gcmVnZXguc291cmNlO1xuICB9XG4gIGNvbnN0IGZsYWdzID0ge1xuICAgIGk6IHJlZ2V4LmZsYWdzLmluY2x1ZGVzKFwiaVwiKSxcbiAgICAvLyBDYXNlLWluc2Vuc2l0aXZlXG4gICAgbTogcmVnZXguZmxhZ3MuaW5jbHVkZXMoXCJtXCIpLFxuICAgIC8vIGBeYCBhbmQgYCRgIG1hdGNoZXMgYWRqYWNlbnQgdG8gbmV3bGluZSBjaGFyYWN0ZXJzXG4gICAgczogcmVnZXguZmxhZ3MuaW5jbHVkZXMoXCJzXCIpXG4gICAgLy8gYC5gIG1hdGNoZXMgbmV3bGluZXNcbiAgfTtcbiAgY29uc3Qgc291cmNlID0gZmxhZ3MuaSA/IHJlZ2V4LnNvdXJjZS50b0xvd2VyQ2FzZSgpIDogcmVnZXguc291cmNlO1xuICBsZXQgcGF0dGVybiA9IFwiXCI7XG4gIGxldCBpc0VzY2FwZWQgPSBmYWxzZTtcbiAgbGV0IGluQ2hhckdyb3VwID0gZmFsc2U7XG4gIGxldCBpbkNoYXJSYW5nZSA9IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpc0VzY2FwZWQpIHtcbiAgICAgIHBhdHRlcm4gKz0gc291cmNlW2ldO1xuICAgICAgaXNFc2NhcGVkID0gZmFsc2U7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGZsYWdzLmkpIHtcbiAgICAgIGlmIChpbkNoYXJHcm91cCkge1xuICAgICAgICBpZiAoc291cmNlW2ldLm1hdGNoKC9bYS16XS8pKSB7XG4gICAgICAgICAgaWYgKGluQ2hhclJhbmdlKSB7XG4gICAgICAgICAgICBwYXR0ZXJuICs9IHNvdXJjZVtpXTtcbiAgICAgICAgICAgIHBhdHRlcm4gKz0gYCR7c291cmNlW2kgLSAyXX0tJHtzb3VyY2VbaV19YC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgaW5DaGFyUmFuZ2UgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZVtpICsgMV0gPT09IFwiLVwiICYmICgoX2EyID0gc291cmNlW2kgKyAyXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5tYXRjaCgvW2Etel0vKSkpIHtcbiAgICAgICAgICAgIHBhdHRlcm4gKz0gc291cmNlW2ldO1xuICAgICAgICAgICAgaW5DaGFyUmFuZ2UgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXR0ZXJuICs9IGAke3NvdXJjZVtpXX0ke3NvdXJjZVtpXS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNvdXJjZVtpXS5tYXRjaCgvW2Etel0vKSkge1xuICAgICAgICBwYXR0ZXJuICs9IGBbJHtzb3VyY2VbaV19JHtzb3VyY2VbaV0udG9VcHBlckNhc2UoKX1dYDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmbGFncy5tKSB7XG4gICAgICBpZiAoc291cmNlW2ldID09PSBcIl5cIikge1xuICAgICAgICBwYXR0ZXJuICs9IGAoXnwoPzw9W1xcclxuXSkpYDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKHNvdXJjZVtpXSA9PT0gXCIkXCIpIHtcbiAgICAgICAgcGF0dGVybiArPSBgKCR8KD89W1xcclxuXSkpYDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmbGFncy5zICYmIHNvdXJjZVtpXSA9PT0gXCIuXCIpIHtcbiAgICAgIHBhdHRlcm4gKz0gaW5DaGFyR3JvdXAgPyBgJHtzb3VyY2VbaV19XFxyXG5gIDogYFske3NvdXJjZVtpXX1cXHJcbl1gO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHBhdHRlcm4gKz0gc291cmNlW2ldO1xuICAgIGlmIChzb3VyY2VbaV0gPT09IFwiXFxcXFwiKSB7XG4gICAgICBpc0VzY2FwZWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoaW5DaGFyR3JvdXAgJiYgc291cmNlW2ldID09PSBcIl1cIikge1xuICAgICAgaW5DaGFyR3JvdXAgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKCFpbkNoYXJHcm91cCAmJiBzb3VyY2VbaV0gPT09IFwiW1wiKSB7XG4gICAgICBpbkNoYXJHcm91cCA9IHRydWU7XG4gICAgfVxuICB9XG4gIHRyeSB7XG4gICAgbmV3IFJlZ0V4cChwYXR0ZXJuKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBDb3VsZCBub3QgY29udmVydCByZWdleCBwYXR0ZXJuIGF0ICR7cmVmcy5jdXJyZW50UGF0aC5qb2luKFxuICAgICAgICBcIi9cIlxuICAgICAgKX0gdG8gYSBmbGFnLWluZGVwZW5kZW50IGZvcm0hIEZhbGxpbmcgYmFjayB0byB0aGUgZmxhZy1pZ25vcmFudCBzb3VyY2VgXG4gICAgKTtcbiAgICByZXR1cm4gcmVnZXguc291cmNlO1xuICB9XG4gIHJldHVybiBwYXR0ZXJuO1xufVxuXG4vLyBzcmMvdG8tanNvbi1zY2hlbWEvem9kMy10by1qc29uLXNjaGVtYS9wYXJzZXJzL3JlY29yZC50c1xuZnVuY3Rpb24gcGFyc2VSZWNvcmREZWYoZGVmLCByZWZzKSB7XG4gIHZhciBfYTIsIF9iMiwgX2MsIF9kLCBfZSwgX2Y7XG4gIGNvbnN0IHNjaGVtYSA9IHtcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiAoX2EyID0gcGFyc2VEZWYoZGVmLnZhbHVlVHlwZS5fZGVmLCB7XG4gICAgICAuLi5yZWZzLFxuICAgICAgY3VycmVudFBhdGg6IFsuLi5yZWZzLmN1cnJlbnRQYXRoLCBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCJdXG4gICAgfSkpICE9IG51bGwgPyBfYTIgOiByZWZzLmFsbG93ZWRBZGRpdGlvbmFsUHJvcGVydGllc1xuICB9O1xuICBpZiAoKChfYjIgPSBkZWYua2V5VHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5fZGVmLnR5cGVOYW1lKSA9PT0gWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMi5ab2RTdHJpbmcgJiYgKChfYyA9IGRlZi5rZXlUeXBlLl9kZWYuY2hlY2tzKSA9PSBudWxsID8gdm9pZCAwIDogX2MubGVuZ3RoKSkge1xuICAgIGNvbnN0IHsgdHlwZSwgLi4ua2V5VHlwZSB9ID0gcGFyc2VTdHJpbmdEZWYoZGVmLmtleVR5cGUuX2RlZiwgcmVmcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnNjaGVtYSxcbiAgICAgIHByb3BlcnR5TmFtZXM6IGtleVR5cGVcbiAgICB9O1xuICB9IGVsc2UgaWYgKCgoX2QgPSBkZWYua2V5VHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLl9kZWYudHlwZU5hbWUpID09PSBab2RGaXJzdFBhcnR5VHlwZUtpbmQyLlpvZEVudW0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc2NoZW1hLFxuICAgICAgcHJvcGVydHlOYW1lczoge1xuICAgICAgICBlbnVtOiBkZWYua2V5VHlwZS5fZGVmLnZhbHVlc1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSBpZiAoKChfZSA9IGRlZi5rZXlUeXBlKSA9PSBudWxsID8gdm9pZCAwIDogX2UuX2RlZi50eXBlTmFtZSkgPT09IFpvZEZpcnN0UGFydHlUeXBlS2luZDIuWm9kQnJhbmRlZCAmJiBkZWYua2V5VHlwZS5fZGVmLnR5cGUuX2RlZi50eXBlTmFtZSA9PT0gWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMi5ab2RTdHJpbmcgJiYgKChfZiA9IGRlZi5rZXlUeXBlLl9kZWYudHlwZS5fZGVmLmNoZWNrcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLmxlbmd0aCkpIHtcbiAgICBjb25zdCB7IHR5cGUsIC4uLmtleVR5cGUgfSA9IHBhcnNlQnJhbmRlZERlZihcbiAgICAgIGRlZi5rZXlUeXBlLl9kZWYsXG4gICAgICByZWZzXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc2NoZW1hLFxuICAgICAgcHJvcGVydHlOYW1lczoga2V5VHlwZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHNjaGVtYTtcbn1cblxuLy8gc3JjL3RvLWpzb24tc2NoZW1hL3pvZDMtdG8tanNvbi1zY2hlbWEvcGFyc2Vycy9tYXAudHNcbmZ1bmN0aW9uIHBhcnNlTWFwRGVmKGRlZiwgcmVmcykge1xuICBpZiAocmVmcy5tYXBTdHJhdGVneSA9PT0gXCJyZWNvcmRcIikge1xuICAgIHJldHVybiBwYXJzZVJlY29yZERlZihkZWYsIHJlZnMpO1xuICB9XG4gIGNvbnN0IGtleXMgPSBwYXJzZURlZihkZWYua2V5VHlwZS5fZGVmLCB7XG4gICAgLi4ucmVmcyxcbiAgICBjdXJyZW50UGF0aDogWy4uLnJlZnMuY3VycmVudFBhdGgsIFwiaXRlbXNcIiwgXCJpdGVtc1wiLCBcIjBcIl1cbiAgfSkgfHwgcGFyc2VBbnlEZWYoKTtcbiAgY29uc3QgdmFsdWVzID0gcGFyc2VEZWYoZGVmLnZhbHVlVHlwZS5fZGVmLCB7XG4gICAgLi4ucmVmcyxcbiAgICBjdXJyZW50UGF0aDogWy4uLnJlZnMuY3VycmVudFBhdGgsIFwiaXRlbXNcIiwgXCJpdGVtc1wiLCBcIjFcIl1cbiAgfSkgfHwgcGFyc2VBbnlEZWYoKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgbWF4SXRlbXM6IDEyNSxcbiAgICBpdGVtczoge1xuICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgaXRlbXM6IFtrZXlzLCB2YWx1ZXNdLFxuICAgICAgbWluSXRlbXM6IDIsXG4gICAgICBtYXhJdGVtczogMlxuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3RvLWpzb24tc2NoZW1hL3pvZDMtdG8tanNvbi1zY2hlbWEvcGFyc2Vycy9uYXRpdmUtZW51bS50c1xuZnVuY3Rpb24gcGFyc2VOYXRpdmVFbnVtRGVmKGRlZikge1xuICBjb25zdCBvYmplY3QgPSBkZWYudmFsdWVzO1xuICBjb25zdCBhY3R1YWxLZXlzID0gT2JqZWN0LmtleXMoZGVmLnZhbHVlcykuZmlsdGVyKChrZXkpID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdFtvYmplY3Rba2V5XV0gIT09IFwibnVtYmVyXCI7XG4gIH0pO1xuICBjb25zdCBhY3R1YWxWYWx1ZXMgPSBhY3R1YWxLZXlzLm1hcCgoa2V5KSA9PiBvYmplY3Rba2V5XSk7XG4gIGNvbnN0IHBhcnNlZFR5cGVzID0gQXJyYXkuZnJvbShcbiAgICBuZXcgU2V0KGFjdHVhbFZhbHVlcy5tYXAoKHZhbHVlcykgPT4gdHlwZW9mIHZhbHVlcykpXG4gICk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogcGFyc2VkVHlwZXMubGVuZ3RoID09PSAxID8gcGFyc2VkVHlwZXNbMF0gPT09IFwic3RyaW5nXCIgPyBcInN0cmluZ1wiIDogXCJudW1iZXJcIiA6IFtcInN0cmluZ1wiLCBcIm51bWJlclwiXSxcbiAgICBlbnVtOiBhY3R1YWxWYWx1ZXNcbiAgfTtcbn1cblxuLy8gc3JjL3RvLWpzb24tc2NoZW1hL3pvZDMtdG8tanNvbi1zY2hlbWEvcGFyc2Vycy9uZXZlci50c1xuZnVuY3Rpb24gcGFyc2VOZXZlckRlZigpIHtcbiAgcmV0dXJuIHsgbm90OiBwYXJzZUFueURlZigpIH07XG59XG5cbi8vIHNyYy90by1qc29uLXNjaGVtYS96b2QzLXRvLWpzb24tc2NoZW1hL3BhcnNlcnMvbnVsbC50c1xuZnVuY3Rpb24gcGFyc2VOdWxsRGVmKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibnVsbFwiXG4gIH07XG59XG5cbi8vIHNyYy90by1qc29uLXNjaGVtYS96b2QzLXRvLWpzb24tc2NoZW1hL3BhcnNlcnMvdW5pb24udHNcbnZhciBwcmltaXRpdmVNYXBwaW5ncyA9IHtcbiAgWm9kU3RyaW5nOiBcInN0cmluZ1wiLFxuICBab2ROdW1iZXI6IFwibnVtYmVyXCIsXG4gIFpvZEJpZ0ludDogXCJpbnRlZ2VyXCIsXG4gIFpvZEJvb2xlYW46IFwiYm9vbGVhblwiLFxuICBab2ROdWxsOiBcIm51bGxcIlxufTtcbmZ1bmN0aW9uIHBhcnNlVW5pb25EZWYoZGVmLCByZWZzKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBkZWYub3B0aW9ucyBpbnN0YW5jZW9mIE1hcCA/IEFycmF5LmZyb20oZGVmLm9wdGlvbnMudmFsdWVzKCkpIDogZGVmLm9wdGlvbnM7XG4gIGlmIChvcHRpb25zLmV2ZXJ5KFxuICAgICh4KSA9PiB4Ll9kZWYudHlwZU5hbWUgaW4gcHJpbWl0aXZlTWFwcGluZ3MgJiYgKCF4Ll9kZWYuY2hlY2tzIHx8ICF4Ll9kZWYuY2hlY2tzLmxlbmd0aClcbiAgKSkge1xuICAgIGNvbnN0IHR5cGVzID0gb3B0aW9ucy5yZWR1Y2UoKHR5cGVzMiwgeCkgPT4ge1xuICAgICAgY29uc3QgdHlwZSA9IHByaW1pdGl2ZU1hcHBpbmdzW3guX2RlZi50eXBlTmFtZV07XG4gICAgICByZXR1cm4gdHlwZSAmJiAhdHlwZXMyLmluY2x1ZGVzKHR5cGUpID8gWy4uLnR5cGVzMiwgdHlwZV0gOiB0eXBlczI7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiB0eXBlcy5sZW5ndGggPiAxID8gdHlwZXMgOiB0eXBlc1swXVxuICAgIH07XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5ldmVyeSgoeCkgPT4geC5fZGVmLnR5cGVOYW1lID09PSBcIlpvZExpdGVyYWxcIiAmJiAheC5kZXNjcmlwdGlvbikpIHtcbiAgICBjb25zdCB0eXBlcyA9IG9wdGlvbnMucmVkdWNlKFxuICAgICAgKGFjYywgeCkgPT4ge1xuICAgICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHguX2RlZi52YWx1ZTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgcmV0dXJuIFsuLi5hY2MsIHR5cGVdO1xuICAgICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIHJldHVybiBbLi4uYWNjLCBcImludGVnZXJcIl07XG4gICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgaWYgKHguX2RlZi52YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIFsuLi5hY2MsIFwibnVsbFwiXTtcbiAgICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgW11cbiAgICApO1xuICAgIGlmICh0eXBlcy5sZW5ndGggPT09IG9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB1bmlxdWVUeXBlcyA9IHR5cGVzLmZpbHRlcigoeCwgaSwgYSkgPT4gYS5pbmRleE9mKHgpID09PSBpKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHVuaXF1ZVR5cGVzLmxlbmd0aCA+IDEgPyB1bmlxdWVUeXBlcyA6IHVuaXF1ZVR5cGVzWzBdLFxuICAgICAgICBlbnVtOiBvcHRpb25zLnJlZHVjZShcbiAgICAgICAgICAoYWNjLCB4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYWNjLmluY2x1ZGVzKHguX2RlZi52YWx1ZSkgPyBhY2MgOiBbLi4uYWNjLCB4Ll9kZWYudmFsdWVdO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgW11cbiAgICAgICAgKVxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5ldmVyeSgoeCkgPT4geC5fZGVmLnR5cGVOYW1lID09PSBcIlpvZEVudW1cIikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgIGVudW06IG9wdGlvbnMucmVkdWNlKFxuICAgICAgICAoYWNjLCB4KSA9PiBbXG4gICAgICAgICAgLi4uYWNjLFxuICAgICAgICAgIC4uLnguX2RlZi52YWx1ZXMuZmlsdGVyKCh4MikgPT4gIWFjYy5pbmNsdWRlcyh4MikpXG4gICAgICAgIF0sXG4gICAgICAgIFtdXG4gICAgICApXG4gICAgfTtcbiAgfVxuICByZXR1cm4gYXNBbnlPZihkZWYsIHJlZnMpO1xufVxudmFyIGFzQW55T2YgPSAoZGVmLCByZWZzKSA9PiB7XG4gIGNvbnN0IGFueU9mID0gKGRlZi5vcHRpb25zIGluc3RhbmNlb2YgTWFwID8gQXJyYXkuZnJvbShkZWYub3B0aW9ucy52YWx1ZXMoKSkgOiBkZWYub3B0aW9ucykubWFwKFxuICAgICh4LCBpKSA9PiBwYXJzZURlZih4Ll9kZWYsIHtcbiAgICAgIC4uLnJlZnMsXG4gICAgICBjdXJyZW50UGF0aDogWy4uLnJlZnMuY3VycmVudFBhdGgsIFwiYW55T2ZcIiwgYCR7aX1gXVxuICAgIH0pXG4gICkuZmlsdGVyKFxuICAgICh4KSA9PiAhIXggJiYgKCFyZWZzLnN0cmljdFVuaW9ucyB8fCB0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cyh4KS5sZW5ndGggPiAwKVxuICApO1xuICByZXR1cm4gYW55T2YubGVuZ3RoID8geyBhbnlPZiB9IDogdm9pZCAwO1xufTtcblxuLy8gc3JjL3RvLWpzb24tc2NoZW1hL3pvZDMtdG8tanNvbi1zY2hlbWEvcGFyc2Vycy9udWxsYWJsZS50c1xuZnVuY3Rpb24gcGFyc2VOdWxsYWJsZURlZihkZWYsIHJlZnMpIHtcbiAgaWYgKFtcIlpvZFN0cmluZ1wiLCBcIlpvZE51bWJlclwiLCBcIlpvZEJpZ0ludFwiLCBcIlpvZEJvb2xlYW5cIiwgXCJab2ROdWxsXCJdLmluY2x1ZGVzKFxuICAgIGRlZi5pbm5lclR5cGUuX2RlZi50eXBlTmFtZVxuICApICYmICghZGVmLmlubmVyVHlwZS5fZGVmLmNoZWNrcyB8fCAhZGVmLmlubmVyVHlwZS5fZGVmLmNoZWNrcy5sZW5ndGgpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFtcbiAgICAgICAgcHJpbWl0aXZlTWFwcGluZ3NbZGVmLmlubmVyVHlwZS5fZGVmLnR5cGVOYW1lXSxcbiAgICAgICAgXCJudWxsXCJcbiAgICAgIF1cbiAgICB9O1xuICB9XG4gIGNvbnN0IGJhc2UgPSBwYXJzZURlZihkZWYuaW5uZXJUeXBlLl9kZWYsIHtcbiAgICAuLi5yZWZzLFxuICAgIGN1cnJlbnRQYXRoOiBbLi4ucmVmcy5jdXJyZW50UGF0aCwgXCJhbnlPZlwiLCBcIjBcIl1cbiAgfSk7XG4gIHJldHVybiBiYXNlICYmIHsgYW55T2Y6IFtiYXNlLCB7IHR5cGU6IFwibnVsbFwiIH1dIH07XG59XG5cbi8vIHNyYy90by1qc29uLXNjaGVtYS96b2QzLXRvLWpzb24tc2NoZW1hL3BhcnNlcnMvbnVtYmVyLnRzXG5mdW5jdGlvbiBwYXJzZU51bWJlckRlZihkZWYpIHtcbiAgY29uc3QgcmVzID0ge1xuICAgIHR5cGU6IFwibnVtYmVyXCJcbiAgfTtcbiAgaWYgKCFkZWYuY2hlY2tzKSByZXR1cm4gcmVzO1xuICBmb3IgKGNvbnN0IGNoZWNrIG9mIGRlZi5jaGVja3MpIHtcbiAgICBzd2l0Y2ggKGNoZWNrLmtpbmQpIHtcbiAgICAgIGNhc2UgXCJpbnRcIjpcbiAgICAgICAgcmVzLnR5cGUgPSBcImludGVnZXJcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibWluXCI6XG4gICAgICAgIGlmIChjaGVjay5pbmNsdXNpdmUpIHtcbiAgICAgICAgICByZXMubWluaW11bSA9IGNoZWNrLnZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcy5leGNsdXNpdmVNaW5pbXVtID0gY2hlY2sudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibWF4XCI6XG4gICAgICAgIGlmIChjaGVjay5pbmNsdXNpdmUpIHtcbiAgICAgICAgICByZXMubWF4aW11bSA9IGNoZWNrLnZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcy5leGNsdXNpdmVNYXhpbXVtID0gY2hlY2sudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibXVsdGlwbGVPZlwiOlxuICAgICAgICByZXMubXVsdGlwbGVPZiA9IGNoZWNrLnZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3RvLWpzb24tc2NoZW1hL3pvZDMtdG8tanNvbi1zY2hlbWEvcGFyc2Vycy9vYmplY3QudHNcbmZ1bmN0aW9uIHBhcnNlT2JqZWN0RGVmKGRlZiwgcmVmcykge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBwcm9wZXJ0aWVzOiB7fVxuICB9O1xuICBjb25zdCByZXF1aXJlZCA9IFtdO1xuICBjb25zdCBzaGFwZSA9IGRlZi5zaGFwZSgpO1xuICBmb3IgKGNvbnN0IHByb3BOYW1lIGluIHNoYXBlKSB7XG4gICAgbGV0IHByb3BEZWYgPSBzaGFwZVtwcm9wTmFtZV07XG4gICAgaWYgKHByb3BEZWYgPT09IHZvaWQgMCB8fCBwcm9wRGVmLl9kZWYgPT09IHZvaWQgMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHByb3BPcHRpb25hbCA9IHNhZmVJc09wdGlvbmFsKHByb3BEZWYpO1xuICAgIGNvbnN0IHBhcnNlZERlZiA9IHBhcnNlRGVmKHByb3BEZWYuX2RlZiwge1xuICAgICAgLi4ucmVmcyxcbiAgICAgIGN1cnJlbnRQYXRoOiBbLi4ucmVmcy5jdXJyZW50UGF0aCwgXCJwcm9wZXJ0aWVzXCIsIHByb3BOYW1lXSxcbiAgICAgIHByb3BlcnR5UGF0aDogWy4uLnJlZnMuY3VycmVudFBhdGgsIFwicHJvcGVydGllc1wiLCBwcm9wTmFtZV1cbiAgICB9KTtcbiAgICBpZiAocGFyc2VkRGVmID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXN1bHQucHJvcGVydGllc1twcm9wTmFtZV0gPSBwYXJzZWREZWY7XG4gICAgaWYgKCFwcm9wT3B0aW9uYWwpIHtcbiAgICAgIHJlcXVpcmVkLnB1c2gocHJvcE5hbWUpO1xuICAgIH1cbiAgfVxuICBpZiAocmVxdWlyZWQubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnJlcXVpcmVkID0gcmVxdWlyZWQ7XG4gIH1cbiAgY29uc3QgYWRkaXRpb25hbFByb3BlcnRpZXMgPSBkZWNpZGVBZGRpdGlvbmFsUHJvcGVydGllcyhkZWYsIHJlZnMpO1xuICBpZiAoYWRkaXRpb25hbFByb3BlcnRpZXMgIT09IHZvaWQgMCkge1xuICAgIHJlc3VsdC5hZGRpdGlvbmFsUHJvcGVydGllcyA9IGFkZGl0aW9uYWxQcm9wZXJ0aWVzO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBkZWNpZGVBZGRpdGlvbmFsUHJvcGVydGllcyhkZWYsIHJlZnMpIHtcbiAgaWYgKGRlZi5jYXRjaGFsbC5fZGVmLnR5cGVOYW1lICE9PSBcIlpvZE5ldmVyXCIpIHtcbiAgICByZXR1cm4gcGFyc2VEZWYoZGVmLmNhdGNoYWxsLl9kZWYsIHtcbiAgICAgIC4uLnJlZnMsXG4gICAgICBjdXJyZW50UGF0aDogWy4uLnJlZnMuY3VycmVudFBhdGgsIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIl1cbiAgICB9KTtcbiAgfVxuICBzd2l0Y2ggKGRlZi51bmtub3duS2V5cykge1xuICAgIGNhc2UgXCJwYXNzdGhyb3VnaFwiOlxuICAgICAgcmV0dXJuIHJlZnMuYWxsb3dlZEFkZGl0aW9uYWxQcm9wZXJ0aWVzO1xuICAgIGNhc2UgXCJzdHJpY3RcIjpcbiAgICAgIHJldHVybiByZWZzLnJlamVjdGVkQWRkaXRpb25hbFByb3BlcnRpZXM7XG4gICAgY2FzZSBcInN0cmlwXCI6XG4gICAgICByZXR1cm4gcmVmcy5yZW1vdmVBZGRpdGlvbmFsU3RyYXRlZ3kgPT09IFwic3RyaWN0XCIgPyByZWZzLmFsbG93ZWRBZGRpdGlvbmFsUHJvcGVydGllcyA6IHJlZnMucmVqZWN0ZWRBZGRpdGlvbmFsUHJvcGVydGllcztcbiAgfVxufVxuZnVuY3Rpb24gc2FmZUlzT3B0aW9uYWwoc2NoZW1hKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHNjaGVtYS5pc09wdGlvbmFsKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vLyBzcmMvdG8tanNvbi1zY2hlbWEvem9kMy10by1qc29uLXNjaGVtYS9wYXJzZXJzL29wdGlvbmFsLnRzXG52YXIgcGFyc2VPcHRpb25hbERlZiA9IChkZWYsIHJlZnMpID0+IHtcbiAgdmFyIF9hMjtcbiAgaWYgKHJlZnMuY3VycmVudFBhdGgudG9TdHJpbmcoKSA9PT0gKChfYTIgPSByZWZzLnByb3BlcnR5UGF0aCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi50b1N0cmluZygpKSkge1xuICAgIHJldHVybiBwYXJzZURlZihkZWYuaW5uZXJUeXBlLl9kZWYsIHJlZnMpO1xuICB9XG4gIGNvbnN0IGlubmVyU2NoZW1hID0gcGFyc2VEZWYoZGVmLmlubmVyVHlwZS5fZGVmLCB7XG4gICAgLi4ucmVmcyxcbiAgICBjdXJyZW50UGF0aDogWy4uLnJlZnMuY3VycmVudFBhdGgsIFwiYW55T2ZcIiwgXCIxXCJdXG4gIH0pO1xuICByZXR1cm4gaW5uZXJTY2hlbWEgPyB7IGFueU9mOiBbeyBub3Q6IHBhcnNlQW55RGVmKCkgfSwgaW5uZXJTY2hlbWFdIH0gOiBwYXJzZUFueURlZigpO1xufTtcblxuLy8gc3JjL3RvLWpzb24tc2NoZW1hL3pvZDMtdG8tanNvbi1zY2hlbWEvcGFyc2Vycy9waXBlbGluZS50c1xudmFyIHBhcnNlUGlwZWxpbmVEZWYgPSAoZGVmLCByZWZzKSA9PiB7XG4gIGlmIChyZWZzLnBpcGVTdHJhdGVneSA9PT0gXCJpbnB1dFwiKSB7XG4gICAgcmV0dXJuIHBhcnNlRGVmKGRlZi5pbi5fZGVmLCByZWZzKTtcbiAgfSBlbHNlIGlmIChyZWZzLnBpcGVTdHJhdGVneSA9PT0gXCJvdXRwdXRcIikge1xuICAgIHJldHVybiBwYXJzZURlZihkZWYub3V0Ll9kZWYsIHJlZnMpO1xuICB9XG4gIGNvbnN0IGEgPSBwYXJzZURlZihkZWYuaW4uX2RlZiwge1xuICAgIC4uLnJlZnMsXG4gICAgY3VycmVudFBhdGg6IFsuLi5yZWZzLmN1cnJlbnRQYXRoLCBcImFsbE9mXCIsIFwiMFwiXVxuICB9KTtcbiAgY29uc3QgYiA9IHBhcnNlRGVmKGRlZi5vdXQuX2RlZiwge1xuICAgIC4uLnJlZnMsXG4gICAgY3VycmVudFBhdGg6IFsuLi5yZWZzLmN1cnJlbnRQYXRoLCBcImFsbE9mXCIsIGEgPyBcIjFcIiA6IFwiMFwiXVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBhbGxPZjogW2EsIGJdLmZpbHRlcigoeCkgPT4geCAhPT0gdm9pZCAwKVxuICB9O1xufTtcblxuLy8gc3JjL3RvLWpzb24tc2NoZW1hL3pvZDMtdG8tanNvbi1zY2hlbWEvcGFyc2Vycy9wcm9taXNlLnRzXG5mdW5jdGlvbiBwYXJzZVByb21pc2VEZWYoZGVmLCByZWZzKSB7XG4gIHJldHVybiBwYXJzZURlZihkZWYudHlwZS5fZGVmLCByZWZzKTtcbn1cblxuLy8gc3JjL3RvLWpzb24tc2NoZW1hL3pvZDMtdG8tanNvbi1zY2hlbWEvcGFyc2Vycy9zZXQudHNcbmZ1bmN0aW9uIHBhcnNlU2V0RGVmKGRlZiwgcmVmcykge1xuICBjb25zdCBpdGVtcyA9IHBhcnNlRGVmKGRlZi52YWx1ZVR5cGUuX2RlZiwge1xuICAgIC4uLnJlZnMsXG4gICAgY3VycmVudFBhdGg6IFsuLi5yZWZzLmN1cnJlbnRQYXRoLCBcIml0ZW1zXCJdXG4gIH0pO1xuICBjb25zdCBzY2hlbWEgPSB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHVuaXF1ZUl0ZW1zOiB0cnVlLFxuICAgIGl0ZW1zXG4gIH07XG4gIGlmIChkZWYubWluU2l6ZSkge1xuICAgIHNjaGVtYS5taW5JdGVtcyA9IGRlZi5taW5TaXplLnZhbHVlO1xuICB9XG4gIGlmIChkZWYubWF4U2l6ZSkge1xuICAgIHNjaGVtYS5tYXhJdGVtcyA9IGRlZi5tYXhTaXplLnZhbHVlO1xuICB9XG4gIHJldHVybiBzY2hlbWE7XG59XG5cbi8vIHNyYy90by1qc29uLXNjaGVtYS96b2QzLXRvLWpzb24tc2NoZW1hL3BhcnNlcnMvdHVwbGUudHNcbmZ1bmN0aW9uIHBhcnNlVHVwbGVEZWYoZGVmLCByZWZzKSB7XG4gIGlmIChkZWYucmVzdCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICBtaW5JdGVtczogZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgIGl0ZW1zOiBkZWYuaXRlbXMubWFwKFxuICAgICAgICAoeCwgaSkgPT4gcGFyc2VEZWYoeC5fZGVmLCB7XG4gICAgICAgICAgLi4ucmVmcyxcbiAgICAgICAgICBjdXJyZW50UGF0aDogWy4uLnJlZnMuY3VycmVudFBhdGgsIFwiaXRlbXNcIiwgYCR7aX1gXVxuICAgICAgICB9KVxuICAgICAgKS5yZWR1Y2UoXG4gICAgICAgIChhY2MsIHgpID0+IHggPT09IHZvaWQgMCA/IGFjYyA6IFsuLi5hY2MsIHhdLFxuICAgICAgICBbXVxuICAgICAgKSxcbiAgICAgIGFkZGl0aW9uYWxJdGVtczogcGFyc2VEZWYoZGVmLnJlc3QuX2RlZiwge1xuICAgICAgICAuLi5yZWZzLFxuICAgICAgICBjdXJyZW50UGF0aDogWy4uLnJlZnMuY3VycmVudFBhdGgsIFwiYWRkaXRpb25hbEl0ZW1zXCJdXG4gICAgICB9KVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgIG1pbkl0ZW1zOiBkZWYuaXRlbXMubGVuZ3RoLFxuICAgICAgbWF4SXRlbXM6IGRlZi5pdGVtcy5sZW5ndGgsXG4gICAgICBpdGVtczogZGVmLml0ZW1zLm1hcChcbiAgICAgICAgKHgsIGkpID0+IHBhcnNlRGVmKHguX2RlZiwge1xuICAgICAgICAgIC4uLnJlZnMsXG4gICAgICAgICAgY3VycmVudFBhdGg6IFsuLi5yZWZzLmN1cnJlbnRQYXRoLCBcIml0ZW1zXCIsIGAke2l9YF1cbiAgICAgICAgfSlcbiAgICAgICkucmVkdWNlKFxuICAgICAgICAoYWNjLCB4KSA9PiB4ID09PSB2b2lkIDAgPyBhY2MgOiBbLi4uYWNjLCB4XSxcbiAgICAgICAgW11cbiAgICAgIClcbiAgICB9O1xuICB9XG59XG5cbi8vIHNyYy90by1qc29uLXNjaGVtYS96b2QzLXRvLWpzb24tc2NoZW1hL3BhcnNlcnMvdW5kZWZpbmVkLnRzXG5mdW5jdGlvbiBwYXJzZVVuZGVmaW5lZERlZigpIHtcbiAgcmV0dXJuIHtcbiAgICBub3Q6IHBhcnNlQW55RGVmKClcbiAgfTtcbn1cblxuLy8gc3JjL3RvLWpzb24tc2NoZW1hL3pvZDMtdG8tanNvbi1zY2hlbWEvcGFyc2Vycy91bmtub3duLnRzXG5mdW5jdGlvbiBwYXJzZVVua25vd25EZWYoKSB7XG4gIHJldHVybiBwYXJzZUFueURlZigpO1xufVxuXG4vLyBzcmMvdG8tanNvbi1zY2hlbWEvem9kMy10by1qc29uLXNjaGVtYS9wYXJzZXJzL3JlYWRvbmx5LnRzXG52YXIgcGFyc2VSZWFkb25seURlZiA9IChkZWYsIHJlZnMpID0+IHtcbiAgcmV0dXJuIHBhcnNlRGVmKGRlZi5pbm5lclR5cGUuX2RlZiwgcmVmcyk7XG59O1xuXG4vLyBzcmMvdG8tanNvbi1zY2hlbWEvem9kMy10by1qc29uLXNjaGVtYS9zZWxlY3QtcGFyc2VyLnRzXG52YXIgc2VsZWN0UGFyc2VyID0gKGRlZiwgdHlwZU5hbWUsIHJlZnMpID0+IHtcbiAgc3dpdGNoICh0eXBlTmFtZSkge1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMy5ab2RTdHJpbmc6XG4gICAgICByZXR1cm4gcGFyc2VTdHJpbmdEZWYoZGVmLCByZWZzKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZDMuWm9kTnVtYmVyOlxuICAgICAgcmV0dXJuIHBhcnNlTnVtYmVyRGVmKGRlZik7XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQzLlpvZE9iamVjdDpcbiAgICAgIHJldHVybiBwYXJzZU9iamVjdERlZihkZWYsIHJlZnMpO1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMy5ab2RCaWdJbnQ6XG4gICAgICByZXR1cm4gcGFyc2VCaWdpbnREZWYoZGVmKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZDMuWm9kQm9vbGVhbjpcbiAgICAgIHJldHVybiBwYXJzZUJvb2xlYW5EZWYoKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZDMuWm9kRGF0ZTpcbiAgICAgIHJldHVybiBwYXJzZURhdGVEZWYoZGVmLCByZWZzKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZDMuWm9kVW5kZWZpbmVkOlxuICAgICAgcmV0dXJuIHBhcnNlVW5kZWZpbmVkRGVmKCk7XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQzLlpvZE51bGw6XG4gICAgICByZXR1cm4gcGFyc2VOdWxsRGVmKCk7XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQzLlpvZEFycmF5OlxuICAgICAgcmV0dXJuIHBhcnNlQXJyYXlEZWYoZGVmLCByZWZzKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZDMuWm9kVW5pb246XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQzLlpvZERpc2NyaW1pbmF0ZWRVbmlvbjpcbiAgICAgIHJldHVybiBwYXJzZVVuaW9uRGVmKGRlZiwgcmVmcyk7XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQzLlpvZEludGVyc2VjdGlvbjpcbiAgICAgIHJldHVybiBwYXJzZUludGVyc2VjdGlvbkRlZihkZWYsIHJlZnMpO1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMy5ab2RUdXBsZTpcbiAgICAgIHJldHVybiBwYXJzZVR1cGxlRGVmKGRlZiwgcmVmcyk7XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQzLlpvZFJlY29yZDpcbiAgICAgIHJldHVybiBwYXJzZVJlY29yZERlZihkZWYsIHJlZnMpO1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMy5ab2RMaXRlcmFsOlxuICAgICAgcmV0dXJuIHBhcnNlTGl0ZXJhbERlZihkZWYpO1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMy5ab2RFbnVtOlxuICAgICAgcmV0dXJuIHBhcnNlRW51bURlZihkZWYpO1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMy5ab2ROYXRpdmVFbnVtOlxuICAgICAgcmV0dXJuIHBhcnNlTmF0aXZlRW51bURlZihkZWYpO1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMy5ab2ROdWxsYWJsZTpcbiAgICAgIHJldHVybiBwYXJzZU51bGxhYmxlRGVmKGRlZiwgcmVmcyk7XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQzLlpvZE9wdGlvbmFsOlxuICAgICAgcmV0dXJuIHBhcnNlT3B0aW9uYWxEZWYoZGVmLCByZWZzKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZDMuWm9kTWFwOlxuICAgICAgcmV0dXJuIHBhcnNlTWFwRGVmKGRlZiwgcmVmcyk7XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQzLlpvZFNldDpcbiAgICAgIHJldHVybiBwYXJzZVNldERlZihkZWYsIHJlZnMpO1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMy5ab2RMYXp5OlxuICAgICAgcmV0dXJuICgpID0+IGRlZi5nZXR0ZXIoKS5fZGVmO1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMy5ab2RQcm9taXNlOlxuICAgICAgcmV0dXJuIHBhcnNlUHJvbWlzZURlZihkZWYsIHJlZnMpO1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMy5ab2ROYU46XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQzLlpvZE5ldmVyOlxuICAgICAgcmV0dXJuIHBhcnNlTmV2ZXJEZWYoKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZDMuWm9kRWZmZWN0czpcbiAgICAgIHJldHVybiBwYXJzZUVmZmVjdHNEZWYoZGVmLCByZWZzKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZDMuWm9kQW55OlxuICAgICAgcmV0dXJuIHBhcnNlQW55RGVmKCk7XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQzLlpvZFVua25vd246XG4gICAgICByZXR1cm4gcGFyc2VVbmtub3duRGVmKCk7XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQzLlpvZERlZmF1bHQ6XG4gICAgICByZXR1cm4gcGFyc2VEZWZhdWx0RGVmKGRlZiwgcmVmcyk7XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQzLlpvZEJyYW5kZWQ6XG4gICAgICByZXR1cm4gcGFyc2VCcmFuZGVkRGVmKGRlZiwgcmVmcyk7XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQzLlpvZFJlYWRvbmx5OlxuICAgICAgcmV0dXJuIHBhcnNlUmVhZG9ubHlEZWYoZGVmLCByZWZzKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZDMuWm9kQ2F0Y2g6XG4gICAgICByZXR1cm4gcGFyc2VDYXRjaERlZihkZWYsIHJlZnMpO1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMy5ab2RQaXBlbGluZTpcbiAgICAgIHJldHVybiBwYXJzZVBpcGVsaW5lRGVmKGRlZiwgcmVmcyk7XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQzLlpvZEZ1bmN0aW9uOlxuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMy5ab2RWb2lkOlxuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMy5ab2RTeW1ib2w6XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovICgoXykgPT4gdm9pZCAwKSh0eXBlTmFtZSk7XG4gIH1cbn07XG5cbi8vIHNyYy90by1qc29uLXNjaGVtYS96b2QzLXRvLWpzb24tc2NoZW1hL2dldC1yZWxhdGl2ZS1wYXRoLnRzXG52YXIgZ2V0UmVsYXRpdmVQYXRoID0gKHBhdGhBLCBwYXRoQikgPT4ge1xuICBsZXQgaSA9IDA7XG4gIGZvciAoOyBpIDwgcGF0aEEubGVuZ3RoICYmIGkgPCBwYXRoQi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwYXRoQVtpXSAhPT0gcGF0aEJbaV0pIGJyZWFrO1xuICB9XG4gIHJldHVybiBbKHBhdGhBLmxlbmd0aCAtIGkpLnRvU3RyaW5nKCksIC4uLnBhdGhCLnNsaWNlKGkpXS5qb2luKFwiL1wiKTtcbn07XG5cbi8vIHNyYy90by1qc29uLXNjaGVtYS96b2QzLXRvLWpzb24tc2NoZW1hL3BhcnNlLWRlZi50c1xuZnVuY3Rpb24gcGFyc2VEZWYoZGVmLCByZWZzLCBmb3JjZVJlc29sdXRpb24gPSBmYWxzZSkge1xuICB2YXIgX2EyO1xuICBjb25zdCBzZWVuSXRlbSA9IHJlZnMuc2Vlbi5nZXQoZGVmKTtcbiAgaWYgKHJlZnMub3ZlcnJpZGUpIHtcbiAgICBjb25zdCBvdmVycmlkZVJlc3VsdCA9IChfYTIgPSByZWZzLm92ZXJyaWRlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNhbGwoXG4gICAgICByZWZzLFxuICAgICAgZGVmLFxuICAgICAgcmVmcyxcbiAgICAgIHNlZW5JdGVtLFxuICAgICAgZm9yY2VSZXNvbHV0aW9uXG4gICAgKTtcbiAgICBpZiAob3ZlcnJpZGVSZXN1bHQgIT09IGlnbm9yZU92ZXJyaWRlKSB7XG4gICAgICByZXR1cm4gb3ZlcnJpZGVSZXN1bHQ7XG4gICAgfVxuICB9XG4gIGlmIChzZWVuSXRlbSAmJiAhZm9yY2VSZXNvbHV0aW9uKSB7XG4gICAgY29uc3Qgc2VlblNjaGVtYSA9IGdldCRyZWYoc2Vlbkl0ZW0sIHJlZnMpO1xuICAgIGlmIChzZWVuU2NoZW1hICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBzZWVuU2NoZW1hO1xuICAgIH1cbiAgfVxuICBjb25zdCBuZXdJdGVtID0geyBkZWYsIHBhdGg6IHJlZnMuY3VycmVudFBhdGgsIGpzb25TY2hlbWE6IHZvaWQgMCB9O1xuICByZWZzLnNlZW4uc2V0KGRlZiwgbmV3SXRlbSk7XG4gIGNvbnN0IGpzb25TY2hlbWFPckdldHRlciA9IHNlbGVjdFBhcnNlcihkZWYsIGRlZi50eXBlTmFtZSwgcmVmcyk7XG4gIGNvbnN0IGpzb25TY2hlbWEyID0gdHlwZW9mIGpzb25TY2hlbWFPckdldHRlciA9PT0gXCJmdW5jdGlvblwiID8gcGFyc2VEZWYoanNvblNjaGVtYU9yR2V0dGVyKCksIHJlZnMpIDoganNvblNjaGVtYU9yR2V0dGVyO1xuICBpZiAoanNvblNjaGVtYTIpIHtcbiAgICBhZGRNZXRhKGRlZiwgcmVmcywganNvblNjaGVtYTIpO1xuICB9XG4gIGlmIChyZWZzLnBvc3RQcm9jZXNzKSB7XG4gICAgY29uc3QgcG9zdFByb2Nlc3NSZXN1bHQgPSByZWZzLnBvc3RQcm9jZXNzKGpzb25TY2hlbWEyLCBkZWYsIHJlZnMpO1xuICAgIG5ld0l0ZW0uanNvblNjaGVtYSA9IGpzb25TY2hlbWEyO1xuICAgIHJldHVybiBwb3N0UHJvY2Vzc1Jlc3VsdDtcbiAgfVxuICBuZXdJdGVtLmpzb25TY2hlbWEgPSBqc29uU2NoZW1hMjtcbiAgcmV0dXJuIGpzb25TY2hlbWEyO1xufVxudmFyIGdldCRyZWYgPSAoaXRlbSwgcmVmcykgPT4ge1xuICBzd2l0Y2ggKHJlZnMuJHJlZlN0cmF0ZWd5KSB7XG4gICAgY2FzZSBcInJvb3RcIjpcbiAgICAgIHJldHVybiB7ICRyZWY6IGl0ZW0ucGF0aC5qb2luKFwiL1wiKSB9O1xuICAgIGNhc2UgXCJyZWxhdGl2ZVwiOlxuICAgICAgcmV0dXJuIHsgJHJlZjogZ2V0UmVsYXRpdmVQYXRoKHJlZnMuY3VycmVudFBhdGgsIGl0ZW0ucGF0aCkgfTtcbiAgICBjYXNlIFwibm9uZVwiOlxuICAgIGNhc2UgXCJzZWVuXCI6IHtcbiAgICAgIGlmIChpdGVtLnBhdGgubGVuZ3RoIDwgcmVmcy5jdXJyZW50UGF0aC5sZW5ndGggJiYgaXRlbS5wYXRoLmV2ZXJ5KCh2YWx1ZSwgaW5kZXgpID0+IHJlZnMuY3VycmVudFBhdGhbaW5kZXhdID09PSB2YWx1ZSkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBSZWN1cnNpdmUgcmVmZXJlbmNlIGRldGVjdGVkIGF0ICR7cmVmcy5jdXJyZW50UGF0aC5qb2luKFxuICAgICAgICAgICAgXCIvXCJcbiAgICAgICAgICApfSEgRGVmYXVsdGluZyB0byBhbnlgXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBwYXJzZUFueURlZigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlZnMuJHJlZlN0cmF0ZWd5ID09PSBcInNlZW5cIiA/IHBhcnNlQW55RGVmKCkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59O1xudmFyIGFkZE1ldGEgPSAoZGVmLCByZWZzLCBqc29uU2NoZW1hMikgPT4ge1xuICBpZiAoZGVmLmRlc2NyaXB0aW9uKSB7XG4gICAganNvblNjaGVtYTIuZGVzY3JpcHRpb24gPSBkZWYuZGVzY3JpcHRpb247XG4gIH1cbiAgcmV0dXJuIGpzb25TY2hlbWEyO1xufTtcblxuLy8gc3JjL3RvLWpzb24tc2NoZW1hL3pvZDMtdG8tanNvbi1zY2hlbWEvcmVmcy50c1xudmFyIGdldFJlZnMgPSAob3B0aW9ucykgPT4ge1xuICBjb25zdCBfb3B0aW9ucyA9IGdldERlZmF1bHRPcHRpb25zKG9wdGlvbnMpO1xuICBjb25zdCBjdXJyZW50UGF0aCA9IF9vcHRpb25zLm5hbWUgIT09IHZvaWQgMCA/IFsuLi5fb3B0aW9ucy5iYXNlUGF0aCwgX29wdGlvbnMuZGVmaW5pdGlvblBhdGgsIF9vcHRpb25zLm5hbWVdIDogX29wdGlvbnMuYmFzZVBhdGg7XG4gIHJldHVybiB7XG4gICAgLi4uX29wdGlvbnMsXG4gICAgY3VycmVudFBhdGgsXG4gICAgcHJvcGVydHlQYXRoOiB2b2lkIDAsXG4gICAgc2VlbjogbmV3IE1hcChcbiAgICAgIE9iamVjdC5lbnRyaWVzKF9vcHRpb25zLmRlZmluaXRpb25zKS5tYXAoKFtuYW1lMiwgZGVmXSkgPT4gW1xuICAgICAgICBkZWYuX2RlZixcbiAgICAgICAge1xuICAgICAgICAgIGRlZjogZGVmLl9kZWYsXG4gICAgICAgICAgcGF0aDogWy4uLl9vcHRpb25zLmJhc2VQYXRoLCBfb3B0aW9ucy5kZWZpbml0aW9uUGF0aCwgbmFtZTJdLFxuICAgICAgICAgIC8vIFJlc29sdXRpb24gb2YgcmVmZXJlbmNlcyB3aWxsIGJlIGZvcmNlZCBldmVuIHRob3VnaCBzZWVuLCBzbyBpdCdzIG9rIHRoYXQgdGhlIHNjaGVtYSBpcyB1bmRlZmluZWQgaGVyZSBmb3Igbm93LlxuICAgICAgICAgIGpzb25TY2hlbWE6IHZvaWQgMFxuICAgICAgICB9XG4gICAgICBdKVxuICAgIClcbiAgfTtcbn07XG5cbi8vIHNyYy90by1qc29uLXNjaGVtYS96b2QzLXRvLWpzb24tc2NoZW1hL3pvZDMtdG8tanNvbi1zY2hlbWEudHNcbnZhciB6b2QzVG9Kc29uU2NoZW1hID0gKHNjaGVtYSwgb3B0aW9ucykgPT4ge1xuICB2YXIgX2EyO1xuICBjb25zdCByZWZzID0gZ2V0UmVmcyhvcHRpb25zKTtcbiAgbGV0IGRlZmluaXRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5kZWZpbml0aW9ucyA/IE9iamVjdC5lbnRyaWVzKG9wdGlvbnMuZGVmaW5pdGlvbnMpLnJlZHVjZShcbiAgICAoYWNjLCBbbmFtZTMsIHNjaGVtYTJdKSA9PiB7XG4gICAgICB2YXIgX2EzO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYWNjLFxuICAgICAgICBbbmFtZTNdOiAoX2EzID0gcGFyc2VEZWYoXG4gICAgICAgICAgc2NoZW1hMi5fZGVmLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC4uLnJlZnMsXG4gICAgICAgICAgICBjdXJyZW50UGF0aDogWy4uLnJlZnMuYmFzZVBhdGgsIHJlZnMuZGVmaW5pdGlvblBhdGgsIG5hbWUzXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApKSAhPSBudWxsID8gX2EzIDogcGFyc2VBbnlEZWYoKVxuICAgICAgfTtcbiAgICB9LFxuICAgIHt9XG4gICkgOiB2b2lkIDA7XG4gIGNvbnN0IG5hbWUyID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgPyBvcHRpb25zIDogKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubmFtZVN0cmF0ZWd5KSA9PT0gXCJ0aXRsZVwiID8gdm9pZCAwIDogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5uYW1lO1xuICBjb25zdCBtYWluID0gKF9hMiA9IHBhcnNlRGVmKFxuICAgIHNjaGVtYS5fZGVmLFxuICAgIG5hbWUyID09PSB2b2lkIDAgPyByZWZzIDoge1xuICAgICAgLi4ucmVmcyxcbiAgICAgIGN1cnJlbnRQYXRoOiBbLi4ucmVmcy5iYXNlUGF0aCwgcmVmcy5kZWZpbml0aW9uUGF0aCwgbmFtZTJdXG4gICAgfSxcbiAgICBmYWxzZVxuICApKSAhPSBudWxsID8gX2EyIDogcGFyc2VBbnlEZWYoKTtcbiAgY29uc3QgdGl0bGUgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLm5hbWUgIT09IHZvaWQgMCAmJiBvcHRpb25zLm5hbWVTdHJhdGVneSA9PT0gXCJ0aXRsZVwiID8gb3B0aW9ucy5uYW1lIDogdm9pZCAwO1xuICBpZiAodGl0bGUgIT09IHZvaWQgMCkge1xuICAgIG1haW4udGl0bGUgPSB0aXRsZTtcbiAgfVxuICBjb25zdCBjb21iaW5lZCA9IG5hbWUyID09PSB2b2lkIDAgPyBkZWZpbml0aW9ucyA/IHtcbiAgICAuLi5tYWluLFxuICAgIFtyZWZzLmRlZmluaXRpb25QYXRoXTogZGVmaW5pdGlvbnNcbiAgfSA6IG1haW4gOiB7XG4gICAgJHJlZjogW1xuICAgICAgLi4ucmVmcy4kcmVmU3RyYXRlZ3kgPT09IFwicmVsYXRpdmVcIiA/IFtdIDogcmVmcy5iYXNlUGF0aCxcbiAgICAgIHJlZnMuZGVmaW5pdGlvblBhdGgsXG4gICAgICBuYW1lMlxuICAgIF0uam9pbihcIi9cIiksXG4gICAgW3JlZnMuZGVmaW5pdGlvblBhdGhdOiB7XG4gICAgICAuLi5kZWZpbml0aW9ucyxcbiAgICAgIFtuYW1lMl06IG1haW5cbiAgICB9XG4gIH07XG4gIGNvbWJpbmVkLiRzY2hlbWEgPSBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hI1wiO1xuICByZXR1cm4gY29tYmluZWQ7XG59O1xuXG4vLyBzcmMvc2NoZW1hLnRzXG52YXIgc2NoZW1hU3ltYm9sID0gU3ltYm9sLmZvcihcInZlcmNlbC5haS5zY2hlbWFcIik7XG5mdW5jdGlvbiBsYXp5U2NoZW1hKGNyZWF0ZVNjaGVtYSkge1xuICBsZXQgc2NoZW1hO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGlmIChzY2hlbWEgPT0gbnVsbCkge1xuICAgICAgc2NoZW1hID0gY3JlYXRlU2NoZW1hKCk7XG4gICAgfVxuICAgIHJldHVybiBzY2hlbWE7XG4gIH07XG59XG5mdW5jdGlvbiBqc29uU2NoZW1hKGpzb25TY2hlbWEyLCB7XG4gIHZhbGlkYXRlXG59ID0ge30pIHtcbiAgcmV0dXJuIHtcbiAgICBbc2NoZW1hU3ltYm9sXTogdHJ1ZSxcbiAgICBfdHlwZTogdm9pZCAwLFxuICAgIC8vIHNob3VsZCBuZXZlciBiZSB1c2VkIGRpcmVjdGx5XG4gICAgZ2V0IGpzb25TY2hlbWEoKSB7XG4gICAgICBpZiAodHlwZW9mIGpzb25TY2hlbWEyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAganNvblNjaGVtYTIgPSBqc29uU2NoZW1hMigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGpzb25TY2hlbWEyO1xuICAgIH0sXG4gICAgdmFsaWRhdGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzU2NoZW1hKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgc2NoZW1hU3ltYm9sIGluIHZhbHVlICYmIHZhbHVlW3NjaGVtYVN5bWJvbF0gPT09IHRydWUgJiYgXCJqc29uU2NoZW1hXCIgaW4gdmFsdWUgJiYgXCJ2YWxpZGF0ZVwiIGluIHZhbHVlO1xufVxuZnVuY3Rpb24gYXNTY2hlbWEoc2NoZW1hKSB7XG4gIHJldHVybiBzY2hlbWEgPT0gbnVsbCA/IGpzb25TY2hlbWEoeyBwcm9wZXJ0aWVzOiB7fSwgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlIH0pIDogaXNTY2hlbWEoc2NoZW1hKSA/IHNjaGVtYSA6IFwifnN0YW5kYXJkXCIgaW4gc2NoZW1hID8gc2NoZW1hW1wifnN0YW5kYXJkXCJdLnZlbmRvciA9PT0gXCJ6b2RcIiA/IHpvZFNjaGVtYShzY2hlbWEpIDogc3RhbmRhcmRTY2hlbWEoc2NoZW1hKSA6IHNjaGVtYSgpO1xufVxuZnVuY3Rpb24gc3RhbmRhcmRTY2hlbWEoc3RhbmRhcmRTY2hlbWEyKSB7XG4gIHJldHVybiBqc29uU2NoZW1hKFxuICAgICgpID0+IGFkZEFkZGl0aW9uYWxQcm9wZXJ0aWVzVG9Kc29uU2NoZW1hKFxuICAgICAgc3RhbmRhcmRTY2hlbWEyW1wifnN0YW5kYXJkXCJdLmpzb25TY2hlbWEuaW5wdXQoe1xuICAgICAgICB0YXJnZXQ6IFwiZHJhZnQtMDdcIlxuICAgICAgfSlcbiAgICApLFxuICAgIHtcbiAgICAgIHZhbGlkYXRlOiBhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3RhbmRhcmRTY2hlbWEyW1wifnN0YW5kYXJkXCJdLnZhbGlkYXRlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIFwidmFsdWVcIiBpbiByZXN1bHQgPyB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlOiByZXN1bHQudmFsdWUgfSA6IHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogcmVzdWx0Lmlzc3Vlc1xuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gem9kM1NjaGVtYSh6b2RTY2hlbWEyLCBvcHRpb25zKSB7XG4gIHZhciBfYTI7XG4gIGNvbnN0IHVzZVJlZmVyZW5jZXMgPSAoX2EyID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy51c2VSZWZlcmVuY2VzKSAhPSBudWxsID8gX2EyIDogZmFsc2U7XG4gIHJldHVybiBqc29uU2NoZW1hKFxuICAgIC8vIGRlZmVyIGpzb24gc2NoZW1hIGNyZWF0aW9uIHRvIGF2b2lkIHVubmVjZXNzYXJ5IGNvbXB1dGF0aW9uIHdoZW4gb25seSB2YWxpZGF0aW9uIGlzIG5lZWRlZFxuICAgICgpID0+IHpvZDNUb0pzb25TY2hlbWEoem9kU2NoZW1hMiwge1xuICAgICAgJHJlZlN0cmF0ZWd5OiB1c2VSZWZlcmVuY2VzID8gXCJyb290XCIgOiBcIm5vbmVcIlxuICAgIH0pLFxuICAgIHtcbiAgICAgIHZhbGlkYXRlOiBhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgem9kU2NoZW1hMi5zYWZlUGFyc2VBc3luYyh2YWx1ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQuc3VjY2VzcyA/IHsgc3VjY2VzczogdHJ1ZSwgdmFsdWU6IHJlc3VsdC5kYXRhIH0gOiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogcmVzdWx0LmVycm9yIH07XG4gICAgICB9XG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gem9kNFNjaGVtYSh6b2RTY2hlbWEyLCBvcHRpb25zKSB7XG4gIHZhciBfYTI7XG4gIGNvbnN0IHVzZVJlZmVyZW5jZXMgPSAoX2EyID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy51c2VSZWZlcmVuY2VzKSAhPSBudWxsID8gX2EyIDogZmFsc2U7XG4gIHJldHVybiBqc29uU2NoZW1hKFxuICAgIC8vIGRlZmVyIGpzb24gc2NoZW1hIGNyZWF0aW9uIHRvIGF2b2lkIHVubmVjZXNzYXJ5IGNvbXB1dGF0aW9uIHdoZW4gb25seSB2YWxpZGF0aW9uIGlzIG5lZWRlZFxuICAgICgpID0+IGFkZEFkZGl0aW9uYWxQcm9wZXJ0aWVzVG9Kc29uU2NoZW1hKFxuICAgICAgejQudG9KU09OU2NoZW1hKHpvZFNjaGVtYTIsIHtcbiAgICAgICAgdGFyZ2V0OiBcImRyYWZ0LTdcIixcbiAgICAgICAgaW86IFwiaW5wdXRcIixcbiAgICAgICAgcmV1c2VkOiB1c2VSZWZlcmVuY2VzID8gXCJyZWZcIiA6IFwiaW5saW5lXCJcbiAgICAgIH0pXG4gICAgKSxcbiAgICB7XG4gICAgICB2YWxpZGF0ZTogYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHo0LnNhZmVQYXJzZUFzeW5jKHpvZFNjaGVtYTIsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zdWNjZXNzID8geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogcmVzdWx0LmRhdGEgfSA6IHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiByZXN1bHQuZXJyb3IgfTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBpc1pvZDRTY2hlbWEoem9kU2NoZW1hMikge1xuICByZXR1cm4gXCJfem9kXCIgaW4gem9kU2NoZW1hMjtcbn1cbmZ1bmN0aW9uIHpvZFNjaGVtYSh6b2RTY2hlbWEyLCBvcHRpb25zKSB7XG4gIGlmIChpc1pvZDRTY2hlbWEoem9kU2NoZW1hMikpIHtcbiAgICByZXR1cm4gem9kNFNjaGVtYSh6b2RTY2hlbWEyLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gem9kM1NjaGVtYSh6b2RTY2hlbWEyLCBvcHRpb25zKTtcbiAgfVxufVxuXG4vLyBzcmMvdmFsaWRhdGUtdHlwZXMudHNcbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlVHlwZXMoe1xuICB2YWx1ZSxcbiAgc2NoZW1hLFxuICBjb250ZXh0XG59KSB7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNhZmVWYWxpZGF0ZVR5cGVzKHsgdmFsdWUsIHNjaGVtYSwgY29udGV4dCB9KTtcbiAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgIHRocm93IFR5cGVWYWxpZGF0aW9uRXJyb3IyLndyYXAoeyB2YWx1ZSwgY2F1c2U6IHJlc3VsdC5lcnJvciwgY29udGV4dCB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LnZhbHVlO1xufVxuYXN5bmMgZnVuY3Rpb24gc2FmZVZhbGlkYXRlVHlwZXMoe1xuICB2YWx1ZSxcbiAgc2NoZW1hLFxuICBjb250ZXh0XG59KSB7XG4gIGNvbnN0IGFjdHVhbFNjaGVtYSA9IGFzU2NoZW1hKHNjaGVtYSk7XG4gIHRyeSB7XG4gICAgaWYgKGFjdHVhbFNjaGVtYS52YWxpZGF0ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZSwgcmF3VmFsdWU6IHZhbHVlIH07XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFjdHVhbFNjaGVtYS52YWxpZGF0ZSh2YWx1ZSk7XG4gICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogcmVzdWx0LnZhbHVlLCByYXdWYWx1ZTogdmFsdWUgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IFR5cGVWYWxpZGF0aW9uRXJyb3IyLndyYXAoeyB2YWx1ZSwgY2F1c2U6IHJlc3VsdC5lcnJvciwgY29udGV4dCB9KSxcbiAgICAgIHJhd1ZhbHVlOiB2YWx1ZVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IFR5cGVWYWxpZGF0aW9uRXJyb3IyLndyYXAoeyB2YWx1ZSwgY2F1c2U6IGVycm9yLCBjb250ZXh0IH0pLFxuICAgICAgcmF3VmFsdWU6IHZhbHVlXG4gICAgfTtcbiAgfVxufVxuXG4vLyBzcmMvcGFyc2UtanNvbi50c1xuYXN5bmMgZnVuY3Rpb24gcGFyc2VKU09OKHtcbiAgdGV4dCxcbiAgc2NoZW1hXG59KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgdmFsdWUgPSBzZWN1cmVKc29uUGFyc2UodGV4dCk7XG4gICAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWxpZGF0ZVR5cGVzKHsgdmFsdWUsIHNjaGVtYSB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoSlNPTlBhcnNlRXJyb3IuaXNJbnN0YW5jZShlcnJvcikgfHwgVHlwZVZhbGlkYXRpb25FcnJvcjMuaXNJbnN0YW5jZShlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgSlNPTlBhcnNlRXJyb3IoeyB0ZXh0LCBjYXVzZTogZXJyb3IgfSk7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHNhZmVQYXJzZUpTT04oe1xuICB0ZXh0LFxuICBzY2hlbWFcbn0pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB2YWx1ZSA9IHNlY3VyZUpzb25QYXJzZSh0ZXh0KTtcbiAgICBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlLCByYXdWYWx1ZTogdmFsdWUgfTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHNhZmVWYWxpZGF0ZVR5cGVzKHsgdmFsdWUsIHNjaGVtYSB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogSlNPTlBhcnNlRXJyb3IuaXNJbnN0YW5jZShlcnJvcikgPyBlcnJvciA6IG5ldyBKU09OUGFyc2VFcnJvcih7IHRleHQsIGNhdXNlOiBlcnJvciB9KSxcbiAgICAgIHJhd1ZhbHVlOiB2b2lkIDBcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBpc1BhcnNhYmxlSnNvbihpbnB1dCkge1xuICB0cnkge1xuICAgIHNlY3VyZUpzb25QYXJzZShpbnB1dCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gc3JjL3BhcnNlLWpzb24tZXZlbnQtc3RyZWFtLnRzXG5pbXBvcnQge1xuICBFdmVudFNvdXJjZVBhcnNlclN0cmVhbVxufSBmcm9tIFwiZXZlbnRzb3VyY2UtcGFyc2VyL3N0cmVhbVwiO1xuZnVuY3Rpb24gcGFyc2VKc29uRXZlbnRTdHJlYW0oe1xuICBzdHJlYW0sXG4gIHNjaGVtYVxufSkge1xuICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RGVjb2RlclN0cmVhbSgpKS5waXBlVGhyb3VnaChuZXcgRXZlbnRTb3VyY2VQYXJzZXJTdHJlYW0oKSkucGlwZVRocm91Z2goXG4gICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICBhc3luYyB0cmFuc2Zvcm0oeyBkYXRhIH0sIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IFwiW0RPTkVdXCIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGF3YWl0IHNhZmVQYXJzZUpTT04oeyB0ZXh0OiBkYXRhLCBzY2hlbWEgfSkpO1xuICAgICAgfVxuICAgIH0pXG4gICk7XG59XG5cbi8vIHNyYy9wYXJzZS1wcm92aWRlci1vcHRpb25zLnRzXG5pbXBvcnQgeyBJbnZhbGlkQXJndW1lbnRFcnJvciBhcyBJbnZhbGlkQXJndW1lbnRFcnJvcjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuYXN5bmMgZnVuY3Rpb24gcGFyc2VQcm92aWRlck9wdGlvbnMoe1xuICBwcm92aWRlcixcbiAgcHJvdmlkZXJPcHRpb25zLFxuICBzY2hlbWFcbn0pIHtcbiAgaWYgKChwcm92aWRlck9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IHByb3ZpZGVyT3B0aW9uc1twcm92aWRlcl0pID09IG51bGwpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IHBhcnNlZFByb3ZpZGVyT3B0aW9ucyA9IGF3YWl0IHNhZmVWYWxpZGF0ZVR5cGVzKHtcbiAgICB2YWx1ZTogcHJvdmlkZXJPcHRpb25zW3Byb3ZpZGVyXSxcbiAgICBzY2hlbWFcbiAgfSk7XG4gIGlmICghcGFyc2VkUHJvdmlkZXJPcHRpb25zLnN1Y2Nlc3MpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IyKHtcbiAgICAgIGFyZ3VtZW50OiBcInByb3ZpZGVyT3B0aW9uc1wiLFxuICAgICAgbWVzc2FnZTogYGludmFsaWQgJHtwcm92aWRlcn0gcHJvdmlkZXIgb3B0aW9uc2AsXG4gICAgICBjYXVzZTogcGFyc2VkUHJvdmlkZXJPcHRpb25zLmVycm9yXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlZFByb3ZpZGVyT3B0aW9ucy52YWx1ZTtcbn1cblxuLy8gc3JjL3Bvc3QtdG8tYXBpLnRzXG5pbXBvcnQgeyBBUElDYWxsRXJyb3IgYXMgQVBJQ2FsbEVycm9yMyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgZ2V0T3JpZ2luYWxGZXRjaDIgPSAoKSA9PiBnbG9iYWxUaGlzLmZldGNoO1xudmFyIHBvc3RKc29uVG9BcGkgPSBhc3luYyAoe1xuICB1cmwsXG4gIGhlYWRlcnMsXG4gIGJvZHksXG4gIGZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcixcbiAgYWJvcnRTaWduYWwsXG4gIGZldGNoOiBmZXRjaDJcbn0pID0+IHBvc3RUb0FwaSh7XG4gIHVybCxcbiAgaGVhZGVyczoge1xuICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIC4uLmhlYWRlcnNcbiAgfSxcbiAgYm9keToge1xuICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgIHZhbHVlczogYm9keVxuICB9LFxuICBmYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXIsXG4gIGFib3J0U2lnbmFsLFxuICBmZXRjaDogZmV0Y2gyXG59KTtcbnZhciBwb3N0Rm9ybURhdGFUb0FwaSA9IGFzeW5jICh7XG4gIHVybCxcbiAgaGVhZGVycyxcbiAgZm9ybURhdGEsXG4gIGZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcixcbiAgYWJvcnRTaWduYWwsXG4gIGZldGNoOiBmZXRjaDJcbn0pID0+IHBvc3RUb0FwaSh7XG4gIHVybCxcbiAgaGVhZGVycyxcbiAgYm9keToge1xuICAgIGNvbnRlbnQ6IGZvcm1EYXRhLFxuICAgIHZhbHVlczogT2JqZWN0LmZyb21FbnRyaWVzKGZvcm1EYXRhLmVudHJpZXMoKSlcbiAgfSxcbiAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyLFxuICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyLFxuICBhYm9ydFNpZ25hbCxcbiAgZmV0Y2g6IGZldGNoMlxufSk7XG52YXIgcG9zdFRvQXBpID0gYXN5bmMgKHtcbiAgdXJsLFxuICBoZWFkZXJzID0ge30sXG4gIGJvZHksXG4gIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXIsXG4gIGZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgYWJvcnRTaWduYWwsXG4gIGZldGNoOiBmZXRjaDIgPSBnZXRPcmlnaW5hbEZldGNoMigpXG59KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaDIodXJsLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczogd2l0aFVzZXJBZ2VudFN1ZmZpeChcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgYGFpLXNkay9wcm92aWRlci11dGlscy8ke1ZFUlNJT059YCxcbiAgICAgICAgZ2V0UnVudGltZUVudmlyb25tZW50VXNlckFnZW50KClcbiAgICAgICksXG4gICAgICBib2R5OiBib2R5LmNvbnRlbnQsXG4gICAgICBzaWduYWw6IGFib3J0U2lnbmFsXG4gICAgfSk7XG4gICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgbGV0IGVycm9ySW5mb3JtYXRpb247XG4gICAgICB0cnkge1xuICAgICAgICBlcnJvckluZm9ybWF0aW9uID0gYXdhaXQgZmFpbGVkUmVzcG9uc2VIYW5kbGVyKHtcbiAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IGJvZHkudmFsdWVzXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikgfHwgQVBJQ2FsbEVycm9yMy5pc0luc3RhbmNlKGVycm9yKSkge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBBUElDYWxsRXJyb3IzKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byBwcm9jZXNzIGVycm9yIHJlc3BvbnNlXCIsXG4gICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9ySW5mb3JtYXRpb24udmFsdWU7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcih7XG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlc1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpIHx8IEFQSUNhbGxFcnJvcjMuaXNJbnN0YW5jZShlcnJvcikpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEFQSUNhbGxFcnJvcjMoe1xuICAgICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byBwcm9jZXNzIHN1Y2Nlc3NmdWwgcmVzcG9uc2VcIixcbiAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICByZXF1ZXN0Qm9keVZhbHVlczogYm9keS52YWx1ZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVGZXRjaEVycm9yKHsgZXJyb3IsIHVybCwgcmVxdWVzdEJvZHlWYWx1ZXM6IGJvZHkudmFsdWVzIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvdHlwZXMvdG9vbC50c1xuZnVuY3Rpb24gdG9vbCh0b29sMikge1xuICByZXR1cm4gdG9vbDI7XG59XG5mdW5jdGlvbiBkeW5hbWljVG9vbCh0b29sMikge1xuICByZXR1cm4geyAuLi50b29sMiwgdHlwZTogXCJkeW5hbWljXCIgfTtcbn1cblxuLy8gc3JjL3Byb3ZpZGVyLXRvb2wtZmFjdG9yeS50c1xuZnVuY3Rpb24gY3JlYXRlUHJvdmlkZXJUb29sRmFjdG9yeSh7XG4gIGlkLFxuICBpbnB1dFNjaGVtYVxufSkge1xuICByZXR1cm4gKHtcbiAgICBleGVjdXRlLFxuICAgIG91dHB1dFNjaGVtYSxcbiAgICBuZWVkc0FwcHJvdmFsLFxuICAgIHRvTW9kZWxPdXRwdXQsXG4gICAgb25JbnB1dFN0YXJ0LFxuICAgIG9uSW5wdXREZWx0YSxcbiAgICBvbklucHV0QXZhaWxhYmxlLFxuICAgIC4uLmFyZ3NcbiAgfSkgPT4gdG9vbCh7XG4gICAgdHlwZTogXCJwcm92aWRlclwiLFxuICAgIGlkLFxuICAgIGFyZ3MsXG4gICAgaW5wdXRTY2hlbWEsXG4gICAgb3V0cHV0U2NoZW1hLFxuICAgIGV4ZWN1dGUsXG4gICAgbmVlZHNBcHByb3ZhbCxcbiAgICB0b01vZGVsT3V0cHV0LFxuICAgIG9uSW5wdXRTdGFydCxcbiAgICBvbklucHV0RGVsdGEsXG4gICAgb25JbnB1dEF2YWlsYWJsZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb3ZpZGVyVG9vbEZhY3RvcnlXaXRoT3V0cHV0U2NoZW1hKHtcbiAgaWQsXG4gIGlucHV0U2NoZW1hLFxuICBvdXRwdXRTY2hlbWEsXG4gIHN1cHBvcnRzRGVmZXJyZWRSZXN1bHRzXG59KSB7XG4gIHJldHVybiAoe1xuICAgIGV4ZWN1dGUsXG4gICAgbmVlZHNBcHByb3ZhbCxcbiAgICB0b01vZGVsT3V0cHV0LFxuICAgIG9uSW5wdXRTdGFydCxcbiAgICBvbklucHV0RGVsdGEsXG4gICAgb25JbnB1dEF2YWlsYWJsZSxcbiAgICAuLi5hcmdzXG4gIH0pID0+IHRvb2woe1xuICAgIHR5cGU6IFwicHJvdmlkZXJcIixcbiAgICBpZCxcbiAgICBhcmdzLFxuICAgIGlucHV0U2NoZW1hLFxuICAgIG91dHB1dFNjaGVtYSxcbiAgICBleGVjdXRlLFxuICAgIG5lZWRzQXBwcm92YWwsXG4gICAgdG9Nb2RlbE91dHB1dCxcbiAgICBvbklucHV0U3RhcnQsXG4gICAgb25JbnB1dERlbHRhLFxuICAgIG9uSW5wdXRBdmFpbGFibGUsXG4gICAgc3VwcG9ydHNEZWZlcnJlZFJlc3VsdHNcbiAgfSk7XG59XG5cbi8vIHNyYy9yZW1vdmUtdW5kZWZpbmVkLWVudHJpZXMudHNcbmZ1bmN0aW9uIHJlbW92ZVVuZGVmaW5lZEVudHJpZXMocmVjb3JkKSB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMocmVjb3JkKS5maWx0ZXIoKFtfa2V5LCB2YWx1ZV0pID0+IHZhbHVlICE9IG51bGwpXG4gICk7XG59XG5cbi8vIHNyYy9yZXNvbHZlLnRzXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgfVxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKTtcbn1cblxuLy8gc3JjL3Jlc3BvbnNlLWhhbmRsZXIudHNcbmltcG9ydCB7IEFQSUNhbGxFcnJvciBhcyBBUElDYWxsRXJyb3I0LCBFbXB0eVJlc3BvbnNlQm9keUVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBjcmVhdGVKc29uRXJyb3JSZXNwb25zZUhhbmRsZXIgPSAoe1xuICBlcnJvclNjaGVtYSxcbiAgZXJyb3JUb01lc3NhZ2UsXG4gIGlzUmV0cnlhYmxlXG59KSA9PiBhc3luYyAoeyByZXNwb25zZSwgdXJsLCByZXF1ZXN0Qm9keVZhbHVlcyB9KSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gIGlmIChyZXNwb25zZUJvZHkudHJpbSgpID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIHZhbHVlOiBuZXcgQVBJQ2FsbEVycm9yNCh7XG4gICAgICAgIG1lc3NhZ2U6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICByZXNwb25zZUJvZHksXG4gICAgICAgIGlzUmV0cnlhYmxlOiBpc1JldHJ5YWJsZSA9PSBudWxsID8gdm9pZCAwIDogaXNSZXRyeWFibGUocmVzcG9uc2UpXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBwYXJzZWRFcnJvciA9IGF3YWl0IHBhcnNlSlNPTih7XG4gICAgICB0ZXh0OiByZXNwb25zZUJvZHksXG4gICAgICBzY2hlbWE6IGVycm9yU2NoZW1hXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIHZhbHVlOiBuZXcgQVBJQ2FsbEVycm9yNCh7XG4gICAgICAgIG1lc3NhZ2U6IGVycm9yVG9NZXNzYWdlKHBhcnNlZEVycm9yKSxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIHJlc3BvbnNlQm9keSxcbiAgICAgICAgZGF0YTogcGFyc2VkRXJyb3IsXG4gICAgICAgIGlzUmV0cnlhYmxlOiBpc1JldHJ5YWJsZSA9PSBudWxsID8gdm9pZCAwIDogaXNSZXRyeWFibGUocmVzcG9uc2UsIHBhcnNlZEVycm9yKVxuICAgICAgfSlcbiAgICB9O1xuICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIHZhbHVlOiBuZXcgQVBJQ2FsbEVycm9yNCh7XG4gICAgICAgIG1lc3NhZ2U6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICByZXNwb25zZUJvZHksXG4gICAgICAgIGlzUmV0cnlhYmxlOiBpc1JldHJ5YWJsZSA9PSBudWxsID8gdm9pZCAwIDogaXNSZXRyeWFibGUocmVzcG9uc2UpXG4gICAgICB9KVxuICAgIH07XG4gIH1cbn07XG52YXIgY3JlYXRlRXZlbnRTb3VyY2VSZXNwb25zZUhhbmRsZXIgPSAoY2h1bmtTY2hlbWEpID0+IGFzeW5jICh7IHJlc3BvbnNlIH0pID0+IHtcbiAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gIGlmIChyZXNwb25zZS5ib2R5ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRW1wdHlSZXNwb25zZUJvZHlFcnJvcih7fSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgdmFsdWU6IHBhcnNlSnNvbkV2ZW50U3RyZWFtKHtcbiAgICAgIHN0cmVhbTogcmVzcG9uc2UuYm9keSxcbiAgICAgIHNjaGVtYTogY2h1bmtTY2hlbWFcbiAgICB9KVxuICB9O1xufTtcbnZhciBjcmVhdGVKc29uUmVzcG9uc2VIYW5kbGVyID0gKHJlc3BvbnNlU2NoZW1hKSA9PiBhc3luYyAoeyByZXNwb25zZSwgdXJsLCByZXF1ZXN0Qm9keVZhbHVlcyB9KSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgY29uc3QgcGFyc2VkUmVzdWx0ID0gYXdhaXQgc2FmZVBhcnNlSlNPTih7XG4gICAgdGV4dDogcmVzcG9uc2VCb2R5LFxuICAgIHNjaGVtYTogcmVzcG9uc2VTY2hlbWFcbiAgfSk7XG4gIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICBpZiAoIXBhcnNlZFJlc3VsdC5zdWNjZXNzKSB7XG4gICAgdGhyb3cgbmV3IEFQSUNhbGxFcnJvcjQoe1xuICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIEpTT04gcmVzcG9uc2VcIixcbiAgICAgIGNhdXNlOiBwYXJzZWRSZXN1bHQuZXJyb3IsXG4gICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICByZXNwb25zZUJvZHksXG4gICAgICB1cmwsXG4gICAgICByZXF1ZXN0Qm9keVZhbHVlc1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgIHZhbHVlOiBwYXJzZWRSZXN1bHQudmFsdWUsXG4gICAgcmF3VmFsdWU6IHBhcnNlZFJlc3VsdC5yYXdWYWx1ZVxuICB9O1xufTtcbnZhciBjcmVhdGVCaW5hcnlSZXNwb25zZUhhbmRsZXIgPSAoKSA9PiBhc3luYyAoeyByZXNwb25zZSwgdXJsLCByZXF1ZXN0Qm9keVZhbHVlcyB9KSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICB0aHJvdyBuZXcgQVBJQ2FsbEVycm9yNCh7XG4gICAgICBtZXNzYWdlOiBcIlJlc3BvbnNlIGJvZHkgaXMgZW1wdHlcIixcbiAgICAgIHVybCxcbiAgICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgcmVzcG9uc2VCb2R5OiB2b2lkIDBcbiAgICB9KTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIHZhbHVlOiBuZXcgVWludDhBcnJheShidWZmZXIpXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgQVBJQ2FsbEVycm9yNCh7XG4gICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byByZWFkIHJlc3BvbnNlIGFzIGFycmF5IGJ1ZmZlclwiLFxuICAgICAgdXJsLFxuICAgICAgcmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICByZXNwb25zZUJvZHk6IHZvaWQgMCxcbiAgICAgIGNhdXNlOiBlcnJvclxuICAgIH0pO1xuICB9XG59O1xudmFyIGNyZWF0ZVN0YXR1c0NvZGVFcnJvclJlc3BvbnNlSGFuZGxlciA9ICgpID0+IGFzeW5jICh7IHJlc3BvbnNlLCB1cmwsIHJlcXVlc3RCb2R5VmFsdWVzIH0pID0+IHtcbiAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgcmV0dXJuIHtcbiAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgdmFsdWU6IG5ldyBBUElDYWxsRXJyb3I0KHtcbiAgICAgIG1lc3NhZ2U6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICB1cmwsXG4gICAgICByZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIHJlc3BvbnNlQm9keVxuICAgIH0pXG4gIH07XG59O1xuXG4vLyBzcmMvd2l0aG91dC10cmFpbGluZy1zbGFzaC50c1xuZnVuY3Rpb24gd2l0aG91dFRyYWlsaW5nU2xhc2godXJsKSB7XG4gIHJldHVybiB1cmwgPT0gbnVsbCA/IHZvaWQgMCA6IHVybC5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG59XG5cbi8vIHNyYy9pcy1hc3luYy1pdGVyYWJsZS50c1xuZnVuY3Rpb24gaXNBc3luY0l0ZXJhYmxlKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9ialtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuLy8gc3JjL3R5cGVzL2V4ZWN1dGUtdG9vbC50c1xuYXN5bmMgZnVuY3Rpb24qIGV4ZWN1dGVUb29sKHtcbiAgZXhlY3V0ZSxcbiAgaW5wdXQsXG4gIG9wdGlvbnNcbn0pIHtcbiAgY29uc3QgcmVzdWx0ID0gZXhlY3V0ZShpbnB1dCwgb3B0aW9ucyk7XG4gIGlmIChpc0FzeW5jSXRlcmFibGUocmVzdWx0KSkge1xuICAgIGxldCBsYXN0T3V0cHV0O1xuICAgIGZvciBhd2FpdCAoY29uc3Qgb3V0cHV0IG9mIHJlc3VsdCkge1xuICAgICAgbGFzdE91dHB1dCA9IG91dHB1dDtcbiAgICAgIHlpZWxkIHsgdHlwZTogXCJwcmVsaW1pbmFyeVwiLCBvdXRwdXQgfTtcbiAgICB9XG4gICAgeWllbGQgeyB0eXBlOiBcImZpbmFsXCIsIG91dHB1dDogbGFzdE91dHB1dCB9O1xuICB9IGVsc2Uge1xuICAgIHlpZWxkIHsgdHlwZTogXCJmaW5hbFwiLCBvdXRwdXQ6IGF3YWl0IHJlc3VsdCB9O1xuICB9XG59XG5cbi8vIHNyYy9pbmRleC50c1xuaW1wb3J0IHtcbiAgRXZlbnRTb3VyY2VQYXJzZXJTdHJlYW0gYXMgRXZlbnRTb3VyY2VQYXJzZXJTdHJlYW0yXG59IGZyb20gXCJldmVudHNvdXJjZS1wYXJzZXIvc3RyZWFtXCI7XG5leHBvcnQge1xuICBERUZBVUxUX01BWF9ET1dOTE9BRF9TSVpFLFxuICBEZWxheWVkUHJvbWlzZSxcbiAgRG93bmxvYWRFcnJvcixcbiAgRXZlbnRTb3VyY2VQYXJzZXJTdHJlYW0yIGFzIEV2ZW50U291cmNlUGFyc2VyU3RyZWFtLFxuICBWRVJTSU9OLFxuICBhc1NjaGVtYSxcbiAgY29tYmluZUhlYWRlcnMsXG4gIGNvbnZlcnRBc3luY0l0ZXJhdG9yVG9SZWFkYWJsZVN0cmVhbSxcbiAgY29udmVydEJhc2U2NFRvVWludDhBcnJheSxcbiAgY29udmVydEltYWdlTW9kZWxGaWxlVG9EYXRhVXJpLFxuICBjb252ZXJ0VG9CYXNlNjQsXG4gIGNvbnZlcnRUb0Zvcm1EYXRhLFxuICBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0LFxuICBjcmVhdGVCaW5hcnlSZXNwb25zZUhhbmRsZXIsXG4gIGNyZWF0ZUV2ZW50U291cmNlUmVzcG9uc2VIYW5kbGVyLFxuICBjcmVhdGVJZEdlbmVyYXRvcixcbiAgY3JlYXRlSnNvbkVycm9yUmVzcG9uc2VIYW5kbGVyLFxuICBjcmVhdGVKc29uUmVzcG9uc2VIYW5kbGVyLFxuICBjcmVhdGVQcm92aWRlclRvb2xGYWN0b3J5LFxuICBjcmVhdGVQcm92aWRlclRvb2xGYWN0b3J5V2l0aE91dHB1dFNjaGVtYSxcbiAgY3JlYXRlU3RhdHVzQ29kZUVycm9yUmVzcG9uc2VIYW5kbGVyLFxuICBjcmVhdGVUb29sTmFtZU1hcHBpbmcsXG4gIGRlbGF5LFxuICBkb3dubG9hZEJsb2IsXG4gIGR5bmFtaWNUb29sLFxuICBleGVjdXRlVG9vbCxcbiAgZXh0cmFjdFJlc3BvbnNlSGVhZGVycyxcbiAgZ2VuZXJhdGVJZCxcbiAgZ2V0RXJyb3JNZXNzYWdlLFxuICBnZXRGcm9tQXBpLFxuICBnZXRSdW50aW1lRW52aXJvbm1lbnRVc2VyQWdlbnQsXG4gIGluamVjdEpzb25JbnN0cnVjdGlvbkludG9NZXNzYWdlcyxcbiAgaXNBYm9ydEVycm9yLFxuICBpc05vbk51bGxhYmxlLFxuICBpc1BhcnNhYmxlSnNvbixcbiAgaXNVcmxTdXBwb3J0ZWQsXG4gIGpzb25TY2hlbWEsXG4gIGxhenlTY2hlbWEsXG4gIGxvYWRBcGlLZXksXG4gIGxvYWRPcHRpb25hbFNldHRpbmcsXG4gIGxvYWRTZXR0aW5nLFxuICBtZWRpYVR5cGVUb0V4dGVuc2lvbixcbiAgbm9ybWFsaXplSGVhZGVycyxcbiAgcGFyc2VKU09OLFxuICBwYXJzZUpzb25FdmVudFN0cmVhbSxcbiAgcGFyc2VQcm92aWRlck9wdGlvbnMsXG4gIHBvc3RGb3JtRGF0YVRvQXBpLFxuICBwb3N0SnNvblRvQXBpLFxuICBwb3N0VG9BcGksXG4gIHJlYWRSZXNwb25zZVdpdGhTaXplTGltaXQsXG4gIHJlbW92ZVVuZGVmaW5lZEVudHJpZXMsXG4gIHJlc29sdmUsXG4gIHNhZmVQYXJzZUpTT04sXG4gIHNhZmVWYWxpZGF0ZVR5cGVzLFxuICB0b29sLFxuICB2YWxpZGF0ZVR5cGVzLFxuICB3aXRoVXNlckFnZW50U3VmZml4LFxuICB3aXRob3V0VHJhaWxpbmdTbGFzaCxcbiAgem9kU2NoZW1hXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ai-sdk/gateway/node_modules/@ai-sdk/provider/dist/index.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/@ai-sdk/gateway/node_modules/@ai-sdk/provider/dist/index.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISDKError: () => (/* binding */ AISDKError),\n/* harmony export */   APICallError: () => (/* binding */ APICallError),\n/* harmony export */   EmptyResponseBodyError: () => (/* binding */ EmptyResponseBodyError),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidPromptError: () => (/* binding */ InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* binding */ InvalidResponseDataError),\n/* harmony export */   JSONParseError: () => (/* binding */ JSONParseError),\n/* harmony export */   LoadAPIKeyError: () => (/* binding */ LoadAPIKeyError),\n/* harmony export */   LoadSettingError: () => (/* binding */ LoadSettingError),\n/* harmony export */   NoContentGeneratedError: () => (/* binding */ NoContentGeneratedError),\n/* harmony export */   NoSuchModelError: () => (/* binding */ NoSuchModelError),\n/* harmony export */   TooManyEmbeddingValuesForCallError: () => (/* binding */ TooManyEmbeddingValuesForCallError),\n/* harmony export */   TypeValidationError: () => (/* binding */ TypeValidationError),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* binding */ UnsupportedFunctionalityError),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   isJSONArray: () => (/* binding */ isJSONArray),\n/* harmony export */   isJSONObject: () => (/* binding */ isJSONObject),\n/* harmony export */   isJSONValue: () => (/* binding */ isJSONValue)\n/* harmony export */ });\n// src/errors/ai-sdk-error.ts\nvar marker = \"vercel.ai.error\";\nvar symbol = Symbol.for(marker);\nvar _a, _b;\nvar AISDKError = class _AISDKError extends (_b = Error, _a = symbol, _b) {\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name: name14,\n    message,\n    cause\n  }) {\n    super(message);\n    this[_a] = true;\n    this.name = name14;\n    this.cause = cause;\n  }\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error) {\n    return _AISDKError.hasMarker(error, marker);\n  }\n  static hasMarker(error, marker15) {\n    const markerSymbol = Symbol.for(marker15);\n    return error != null && typeof error === \"object\" && markerSymbol in error && typeof error[markerSymbol] === \"boolean\" && error[markerSymbol] === true;\n  }\n};\n\n// src/errors/api-call-error.ts\nvar name = \"AI_APICallError\";\nvar marker2 = `vercel.ai.error.${name}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2, _b2;\nvar APICallError = class extends (_b2 = AISDKError, _a2 = symbol2, _b2) {\n  constructor({\n    message,\n    url,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null && (statusCode === 408 || // request timeout\n    statusCode === 409 || // conflict\n    statusCode === 429 || // too many requests\n    statusCode >= 500),\n    // server error\n    data\n  }) {\n    super({ name, message, cause });\n    this[_a2] = true;\n    this.url = url;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker2);\n  }\n};\n\n// src/errors/empty-response-body-error.ts\nvar name2 = \"AI_EmptyResponseBodyError\";\nvar marker3 = `vercel.ai.error.${name2}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3, _b3;\nvar EmptyResponseBodyError = class extends (_b3 = AISDKError, _a3 = symbol3, _b3) {\n  // used in isInstance\n  constructor({ message = \"Empty response body\" } = {}) {\n    super({ name: name2, message });\n    this[_a3] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker3);\n  }\n};\n\n// src/errors/get-error-message.ts\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\n\n// src/errors/invalid-argument-error.ts\nvar name3 = \"AI_InvalidArgumentError\";\nvar marker4 = `vercel.ai.error.${name3}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4, _b4;\nvar InvalidArgumentError = class extends (_b4 = AISDKError, _a4 = symbol4, _b4) {\n  constructor({\n    message,\n    cause,\n    argument\n  }) {\n    super({ name: name3, message, cause });\n    this[_a4] = true;\n    this.argument = argument;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker4);\n  }\n};\n\n// src/errors/invalid-prompt-error.ts\nvar name4 = \"AI_InvalidPromptError\";\nvar marker5 = `vercel.ai.error.${name4}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5, _b5;\nvar InvalidPromptError = class extends (_b5 = AISDKError, _a5 = symbol5, _b5) {\n  constructor({\n    prompt,\n    message,\n    cause\n  }) {\n    super({ name: name4, message: `Invalid prompt: ${message}`, cause });\n    this[_a5] = true;\n    this.prompt = prompt;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker5);\n  }\n};\n\n// src/errors/invalid-response-data-error.ts\nvar name5 = \"AI_InvalidResponseDataError\";\nvar marker6 = `vercel.ai.error.${name5}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6, _b6;\nvar InvalidResponseDataError = class extends (_b6 = AISDKError, _a6 = symbol6, _b6) {\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`\n  }) {\n    super({ name: name5, message });\n    this[_a6] = true;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker6);\n  }\n};\n\n// src/errors/json-parse-error.ts\nvar name6 = \"AI_JSONParseError\";\nvar marker7 = `vercel.ai.error.${name6}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7, _b7;\nvar JSONParseError = class extends (_b7 = AISDKError, _a7 = symbol7, _b7) {\n  constructor({ text, cause }) {\n    super({\n      name: name6,\n      message: `JSON parsing failed: Text: ${text}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a7] = true;\n    this.text = text;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker7);\n  }\n};\n\n// src/errors/load-api-key-error.ts\nvar name7 = \"AI_LoadAPIKeyError\";\nvar marker8 = `vercel.ai.error.${name7}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8, _b8;\nvar LoadAPIKeyError = class extends (_b8 = AISDKError, _a8 = symbol8, _b8) {\n  // used in isInstance\n  constructor({ message }) {\n    super({ name: name7, message });\n    this[_a8] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker8);\n  }\n};\n\n// src/errors/load-setting-error.ts\nvar name8 = \"AI_LoadSettingError\";\nvar marker9 = `vercel.ai.error.${name8}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9, _b9;\nvar LoadSettingError = class extends (_b9 = AISDKError, _a9 = symbol9, _b9) {\n  // used in isInstance\n  constructor({ message }) {\n    super({ name: name8, message });\n    this[_a9] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker9);\n  }\n};\n\n// src/errors/no-content-generated-error.ts\nvar name9 = \"AI_NoContentGeneratedError\";\nvar marker10 = `vercel.ai.error.${name9}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10, _b10;\nvar NoContentGeneratedError = class extends (_b10 = AISDKError, _a10 = symbol10, _b10) {\n  // used in isInstance\n  constructor({\n    message = \"No content generated.\"\n  } = {}) {\n    super({ name: name9, message });\n    this[_a10] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker10);\n  }\n};\n\n// src/errors/no-such-model-error.ts\nvar name10 = \"AI_NoSuchModelError\";\nvar marker11 = `vercel.ai.error.${name10}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11, _b11;\nvar NoSuchModelError = class extends (_b11 = AISDKError, _a11 = symbol11, _b11) {\n  constructor({\n    errorName = name10,\n    modelId,\n    modelType,\n    message = `No such ${modelType}: ${modelId}`\n  }) {\n    super({ name: errorName, message });\n    this[_a11] = true;\n    this.modelId = modelId;\n    this.modelType = modelType;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker11);\n  }\n};\n\n// src/errors/too-many-embedding-values-for-call-error.ts\nvar name11 = \"AI_TooManyEmbeddingValuesForCallError\";\nvar marker12 = `vercel.ai.error.${name11}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12, _b12;\nvar TooManyEmbeddingValuesForCallError = class extends (_b12 = AISDKError, _a12 = symbol12, _b12) {\n  constructor(options) {\n    super({\n      name: name11,\n      message: `Too many values for a single embedding call. The ${options.provider} model \"${options.modelId}\" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`\n    });\n    this[_a12] = true;\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n    this.values = options.values;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker12);\n  }\n};\n\n// src/errors/type-validation-error.ts\nvar name12 = \"AI_TypeValidationError\";\nvar marker13 = `vercel.ai.error.${name12}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13, _b13;\nvar TypeValidationError = class _TypeValidationError extends (_b13 = AISDKError, _a13 = symbol13, _b13) {\n  constructor({\n    value,\n    cause,\n    context\n  }) {\n    let contextPrefix = \"Type validation failed\";\n    if (context == null ? void 0 : context.field) {\n      contextPrefix += ` for ${context.field}`;\n    }\n    if ((context == null ? void 0 : context.entityName) || (context == null ? void 0 : context.entityId)) {\n      contextPrefix += \" (\";\n      const parts = [];\n      if (context.entityName) {\n        parts.push(context.entityName);\n      }\n      if (context.entityId) {\n        parts.push(`id: \"${context.entityId}\"`);\n      }\n      contextPrefix += parts.join(\", \");\n      contextPrefix += \")\";\n    }\n    super({\n      name: name12,\n      message: `${contextPrefix}: Value: ${JSON.stringify(value)}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a13] = true;\n    this.value = value;\n    this.context = context;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker13);\n  }\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value and context, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @param {TypeValidationContext} params.context - Optional context about what is being validated.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause,\n    context\n  }) {\n    var _a15, _b15, _c;\n    if (_TypeValidationError.isInstance(cause) && cause.value === value && ((_a15 = cause.context) == null ? void 0 : _a15.field) === (context == null ? void 0 : context.field) && ((_b15 = cause.context) == null ? void 0 : _b15.entityName) === (context == null ? void 0 : context.entityName) && ((_c = cause.context) == null ? void 0 : _c.entityId) === (context == null ? void 0 : context.entityId)) {\n      return cause;\n    }\n    return new _TypeValidationError({ value, cause, context });\n  }\n};\n\n// src/errors/unsupported-functionality-error.ts\nvar name13 = \"AI_UnsupportedFunctionalityError\";\nvar marker14 = `vercel.ai.error.${name13}`;\nvar symbol14 = Symbol.for(marker14);\nvar _a14, _b14;\nvar UnsupportedFunctionalityError = class extends (_b14 = AISDKError, _a14 = symbol14, _b14) {\n  constructor({\n    functionality,\n    message = `'${functionality}' functionality not supported.`\n  }) {\n    super({ name: name13, message });\n    this[_a14] = true;\n    this.functionality = functionality;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker14);\n  }\n};\n\n// src/json-value/is-json.ts\nfunction isJSONValue(value) {\n  if (value === null || typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n    return true;\n  }\n  if (Array.isArray(value)) {\n    return value.every(isJSONValue);\n  }\n  if (typeof value === \"object\") {\n    return Object.entries(value).every(\n      ([key, val]) => typeof key === \"string\" && (val === void 0 || isJSONValue(val))\n    );\n  }\n  return false;\n}\nfunction isJSONArray(value) {\n  return Array.isArray(value) && value.every(isJSONValue);\n}\nfunction isJSONObject(value) {\n  return value != null && typeof value === \"object\" && Object.entries(value).every(\n    ([key, val]) => typeof key === \"string\" && (val === void 0 || isJSONValue(val))\n  );\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9nYXRld2F5L25vZGVfbW9kdWxlcy9AYWktc2RrL3Byb3ZpZGVyL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsS0FBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsTUFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQ0FBa0MsSUFBSTtBQUN0RCxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFvQkU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsZWV0Zmxvdy8uL25vZGVfbW9kdWxlcy9AYWktc2RrL2dhdGV3YXkvbm9kZV9tb2R1bGVzL0BhaS1zZGsvcHJvdmlkZXIvZGlzdC9pbmRleC5tanM/MzEyMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvZXJyb3JzL2FpLXNkay1lcnJvci50c1xudmFyIG1hcmtlciA9IFwidmVyY2VsLmFpLmVycm9yXCI7XG52YXIgc3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIpO1xudmFyIF9hLCBfYjtcbnZhciBBSVNES0Vycm9yID0gY2xhc3MgX0FJU0RLRXJyb3IgZXh0ZW5kcyAoX2IgPSBFcnJvciwgX2EgPSBzeW1ib2wsIF9iKSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIEFJIFNESyBFcnJvci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBjcmVhdGluZyB0aGUgZXJyb3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMubmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBlcnJvci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5tZXNzYWdlIC0gVGhlIGVycm9yIG1lc3NhZ2UuXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gW3BhcmFtcy5jYXVzZV0gLSBUaGUgdW5kZXJseWluZyBjYXVzZSBvZiB0aGUgZXJyb3IuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbmFtZTogbmFtZTE0LFxuICAgIG1lc3NhZ2UsXG4gICAgY2F1c2VcbiAgfSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXNbX2FdID0gdHJ1ZTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lMTQ7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGVycm9yIGlzIGFuIEFJIFNESyBFcnJvci5cbiAgICogQHBhcmFtIHt1bmtub3dufSBlcnJvciAtIFRoZSBlcnJvciB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGVycm9yIGlzIGFuIEFJIFNESyBFcnJvciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gX0FJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIpO1xuICB9XG4gIHN0YXRpYyBoYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjE1KSB7XG4gICAgY29uc3QgbWFya2VyU3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIxNSk7XG4gICAgcmV0dXJuIGVycm9yICE9IG51bGwgJiYgdHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiICYmIG1hcmtlclN5bWJvbCBpbiBlcnJvciAmJiB0eXBlb2YgZXJyb3JbbWFya2VyU3ltYm9sXSA9PT0gXCJib29sZWFuXCIgJiYgZXJyb3JbbWFya2VyU3ltYm9sXSA9PT0gdHJ1ZTtcbiAgfVxufTtcblxuLy8gc3JjL2Vycm9ycy9hcGktY2FsbC1lcnJvci50c1xudmFyIG5hbWUgPSBcIkFJX0FQSUNhbGxFcnJvclwiO1xudmFyIG1hcmtlcjIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZX1gO1xudmFyIHN5bWJvbDIgPSBTeW1ib2wuZm9yKG1hcmtlcjIpO1xudmFyIF9hMiwgX2IyO1xudmFyIEFQSUNhbGxFcnJvciA9IGNsYXNzIGV4dGVuZHMgKF9iMiA9IEFJU0RLRXJyb3IsIF9hMiA9IHN5bWJvbDIsIF9iMikge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSxcbiAgICB1cmwsXG4gICAgcmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgc3RhdHVzQ29kZSxcbiAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgcmVzcG9uc2VCb2R5LFxuICAgIGNhdXNlLFxuICAgIGlzUmV0cnlhYmxlID0gc3RhdHVzQ29kZSAhPSBudWxsICYmIChzdGF0dXNDb2RlID09PSA0MDggfHwgLy8gcmVxdWVzdCB0aW1lb3V0XG4gICAgc3RhdHVzQ29kZSA9PT0gNDA5IHx8IC8vIGNvbmZsaWN0XG4gICAgc3RhdHVzQ29kZSA9PT0gNDI5IHx8IC8vIHRvbyBtYW55IHJlcXVlc3RzXG4gICAgc3RhdHVzQ29kZSA+PSA1MDApLFxuICAgIC8vIHNlcnZlciBlcnJvclxuICAgIGRhdGFcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZSwgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTJdID0gdHJ1ZTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLnJlcXVlc3RCb2R5VmFsdWVzID0gcmVxdWVzdEJvZHlWYWx1ZXM7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICB0aGlzLnJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycztcbiAgICB0aGlzLnJlc3BvbnNlQm9keSA9IHJlc3BvbnNlQm9keTtcbiAgICB0aGlzLmlzUmV0cnlhYmxlID0gaXNSZXRyeWFibGU7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMik7XG4gIH1cbn07XG5cbi8vIHNyYy9lcnJvcnMvZW1wdHktcmVzcG9uc2UtYm9keS1lcnJvci50c1xudmFyIG5hbWUyID0gXCJBSV9FbXB0eVJlc3BvbnNlQm9keUVycm9yXCI7XG52YXIgbWFya2VyMyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMn1gO1xudmFyIHN5bWJvbDMgPSBTeW1ib2wuZm9yKG1hcmtlcjMpO1xudmFyIF9hMywgX2IzO1xudmFyIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IgPSBjbGFzcyBleHRlbmRzIChfYjMgPSBBSVNES0Vycm9yLCBfYTMgPSBzeW1ib2wzLCBfYjMpIHtcbiAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSA9IFwiRW1wdHkgcmVzcG9uc2UgYm9keVwiIH0gPSB7fSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTIsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTNdID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMyk7XG4gIH1cbn07XG5cbi8vIHNyYy9lcnJvcnMvZ2V0LWVycm9yLW1lc3NhZ2UudHNcbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShlcnJvcikge1xuICBpZiAoZXJyb3IgPT0gbnVsbCkge1xuICAgIHJldHVybiBcInVua25vd24gZXJyb3JcIjtcbiAgfVxuICBpZiAodHlwZW9mIGVycm9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gIH1cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbn1cblxuLy8gc3JjL2Vycm9ycy9pbnZhbGlkLWFyZ3VtZW50LWVycm9yLnRzXG52YXIgbmFtZTMgPSBcIkFJX0ludmFsaWRBcmd1bWVudEVycm9yXCI7XG52YXIgbWFya2VyNCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lM31gO1xudmFyIHN5bWJvbDQgPSBTeW1ib2wuZm9yKG1hcmtlcjQpO1xudmFyIF9hNCwgX2I0O1xudmFyIEludmFsaWRBcmd1bWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyAoX2I0ID0gQUlTREtFcnJvciwgX2E0ID0gc3ltYm9sNCwgX2I0KSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlLFxuICAgIGNhdXNlLFxuICAgIGFyZ3VtZW50XG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUzLCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hNF0gPSB0cnVlO1xuICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyNCk7XG4gIH1cbn07XG5cbi8vIHNyYy9lcnJvcnMvaW52YWxpZC1wcm9tcHQtZXJyb3IudHNcbnZhciBuYW1lNCA9IFwiQUlfSW52YWxpZFByb21wdEVycm9yXCI7XG52YXIgbWFya2VyNSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNH1gO1xudmFyIHN5bWJvbDUgPSBTeW1ib2wuZm9yKG1hcmtlcjUpO1xudmFyIF9hNSwgX2I1O1xudmFyIEludmFsaWRQcm9tcHRFcnJvciA9IGNsYXNzIGV4dGVuZHMgKF9iNSA9IEFJU0RLRXJyb3IsIF9hNSA9IHN5bWJvbDUsIF9iNSkge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcHJvbXB0LFxuICAgIG1lc3NhZ2UsXG4gICAgY2F1c2VcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTQsIG1lc3NhZ2U6IGBJbnZhbGlkIHByb21wdDogJHttZXNzYWdlfWAsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2E1XSA9IHRydWU7XG4gICAgdGhpcy5wcm9tcHQgPSBwcm9tcHQ7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjUpO1xuICB9XG59O1xuXG4vLyBzcmMvZXJyb3JzL2ludmFsaWQtcmVzcG9uc2UtZGF0YS1lcnJvci50c1xudmFyIG5hbWU1ID0gXCJBSV9JbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3JcIjtcbnZhciBtYXJrZXI2ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU1fWA7XG52YXIgc3ltYm9sNiA9IFN5bWJvbC5mb3IobWFya2VyNik7XG52YXIgX2E2LCBfYjY7XG52YXIgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yID0gY2xhc3MgZXh0ZW5kcyAoX2I2ID0gQUlTREtFcnJvciwgX2E2ID0gc3ltYm9sNiwgX2I2KSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkYXRhLFxuICAgIG1lc3NhZ2UgPSBgSW52YWxpZCByZXNwb25zZSBkYXRhOiAke0pTT04uc3RyaW5naWZ5KGRhdGEpfS5gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU1LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2E2XSA9IHRydWU7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyNik7XG4gIH1cbn07XG5cbi8vIHNyYy9lcnJvcnMvanNvbi1wYXJzZS1lcnJvci50c1xudmFyIG5hbWU2ID0gXCJBSV9KU09OUGFyc2VFcnJvclwiO1xudmFyIG1hcmtlcjcgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTZ9YDtcbnZhciBzeW1ib2w3ID0gU3ltYm9sLmZvcihtYXJrZXI3KTtcbnZhciBfYTcsIF9iNztcbnZhciBKU09OUGFyc2VFcnJvciA9IGNsYXNzIGV4dGVuZHMgKF9iNyA9IEFJU0RLRXJyb3IsIF9hNyA9IHN5bWJvbDcsIF9iNykge1xuICBjb25zdHJ1Y3Rvcih7IHRleHQsIGNhdXNlIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBuYW1lNixcbiAgICAgIG1lc3NhZ2U6IGBKU09OIHBhcnNpbmcgZmFpbGVkOiBUZXh0OiAke3RleHR9LlxuRXJyb3IgbWVzc2FnZTogJHtnZXRFcnJvck1lc3NhZ2UoY2F1c2UpfWAsXG4gICAgICBjYXVzZVxuICAgIH0pO1xuICAgIHRoaXNbX2E3XSA9IHRydWU7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyNyk7XG4gIH1cbn07XG5cbi8vIHNyYy9lcnJvcnMvbG9hZC1hcGkta2V5LWVycm9yLnRzXG52YXIgbmFtZTcgPSBcIkFJX0xvYWRBUElLZXlFcnJvclwiO1xudmFyIG1hcmtlcjggPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTd9YDtcbnZhciBzeW1ib2w4ID0gU3ltYm9sLmZvcihtYXJrZXI4KTtcbnZhciBfYTgsIF9iODtcbnZhciBMb2FkQVBJS2V5RXJyb3IgPSBjbGFzcyBleHRlbmRzIChfYjggPSBBSVNES0Vycm9yLCBfYTggPSBzeW1ib2w4LCBfYjgpIHtcbiAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNywgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hOF0gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI4KTtcbiAgfVxufTtcblxuLy8gc3JjL2Vycm9ycy9sb2FkLXNldHRpbmctZXJyb3IudHNcbnZhciBuYW1lOCA9IFwiQUlfTG9hZFNldHRpbmdFcnJvclwiO1xudmFyIG1hcmtlcjkgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTh9YDtcbnZhciBzeW1ib2w5ID0gU3ltYm9sLmZvcihtYXJrZXI5KTtcbnZhciBfYTksIF9iOTtcbnZhciBMb2FkU2V0dGluZ0Vycm9yID0gY2xhc3MgZXh0ZW5kcyAoX2I5ID0gQUlTREtFcnJvciwgX2E5ID0gc3ltYm9sOSwgX2I5KSB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTgsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTldID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyOSk7XG4gIH1cbn07XG5cbi8vIHNyYy9lcnJvcnMvbm8tY29udGVudC1nZW5lcmF0ZWQtZXJyb3IudHNcbnZhciBuYW1lOSA9IFwiQUlfTm9Db250ZW50R2VuZXJhdGVkRXJyb3JcIjtcbnZhciBtYXJrZXIxMCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lOX1gO1xudmFyIHN5bWJvbDEwID0gU3ltYm9sLmZvcihtYXJrZXIxMCk7XG52YXIgX2ExMCwgX2IxMDtcbnZhciBOb0NvbnRlbnRHZW5lcmF0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgKF9iMTAgPSBBSVNES0Vycm9yLCBfYTEwID0gc3ltYm9sMTAsIF9iMTApIHtcbiAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlID0gXCJObyBjb250ZW50IGdlbmVyYXRlZC5cIlxuICB9ID0ge30pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU5LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2ExMF0gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMCk7XG4gIH1cbn07XG5cbi8vIHNyYy9lcnJvcnMvbm8tc3VjaC1tb2RlbC1lcnJvci50c1xudmFyIG5hbWUxMCA9IFwiQUlfTm9TdWNoTW9kZWxFcnJvclwiO1xudmFyIG1hcmtlcjExID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxMH1gO1xudmFyIHN5bWJvbDExID0gU3ltYm9sLmZvcihtYXJrZXIxMSk7XG52YXIgX2ExMSwgX2IxMTtcbnZhciBOb1N1Y2hNb2RlbEVycm9yID0gY2xhc3MgZXh0ZW5kcyAoX2IxMSA9IEFJU0RLRXJyb3IsIF9hMTEgPSBzeW1ib2wxMSwgX2IxMSkge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZXJyb3JOYW1lID0gbmFtZTEwLFxuICAgIG1vZGVsSWQsXG4gICAgbW9kZWxUeXBlLFxuICAgIG1lc3NhZ2UgPSBgTm8gc3VjaCAke21vZGVsVHlwZX06ICR7bW9kZWxJZH1gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IGVycm9yTmFtZSwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hMTFdID0gdHJ1ZTtcbiAgICB0aGlzLm1vZGVsSWQgPSBtb2RlbElkO1xuICAgIHRoaXMubW9kZWxUeXBlID0gbW9kZWxUeXBlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMSk7XG4gIH1cbn07XG5cbi8vIHNyYy9lcnJvcnMvdG9vLW1hbnktZW1iZWRkaW5nLXZhbHVlcy1mb3ItY2FsbC1lcnJvci50c1xudmFyIG5hbWUxMSA9IFwiQUlfVG9vTWFueUVtYmVkZGluZ1ZhbHVlc0ZvckNhbGxFcnJvclwiO1xudmFyIG1hcmtlcjEyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxMX1gO1xudmFyIHN5bWJvbDEyID0gU3ltYm9sLmZvcihtYXJrZXIxMik7XG52YXIgX2ExMiwgX2IxMjtcbnZhciBUb29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yID0gY2xhc3MgZXh0ZW5kcyAoX2IxMiA9IEFJU0RLRXJyb3IsIF9hMTIgPSBzeW1ib2wxMiwgX2IxMikge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogbmFtZTExLFxuICAgICAgbWVzc2FnZTogYFRvbyBtYW55IHZhbHVlcyBmb3IgYSBzaW5nbGUgZW1iZWRkaW5nIGNhbGwuIFRoZSAke29wdGlvbnMucHJvdmlkZXJ9IG1vZGVsIFwiJHtvcHRpb25zLm1vZGVsSWR9XCIgY2FuIG9ubHkgZW1iZWQgdXAgdG8gJHtvcHRpb25zLm1heEVtYmVkZGluZ3NQZXJDYWxsfSB2YWx1ZXMgcGVyIGNhbGwsIGJ1dCAke29wdGlvbnMudmFsdWVzLmxlbmd0aH0gdmFsdWVzIHdlcmUgcHJvdmlkZWQuYFxuICAgIH0pO1xuICAgIHRoaXNbX2ExMl0gPSB0cnVlO1xuICAgIHRoaXMucHJvdmlkZXIgPSBvcHRpb25zLnByb3ZpZGVyO1xuICAgIHRoaXMubW9kZWxJZCA9IG9wdGlvbnMubW9kZWxJZDtcbiAgICB0aGlzLm1heEVtYmVkZGluZ3NQZXJDYWxsID0gb3B0aW9ucy5tYXhFbWJlZGRpbmdzUGVyQ2FsbDtcbiAgICB0aGlzLnZhbHVlcyA9IG9wdGlvbnMudmFsdWVzO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMik7XG4gIH1cbn07XG5cbi8vIHNyYy9lcnJvcnMvdHlwZS12YWxpZGF0aW9uLWVycm9yLnRzXG52YXIgbmFtZTEyID0gXCJBSV9UeXBlVmFsaWRhdGlvbkVycm9yXCI7XG52YXIgbWFya2VyMTMgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTEyfWA7XG52YXIgc3ltYm9sMTMgPSBTeW1ib2wuZm9yKG1hcmtlcjEzKTtcbnZhciBfYTEzLCBfYjEzO1xudmFyIFR5cGVWYWxpZGF0aW9uRXJyb3IgPSBjbGFzcyBfVHlwZVZhbGlkYXRpb25FcnJvciBleHRlbmRzIChfYjEzID0gQUlTREtFcnJvciwgX2ExMyA9IHN5bWJvbDEzLCBfYjEzKSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB2YWx1ZSxcbiAgICBjYXVzZSxcbiAgICBjb250ZXh0XG4gIH0pIHtcbiAgICBsZXQgY29udGV4dFByZWZpeCA9IFwiVHlwZSB2YWxpZGF0aW9uIGZhaWxlZFwiO1xuICAgIGlmIChjb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBjb250ZXh0LmZpZWxkKSB7XG4gICAgICBjb250ZXh0UHJlZml4ICs9IGAgZm9yICR7Y29udGV4dC5maWVsZH1gO1xuICAgIH1cbiAgICBpZiAoKGNvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRleHQuZW50aXR5TmFtZSkgfHwgKGNvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRleHQuZW50aXR5SWQpKSB7XG4gICAgICBjb250ZXh0UHJlZml4ICs9IFwiIChcIjtcbiAgICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgICBpZiAoY29udGV4dC5lbnRpdHlOYW1lKSB7XG4gICAgICAgIHBhcnRzLnB1c2goY29udGV4dC5lbnRpdHlOYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0LmVudGl0eUlkKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYGlkOiBcIiR7Y29udGV4dC5lbnRpdHlJZH1cImApO1xuICAgICAgfVxuICAgICAgY29udGV4dFByZWZpeCArPSBwYXJ0cy5qb2luKFwiLCBcIik7XG4gICAgICBjb250ZXh0UHJlZml4ICs9IFwiKVwiO1xuICAgIH1cbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBuYW1lMTIsXG4gICAgICBtZXNzYWdlOiBgJHtjb250ZXh0UHJlZml4fTogVmFsdWU6ICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfS5cbkVycm9yIG1lc3NhZ2U6ICR7Z2V0RXJyb3JNZXNzYWdlKGNhdXNlKX1gLFxuICAgICAgY2F1c2VcbiAgICB9KTtcbiAgICB0aGlzW19hMTNdID0gdHJ1ZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTMpO1xuICB9XG4gIC8qKlxuICAgKiBXcmFwcyBhbiBlcnJvciBpbnRvIGEgVHlwZVZhbGlkYXRpb25FcnJvci5cbiAgICogSWYgdGhlIGNhdXNlIGlzIGFscmVhZHkgYSBUeXBlVmFsaWRhdGlvbkVycm9yIHdpdGggdGhlIHNhbWUgdmFsdWUgYW5kIGNvbnRleHQsIGl0IHJldHVybnMgdGhlIGNhdXNlLlxuICAgKiBPdGhlcndpc2UsIGl0IGNyZWF0ZXMgYSBuZXcgVHlwZVZhbGlkYXRpb25FcnJvci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB3cmFwcGluZyB0aGUgZXJyb3IuXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gcGFyYW1zLnZhbHVlIC0gVGhlIHZhbHVlIHRoYXQgZmFpbGVkIHZhbGlkYXRpb24uXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gcGFyYW1zLmNhdXNlIC0gVGhlIG9yaWdpbmFsIGVycm9yIG9yIGNhdXNlIG9mIHRoZSB2YWxpZGF0aW9uIGZhaWx1cmUuXG4gICAqIEBwYXJhbSB7VHlwZVZhbGlkYXRpb25Db250ZXh0fSBwYXJhbXMuY29udGV4dCAtIE9wdGlvbmFsIGNvbnRleHQgYWJvdXQgd2hhdCBpcyBiZWluZyB2YWxpZGF0ZWQuXG4gICAqIEByZXR1cm5zIHtUeXBlVmFsaWRhdGlvbkVycm9yfSBBIFR5cGVWYWxpZGF0aW9uRXJyb3IgaW5zdGFuY2UuXG4gICAqL1xuICBzdGF0aWMgd3JhcCh7XG4gICAgdmFsdWUsXG4gICAgY2F1c2UsXG4gICAgY29udGV4dFxuICB9KSB7XG4gICAgdmFyIF9hMTUsIF9iMTUsIF9jO1xuICAgIGlmIChfVHlwZVZhbGlkYXRpb25FcnJvci5pc0luc3RhbmNlKGNhdXNlKSAmJiBjYXVzZS52YWx1ZSA9PT0gdmFsdWUgJiYgKChfYTE1ID0gY2F1c2UuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTUuZmllbGQpID09PSAoY29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogY29udGV4dC5maWVsZCkgJiYgKChfYjE1ID0gY2F1c2UuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMTUuZW50aXR5TmFtZSkgPT09IChjb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBjb250ZXh0LmVudGl0eU5hbWUpICYmICgoX2MgPSBjYXVzZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2MuZW50aXR5SWQpID09PSAoY29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogY29udGV4dC5lbnRpdHlJZCkpIHtcbiAgICAgIHJldHVybiBjYXVzZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfVHlwZVZhbGlkYXRpb25FcnJvcih7IHZhbHVlLCBjYXVzZSwgY29udGV4dCB9KTtcbiAgfVxufTtcblxuLy8gc3JjL2Vycm9ycy91bnN1cHBvcnRlZC1mdW5jdGlvbmFsaXR5LWVycm9yLnRzXG52YXIgbmFtZTEzID0gXCJBSV9VbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvclwiO1xudmFyIG1hcmtlcjE0ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxM31gO1xudmFyIHN5bWJvbDE0ID0gU3ltYm9sLmZvcihtYXJrZXIxNCk7XG52YXIgX2ExNCwgX2IxNDtcbnZhciBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvciA9IGNsYXNzIGV4dGVuZHMgKF9iMTQgPSBBSVNES0Vycm9yLCBfYTE0ID0gc3ltYm9sMTQsIF9iMTQpIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGZ1bmN0aW9uYWxpdHksXG4gICAgbWVzc2FnZSA9IGAnJHtmdW5jdGlvbmFsaXR5fScgZnVuY3Rpb25hbGl0eSBub3Qgc3VwcG9ydGVkLmBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTEzLCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2ExNF0gPSB0cnVlO1xuICAgIHRoaXMuZnVuY3Rpb25hbGl0eSA9IGZ1bmN0aW9uYWxpdHk7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjE0KTtcbiAgfVxufTtcblxuLy8gc3JjL2pzb24tdmFsdWUvaXMtanNvbi50c1xuZnVuY3Rpb24gaXNKU09OVmFsdWUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS5ldmVyeShpc0pTT05WYWx1ZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyh2YWx1ZSkuZXZlcnkoXG4gICAgICAoW2tleSwgdmFsXSkgPT4gdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiAmJiAodmFsID09PSB2b2lkIDAgfHwgaXNKU09OVmFsdWUodmFsKSlcbiAgICApO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzSlNPTkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeShpc0pTT05WYWx1ZSk7XG59XG5mdW5jdGlvbiBpc0pTT05PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5ldmVyeShcbiAgICAoW2tleSwgdmFsXSkgPT4gdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiAmJiAodmFsID09PSB2b2lkIDAgfHwgaXNKU09OVmFsdWUodmFsKSlcbiAgKTtcbn1cbmV4cG9ydCB7XG4gIEFJU0RLRXJyb3IsXG4gIEFQSUNhbGxFcnJvcixcbiAgRW1wdHlSZXNwb25zZUJvZHlFcnJvcixcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gIEludmFsaWRQcm9tcHRFcnJvcixcbiAgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yLFxuICBKU09OUGFyc2VFcnJvcixcbiAgTG9hZEFQSUtleUVycm9yLFxuICBMb2FkU2V0dGluZ0Vycm9yLFxuICBOb0NvbnRlbnRHZW5lcmF0ZWRFcnJvcixcbiAgTm9TdWNoTW9kZWxFcnJvcixcbiAgVG9vTWFueUVtYmVkZGluZ1ZhbHVlc0ZvckNhbGxFcnJvcixcbiAgVHlwZVZhbGlkYXRpb25FcnJvcixcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IsXG4gIGdldEVycm9yTWVzc2FnZSxcbiAgaXNKU09OQXJyYXksXG4gIGlzSlNPTk9iamVjdCxcbiAgaXNKU09OVmFsdWVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ai-sdk/gateway/node_modules/@ai-sdk/provider/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ai-sdk/react/dist/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@ai-sdk/react/dist/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chat: () => (/* binding */ Chat),\n/* harmony export */   experimental_useObject: () => (/* binding */ experimental_useObject),\n/* harmony export */   useChat: () => (/* binding */ useChat),\n/* harmony export */   useCompletion: () => (/* binding */ useCompletion)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var ai__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ai */ \"(ssr)/./node_modules/@ai-sdk/react/node_modules/ai/dist/index.mjs\");\n/* harmony import */ var throttleit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! throttleit */ \"(ssr)/./node_modules/throttleit/index.js\");\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! swr */ \"(ssr)/./node_modules/swr/dist/index/index.mjs\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ai */ \"(ssr)/./node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\n\n// src/use-chat.ts\n\n\n// src/chat.react.ts\n\n\n// src/throttle.ts\n\nfunction throttle(fn, waitMs) {\n  return waitMs != null ? throttleit__WEBPACK_IMPORTED_MODULE_1__(fn, waitMs) : fn;\n}\n\n// src/chat.react.ts\nvar _messages, _status, _error, _messagesCallbacks, _statusCallbacks, _errorCallbacks, _callMessagesCallbacks, _callStatusCallbacks, _callErrorCallbacks;\nvar ReactChatState = class {\n  constructor(initialMessages = []) {\n    __privateAdd(this, _messages, void 0);\n    __privateAdd(this, _status, \"ready\");\n    __privateAdd(this, _error, void 0);\n    __privateAdd(this, _messagesCallbacks, /* @__PURE__ */ new Set());\n    __privateAdd(this, _statusCallbacks, /* @__PURE__ */ new Set());\n    __privateAdd(this, _errorCallbacks, /* @__PURE__ */ new Set());\n    this.pushMessage = (message) => {\n      __privateSet(this, _messages, __privateGet(this, _messages).concat(message));\n      __privateGet(this, _callMessagesCallbacks).call(this);\n    };\n    this.popMessage = () => {\n      __privateSet(this, _messages, __privateGet(this, _messages).slice(0, -1));\n      __privateGet(this, _callMessagesCallbacks).call(this);\n    };\n    this.replaceMessage = (index, message) => {\n      __privateSet(this, _messages, [\n        ...__privateGet(this, _messages).slice(0, index),\n        // We deep clone the message here to ensure the new React Compiler (currently in RC) detects deeply nested parts/metadata changes:\n        this.snapshot(message),\n        ...__privateGet(this, _messages).slice(index + 1)\n      ]);\n      __privateGet(this, _callMessagesCallbacks).call(this);\n    };\n    this.snapshot = (value) => structuredClone(value);\n    this[\"~registerMessagesCallback\"] = (onChange, throttleWaitMs) => {\n      const callback = throttleWaitMs ? throttle(onChange, throttleWaitMs) : onChange;\n      __privateGet(this, _messagesCallbacks).add(callback);\n      return () => {\n        __privateGet(this, _messagesCallbacks).delete(callback);\n      };\n    };\n    this[\"~registerStatusCallback\"] = (onChange) => {\n      __privateGet(this, _statusCallbacks).add(onChange);\n      return () => {\n        __privateGet(this, _statusCallbacks).delete(onChange);\n      };\n    };\n    this[\"~registerErrorCallback\"] = (onChange) => {\n      __privateGet(this, _errorCallbacks).add(onChange);\n      return () => {\n        __privateGet(this, _errorCallbacks).delete(onChange);\n      };\n    };\n    __privateAdd(this, _callMessagesCallbacks, () => {\n      __privateGet(this, _messagesCallbacks).forEach((callback) => callback());\n    });\n    __privateAdd(this, _callStatusCallbacks, () => {\n      __privateGet(this, _statusCallbacks).forEach((callback) => callback());\n    });\n    __privateAdd(this, _callErrorCallbacks, () => {\n      __privateGet(this, _errorCallbacks).forEach((callback) => callback());\n    });\n    __privateSet(this, _messages, initialMessages);\n  }\n  get status() {\n    return __privateGet(this, _status);\n  }\n  set status(newStatus) {\n    __privateSet(this, _status, newStatus);\n    __privateGet(this, _callStatusCallbacks).call(this);\n  }\n  get error() {\n    return __privateGet(this, _error);\n  }\n  set error(newError) {\n    __privateSet(this, _error, newError);\n    __privateGet(this, _callErrorCallbacks).call(this);\n  }\n  get messages() {\n    return __privateGet(this, _messages);\n  }\n  set messages(newMessages) {\n    __privateSet(this, _messages, [...newMessages]);\n    __privateGet(this, _callMessagesCallbacks).call(this);\n  }\n};\n_messages = new WeakMap();\n_status = new WeakMap();\n_error = new WeakMap();\n_messagesCallbacks = new WeakMap();\n_statusCallbacks = new WeakMap();\n_errorCallbacks = new WeakMap();\n_callMessagesCallbacks = new WeakMap();\n_callStatusCallbacks = new WeakMap();\n_callErrorCallbacks = new WeakMap();\nvar _state;\nvar Chat = class extends ai__WEBPACK_IMPORTED_MODULE_2__.AbstractChat {\n  constructor({ messages, ...init }) {\n    const state = new ReactChatState(messages);\n    super({ ...init, state });\n    __privateAdd(this, _state, void 0);\n    this[\"~registerMessagesCallback\"] = (onChange, throttleWaitMs) => __privateGet(this, _state)[\"~registerMessagesCallback\"](onChange, throttleWaitMs);\n    this[\"~registerStatusCallback\"] = (onChange) => __privateGet(this, _state)[\"~registerStatusCallback\"](onChange);\n    this[\"~registerErrorCallback\"] = (onChange) => __privateGet(this, _state)[\"~registerErrorCallback\"](onChange);\n    __privateSet(this, _state, state);\n  }\n};\n_state = new WeakMap();\n\n// src/use-chat.ts\nfunction useChat({\n  experimental_throttle: throttleWaitMs,\n  resume = false,\n  ...options\n} = {}) {\n  const callbacksRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(\n    !(\"chat\" in options) ? {\n      onToolCall: options.onToolCall,\n      onData: options.onData,\n      onFinish: options.onFinish,\n      onError: options.onError,\n      sendAutomaticallyWhen: options.sendAutomaticallyWhen\n    } : {}\n  );\n  if (!(\"chat\" in options)) {\n    callbacksRef.current = {\n      onToolCall: options.onToolCall,\n      onData: options.onData,\n      onFinish: options.onFinish,\n      onError: options.onError,\n      sendAutomaticallyWhen: options.sendAutomaticallyWhen\n    };\n  }\n  const optionsWithCallbacks = {\n    ...options,\n    onToolCall: (arg) => {\n      var _a, _b;\n      return (_b = (_a = callbacksRef.current).onToolCall) == null ? void 0 : _b.call(_a, arg);\n    },\n    onData: (arg) => {\n      var _a, _b;\n      return (_b = (_a = callbacksRef.current).onData) == null ? void 0 : _b.call(_a, arg);\n    },\n    onFinish: (arg) => {\n      var _a, _b;\n      return (_b = (_a = callbacksRef.current).onFinish) == null ? void 0 : _b.call(_a, arg);\n    },\n    onError: (arg) => {\n      var _a, _b;\n      return (_b = (_a = callbacksRef.current).onError) == null ? void 0 : _b.call(_a, arg);\n    },\n    sendAutomaticallyWhen: (arg) => {\n      var _a, _b, _c;\n      return (_c = (_b = (_a = callbacksRef.current).sendAutomaticallyWhen) == null ? void 0 : _b.call(_a, arg)) != null ? _c : false;\n    }\n  };\n  const chatRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(\n    \"chat\" in options ? options.chat : new Chat(optionsWithCallbacks)\n  );\n  const shouldRecreateChat = \"chat\" in options && options.chat !== chatRef.current || \"id\" in options && chatRef.current.id !== options.id;\n  if (shouldRecreateChat) {\n    chatRef.current = \"chat\" in options ? options.chat : new Chat(optionsWithCallbacks);\n  }\n  const subscribeToMessages = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (update) => chatRef.current[\"~registerMessagesCallback\"](update, throttleWaitMs),\n    // `chatRef.current.id` is required to trigger re-subscription when the chat ID changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [throttleWaitMs, chatRef.current.id]\n  );\n  const messages = (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(\n    subscribeToMessages,\n    () => chatRef.current.messages,\n    () => chatRef.current.messages\n  );\n  const status = (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(\n    chatRef.current[\"~registerStatusCallback\"],\n    () => chatRef.current.status,\n    () => chatRef.current.status\n  );\n  const error = (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(\n    chatRef.current[\"~registerErrorCallback\"],\n    () => chatRef.current.error,\n    () => chatRef.current.error\n  );\n  const setMessages = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (messagesParam) => {\n      if (typeof messagesParam === \"function\") {\n        messagesParam = messagesParam(chatRef.current.messages);\n      }\n      chatRef.current.messages = messagesParam;\n    },\n    [chatRef]\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (resume) {\n      chatRef.current.resumeStream();\n    }\n  }, [resume, chatRef]);\n  return {\n    id: chatRef.current.id,\n    messages,\n    setMessages,\n    sendMessage: chatRef.current.sendMessage,\n    regenerate: chatRef.current.regenerate,\n    clearError: chatRef.current.clearError,\n    stop: chatRef.current.stop,\n    error,\n    resumeStream: chatRef.current.resumeStream,\n    status,\n    /**\n     * @deprecated Use `addToolOutput` instead.\n     */\n    addToolResult: chatRef.current.addToolOutput,\n    addToolOutput: chatRef.current.addToolOutput,\n    addToolApprovalResponse: chatRef.current.addToolApprovalResponse\n  };\n}\n\n// src/use-completion.ts\n\n\n\nfunction useCompletion({\n  api = \"/api/completion\",\n  id,\n  initialCompletion = \"\",\n  initialInput = \"\",\n  credentials,\n  headers,\n  body,\n  streamProtocol = \"data\",\n  fetch: fetch2,\n  onFinish,\n  onError,\n  experimental_throttle: throttleWaitMs\n} = {}) {\n  const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n  const completionId = id || hookId;\n  const { data, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_3__[\"default\"])([api, completionId], null, {\n    fallbackData: initialCompletion\n  });\n  const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\n    [completionId, \"loading\"],\n    null\n  );\n  const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n  const completion = data;\n  const [abortController, setAbortController] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n    credentials,\n    headers,\n    body\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    extraMetadataRef.current = {\n      credentials,\n      headers,\n      body\n    };\n  }, [credentials, headers, body]);\n  const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    async (prompt, options) => (0,ai__WEBPACK_IMPORTED_MODULE_2__.callCompletionApi)({\n      api,\n      prompt,\n      credentials: extraMetadataRef.current.credentials,\n      headers: { ...extraMetadataRef.current.headers, ...options == null ? void 0 : options.headers },\n      body: {\n        ...extraMetadataRef.current.body,\n        ...options == null ? void 0 : options.body\n      },\n      streamProtocol,\n      fetch: fetch2,\n      // throttle streamed ui updates:\n      setCompletion: throttle(\n        (completion2) => mutate(completion2, false),\n        throttleWaitMs\n      ),\n      setLoading: mutateLoading,\n      setError,\n      setAbortController,\n      onFinish,\n      onError\n    }),\n    [\n      mutate,\n      mutateLoading,\n      api,\n      extraMetadataRef,\n      setAbortController,\n      onFinish,\n      onError,\n      setError,\n      streamProtocol,\n      fetch2,\n      throttleWaitMs\n    ]\n  );\n  const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    if (abortController) {\n      abortController.abort();\n      setAbortController(null);\n    }\n  }, [abortController]);\n  const setCompletion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (completion2) => {\n      mutate(completion2, false);\n    },\n    [mutate]\n  );\n  const complete = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    async (prompt, options) => {\n      return triggerRequest(prompt, options);\n    },\n    [triggerRequest]\n  );\n  const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n  const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (event) => {\n      var _a;\n      (_a = event == null ? void 0 : event.preventDefault) == null ? void 0 : _a.call(event);\n      return input ? complete(input) : void 0;\n    },\n    [input, complete]\n  );\n  const handleInputChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (e) => {\n      setInput(e.target.value);\n    },\n    [setInput]\n  );\n  return {\n    completion,\n    complete,\n    error,\n    setCompletion,\n    stop,\n    input,\n    setInput,\n    handleInputChange,\n    handleSubmit,\n    isLoading\n  };\n}\n\n// src/use-object.ts\n\n\n\n\nvar getOriginalFetch = () => fetch;\nfunction useObject({\n  api,\n  id,\n  schema,\n  // required, in the future we will use it for validation\n  initialValue,\n  fetch: fetch2,\n  onError,\n  onFinish,\n  headers,\n  credentials\n}) {\n  const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n  const completionId = id != null ? id : hookId;\n  const { data, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\n    [api, completionId],\n    null,\n    { fallbackData: initialValue }\n  );\n  const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n  const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const abortControllerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    var _a;\n    try {\n      (_a = abortControllerRef.current) == null ? void 0 : _a.abort();\n    } catch (ignored) {\n    } finally {\n      setIsLoading(false);\n      abortControllerRef.current = null;\n    }\n  }, []);\n  const submit = async (input) => {\n    var _a;\n    try {\n      clearObject();\n      setIsLoading(true);\n      const abortController = new AbortController();\n      abortControllerRef.current = abortController;\n      const resolvedHeaders = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_4__.resolve)(headers);\n      const actualFetch = fetch2 != null ? fetch2 : getOriginalFetch();\n      const response = await actualFetch(api, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          ...(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_4__.normalizeHeaders)(resolvedHeaders)\n        },\n        credentials,\n        signal: abortController.signal,\n        body: JSON.stringify(input)\n      });\n      if (!response.ok) {\n        throw new Error(\n          (_a = await response.text()) != null ? _a : \"Failed to fetch the response.\"\n        );\n      }\n      if (response.body == null) {\n        throw new Error(\"The response body is empty.\");\n      }\n      let accumulatedText = \"\";\n      let latestObject = void 0;\n      await response.body.pipeThrough(new TextDecoderStream()).pipeTo(\n        new WritableStream({\n          async write(chunk) {\n            accumulatedText += chunk;\n            const { value } = await (0,ai__WEBPACK_IMPORTED_MODULE_2__.parsePartialJson)(accumulatedText);\n            const currentObject = value;\n            if (!(0,ai__WEBPACK_IMPORTED_MODULE_2__.isDeepEqualData)(latestObject, currentObject)) {\n              latestObject = currentObject;\n              mutate(currentObject);\n            }\n          },\n          async close() {\n            setIsLoading(false);\n            abortControllerRef.current = null;\n            if (onFinish != null) {\n              const validationResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_4__.safeValidateTypes)({\n                value: latestObject,\n                schema: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_4__.asSchema)(schema)\n              });\n              onFinish(\n                validationResult.success ? { object: validationResult.value, error: void 0 } : { object: void 0, error: validationResult.error }\n              );\n            }\n          }\n        })\n      );\n    } catch (error2) {\n      if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_4__.isAbortError)(error2)) {\n        return;\n      }\n      if (onError && error2 instanceof Error) {\n        onError(error2);\n      }\n      setIsLoading(false);\n      setError(error2 instanceof Error ? error2 : new Error(String(error2)));\n    }\n  };\n  const clear = () => {\n    stop();\n    clearObject();\n  };\n  const clearObject = () => {\n    setError(void 0);\n    setIsLoading(false);\n    mutate(void 0);\n  };\n  return {\n    submit,\n    object: data,\n    error,\n    isLoading,\n    stop,\n    clear\n  };\n}\nvar experimental_useObject = useObject;\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9yZWFjdC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDNkU7O0FBRTdFO0FBQ2tDOztBQUVsQztBQUMwQztBQUMxQztBQUNBLDBCQUEwQix1Q0FBZ0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRDQUFZO0FBQ3JDLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTix1QkFBdUIsNkNBQU07QUFDN0I7QUFDQTtBQUNBO0FB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QUMzQjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywrREFBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3RUFBZ0I7QUFDN0IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVEsUUFBUSxvREFBZ0I7QUFDcEQ7QUFDQSxpQkFBaUIsbURBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHlFQUFpQjtBQUM5RDtBQUNBLHdCQUF3QixnRUFBUTtBQUNoQyxlQUFlO0FBQ2Y7QUFDQSw2Q0FBNkMsZ0RBQWdELElBQUk7QUFDakc7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOLFVBQVUsb0VBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmxlZXRmbG93Ly4vbm9kZV9tb2R1bGVzL0BhaS1zZGsvcmVhY3QvZGlzdC9pbmRleC5tanM/MjQ1MSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19hY2Nlc3NDaGVjayA9IChvYmosIG1lbWJlciwgbXNnKSA9PiB7XG4gIGlmICghbWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG59O1xudmFyIF9fcHJpdmF0ZUdldCA9IChvYmosIG1lbWJlciwgZ2V0dGVyKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIik7XG4gIHJldHVybiBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogbWVtYmVyLmdldChvYmopO1xufTtcbnZhciBfX3ByaXZhdGVBZGQgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiB7XG4gIGlmIChtZW1iZXIuaGFzKG9iaikpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCB0aGUgc2FtZSBwcml2YXRlIG1lbWJlciBtb3JlIHRoYW4gb25jZVwiKTtcbiAgbWVtYmVyIGluc3RhbmNlb2YgV2Vha1NldCA/IG1lbWJlci5hZGQob2JqKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG59O1xudmFyIF9fcHJpdmF0ZVNldCA9IChvYmosIG1lbWJlciwgdmFsdWUsIHNldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIik7XG4gIHNldHRlciA/IHNldHRlci5jYWxsKG9iaiwgdmFsdWUpIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuLy8gc3JjL3VzZS1jaGF0LnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN5bmNFeHRlcm5hbFN0b3JlIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9jaGF0LnJlYWN0LnRzXG5pbXBvcnQgeyBBYnN0cmFjdENoYXQgfSBmcm9tIFwiYWlcIjtcblxuLy8gc3JjL3Rocm90dGxlLnRzXG5pbXBvcnQgdGhyb3R0bGVGdW5jdGlvbiBmcm9tIFwidGhyb3R0bGVpdFwiO1xuZnVuY3Rpb24gdGhyb3R0bGUoZm4sIHdhaXRNcykge1xuICByZXR1cm4gd2FpdE1zICE9IG51bGwgPyB0aHJvdHRsZUZ1bmN0aW9uKGZuLCB3YWl0TXMpIDogZm47XG59XG5cbi8vIHNyYy9jaGF0LnJlYWN0LnRzXG52YXIgX21lc3NhZ2VzLCBfc3RhdHVzLCBfZXJyb3IsIF9tZXNzYWdlc0NhbGxiYWNrcywgX3N0YXR1c0NhbGxiYWNrcywgX2Vycm9yQ2FsbGJhY2tzLCBfY2FsbE1lc3NhZ2VzQ2FsbGJhY2tzLCBfY2FsbFN0YXR1c0NhbGxiYWNrcywgX2NhbGxFcnJvckNhbGxiYWNrcztcbnZhciBSZWFjdENoYXRTdGF0ZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaW5pdGlhbE1lc3NhZ2VzID0gW10pIHtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX21lc3NhZ2VzLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfc3RhdHVzLCBcInJlYWR5XCIpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfZXJyb3IsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9tZXNzYWdlc0NhbGxiYWNrcywgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9zdGF0dXNDYWxsYmFja3MsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfZXJyb3JDYWxsYmFja3MsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICAgIHRoaXMucHVzaE1lc3NhZ2UgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9tZXNzYWdlcywgX19wcml2YXRlR2V0KHRoaXMsIF9tZXNzYWdlcykuY29uY2F0KG1lc3NhZ2UpKTtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfY2FsbE1lc3NhZ2VzQ2FsbGJhY2tzKS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgdGhpcy5wb3BNZXNzYWdlID0gKCkgPT4ge1xuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9tZXNzYWdlcywgX19wcml2YXRlR2V0KHRoaXMsIF9tZXNzYWdlcykuc2xpY2UoMCwgLTEpKTtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfY2FsbE1lc3NhZ2VzQ2FsbGJhY2tzKS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgdGhpcy5yZXBsYWNlTWVzc2FnZSA9IChpbmRleCwgbWVzc2FnZSkgPT4ge1xuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9tZXNzYWdlcywgW1xuICAgICAgICAuLi5fX3ByaXZhdGVHZXQodGhpcywgX21lc3NhZ2VzKS5zbGljZSgwLCBpbmRleCksXG4gICAgICAgIC8vIFdlIGRlZXAgY2xvbmUgdGhlIG1lc3NhZ2UgaGVyZSB0byBlbnN1cmUgdGhlIG5ldyBSZWFjdCBDb21waWxlciAoY3VycmVudGx5IGluIFJDKSBkZXRlY3RzIGRlZXBseSBuZXN0ZWQgcGFydHMvbWV0YWRhdGEgY2hhbmdlczpcbiAgICAgICAgdGhpcy5zbmFwc2hvdChtZXNzYWdlKSxcbiAgICAgICAgLi4uX19wcml2YXRlR2V0KHRoaXMsIF9tZXNzYWdlcykuc2xpY2UoaW5kZXggKyAxKVxuICAgICAgXSk7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX2NhbGxNZXNzYWdlc0NhbGxiYWNrcykuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHRoaXMuc25hcHNob3QgPSAodmFsdWUpID0+IHN0cnVjdHVyZWRDbG9uZSh2YWx1ZSk7XG4gICAgdGhpc1tcIn5yZWdpc3Rlck1lc3NhZ2VzQ2FsbGJhY2tcIl0gPSAob25DaGFuZ2UsIHRocm90dGxlV2FpdE1zKSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9IHRocm90dGxlV2FpdE1zID8gdGhyb3R0bGUob25DaGFuZ2UsIHRocm90dGxlV2FpdE1zKSA6IG9uQ2hhbmdlO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9tZXNzYWdlc0NhbGxiYWNrcykuYWRkKGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbWVzc2FnZXNDYWxsYmFja3MpLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICB9O1xuICAgIH07XG4gICAgdGhpc1tcIn5yZWdpc3RlclN0YXR1c0NhbGxiYWNrXCJdID0gKG9uQ2hhbmdlKSA9PiB7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX3N0YXR1c0NhbGxiYWNrcykuYWRkKG9uQ2hhbmdlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfc3RhdHVzQ2FsbGJhY2tzKS5kZWxldGUob25DaGFuZ2UpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHRoaXNbXCJ+cmVnaXN0ZXJFcnJvckNhbGxiYWNrXCJdID0gKG9uQ2hhbmdlKSA9PiB7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX2Vycm9yQ2FsbGJhY2tzKS5hZGQob25DaGFuZ2UpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9lcnJvckNhbGxiYWNrcykuZGVsZXRlKG9uQ2hhbmdlKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2NhbGxNZXNzYWdlc0NhbGxiYWNrcywgKCkgPT4ge1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9tZXNzYWdlc0NhbGxiYWNrcykuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKCkpO1xuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfY2FsbFN0YXR1c0NhbGxiYWNrcywgKCkgPT4ge1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9zdGF0dXNDYWxsYmFja3MpLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjaygpKTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2NhbGxFcnJvckNhbGxiYWNrcywgKCkgPT4ge1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9lcnJvckNhbGxiYWNrcykuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKCkpO1xuICAgIH0pO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfbWVzc2FnZXMsIGluaXRpYWxNZXNzYWdlcyk7XG4gIH1cbiAgZ2V0IHN0YXR1cygpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9zdGF0dXMpO1xuICB9XG4gIHNldCBzdGF0dXMobmV3U3RhdHVzKSB7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9zdGF0dXMsIG5ld1N0YXR1cyk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9jYWxsU3RhdHVzQ2FsbGJhY2tzKS5jYWxsKHRoaXMpO1xuICB9XG4gIGdldCBlcnJvcigpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9lcnJvcik7XG4gIH1cbiAgc2V0IGVycm9yKG5ld0Vycm9yKSB7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9lcnJvciwgbmV3RXJyb3IpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfY2FsbEVycm9yQ2FsbGJhY2tzKS5jYWxsKHRoaXMpO1xuICB9XG4gIGdldCBtZXNzYWdlcygpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9tZXNzYWdlcyk7XG4gIH1cbiAgc2V0IG1lc3NhZ2VzKG5ld01lc3NhZ2VzKSB7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9tZXNzYWdlcywgWy4uLm5ld01lc3NhZ2VzXSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9jYWxsTWVzc2FnZXNDYWxsYmFja3MpLmNhbGwodGhpcyk7XG4gIH1cbn07XG5fbWVzc2FnZXMgPSBuZXcgV2Vha01hcCgpO1xuX3N0YXR1cyA9IG5ldyBXZWFrTWFwKCk7XG5fZXJyb3IgPSBuZXcgV2Vha01hcCgpO1xuX21lc3NhZ2VzQ2FsbGJhY2tzID0gbmV3IFdlYWtNYXAoKTtcbl9zdGF0dXNDYWxsYmFja3MgPSBuZXcgV2Vha01hcCgpO1xuX2Vycm9yQ2FsbGJhY2tzID0gbmV3IFdlYWtNYXAoKTtcbl9jYWxsTWVzc2FnZXNDYWxsYmFja3MgPSBuZXcgV2Vha01hcCgpO1xuX2NhbGxTdGF0dXNDYWxsYmFja3MgPSBuZXcgV2Vha01hcCgpO1xuX2NhbGxFcnJvckNhbGxiYWNrcyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgX3N0YXRlO1xudmFyIENoYXQgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0Q2hhdCB7XG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZXMsIC4uLmluaXQgfSkge1xuICAgIGNvbnN0IHN0YXRlID0gbmV3IFJlYWN0Q2hhdFN0YXRlKG1lc3NhZ2VzKTtcbiAgICBzdXBlcih7IC4uLmluaXQsIHN0YXRlIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfc3RhdGUsIHZvaWQgMCk7XG4gICAgdGhpc1tcIn5yZWdpc3Rlck1lc3NhZ2VzQ2FsbGJhY2tcIl0gPSAob25DaGFuZ2UsIHRocm90dGxlV2FpdE1zKSA9PiBfX3ByaXZhdGVHZXQodGhpcywgX3N0YXRlKVtcIn5yZWdpc3Rlck1lc3NhZ2VzQ2FsbGJhY2tcIl0ob25DaGFuZ2UsIHRocm90dGxlV2FpdE1zKTtcbiAgICB0aGlzW1wifnJlZ2lzdGVyU3RhdHVzQ2FsbGJhY2tcIl0gPSAob25DaGFuZ2UpID0+IF9fcHJpdmF0ZUdldCh0aGlzLCBfc3RhdGUpW1wifnJlZ2lzdGVyU3RhdHVzQ2FsbGJhY2tcIl0ob25DaGFuZ2UpO1xuICAgIHRoaXNbXCJ+cmVnaXN0ZXJFcnJvckNhbGxiYWNrXCJdID0gKG9uQ2hhbmdlKSA9PiBfX3ByaXZhdGVHZXQodGhpcywgX3N0YXRlKVtcIn5yZWdpc3RlckVycm9yQ2FsbGJhY2tcIl0ob25DaGFuZ2UpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfc3RhdGUsIHN0YXRlKTtcbiAgfVxufTtcbl9zdGF0ZSA9IG5ldyBXZWFrTWFwKCk7XG5cbi8vIHNyYy91c2UtY2hhdC50c1xuZnVuY3Rpb24gdXNlQ2hhdCh7XG4gIGV4cGVyaW1lbnRhbF90aHJvdHRsZTogdGhyb3R0bGVXYWl0TXMsXG4gIHJlc3VtZSA9IGZhbHNlLFxuICAuLi5vcHRpb25zXG59ID0ge30pIHtcbiAgY29uc3QgY2FsbGJhY2tzUmVmID0gdXNlUmVmKFxuICAgICEoXCJjaGF0XCIgaW4gb3B0aW9ucykgPyB7XG4gICAgICBvblRvb2xDYWxsOiBvcHRpb25zLm9uVG9vbENhbGwsXG4gICAgICBvbkRhdGE6IG9wdGlvbnMub25EYXRhLFxuICAgICAgb25GaW5pc2g6IG9wdGlvbnMub25GaW5pc2gsXG4gICAgICBvbkVycm9yOiBvcHRpb25zLm9uRXJyb3IsXG4gICAgICBzZW5kQXV0b21hdGljYWxseVdoZW46IG9wdGlvbnMuc2VuZEF1dG9tYXRpY2FsbHlXaGVuXG4gICAgfSA6IHt9XG4gICk7XG4gIGlmICghKFwiY2hhdFwiIGluIG9wdGlvbnMpKSB7XG4gICAgY2FsbGJhY2tzUmVmLmN1cnJlbnQgPSB7XG4gICAgICBvblRvb2xDYWxsOiBvcHRpb25zLm9uVG9vbENhbGwsXG4gICAgICBvbkRhdGE6IG9wdGlvbnMub25EYXRhLFxuICAgICAgb25GaW5pc2g6IG9wdGlvbnMub25GaW5pc2gsXG4gICAgICBvbkVycm9yOiBvcHRpb25zLm9uRXJyb3IsXG4gICAgICBzZW5kQXV0b21hdGljYWxseVdoZW46IG9wdGlvbnMuc2VuZEF1dG9tYXRpY2FsbHlXaGVuXG4gICAgfTtcbiAgfVxuICBjb25zdCBvcHRpb25zV2l0aENhbGxiYWNrcyA9IHtcbiAgICAuLi5vcHRpb25zLFxuICAgIG9uVG9vbENhbGw6IChhcmcpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICByZXR1cm4gKF9iID0gKF9hID0gY2FsbGJhY2tzUmVmLmN1cnJlbnQpLm9uVG9vbENhbGwpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBhcmcpO1xuICAgIH0sXG4gICAgb25EYXRhOiAoYXJnKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgcmV0dXJuIChfYiA9IChfYSA9IGNhbGxiYWNrc1JlZi5jdXJyZW50KS5vbkRhdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBhcmcpO1xuICAgIH0sXG4gICAgb25GaW5pc2g6IChhcmcpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICByZXR1cm4gKF9iID0gKF9hID0gY2FsbGJhY2tzUmVmLmN1cnJlbnQpLm9uRmluaXNoKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgYXJnKTtcbiAgICB9LFxuICAgIG9uRXJyb3I6IChhcmcpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICByZXR1cm4gKF9iID0gKF9hID0gY2FsbGJhY2tzUmVmLmN1cnJlbnQpLm9uRXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBhcmcpO1xuICAgIH0sXG4gICAgc2VuZEF1dG9tYXRpY2FsbHlXaGVuOiAoYXJnKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgIHJldHVybiAoX2MgPSAoX2IgPSAoX2EgPSBjYWxsYmFja3NSZWYuY3VycmVudCkuc2VuZEF1dG9tYXRpY2FsbHlXaGVuKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgYXJnKSkgIT0gbnVsbCA/IF9jIDogZmFsc2U7XG4gICAgfVxuICB9O1xuICBjb25zdCBjaGF0UmVmID0gdXNlUmVmKFxuICAgIFwiY2hhdFwiIGluIG9wdGlvbnMgPyBvcHRpb25zLmNoYXQgOiBuZXcgQ2hhdChvcHRpb25zV2l0aENhbGxiYWNrcylcbiAgKTtcbiAgY29uc3Qgc2hvdWxkUmVjcmVhdGVDaGF0ID0gXCJjaGF0XCIgaW4gb3B0aW9ucyAmJiBvcHRpb25zLmNoYXQgIT09IGNoYXRSZWYuY3VycmVudCB8fCBcImlkXCIgaW4gb3B0aW9ucyAmJiBjaGF0UmVmLmN1cnJlbnQuaWQgIT09IG9wdGlvbnMuaWQ7XG4gIGlmIChzaG91bGRSZWNyZWF0ZUNoYXQpIHtcbiAgICBjaGF0UmVmLmN1cnJlbnQgPSBcImNoYXRcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5jaGF0IDogbmV3IENoYXQob3B0aW9uc1dpdGhDYWxsYmFja3MpO1xuICB9XG4gIGNvbnN0IHN1YnNjcmliZVRvTWVzc2FnZXMgPSB1c2VDYWxsYmFjayhcbiAgICAodXBkYXRlKSA9PiBjaGF0UmVmLmN1cnJlbnRbXCJ+cmVnaXN0ZXJNZXNzYWdlc0NhbGxiYWNrXCJdKHVwZGF0ZSwgdGhyb3R0bGVXYWl0TXMpLFxuICAgIC8vIGBjaGF0UmVmLmN1cnJlbnQuaWRgIGlzIHJlcXVpcmVkIHRvIHRyaWdnZXIgcmUtc3Vic2NyaXB0aW9uIHdoZW4gdGhlIGNoYXQgSUQgY2hhbmdlc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbdGhyb3R0bGVXYWl0TXMsIGNoYXRSZWYuY3VycmVudC5pZF1cbiAgKTtcbiAgY29uc3QgbWVzc2FnZXMgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICBzdWJzY3JpYmVUb01lc3NhZ2VzLFxuICAgICgpID0+IGNoYXRSZWYuY3VycmVudC5tZXNzYWdlcyxcbiAgICAoKSA9PiBjaGF0UmVmLmN1cnJlbnQubWVzc2FnZXNcbiAgKTtcbiAgY29uc3Qgc3RhdHVzID0gdXNlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgY2hhdFJlZi5jdXJyZW50W1wifnJlZ2lzdGVyU3RhdHVzQ2FsbGJhY2tcIl0sXG4gICAgKCkgPT4gY2hhdFJlZi5jdXJyZW50LnN0YXR1cyxcbiAgICAoKSA9PiBjaGF0UmVmLmN1cnJlbnQuc3RhdHVzXG4gICk7XG4gIGNvbnN0IGVycm9yID0gdXNlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgY2hhdFJlZi5jdXJyZW50W1wifnJlZ2lzdGVyRXJyb3JDYWxsYmFja1wiXSxcbiAgICAoKSA9PiBjaGF0UmVmLmN1cnJlbnQuZXJyb3IsXG4gICAgKCkgPT4gY2hhdFJlZi5jdXJyZW50LmVycm9yXG4gICk7XG4gIGNvbnN0IHNldE1lc3NhZ2VzID0gdXNlQ2FsbGJhY2soXG4gICAgKG1lc3NhZ2VzUGFyYW0pID0+IHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZXNQYXJhbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG1lc3NhZ2VzUGFyYW0gPSBtZXNzYWdlc1BhcmFtKGNoYXRSZWYuY3VycmVudC5tZXNzYWdlcyk7XG4gICAgICB9XG4gICAgICBjaGF0UmVmLmN1cnJlbnQubWVzc2FnZXMgPSBtZXNzYWdlc1BhcmFtO1xuICAgIH0sXG4gICAgW2NoYXRSZWZdXG4gICk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHJlc3VtZSkge1xuICAgICAgY2hhdFJlZi5jdXJyZW50LnJlc3VtZVN0cmVhbSgpO1xuICAgIH1cbiAgfSwgW3Jlc3VtZSwgY2hhdFJlZl0pO1xuICByZXR1cm4ge1xuICAgIGlkOiBjaGF0UmVmLmN1cnJlbnQuaWQsXG4gICAgbWVzc2FnZXMsXG4gICAgc2V0TWVzc2FnZXMsXG4gICAgc2VuZE1lc3NhZ2U6IGNoYXRSZWYuY3VycmVudC5zZW5kTWVzc2FnZSxcbiAgICByZWdlbmVyYXRlOiBjaGF0UmVmLmN1cnJlbnQucmVnZW5lcmF0ZSxcbiAgICBjbGVhckVycm9yOiBjaGF0UmVmLmN1cnJlbnQuY2xlYXJFcnJvcixcbiAgICBzdG9wOiBjaGF0UmVmLmN1cnJlbnQuc3RvcCxcbiAgICBlcnJvcixcbiAgICByZXN1bWVTdHJlYW06IGNoYXRSZWYuY3VycmVudC5yZXN1bWVTdHJlYW0sXG4gICAgc3RhdHVzLFxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgYWRkVG9vbE91dHB1dGAgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBhZGRUb29sUmVzdWx0OiBjaGF0UmVmLmN1cnJlbnQuYWRkVG9vbE91dHB1dCxcbiAgICBhZGRUb29sT3V0cHV0OiBjaGF0UmVmLmN1cnJlbnQuYWRkVG9vbE91dHB1dCxcbiAgICBhZGRUb29sQXBwcm92YWxSZXNwb25zZTogY2hhdFJlZi5jdXJyZW50LmFkZFRvb2xBcHByb3ZhbFJlc3BvbnNlXG4gIH07XG59XG5cbi8vIHNyYy91c2UtY29tcGxldGlvbi50c1xuaW1wb3J0IHtcbiAgY2FsbENvbXBsZXRpb25BcGlcbn0gZnJvbSBcImFpXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazIsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QyLCB1c2VJZCwgdXNlUmVmIGFzIHVzZVJlZjIsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdXNlU1dSIGZyb20gXCJzd3JcIjtcbmZ1bmN0aW9uIHVzZUNvbXBsZXRpb24oe1xuICBhcGkgPSBcIi9hcGkvY29tcGxldGlvblwiLFxuICBpZCxcbiAgaW5pdGlhbENvbXBsZXRpb24gPSBcIlwiLFxuICBpbml0aWFsSW5wdXQgPSBcIlwiLFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgc3RyZWFtUHJvdG9jb2wgPSBcImRhdGFcIixcbiAgZmV0Y2g6IGZldGNoMixcbiAgb25GaW5pc2gsXG4gIG9uRXJyb3IsXG4gIGV4cGVyaW1lbnRhbF90aHJvdHRsZTogdGhyb3R0bGVXYWl0TXNcbn0gPSB7fSkge1xuICBjb25zdCBob29rSWQgPSB1c2VJZCgpO1xuICBjb25zdCBjb21wbGV0aW9uSWQgPSBpZCB8fCBob29rSWQ7XG4gIGNvbnN0IHsgZGF0YSwgbXV0YXRlIH0gPSB1c2VTV1IoW2FwaSwgY29tcGxldGlvbklkXSwgbnVsbCwge1xuICAgIGZhbGxiYWNrRGF0YTogaW5pdGlhbENvbXBsZXRpb25cbiAgfSk7XG4gIGNvbnN0IHsgZGF0YTogaXNMb2FkaW5nID0gZmFsc2UsIG11dGF0ZTogbXV0YXRlTG9hZGluZyB9ID0gdXNlU1dSKFxuICAgIFtjb21wbGV0aW9uSWQsIFwibG9hZGluZ1wiXSxcbiAgICBudWxsXG4gICk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGUodm9pZCAwKTtcbiAgY29uc3QgY29tcGxldGlvbiA9IGRhdGE7XG4gIGNvbnN0IFthYm9ydENvbnRyb2xsZXIsIHNldEFib3J0Q29udHJvbGxlcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgZXh0cmFNZXRhZGF0YVJlZiA9IHVzZVJlZjIoe1xuICAgIGNyZWRlbnRpYWxzLFxuICAgIGhlYWRlcnMsXG4gICAgYm9keVxuICB9KTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50ID0ge1xuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sIFtjcmVkZW50aWFscywgaGVhZGVycywgYm9keV0pO1xuICBjb25zdCB0cmlnZ2VyUmVxdWVzdCA9IHVzZUNhbGxiYWNrMihcbiAgICBhc3luYyAocHJvbXB0LCBvcHRpb25zKSA9PiBjYWxsQ29tcGxldGlvbkFwaSh7XG4gICAgICBhcGksXG4gICAgICBwcm9tcHQsXG4gICAgICBjcmVkZW50aWFsczogZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmNyZWRlbnRpYWxzLFxuICAgICAgaGVhZGVyczogeyAuLi5leHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuaGVhZGVycywgLi4ub3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzIH0sXG4gICAgICBib2R5OiB7XG4gICAgICAgIC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5ib2R5LFxuICAgICAgICAuLi5vcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmJvZHlcbiAgICAgIH0sXG4gICAgICBzdHJlYW1Qcm90b2NvbCxcbiAgICAgIGZldGNoOiBmZXRjaDIsXG4gICAgICAvLyB0aHJvdHRsZSBzdHJlYW1lZCB1aSB1cGRhdGVzOlxuICAgICAgc2V0Q29tcGxldGlvbjogdGhyb3R0bGUoXG4gICAgICAgIChjb21wbGV0aW9uMikgPT4gbXV0YXRlKGNvbXBsZXRpb24yLCBmYWxzZSksXG4gICAgICAgIHRocm90dGxlV2FpdE1zXG4gICAgICApLFxuICAgICAgc2V0TG9hZGluZzogbXV0YXRlTG9hZGluZyxcbiAgICAgIHNldEVycm9yLFxuICAgICAgc2V0QWJvcnRDb250cm9sbGVyLFxuICAgICAgb25GaW5pc2gsXG4gICAgICBvbkVycm9yXG4gICAgfSksXG4gICAgW1xuICAgICAgbXV0YXRlLFxuICAgICAgbXV0YXRlTG9hZGluZyxcbiAgICAgIGFwaSxcbiAgICAgIGV4dHJhTWV0YWRhdGFSZWYsXG4gICAgICBzZXRBYm9ydENvbnRyb2xsZXIsXG4gICAgICBvbkZpbmlzaCxcbiAgICAgIG9uRXJyb3IsXG4gICAgICBzZXRFcnJvcixcbiAgICAgIHN0cmVhbVByb3RvY29sLFxuICAgICAgZmV0Y2gyLFxuICAgICAgdGhyb3R0bGVXYWl0TXNcbiAgICBdXG4gICk7XG4gIGNvbnN0IHN0b3AgPSB1c2VDYWxsYmFjazIoKCkgPT4ge1xuICAgIGlmIChhYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgIH1cbiAgfSwgW2Fib3J0Q29udHJvbGxlcl0pO1xuICBjb25zdCBzZXRDb21wbGV0aW9uID0gdXNlQ2FsbGJhY2syKFxuICAgIChjb21wbGV0aW9uMikgPT4ge1xuICAgICAgbXV0YXRlKGNvbXBsZXRpb24yLCBmYWxzZSk7XG4gICAgfSxcbiAgICBbbXV0YXRlXVxuICApO1xuICBjb25zdCBjb21wbGV0ZSA9IHVzZUNhbGxiYWNrMihcbiAgICBhc3luYyAocHJvbXB0LCBvcHRpb25zKSA9PiB7XG4gICAgICByZXR1cm4gdHJpZ2dlclJlcXVlc3QocHJvbXB0LCBvcHRpb25zKTtcbiAgICB9LFxuICAgIFt0cmlnZ2VyUmVxdWVzdF1cbiAgKTtcbiAgY29uc3QgW2lucHV0LCBzZXRJbnB1dF0gPSB1c2VTdGF0ZShpbml0aWFsSW5wdXQpO1xuICBjb25zdCBoYW5kbGVTdWJtaXQgPSB1c2VDYWxsYmFjazIoXG4gICAgKGV2ZW50KSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSBldmVudCA9PSBudWxsID8gdm9pZCAwIDogZXZlbnQucHJldmVudERlZmF1bHQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKGV2ZW50KTtcbiAgICAgIHJldHVybiBpbnB1dCA/IGNvbXBsZXRlKGlucHV0KSA6IHZvaWQgMDtcbiAgICB9LFxuICAgIFtpbnB1dCwgY29tcGxldGVdXG4gICk7XG4gIGNvbnN0IGhhbmRsZUlucHV0Q2hhbmdlID0gdXNlQ2FsbGJhY2syKFxuICAgIChlKSA9PiB7XG4gICAgICBzZXRJbnB1dChlLnRhcmdldC52YWx1ZSk7XG4gICAgfSxcbiAgICBbc2V0SW5wdXRdXG4gICk7XG4gIHJldHVybiB7XG4gICAgY29tcGxldGlvbixcbiAgICBjb21wbGV0ZSxcbiAgICBlcnJvcixcbiAgICBzZXRDb21wbGV0aW9uLFxuICAgIHN0b3AsXG4gICAgaW5wdXQsXG4gICAgc2V0SW5wdXQsXG4gICAgaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgaGFuZGxlU3VibWl0LFxuICAgIGlzTG9hZGluZ1xuICB9O1xufVxuXG4vLyBzcmMvdXNlLW9iamVjdC50c1xuaW1wb3J0IHtcbiAgaXNBYm9ydEVycm9yLFxuICByZXNvbHZlLFxuICBub3JtYWxpemVIZWFkZXJzLFxuICBzYWZlVmFsaWRhdGVUeXBlc1xufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuaW1wb3J0IHsgYXNTY2hlbWEsIGlzRGVlcEVxdWFsRGF0YSwgcGFyc2VQYXJ0aWFsSnNvbiB9IGZyb20gXCJhaVwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2szLCB1c2VJZCBhcyB1c2VJZDIsIHVzZVJlZiBhcyB1c2VSZWYzLCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTIgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB1c2VTV1IyIGZyb20gXCJzd3JcIjtcbnZhciBnZXRPcmlnaW5hbEZldGNoID0gKCkgPT4gZmV0Y2g7XG5mdW5jdGlvbiB1c2VPYmplY3Qoe1xuICBhcGksXG4gIGlkLFxuICBzY2hlbWEsXG4gIC8vIHJlcXVpcmVkLCBpbiB0aGUgZnV0dXJlIHdlIHdpbGwgdXNlIGl0IGZvciB2YWxpZGF0aW9uXG4gIGluaXRpYWxWYWx1ZSxcbiAgZmV0Y2g6IGZldGNoMixcbiAgb25FcnJvcixcbiAgb25GaW5pc2gsXG4gIGhlYWRlcnMsXG4gIGNyZWRlbnRpYWxzXG59KSB7XG4gIGNvbnN0IGhvb2tJZCA9IHVzZUlkMigpO1xuICBjb25zdCBjb21wbGV0aW9uSWQgPSBpZCAhPSBudWxsID8gaWQgOiBob29rSWQ7XG4gIGNvbnN0IHsgZGF0YSwgbXV0YXRlIH0gPSB1c2VTV1IyKFxuICAgIFthcGksIGNvbXBsZXRpb25JZF0sXG4gICAgbnVsbCxcbiAgICB7IGZhbGxiYWNrRGF0YTogaW5pdGlhbFZhbHVlIH1cbiAgKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTIodm9pZCAwKTtcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlMihmYWxzZSk7XG4gIGNvbnN0IGFib3J0Q29udHJvbGxlclJlZiA9IHVzZVJlZjMobnVsbCk7XG4gIGNvbnN0IHN0b3AgPSB1c2VDYWxsYmFjazMoKCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICB0cnkge1xuICAgICAgKF9hID0gYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5hYm9ydCgpO1xuICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3Qgc3VibWl0ID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHRyeSB7XG4gICAgICBjbGVhck9iamVjdCgpO1xuICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBhYm9ydENvbnRyb2xsZXI7XG4gICAgICBjb25zdCByZXNvbHZlZEhlYWRlcnMgPSBhd2FpdCByZXNvbHZlKGhlYWRlcnMpO1xuICAgICAgY29uc3QgYWN0dWFsRmV0Y2ggPSBmZXRjaDIgIT0gbnVsbCA/IGZldGNoMiA6IGdldE9yaWdpbmFsRmV0Y2goKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWN0dWFsRmV0Y2goYXBpLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5ub3JtYWxpemVIZWFkZXJzKHJlc29sdmVkSGVhZGVycylcbiAgICAgICAgfSxcbiAgICAgICAgY3JlZGVudGlhbHMsXG4gICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoaW5wdXQpXG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIChfYSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKSkgIT0gbnVsbCA/IF9hIDogXCJGYWlsZWQgdG8gZmV0Y2ggdGhlIHJlc3BvbnNlLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocmVzcG9uc2UuYm9keSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByZXNwb25zZSBib2R5IGlzIGVtcHR5LlwiKTtcbiAgICAgIH1cbiAgICAgIGxldCBhY2N1bXVsYXRlZFRleHQgPSBcIlwiO1xuICAgICAgbGV0IGxhdGVzdE9iamVjdCA9IHZvaWQgMDtcbiAgICAgIGF3YWl0IHJlc3BvbnNlLmJvZHkucGlwZVRocm91Z2gobmV3IFRleHREZWNvZGVyU3RyZWFtKCkpLnBpcGVUbyhcbiAgICAgICAgbmV3IFdyaXRhYmxlU3RyZWFtKHtcbiAgICAgICAgICBhc3luYyB3cml0ZShjaHVuaykge1xuICAgICAgICAgICAgYWNjdW11bGF0ZWRUZXh0ICs9IGNodW5rO1xuICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSB9ID0gYXdhaXQgcGFyc2VQYXJ0aWFsSnNvbihhY2N1bXVsYXRlZFRleHQpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudE9iamVjdCA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKCFpc0RlZXBFcXVhbERhdGEobGF0ZXN0T2JqZWN0LCBjdXJyZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgICBsYXRlc3RPYmplY3QgPSBjdXJyZW50T2JqZWN0O1xuICAgICAgICAgICAgICBtdXRhdGUoY3VycmVudE9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhc3luYyBjbG9zZSgpIHtcbiAgICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICBpZiAob25GaW5pc2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gYXdhaXQgc2FmZVZhbGlkYXRlVHlwZXMoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBsYXRlc3RPYmplY3QsXG4gICAgICAgICAgICAgICAgc2NoZW1hOiBhc1NjaGVtYShzY2hlbWEpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBvbkZpbmlzaChcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MgPyB7IG9iamVjdDogdmFsaWRhdGlvblJlc3VsdC52YWx1ZSwgZXJyb3I6IHZvaWQgMCB9IDogeyBvYmplY3Q6IHZvaWQgMCwgZXJyb3I6IHZhbGlkYXRpb25SZXN1bHQuZXJyb3IgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICBpZiAoaXNBYm9ydEVycm9yKGVycm9yMikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9uRXJyb3IgJiYgZXJyb3IyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgb25FcnJvcihlcnJvcjIpO1xuICAgICAgfVxuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgIHNldEVycm9yKGVycm9yMiBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IyIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcjIpKSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBjbGVhciA9ICgpID0+IHtcbiAgICBzdG9wKCk7XG4gICAgY2xlYXJPYmplY3QoKTtcbiAgfTtcbiAgY29uc3QgY2xlYXJPYmplY3QgPSAoKSA9PiB7XG4gICAgc2V0RXJyb3Iodm9pZCAwKTtcbiAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIG11dGF0ZSh2b2lkIDApO1xuICB9O1xuICByZXR1cm4ge1xuICAgIHN1Ym1pdCxcbiAgICBvYmplY3Q6IGRhdGEsXG4gICAgZXJyb3IsXG4gICAgaXNMb2FkaW5nLFxuICAgIHN0b3AsXG4gICAgY2xlYXJcbiAgfTtcbn1cbnZhciBleHBlcmltZW50YWxfdXNlT2JqZWN0ID0gdXNlT2JqZWN0O1xuZXhwb3J0IHtcbiAgQ2hhdCxcbiAgZXhwZXJpbWVudGFsX3VzZU9iamVjdCxcbiAgdXNlQ2hhdCxcbiAgdXNlQ29tcGxldGlvblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ai-sdk/react/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/dist/index.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/dist/index.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_MAX_DOWNLOAD_SIZE: () => (/* binding */ DEFAULT_MAX_DOWNLOAD_SIZE),\n/* harmony export */   DelayedPromise: () => (/* binding */ DelayedPromise),\n/* harmony export */   DownloadError: () => (/* binding */ DownloadError),\n/* harmony export */   EventSourceParserStream: () => (/* reexport safe */ eventsource_parser_stream__WEBPACK_IMPORTED_MODULE_4__.EventSourceParserStream),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   asSchema: () => (/* binding */ asSchema),\n/* harmony export */   combineHeaders: () => (/* binding */ combineHeaders),\n/* harmony export */   convertAsyncIteratorToReadableStream: () => (/* binding */ convertAsyncIteratorToReadableStream),\n/* harmony export */   convertBase64ToUint8Array: () => (/* binding */ convertBase64ToUint8Array),\n/* harmony export */   convertImageModelFileToDataUri: () => (/* binding */ convertImageModelFileToDataUri),\n/* harmony export */   convertToBase64: () => (/* binding */ convertToBase64),\n/* harmony export */   convertToFormData: () => (/* binding */ convertToFormData),\n/* harmony export */   convertUint8ArrayToBase64: () => (/* binding */ convertUint8ArrayToBase64),\n/* harmony export */   createBinaryResponseHandler: () => (/* binding */ createBinaryResponseHandler),\n/* harmony export */   createEventSourceResponseHandler: () => (/* binding */ createEventSourceResponseHandler),\n/* harmony export */   createIdGenerator: () => (/* binding */ createIdGenerator),\n/* harmony export */   createJsonErrorResponseHandler: () => (/* binding */ createJsonErrorResponseHandler),\n/* harmony export */   createJsonResponseHandler: () => (/* binding */ createJsonResponseHandler),\n/* harmony export */   createProviderToolFactory: () => (/* binding */ createProviderToolFactory),\n/* harmony export */   createProviderToolFactoryWithOutputSchema: () => (/* binding */ createProviderToolFactoryWithOutputSchema),\n/* harmony export */   createStatusCodeErrorResponseHandler: () => (/* binding */ createStatusCodeErrorResponseHandler),\n/* harmony export */   createToolNameMapping: () => (/* binding */ createToolNameMapping),\n/* harmony export */   delay: () => (/* binding */ delay),\n/* harmony export */   downloadBlob: () => (/* binding */ downloadBlob),\n/* harmony export */   dynamicTool: () => (/* binding */ dynamicTool),\n/* harmony export */   executeTool: () => (/* binding */ executeTool),\n/* harmony export */   extractResponseHeaders: () => (/* binding */ extractResponseHeaders),\n/* harmony export */   generateId: () => (/* binding */ generateId),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   getFromApi: () => (/* binding */ getFromApi),\n/* harmony export */   getRuntimeEnvironmentUserAgent: () => (/* binding */ getRuntimeEnvironmentUserAgent),\n/* harmony export */   injectJsonInstructionIntoMessages: () => (/* binding */ injectJsonInstructionIntoMessages),\n/* harmony export */   isAbortError: () => (/* binding */ isAbortError),\n/* harmony export */   isNonNullable: () => (/* binding */ isNonNullable),\n/* harmony export */   isParsableJson: () => (/* binding */ isParsableJson),\n/* harmony export */   isUrlSupported: () => (/* binding */ isUrlSupported),\n/* harmony export */   jsonSchema: () => (/* binding */ jsonSchema),\n/* harmony export */   lazySchema: () => (/* binding */ lazySchema),\n/* harmony export */   loadApiKey: () => (/* binding */ loadApiKey),\n/* harmony export */   loadOptionalSetting: () => (/* binding */ loadOptionalSetting),\n/* harmony export */   loadSetting: () => (/* binding */ loadSetting),\n/* harmony export */   mediaTypeToExtension: () => (/* binding */ mediaTypeToExtension),\n/* harmony export */   normalizeHeaders: () => (/* binding */ normalizeHeaders),\n/* harmony export */   parseJSON: () => (/* binding */ parseJSON),\n/* harmony export */   parseJsonEventStream: () => (/* binding */ parseJsonEventStream),\n/* harmony export */   parseProviderOptions: () => (/* binding */ parseProviderOptions),\n/* harmony export */   postFormDataToApi: () => (/* binding */ postFormDataToApi),\n/* harmony export */   postJsonToApi: () => (/* binding */ postJsonToApi),\n/* harmony export */   postToApi: () => (/* binding */ postToApi),\n/* harmony export */   readResponseWithSizeLimit: () => (/* binding */ readResponseWithSizeLimit),\n/* harmony export */   removeUndefinedEntries: () => (/* binding */ removeUndefinedEntries),\n/* harmony export */   resolve: () => (/* binding */ resolve),\n/* harmony export */   safeParseJSON: () => (/* binding */ safeParseJSON),\n/* harmony export */   safeValidateTypes: () => (/* binding */ safeValidateTypes),\n/* harmony export */   tool: () => (/* binding */ tool),\n/* harmony export */   validateTypes: () => (/* binding */ validateTypes),\n/* harmony export */   withUserAgentSuffix: () => (/* binding */ withUserAgentSuffix),\n/* harmony export */   withoutTrailingSlash: () => (/* binding */ withoutTrailingSlash),\n/* harmony export */   zodSchema: () => (/* binding */ zodSchema)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/provider */ \"(ssr)/./node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var zod_v4__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zod/v4 */ \"(ssr)/./node_modules/zod/v4/core/to-json-schema.js\");\n/* harmony import */ var zod_v4__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zod/v4 */ \"(ssr)/./node_modules/zod/v4/classic/parse.js\");\n/* harmony import */ var zod_v3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zod/v3 */ \"(ssr)/./node_modules/zod/v3/types.js\");\n/* harmony import */ var eventsource_parser_stream__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! eventsource-parser/stream */ \"(ssr)/./node_modules/eventsource-parser/dist/stream.js\");\n// src/combine-headers.ts\nfunction combineHeaders(...headers) {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => ({\n      ...combinedHeaders,\n      ...currentHeaders != null ? currentHeaders : {}\n    }),\n    {}\n  );\n}\n\n// src/convert-async-iterator-to-readable-stream.ts\nfunction convertAsyncIteratorToReadableStream(iterator) {\n  let cancelled = false;\n  return new ReadableStream({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      if (cancelled) return;\n      try {\n        const { value, done } = await iterator.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    async cancel(reason) {\n      cancelled = true;\n      if (iterator.return) {\n        try {\n          await iterator.return(reason);\n        } catch (e) {\n        }\n      }\n    }\n  });\n}\n\n// src/create-tool-name-mapping.ts\nfunction createToolNameMapping({\n  tools = [],\n  providerToolNames\n}) {\n  const customToolNameToProviderToolName = {};\n  const providerToolNameToCustomToolName = {};\n  for (const tool2 of tools) {\n    if (tool2.type === \"provider\" && tool2.id in providerToolNames) {\n      const providerToolName = providerToolNames[tool2.id];\n      customToolNameToProviderToolName[tool2.name] = providerToolName;\n      providerToolNameToCustomToolName[providerToolName] = tool2.name;\n    }\n  }\n  return {\n    toProviderToolName: (customToolName) => {\n      var _a2;\n      return (_a2 = customToolNameToProviderToolName[customToolName]) != null ? _a2 : customToolName;\n    },\n    toCustomToolName: (providerToolName) => {\n      var _a2;\n      return (_a2 = providerToolNameToCustomToolName[providerToolName]) != null ? _a2 : providerToolName;\n    }\n  };\n}\n\n// src/delay.ts\nasync function delay(delayInMs, options) {\n  if (delayInMs == null) {\n    return Promise.resolve();\n  }\n  const signal = options == null ? void 0 : options.abortSignal;\n  return new Promise((resolve2, reject) => {\n    if (signal == null ? void 0 : signal.aborted) {\n      reject(createAbortError());\n      return;\n    }\n    const timeoutId = setTimeout(() => {\n      cleanup();\n      resolve2();\n    }, delayInMs);\n    const cleanup = () => {\n      clearTimeout(timeoutId);\n      signal == null ? void 0 : signal.removeEventListener(\"abort\", onAbort);\n    };\n    const onAbort = () => {\n      cleanup();\n      reject(createAbortError());\n    };\n    signal == null ? void 0 : signal.addEventListener(\"abort\", onAbort);\n  });\n}\nfunction createAbortError() {\n  return new DOMException(\"Delay was aborted\", \"AbortError\");\n}\n\n// src/delayed-promise.ts\nvar DelayedPromise = class {\n  constructor() {\n    this.status = { type: \"pending\" };\n    this._resolve = void 0;\n    this._reject = void 0;\n  }\n  get promise() {\n    if (this._promise) {\n      return this._promise;\n    }\n    this._promise = new Promise((resolve2, reject) => {\n      if (this.status.type === \"resolved\") {\n        resolve2(this.status.value);\n      } else if (this.status.type === \"rejected\") {\n        reject(this.status.error);\n      }\n      this._resolve = resolve2;\n      this._reject = reject;\n    });\n    return this._promise;\n  }\n  resolve(value) {\n    var _a2;\n    this.status = { type: \"resolved\", value };\n    if (this._promise) {\n      (_a2 = this._resolve) == null ? void 0 : _a2.call(this, value);\n    }\n  }\n  reject(error) {\n    var _a2;\n    this.status = { type: \"rejected\", error };\n    if (this._promise) {\n      (_a2 = this._reject) == null ? void 0 : _a2.call(this, error);\n    }\n  }\n  isResolved() {\n    return this.status.type === \"resolved\";\n  }\n  isRejected() {\n    return this.status.type === \"rejected\";\n  }\n  isPending() {\n    return this.status.type === \"pending\";\n  }\n};\n\n// src/extract-response-headers.ts\nfunction extractResponseHeaders(response) {\n  return Object.fromEntries([...response.headers]);\n}\n\n// src/uint8-utils.ts\nvar { btoa, atob } = globalThis;\nfunction convertBase64ToUint8Array(base64String) {\n  const base64Url = base64String.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const latin1string = atob(base64Url);\n  return Uint8Array.from(latin1string, (byte) => byte.codePointAt(0));\n}\nfunction convertUint8ArrayToBase64(array) {\n  let latin1string = \"\";\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n  return btoa(latin1string);\n}\nfunction convertToBase64(value) {\n  return value instanceof Uint8Array ? convertUint8ArrayToBase64(value) : value;\n}\n\n// src/convert-image-model-file-to-data-uri.ts\nfunction convertImageModelFileToDataUri(file) {\n  if (file.type === \"url\") return file.url;\n  return `data:${file.mediaType};base64,${typeof file.data === \"string\" ? file.data : convertUint8ArrayToBase64(file.data)}`;\n}\n\n// src/convert-to-form-data.ts\nfunction convertToFormData(input, options = {}) {\n  const { useArrayBrackets = true } = options;\n  const formData = new FormData();\n  for (const [key, value] of Object.entries(input)) {\n    if (value == null) {\n      continue;\n    }\n    if (Array.isArray(value)) {\n      if (value.length === 1) {\n        formData.append(key, value[0]);\n        continue;\n      }\n      const arrayKey = useArrayBrackets ? `${key}[]` : key;\n      for (const item of value) {\n        formData.append(arrayKey, item);\n      }\n      continue;\n    }\n    formData.append(key, value);\n  }\n  return formData;\n}\n\n// src/download-error.ts\n\nvar name = \"AI_DownloadError\";\nvar marker = `vercel.ai.error.${name}`;\nvar symbol = Symbol.for(marker);\nvar _a, _b;\nvar DownloadError = class extends (_b = _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError, _a = symbol, _b) {\n  constructor({\n    url,\n    statusCode,\n    statusText,\n    cause,\n    message = cause == null ? `Failed to download ${url}: ${statusCode} ${statusText}` : `Failed to download ${url}: ${cause}`\n  }) {\n    super({ name, message, cause });\n    this[_a] = true;\n    this.url = url;\n    this.statusCode = statusCode;\n    this.statusText = statusText;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker);\n  }\n};\n\n// src/read-response-with-size-limit.ts\nvar DEFAULT_MAX_DOWNLOAD_SIZE = 2 * 1024 * 1024 * 1024;\nasync function readResponseWithSizeLimit({\n  response,\n  url,\n  maxBytes = DEFAULT_MAX_DOWNLOAD_SIZE\n}) {\n  const contentLength = response.headers.get(\"content-length\");\n  if (contentLength != null) {\n    const length = parseInt(contentLength, 10);\n    if (!isNaN(length) && length > maxBytes) {\n      throw new DownloadError({\n        url,\n        message: `Download of ${url} exceeded maximum size of ${maxBytes} bytes (Content-Length: ${length}).`\n      });\n    }\n  }\n  const body = response.body;\n  if (body == null) {\n    return new Uint8Array(0);\n  }\n  const reader = body.getReader();\n  const chunks = [];\n  let totalBytes = 0;\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) {\n        break;\n      }\n      totalBytes += value.length;\n      if (totalBytes > maxBytes) {\n        throw new DownloadError({\n          url,\n          message: `Download of ${url} exceeded maximum size of ${maxBytes} bytes.`\n        });\n      }\n      chunks.push(value);\n    }\n  } finally {\n    try {\n      await reader.cancel();\n    } finally {\n      reader.releaseLock();\n    }\n  }\n  const result = new Uint8Array(totalBytes);\n  let offset = 0;\n  for (const chunk of chunks) {\n    result.set(chunk, offset);\n    offset += chunk.length;\n  }\n  return result;\n}\n\n// src/download-blob.ts\nasync function downloadBlob(url, options) {\n  var _a2, _b2;\n  try {\n    const response = await fetch(url, {\n      signal: options == null ? void 0 : options.abortSignal\n    });\n    if (!response.ok) {\n      throw new DownloadError({\n        url,\n        statusCode: response.status,\n        statusText: response.statusText\n      });\n    }\n    const data = await readResponseWithSizeLimit({\n      response,\n      url,\n      maxBytes: (_a2 = options == null ? void 0 : options.maxBytes) != null ? _a2 : DEFAULT_MAX_DOWNLOAD_SIZE\n    });\n    const contentType = (_b2 = response.headers.get(\"content-type\")) != null ? _b2 : void 0;\n    return new Blob([data], contentType ? { type: contentType } : void 0);\n  } catch (error) {\n    if (DownloadError.isInstance(error)) {\n      throw error;\n    }\n    throw new DownloadError({ url, cause: error });\n  }\n}\n\n// src/generate-id.ts\n\nvar createIdGenerator = ({\n  prefix,\n  size = 16,\n  alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  separator = \"-\"\n} = {}) => {\n  const generator = () => {\n    const alphabetLength = alphabet.length;\n    const chars = new Array(size);\n    for (let i = 0; i < size; i++) {\n      chars[i] = alphabet[Math.random() * alphabetLength | 0];\n    }\n    return chars.join(\"\");\n  };\n  if (prefix == null) {\n    return generator;\n  }\n  if (alphabet.includes(separator)) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError({\n      argument: \"separator\",\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`\n    });\n  }\n  return () => `${prefix}${separator}${generator()}`;\n};\nvar generateId = createIdGenerator();\n\n// src/get-error-message.ts\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\n\n// src/get-from-api.ts\n\n\n// src/handle-fetch-error.ts\n\n\n// src/is-abort-error.ts\nfunction isAbortError(error) {\n  return (error instanceof Error || error instanceof DOMException) && (error.name === \"AbortError\" || error.name === \"ResponseAborted\" || // Next.js\n  error.name === \"TimeoutError\");\n}\n\n// src/handle-fetch-error.ts\nvar FETCH_FAILED_ERROR_MESSAGES = [\"fetch failed\", \"failed to fetch\"];\nvar BUN_ERROR_CODES = [\n  \"ConnectionRefused\",\n  \"ConnectionClosed\",\n  \"FailedToOpenSocket\",\n  \"ECONNRESET\",\n  \"ECONNREFUSED\",\n  \"ETIMEDOUT\",\n  \"EPIPE\"\n];\nfunction isBunNetworkError(error) {\n  if (!(error instanceof Error)) {\n    return false;\n  }\n  const code = error.code;\n  if (typeof code === \"string\" && BUN_ERROR_CODES.includes(code)) {\n    return true;\n  }\n  return false;\n}\nfunction handleFetchError({\n  error,\n  url,\n  requestBodyValues\n}) {\n  if (isAbortError(error)) {\n    return error;\n  }\n  if (error instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES.includes(error.message.toLowerCase())) {\n    const cause = error.cause;\n    if (cause != null) {\n      return new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n        message: `Cannot connect to API: ${cause.message}`,\n        cause,\n        url,\n        requestBodyValues,\n        isRetryable: true\n        // retry when network error\n      });\n    }\n  }\n  if (isBunNetworkError(error)) {\n    return new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n      message: `Cannot connect to API: ${error.message}`,\n      cause: error,\n      url,\n      requestBodyValues,\n      isRetryable: true\n    });\n  }\n  return error;\n}\n\n// src/get-runtime-environment-user-agent.ts\nfunction getRuntimeEnvironmentUserAgent(globalThisAny = globalThis) {\n  var _a2, _b2, _c;\n  if (globalThisAny.window) {\n    return `runtime/browser`;\n  }\n  if ((_a2 = globalThisAny.navigator) == null ? void 0 : _a2.userAgent) {\n    return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;\n  }\n  if ((_c = (_b2 = globalThisAny.process) == null ? void 0 : _b2.versions) == null ? void 0 : _c.node) {\n    return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;\n  }\n  if (globalThisAny.EdgeRuntime) {\n    return `runtime/vercel-edge`;\n  }\n  return \"runtime/unknown\";\n}\n\n// src/normalize-headers.ts\nfunction normalizeHeaders(headers) {\n  if (headers == null) {\n    return {};\n  }\n  const normalized = {};\n  if (headers instanceof Headers) {\n    headers.forEach((value, key) => {\n      normalized[key.toLowerCase()] = value;\n    });\n  } else {\n    if (!Array.isArray(headers)) {\n      headers = Object.entries(headers);\n    }\n    for (const [key, value] of headers) {\n      if (value != null) {\n        normalized[key.toLowerCase()] = value;\n      }\n    }\n  }\n  return normalized;\n}\n\n// src/with-user-agent-suffix.ts\nfunction withUserAgentSuffix(headers, ...userAgentSuffixParts) {\n  const normalizedHeaders = new Headers(normalizeHeaders(headers));\n  const currentUserAgentHeader = normalizedHeaders.get(\"user-agent\") || \"\";\n  normalizedHeaders.set(\n    \"user-agent\",\n    [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(\" \")\n  );\n  return Object.fromEntries(normalizedHeaders.entries());\n}\n\n// src/version.ts\nvar VERSION =  true ? \"4.0.15\" : 0;\n\n// src/get-from-api.ts\nvar getOriginalFetch = () => globalThis.fetch;\nvar getFromApi = async ({\n  url,\n  headers = {},\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch: fetch2 = getOriginalFetch()\n}) => {\n  try {\n    const response = await fetch2(url, {\n      method: \"GET\",\n      headers: withUserAgentSuffix(\n        headers,\n        `ai-sdk/provider-utils/${VERSION}`,\n        getRuntimeEnvironmentUserAgent()\n      ),\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: {}\n        });\n      } catch (error) {\n        if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError.isInstance(error)) {\n          throw error;\n        }\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n          message: \"Failed to process error response\",\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: {}\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: {}\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n        message: \"Failed to process successful response\",\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: {}\n      });\n    }\n  } catch (error) {\n    throw handleFetchError({ error, url, requestBodyValues: {} });\n  }\n};\n\n// src/inject-json-instruction.ts\nvar DEFAULT_SCHEMA_PREFIX = \"JSON schema:\";\nvar DEFAULT_SCHEMA_SUFFIX = \"You MUST answer with a JSON object that matches the JSON schema above.\";\nvar DEFAULT_GENERIC_SUFFIX = \"You MUST answer with JSON.\";\nfunction injectJsonInstruction({\n  prompt,\n  schema,\n  schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX : void 0,\n  schemaSuffix = schema != null ? DEFAULT_SCHEMA_SUFFIX : DEFAULT_GENERIC_SUFFIX\n}) {\n  return [\n    prompt != null && prompt.length > 0 ? prompt : void 0,\n    prompt != null && prompt.length > 0 ? \"\" : void 0,\n    // add a newline if prompt is not null\n    schemaPrefix,\n    schema != null ? JSON.stringify(schema) : void 0,\n    schemaSuffix\n  ].filter((line) => line != null).join(\"\\n\");\n}\nfunction injectJsonInstructionIntoMessages({\n  messages,\n  schema,\n  schemaPrefix,\n  schemaSuffix\n}) {\n  var _a2, _b2;\n  const systemMessage = ((_a2 = messages[0]) == null ? void 0 : _a2.role) === \"system\" ? { ...messages[0] } : { role: \"system\", content: \"\" };\n  systemMessage.content = injectJsonInstruction({\n    prompt: systemMessage.content,\n    schema,\n    schemaPrefix,\n    schemaSuffix\n  });\n  return [\n    systemMessage,\n    ...((_b2 = messages[0]) == null ? void 0 : _b2.role) === \"system\" ? messages.slice(1) : messages\n  ];\n}\n\n// src/is-non-nullable.ts\nfunction isNonNullable(value) {\n  return value != null;\n}\n\n// src/is-url-supported.ts\nfunction isUrlSupported({\n  mediaType,\n  url,\n  supportedUrls\n}) {\n  url = url.toLowerCase();\n  mediaType = mediaType.toLowerCase();\n  return Object.entries(supportedUrls).map(([key, value]) => {\n    const mediaType2 = key.toLowerCase();\n    return mediaType2 === \"*\" || mediaType2 === \"*/*\" ? { mediaTypePrefix: \"\", regexes: value } : { mediaTypePrefix: mediaType2.replace(/\\*/, \"\"), regexes: value };\n  }).filter(({ mediaTypePrefix }) => mediaType.startsWith(mediaTypePrefix)).flatMap(({ regexes }) => regexes).some((pattern) => pattern.test(url));\n}\n\n// src/load-api-key.ts\n\nfunction loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = \"apiKey\",\n  description\n}) {\n  if (typeof apiKey === \"string\") {\n    return apiKey;\n  }\n  if (apiKey != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadAPIKeyError({\n      message: `${description} API key must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  apiKey = process.env[environmentVariableName];\n  if (apiKey == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof apiKey !== \"string\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return apiKey;\n}\n\n// src/load-optional-setting.ts\nfunction loadOptionalSetting({\n  settingValue,\n  environmentVariableName\n}) {\n  if (typeof settingValue === \"string\") {\n    return settingValue;\n  }\n  if (settingValue != null || typeof process === \"undefined\") {\n    return void 0;\n  }\n  settingValue = process.env[environmentVariableName];\n  if (settingValue == null || typeof settingValue !== \"string\") {\n    return void 0;\n  }\n  return settingValue;\n}\n\n// src/load-setting.ts\n\nfunction loadSetting({\n  settingValue,\n  environmentVariableName,\n  settingName,\n  description\n}) {\n  if (typeof settingValue === \"string\") {\n    return settingValue;\n  }\n  if (settingValue != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadSettingError({\n      message: `${description} setting must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  settingValue = process.env[environmentVariableName];\n  if (settingValue == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof settingValue !== \"string\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadSettingError({\n      message: `${description} setting must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return settingValue;\n}\n\n// src/media-type-to-extension.ts\nfunction mediaTypeToExtension(mediaType) {\n  var _a2;\n  const [_type, subtype = \"\"] = mediaType.toLowerCase().split(\"/\");\n  return (_a2 = {\n    mpeg: \"mp3\",\n    \"x-wav\": \"wav\",\n    opus: \"ogg\",\n    mp4: \"m4a\",\n    \"x-m4a\": \"m4a\"\n  }[subtype]) != null ? _a2 : subtype;\n}\n\n// src/parse-json.ts\n\n\n// src/secure-json-parse.ts\nvar suspectProtoRx = /\"__proto__\"\\s*:/;\nvar suspectConstructorRx = /\"constructor\"\\s*:/;\nfunction _parse(text) {\n  const obj = JSON.parse(text);\n  if (obj === null || typeof obj !== \"object\") {\n    return obj;\n  }\n  if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {\n    return obj;\n  }\n  return filter(obj);\n}\nfunction filter(obj) {\n  let next = [obj];\n  while (next.length) {\n    const nodes = next;\n    next = [];\n    for (const node of nodes) {\n      if (Object.prototype.hasOwnProperty.call(node, \"__proto__\")) {\n        throw new SyntaxError(\"Object contains forbidden prototype property\");\n      }\n      if (Object.prototype.hasOwnProperty.call(node, \"constructor\") && Object.prototype.hasOwnProperty.call(node.constructor, \"prototype\")) {\n        throw new SyntaxError(\"Object contains forbidden prototype property\");\n      }\n      for (const key in node) {\n        const value = node[key];\n        if (value && typeof value === \"object\") {\n          next.push(value);\n        }\n      }\n    }\n  }\n  return obj;\n}\nfunction secureJsonParse(text) {\n  const { stackTraceLimit } = Error;\n  try {\n    Error.stackTraceLimit = 0;\n  } catch (e) {\n    return _parse(text);\n  }\n  try {\n    return _parse(text);\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit;\n  }\n}\n\n// src/validate-types.ts\n\n\n// src/schema.ts\n\n\n\n// src/add-additional-properties-to-json-schema.ts\nfunction addAdditionalPropertiesToJsonSchema(jsonSchema2) {\n  if (jsonSchema2.type === \"object\" || Array.isArray(jsonSchema2.type) && jsonSchema2.type.includes(\"object\")) {\n    jsonSchema2.additionalProperties = false;\n    const { properties } = jsonSchema2;\n    if (properties != null) {\n      for (const key of Object.keys(properties)) {\n        properties[key] = visit(properties[key]);\n      }\n    }\n  }\n  if (jsonSchema2.items != null) {\n    jsonSchema2.items = Array.isArray(jsonSchema2.items) ? jsonSchema2.items.map(visit) : visit(jsonSchema2.items);\n  }\n  if (jsonSchema2.anyOf != null) {\n    jsonSchema2.anyOf = jsonSchema2.anyOf.map(visit);\n  }\n  if (jsonSchema2.allOf != null) {\n    jsonSchema2.allOf = jsonSchema2.allOf.map(visit);\n  }\n  if (jsonSchema2.oneOf != null) {\n    jsonSchema2.oneOf = jsonSchema2.oneOf.map(visit);\n  }\n  const { definitions } = jsonSchema2;\n  if (definitions != null) {\n    for (const key of Object.keys(definitions)) {\n      definitions[key] = visit(definitions[key]);\n    }\n  }\n  return jsonSchema2;\n}\nfunction visit(def) {\n  if (typeof def === \"boolean\") return def;\n  return addAdditionalPropertiesToJsonSchema(def);\n}\n\n// src/to-json-schema/zod3-to-json-schema/options.ts\nvar ignoreOverride = Symbol(\n  \"Let zodToJsonSchema decide on which parser to use\"\n);\nvar defaultOptions = {\n  name: void 0,\n  $refStrategy: \"root\",\n  basePath: [\"#\"],\n  effectStrategy: \"input\",\n  pipeStrategy: \"all\",\n  dateStrategy: \"format:date-time\",\n  mapStrategy: \"entries\",\n  removeAdditionalStrategy: \"passthrough\",\n  allowedAdditionalProperties: true,\n  rejectedAdditionalProperties: false,\n  definitionPath: \"definitions\",\n  strictUnions: false,\n  definitions: {},\n  errorMessages: false,\n  patternStrategy: \"escape\",\n  applyRegexFlags: false,\n  emailStrategy: \"format:email\",\n  base64Strategy: \"contentEncoding:base64\",\n  nameStrategy: \"ref\"\n};\nvar getDefaultOptions = (options) => typeof options === \"string\" ? {\n  ...defaultOptions,\n  name: options\n} : {\n  ...defaultOptions,\n  ...options\n};\n\n// src/to-json-schema/zod3-to-json-schema/select-parser.ts\n\n\n// src/to-json-schema/zod3-to-json-schema/parsers/any.ts\nfunction parseAnyDef() {\n  return {};\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/array.ts\n\nfunction parseArrayDef(def, refs) {\n  var _a2, _b2, _c;\n  const res = {\n    type: \"array\"\n  };\n  if (((_a2 = def.type) == null ? void 0 : _a2._def) && ((_c = (_b2 = def.type) == null ? void 0 : _b2._def) == null ? void 0 : _c.typeName) !== zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodAny) {\n    res.items = parseDef(def.type._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"items\"]\n    });\n  }\n  if (def.minLength) {\n    res.minItems = def.minLength.value;\n  }\n  if (def.maxLength) {\n    res.maxItems = def.maxLength.value;\n  }\n  if (def.exactLength) {\n    res.minItems = def.exactLength.value;\n    res.maxItems = def.exactLength.value;\n  }\n  return res;\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/bigint.ts\nfunction parseBigintDef(def) {\n  const res = {\n    type: \"integer\",\n    format: \"int64\"\n  };\n  if (!def.checks) return res;\n  for (const check of def.checks) {\n    switch (check.kind) {\n      case \"min\":\n        if (check.inclusive) {\n          res.minimum = check.value;\n        } else {\n          res.exclusiveMinimum = check.value;\n        }\n        break;\n      case \"max\":\n        if (check.inclusive) {\n          res.maximum = check.value;\n        } else {\n          res.exclusiveMaximum = check.value;\n        }\n        break;\n      case \"multipleOf\":\n        res.multipleOf = check.value;\n        break;\n    }\n  }\n  return res;\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/boolean.ts\nfunction parseBooleanDef() {\n  return { type: \"boolean\" };\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/branded.ts\nfunction parseBrandedDef(_def, refs) {\n  return parseDef(_def.type._def, refs);\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/catch.ts\nvar parseCatchDef = (def, refs) => {\n  return parseDef(def.innerType._def, refs);\n};\n\n// src/to-json-schema/zod3-to-json-schema/parsers/date.ts\nfunction parseDateDef(def, refs, overrideDateStrategy) {\n  const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;\n  if (Array.isArray(strategy)) {\n    return {\n      anyOf: strategy.map((item, i) => parseDateDef(def, refs, item))\n    };\n  }\n  switch (strategy) {\n    case \"string\":\n    case \"format:date-time\":\n      return {\n        type: \"string\",\n        format: \"date-time\"\n      };\n    case \"format:date\":\n      return {\n        type: \"string\",\n        format: \"date\"\n      };\n    case \"integer\":\n      return integerDateParser(def);\n  }\n}\nvar integerDateParser = (def) => {\n  const res = {\n    type: \"integer\",\n    format: \"unix-time\"\n  };\n  for (const check of def.checks) {\n    switch (check.kind) {\n      case \"min\":\n        res.minimum = check.value;\n        break;\n      case \"max\":\n        res.maximum = check.value;\n        break;\n    }\n  }\n  return res;\n};\n\n// src/to-json-schema/zod3-to-json-schema/parsers/default.ts\nfunction parseDefaultDef(_def, refs) {\n  return {\n    ...parseDef(_def.innerType._def, refs),\n    default: _def.defaultValue()\n  };\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/effects.ts\nfunction parseEffectsDef(_def, refs) {\n  return refs.effectStrategy === \"input\" ? parseDef(_def.schema._def, refs) : parseAnyDef();\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/enum.ts\nfunction parseEnumDef(def) {\n  return {\n    type: \"string\",\n    enum: Array.from(def.values)\n  };\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/intersection.ts\nvar isJsonSchema7AllOfType = (type) => {\n  if (\"type\" in type && type.type === \"string\") return false;\n  return \"allOf\" in type;\n};\nfunction parseIntersectionDef(def, refs) {\n  const allOf = [\n    parseDef(def.left._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"allOf\", \"0\"]\n    }),\n    parseDef(def.right._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"allOf\", \"1\"]\n    })\n  ].filter((x) => !!x);\n  const mergedAllOf = [];\n  allOf.forEach((schema) => {\n    if (isJsonSchema7AllOfType(schema)) {\n      mergedAllOf.push(...schema.allOf);\n    } else {\n      let nestedSchema = schema;\n      if (\"additionalProperties\" in schema && schema.additionalProperties === false) {\n        const { additionalProperties, ...rest } = schema;\n        nestedSchema = rest;\n      }\n      mergedAllOf.push(nestedSchema);\n    }\n  });\n  return mergedAllOf.length ? { allOf: mergedAllOf } : void 0;\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/literal.ts\nfunction parseLiteralDef(def) {\n  const parsedType = typeof def.value;\n  if (parsedType !== \"bigint\" && parsedType !== \"number\" && parsedType !== \"boolean\" && parsedType !== \"string\") {\n    return {\n      type: Array.isArray(def.value) ? \"array\" : \"object\"\n    };\n  }\n  return {\n    type: parsedType === \"bigint\" ? \"integer\" : parsedType,\n    const: def.value\n  };\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/record.ts\n\n\n// src/to-json-schema/zod3-to-json-schema/parsers/string.ts\nvar emojiRegex = void 0;\nvar zodPatterns = {\n  /**\n   * `c` was changed to `[cC]` to replicate /i flag\n   */\n  cuid: /^[cC][^\\s-]{8,}$/,\n  cuid2: /^[0-9a-z]+$/,\n  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,\n  /**\n   * `a-z` was added to replicate /i flag\n   */\n  email: /^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_'+\\-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$/,\n  /**\n   * Constructed a valid Unicode RegExp\n   *\n   * Lazily instantiate since this type of regex isn't supported\n   * in all envs (e.g. React Native).\n   *\n   * See:\n   * https://github.com/colinhacks/zod/issues/2433\n   * Fix in Zod:\n   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b\n   */\n  emoji: () => {\n    if (emojiRegex === void 0) {\n      emojiRegex = RegExp(\n        \"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\",\n        \"u\"\n      );\n    }\n    return emojiRegex;\n  },\n  /**\n   * Unused\n   */\n  uuid: /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/,\n  /**\n   * Unused\n   */\n  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,\n  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/,\n  /**\n   * Unused\n   */\n  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,\n  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,\n  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,\n  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,\n  nanoid: /^[a-zA-Z0-9_-]{21}$/,\n  jwt: /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/\n};\nfunction parseStringDef(def, refs) {\n  const res = {\n    type: \"string\"\n  };\n  if (def.checks) {\n    for (const check of def.checks) {\n      switch (check.kind) {\n        case \"min\":\n          res.minLength = typeof res.minLength === \"number\" ? Math.max(res.minLength, check.value) : check.value;\n          break;\n        case \"max\":\n          res.maxLength = typeof res.maxLength === \"number\" ? Math.min(res.maxLength, check.value) : check.value;\n          break;\n        case \"email\":\n          switch (refs.emailStrategy) {\n            case \"format:email\":\n              addFormat(res, \"email\", check.message, refs);\n              break;\n            case \"format:idn-email\":\n              addFormat(res, \"idn-email\", check.message, refs);\n              break;\n            case \"pattern:zod\":\n              addPattern(res, zodPatterns.email, check.message, refs);\n              break;\n          }\n          break;\n        case \"url\":\n          addFormat(res, \"uri\", check.message, refs);\n          break;\n        case \"uuid\":\n          addFormat(res, \"uuid\", check.message, refs);\n          break;\n        case \"regex\":\n          addPattern(res, check.regex, check.message, refs);\n          break;\n        case \"cuid\":\n          addPattern(res, zodPatterns.cuid, check.message, refs);\n          break;\n        case \"cuid2\":\n          addPattern(res, zodPatterns.cuid2, check.message, refs);\n          break;\n        case \"startsWith\":\n          addPattern(\n            res,\n            RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`),\n            check.message,\n            refs\n          );\n          break;\n        case \"endsWith\":\n          addPattern(\n            res,\n            RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`),\n            check.message,\n            refs\n          );\n          break;\n        case \"datetime\":\n          addFormat(res, \"date-time\", check.message, refs);\n          break;\n        case \"date\":\n          addFormat(res, \"date\", check.message, refs);\n          break;\n        case \"time\":\n          addFormat(res, \"time\", check.message, refs);\n          break;\n        case \"duration\":\n          addFormat(res, \"duration\", check.message, refs);\n          break;\n        case \"length\":\n          res.minLength = typeof res.minLength === \"number\" ? Math.max(res.minLength, check.value) : check.value;\n          res.maxLength = typeof res.maxLength === \"number\" ? Math.min(res.maxLength, check.value) : check.value;\n          break;\n        case \"includes\": {\n          addPattern(\n            res,\n            RegExp(escapeLiteralCheckValue(check.value, refs)),\n            check.message,\n            refs\n          );\n          break;\n        }\n        case \"ip\": {\n          if (check.version !== \"v6\") {\n            addFormat(res, \"ipv4\", check.message, refs);\n          }\n          if (check.version !== \"v4\") {\n            addFormat(res, \"ipv6\", check.message, refs);\n          }\n          break;\n        }\n        case \"base64url\":\n          addPattern(res, zodPatterns.base64url, check.message, refs);\n          break;\n        case \"jwt\":\n          addPattern(res, zodPatterns.jwt, check.message, refs);\n          break;\n        case \"cidr\": {\n          if (check.version !== \"v6\") {\n            addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);\n          }\n          if (check.version !== \"v4\") {\n            addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);\n          }\n          break;\n        }\n        case \"emoji\":\n          addPattern(res, zodPatterns.emoji(), check.message, refs);\n          break;\n        case \"ulid\": {\n          addPattern(res, zodPatterns.ulid, check.message, refs);\n          break;\n        }\n        case \"base64\": {\n          switch (refs.base64Strategy) {\n            case \"format:binary\": {\n              addFormat(res, \"binary\", check.message, refs);\n              break;\n            }\n            case \"contentEncoding:base64\": {\n              res.contentEncoding = \"base64\";\n              break;\n            }\n            case \"pattern:zod\": {\n              addPattern(res, zodPatterns.base64, check.message, refs);\n              break;\n            }\n          }\n          break;\n        }\n        case \"nanoid\": {\n          addPattern(res, zodPatterns.nanoid, check.message, refs);\n        }\n        case \"toLowerCase\":\n        case \"toUpperCase\":\n        case \"trim\":\n          break;\n        default:\n          /* @__PURE__ */ ((_) => {\n          })(check);\n      }\n    }\n  }\n  return res;\n}\nfunction escapeLiteralCheckValue(literal, refs) {\n  return refs.patternStrategy === \"escape\" ? escapeNonAlphaNumeric(literal) : literal;\n}\nvar ALPHA_NUMERIC = new Set(\n  \"ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789\"\n);\nfunction escapeNonAlphaNumeric(source) {\n  let result = \"\";\n  for (let i = 0; i < source.length; i++) {\n    if (!ALPHA_NUMERIC.has(source[i])) {\n      result += \"\\\\\";\n    }\n    result += source[i];\n  }\n  return result;\n}\nfunction addFormat(schema, value, message, refs) {\n  var _a2;\n  if (schema.format || ((_a2 = schema.anyOf) == null ? void 0 : _a2.some((x) => x.format))) {\n    if (!schema.anyOf) {\n      schema.anyOf = [];\n    }\n    if (schema.format) {\n      schema.anyOf.push({\n        format: schema.format\n      });\n      delete schema.format;\n    }\n    schema.anyOf.push({\n      format: value,\n      ...message && refs.errorMessages && { errorMessage: { format: message } }\n    });\n  } else {\n    schema.format = value;\n  }\n}\nfunction addPattern(schema, regex, message, refs) {\n  var _a2;\n  if (schema.pattern || ((_a2 = schema.allOf) == null ? void 0 : _a2.some((x) => x.pattern))) {\n    if (!schema.allOf) {\n      schema.allOf = [];\n    }\n    if (schema.pattern) {\n      schema.allOf.push({\n        pattern: schema.pattern\n      });\n      delete schema.pattern;\n    }\n    schema.allOf.push({\n      pattern: stringifyRegExpWithFlags(regex, refs),\n      ...message && refs.errorMessages && { errorMessage: { pattern: message } }\n    });\n  } else {\n    schema.pattern = stringifyRegExpWithFlags(regex, refs);\n  }\n}\nfunction stringifyRegExpWithFlags(regex, refs) {\n  var _a2;\n  if (!refs.applyRegexFlags || !regex.flags) {\n    return regex.source;\n  }\n  const flags = {\n    i: regex.flags.includes(\"i\"),\n    // Case-insensitive\n    m: regex.flags.includes(\"m\"),\n    // `^` and `$` matches adjacent to newline characters\n    s: regex.flags.includes(\"s\")\n    // `.` matches newlines\n  };\n  const source = flags.i ? regex.source.toLowerCase() : regex.source;\n  let pattern = \"\";\n  let isEscaped = false;\n  let inCharGroup = false;\n  let inCharRange = false;\n  for (let i = 0; i < source.length; i++) {\n    if (isEscaped) {\n      pattern += source[i];\n      isEscaped = false;\n      continue;\n    }\n    if (flags.i) {\n      if (inCharGroup) {\n        if (source[i].match(/[a-z]/)) {\n          if (inCharRange) {\n            pattern += source[i];\n            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();\n            inCharRange = false;\n          } else if (source[i + 1] === \"-\" && ((_a2 = source[i + 2]) == null ? void 0 : _a2.match(/[a-z]/))) {\n            pattern += source[i];\n            inCharRange = true;\n          } else {\n            pattern += `${source[i]}${source[i].toUpperCase()}`;\n          }\n          continue;\n        }\n      } else if (source[i].match(/[a-z]/)) {\n        pattern += `[${source[i]}${source[i].toUpperCase()}]`;\n        continue;\n      }\n    }\n    if (flags.m) {\n      if (source[i] === \"^\") {\n        pattern += `(^|(?<=[\\r\n]))`;\n        continue;\n      } else if (source[i] === \"$\") {\n        pattern += `($|(?=[\\r\n]))`;\n        continue;\n      }\n    }\n    if (flags.s && source[i] === \".\") {\n      pattern += inCharGroup ? `${source[i]}\\r\n` : `[${source[i]}\\r\n]`;\n      continue;\n    }\n    pattern += source[i];\n    if (source[i] === \"\\\\\") {\n      isEscaped = true;\n    } else if (inCharGroup && source[i] === \"]\") {\n      inCharGroup = false;\n    } else if (!inCharGroup && source[i] === \"[\") {\n      inCharGroup = true;\n    }\n  }\n  try {\n    new RegExp(pattern);\n  } catch (e) {\n    console.warn(\n      `Could not convert regex pattern at ${refs.currentPath.join(\n        \"/\"\n      )} to a flag-independent form! Falling back to the flag-ignorant source`\n    );\n    return regex.source;\n  }\n  return pattern;\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/record.ts\nfunction parseRecordDef(def, refs) {\n  var _a2, _b2, _c, _d, _e, _f;\n  const schema = {\n    type: \"object\",\n    additionalProperties: (_a2 = parseDef(def.valueType._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"additionalProperties\"]\n    })) != null ? _a2 : refs.allowedAdditionalProperties\n  };\n  if (((_b2 = def.keyType) == null ? void 0 : _b2._def.typeName) === zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {\n    const { type, ...keyType } = parseStringDef(def.keyType._def, refs);\n    return {\n      ...schema,\n      propertyNames: keyType\n    };\n  } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodEnum) {\n    return {\n      ...schema,\n      propertyNames: {\n        enum: def.keyType._def.values\n      }\n    };\n  } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {\n    const { type, ...keyType } = parseBrandedDef(\n      def.keyType._def,\n      refs\n    );\n    return {\n      ...schema,\n      propertyNames: keyType\n    };\n  }\n  return schema;\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/map.ts\nfunction parseMapDef(def, refs) {\n  if (refs.mapStrategy === \"record\") {\n    return parseRecordDef(def, refs);\n  }\n  const keys = parseDef(def.keyType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"items\", \"items\", \"0\"]\n  }) || parseAnyDef();\n  const values = parseDef(def.valueType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"items\", \"items\", \"1\"]\n  }) || parseAnyDef();\n  return {\n    type: \"array\",\n    maxItems: 125,\n    items: {\n      type: \"array\",\n      items: [keys, values],\n      minItems: 2,\n      maxItems: 2\n    }\n  };\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/native-enum.ts\nfunction parseNativeEnumDef(def) {\n  const object = def.values;\n  const actualKeys = Object.keys(def.values).filter((key) => {\n    return typeof object[object[key]] !== \"number\";\n  });\n  const actualValues = actualKeys.map((key) => object[key]);\n  const parsedTypes = Array.from(\n    new Set(actualValues.map((values) => typeof values))\n  );\n  return {\n    type: parsedTypes.length === 1 ? parsedTypes[0] === \"string\" ? \"string\" : \"number\" : [\"string\", \"number\"],\n    enum: actualValues\n  };\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/never.ts\nfunction parseNeverDef() {\n  return { not: parseAnyDef() };\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/null.ts\nfunction parseNullDef() {\n  return {\n    type: \"null\"\n  };\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/union.ts\nvar primitiveMappings = {\n  ZodString: \"string\",\n  ZodNumber: \"number\",\n  ZodBigInt: \"integer\",\n  ZodBoolean: \"boolean\",\n  ZodNull: \"null\"\n};\nfunction parseUnionDef(def, refs) {\n  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;\n  if (options.every(\n    (x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length)\n  )) {\n    const types = options.reduce((types2, x) => {\n      const type = primitiveMappings[x._def.typeName];\n      return type && !types2.includes(type) ? [...types2, type] : types2;\n    }, []);\n    return {\n      type: types.length > 1 ? types : types[0]\n    };\n  } else if (options.every((x) => x._def.typeName === \"ZodLiteral\" && !x.description)) {\n    const types = options.reduce(\n      (acc, x) => {\n        const type = typeof x._def.value;\n        switch (type) {\n          case \"string\":\n          case \"number\":\n          case \"boolean\":\n            return [...acc, type];\n          case \"bigint\":\n            return [...acc, \"integer\"];\n          case \"object\":\n            if (x._def.value === null) return [...acc, \"null\"];\n          case \"symbol\":\n          case \"undefined\":\n          case \"function\":\n          default:\n            return acc;\n        }\n      },\n      []\n    );\n    if (types.length === options.length) {\n      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);\n      return {\n        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],\n        enum: options.reduce(\n          (acc, x) => {\n            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];\n          },\n          []\n        )\n      };\n    }\n  } else if (options.every((x) => x._def.typeName === \"ZodEnum\")) {\n    return {\n      type: \"string\",\n      enum: options.reduce(\n        (acc, x) => [\n          ...acc,\n          ...x._def.values.filter((x2) => !acc.includes(x2))\n        ],\n        []\n      )\n    };\n  }\n  return asAnyOf(def, refs);\n}\nvar asAnyOf = (def, refs) => {\n  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map(\n    (x, i) => parseDef(x._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"anyOf\", `${i}`]\n    })\n  ).filter(\n    (x) => !!x && (!refs.strictUnions || typeof x === \"object\" && Object.keys(x).length > 0)\n  );\n  return anyOf.length ? { anyOf } : void 0;\n};\n\n// src/to-json-schema/zod3-to-json-schema/parsers/nullable.ts\nfunction parseNullableDef(def, refs) {\n  if ([\"ZodString\", \"ZodNumber\", \"ZodBigInt\", \"ZodBoolean\", \"ZodNull\"].includes(\n    def.innerType._def.typeName\n  ) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {\n    return {\n      type: [\n        primitiveMappings[def.innerType._def.typeName],\n        \"null\"\n      ]\n    };\n  }\n  const base = parseDef(def.innerType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"anyOf\", \"0\"]\n  });\n  return base && { anyOf: [base, { type: \"null\" }] };\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/number.ts\nfunction parseNumberDef(def) {\n  const res = {\n    type: \"number\"\n  };\n  if (!def.checks) return res;\n  for (const check of def.checks) {\n    switch (check.kind) {\n      case \"int\":\n        res.type = \"integer\";\n        break;\n      case \"min\":\n        if (check.inclusive) {\n          res.minimum = check.value;\n        } else {\n          res.exclusiveMinimum = check.value;\n        }\n        break;\n      case \"max\":\n        if (check.inclusive) {\n          res.maximum = check.value;\n        } else {\n          res.exclusiveMaximum = check.value;\n        }\n        break;\n      case \"multipleOf\":\n        res.multipleOf = check.value;\n        break;\n    }\n  }\n  return res;\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/object.ts\nfunction parseObjectDef(def, refs) {\n  const result = {\n    type: \"object\",\n    properties: {}\n  };\n  const required = [];\n  const shape = def.shape();\n  for (const propName in shape) {\n    let propDef = shape[propName];\n    if (propDef === void 0 || propDef._def === void 0) {\n      continue;\n    }\n    const propOptional = safeIsOptional(propDef);\n    const parsedDef = parseDef(propDef._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"properties\", propName],\n      propertyPath: [...refs.currentPath, \"properties\", propName]\n    });\n    if (parsedDef === void 0) {\n      continue;\n    }\n    result.properties[propName] = parsedDef;\n    if (!propOptional) {\n      required.push(propName);\n    }\n  }\n  if (required.length) {\n    result.required = required;\n  }\n  const additionalProperties = decideAdditionalProperties(def, refs);\n  if (additionalProperties !== void 0) {\n    result.additionalProperties = additionalProperties;\n  }\n  return result;\n}\nfunction decideAdditionalProperties(def, refs) {\n  if (def.catchall._def.typeName !== \"ZodNever\") {\n    return parseDef(def.catchall._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"additionalProperties\"]\n    });\n  }\n  switch (def.unknownKeys) {\n    case \"passthrough\":\n      return refs.allowedAdditionalProperties;\n    case \"strict\":\n      return refs.rejectedAdditionalProperties;\n    case \"strip\":\n      return refs.removeAdditionalStrategy === \"strict\" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;\n  }\n}\nfunction safeIsOptional(schema) {\n  try {\n    return schema.isOptional();\n  } catch (e) {\n    return true;\n  }\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/optional.ts\nvar parseOptionalDef = (def, refs) => {\n  var _a2;\n  if (refs.currentPath.toString() === ((_a2 = refs.propertyPath) == null ? void 0 : _a2.toString())) {\n    return parseDef(def.innerType._def, refs);\n  }\n  const innerSchema = parseDef(def.innerType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"anyOf\", \"1\"]\n  });\n  return innerSchema ? { anyOf: [{ not: parseAnyDef() }, innerSchema] } : parseAnyDef();\n};\n\n// src/to-json-schema/zod3-to-json-schema/parsers/pipeline.ts\nvar parsePipelineDef = (def, refs) => {\n  if (refs.pipeStrategy === \"input\") {\n    return parseDef(def.in._def, refs);\n  } else if (refs.pipeStrategy === \"output\") {\n    return parseDef(def.out._def, refs);\n  }\n  const a = parseDef(def.in._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"allOf\", \"0\"]\n  });\n  const b = parseDef(def.out._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"allOf\", a ? \"1\" : \"0\"]\n  });\n  return {\n    allOf: [a, b].filter((x) => x !== void 0)\n  };\n};\n\n// src/to-json-schema/zod3-to-json-schema/parsers/promise.ts\nfunction parsePromiseDef(def, refs) {\n  return parseDef(def.type._def, refs);\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/set.ts\nfunction parseSetDef(def, refs) {\n  const items = parseDef(def.valueType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"items\"]\n  });\n  const schema = {\n    type: \"array\",\n    uniqueItems: true,\n    items\n  };\n  if (def.minSize) {\n    schema.minItems = def.minSize.value;\n  }\n  if (def.maxSize) {\n    schema.maxItems = def.maxSize.value;\n  }\n  return schema;\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/tuple.ts\nfunction parseTupleDef(def, refs) {\n  if (def.rest) {\n    return {\n      type: \"array\",\n      minItems: def.items.length,\n      items: def.items.map(\n        (x, i) => parseDef(x._def, {\n          ...refs,\n          currentPath: [...refs.currentPath, \"items\", `${i}`]\n        })\n      ).reduce(\n        (acc, x) => x === void 0 ? acc : [...acc, x],\n        []\n      ),\n      additionalItems: parseDef(def.rest._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"additionalItems\"]\n      })\n    };\n  } else {\n    return {\n      type: \"array\",\n      minItems: def.items.length,\n      maxItems: def.items.length,\n      items: def.items.map(\n        (x, i) => parseDef(x._def, {\n          ...refs,\n          currentPath: [...refs.currentPath, \"items\", `${i}`]\n        })\n      ).reduce(\n        (acc, x) => x === void 0 ? acc : [...acc, x],\n        []\n      )\n    };\n  }\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/undefined.ts\nfunction parseUndefinedDef() {\n  return {\n    not: parseAnyDef()\n  };\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/unknown.ts\nfunction parseUnknownDef() {\n  return parseAnyDef();\n}\n\n// src/to-json-schema/zod3-to-json-schema/parsers/readonly.ts\nvar parseReadonlyDef = (def, refs) => {\n  return parseDef(def.innerType._def, refs);\n};\n\n// src/to-json-schema/zod3-to-json-schema/select-parser.ts\nvar selectParser = (def, typeName, refs) => {\n  switch (typeName) {\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodString:\n      return parseStringDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodNumber:\n      return parseNumberDef(def);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodObject:\n      return parseObjectDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodBigInt:\n      return parseBigintDef(def);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodBoolean:\n      return parseBooleanDef();\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodDate:\n      return parseDateDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodUndefined:\n      return parseUndefinedDef();\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodNull:\n      return parseNullDef();\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodArray:\n      return parseArrayDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodUnion:\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:\n      return parseUnionDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodIntersection:\n      return parseIntersectionDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodTuple:\n      return parseTupleDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodRecord:\n      return parseRecordDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodLiteral:\n      return parseLiteralDef(def);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodEnum:\n      return parseEnumDef(def);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodNativeEnum:\n      return parseNativeEnumDef(def);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodNullable:\n      return parseNullableDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodOptional:\n      return parseOptionalDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodMap:\n      return parseMapDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodSet:\n      return parseSetDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodLazy:\n      return () => def.getter()._def;\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodPromise:\n      return parsePromiseDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodNaN:\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodNever:\n      return parseNeverDef();\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodEffects:\n      return parseEffectsDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodAny:\n      return parseAnyDef();\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodUnknown:\n      return parseUnknownDef();\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodDefault:\n      return parseDefaultDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodBranded:\n      return parseBrandedDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodReadonly:\n      return parseReadonlyDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodCatch:\n      return parseCatchDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodPipeline:\n      return parsePipelineDef(def, refs);\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodFunction:\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodVoid:\n    case zod_v3__WEBPACK_IMPORTED_MODULE_1__.ZodFirstPartyTypeKind.ZodSymbol:\n      return void 0;\n    default:\n      return /* @__PURE__ */ ((_) => void 0)(typeName);\n  }\n};\n\n// src/to-json-schema/zod3-to-json-schema/get-relative-path.ts\nvar getRelativePath = (pathA, pathB) => {\n  let i = 0;\n  for (; i < pathA.length && i < pathB.length; i++) {\n    if (pathA[i] !== pathB[i]) break;\n  }\n  return [(pathA.length - i).toString(), ...pathB.slice(i)].join(\"/\");\n};\n\n// src/to-json-schema/zod3-to-json-schema/parse-def.ts\nfunction parseDef(def, refs, forceResolution = false) {\n  var _a2;\n  const seenItem = refs.seen.get(def);\n  if (refs.override) {\n    const overrideResult = (_a2 = refs.override) == null ? void 0 : _a2.call(\n      refs,\n      def,\n      refs,\n      seenItem,\n      forceResolution\n    );\n    if (overrideResult !== ignoreOverride) {\n      return overrideResult;\n    }\n  }\n  if (seenItem && !forceResolution) {\n    const seenSchema = get$ref(seenItem, refs);\n    if (seenSchema !== void 0) {\n      return seenSchema;\n    }\n  }\n  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };\n  refs.seen.set(def, newItem);\n  const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);\n  const jsonSchema2 = typeof jsonSchemaOrGetter === \"function\" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;\n  if (jsonSchema2) {\n    addMeta(def, refs, jsonSchema2);\n  }\n  if (refs.postProcess) {\n    const postProcessResult = refs.postProcess(jsonSchema2, def, refs);\n    newItem.jsonSchema = jsonSchema2;\n    return postProcessResult;\n  }\n  newItem.jsonSchema = jsonSchema2;\n  return jsonSchema2;\n}\nvar get$ref = (item, refs) => {\n  switch (refs.$refStrategy) {\n    case \"root\":\n      return { $ref: item.path.join(\"/\") };\n    case \"relative\":\n      return { $ref: getRelativePath(refs.currentPath, item.path) };\n    case \"none\":\n    case \"seen\": {\n      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {\n        console.warn(\n          `Recursive reference detected at ${refs.currentPath.join(\n            \"/\"\n          )}! Defaulting to any`\n        );\n        return parseAnyDef();\n      }\n      return refs.$refStrategy === \"seen\" ? parseAnyDef() : void 0;\n    }\n  }\n};\nvar addMeta = (def, refs, jsonSchema2) => {\n  if (def.description) {\n    jsonSchema2.description = def.description;\n  }\n  return jsonSchema2;\n};\n\n// src/to-json-schema/zod3-to-json-schema/refs.ts\nvar getRefs = (options) => {\n  const _options = getDefaultOptions(options);\n  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;\n  return {\n    ..._options,\n    currentPath,\n    propertyPath: void 0,\n    seen: new Map(\n      Object.entries(_options.definitions).map(([name2, def]) => [\n        def._def,\n        {\n          def: def._def,\n          path: [..._options.basePath, _options.definitionPath, name2],\n          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.\n          jsonSchema: void 0\n        }\n      ])\n    )\n  };\n};\n\n// src/to-json-schema/zod3-to-json-schema/zod3-to-json-schema.ts\nvar zod3ToJsonSchema = (schema, options) => {\n  var _a2;\n  const refs = getRefs(options);\n  let definitions = typeof options === \"object\" && options.definitions ? Object.entries(options.definitions).reduce(\n    (acc, [name3, schema2]) => {\n      var _a3;\n      return {\n        ...acc,\n        [name3]: (_a3 = parseDef(\n          schema2._def,\n          {\n            ...refs,\n            currentPath: [...refs.basePath, refs.definitionPath, name3]\n          },\n          true\n        )) != null ? _a3 : parseAnyDef()\n      };\n    },\n    {}\n  ) : void 0;\n  const name2 = typeof options === \"string\" ? options : (options == null ? void 0 : options.nameStrategy) === \"title\" ? void 0 : options == null ? void 0 : options.name;\n  const main = (_a2 = parseDef(\n    schema._def,\n    name2 === void 0 ? refs : {\n      ...refs,\n      currentPath: [...refs.basePath, refs.definitionPath, name2]\n    },\n    false\n  )) != null ? _a2 : parseAnyDef();\n  const title = typeof options === \"object\" && options.name !== void 0 && options.nameStrategy === \"title\" ? options.name : void 0;\n  if (title !== void 0) {\n    main.title = title;\n  }\n  const combined = name2 === void 0 ? definitions ? {\n    ...main,\n    [refs.definitionPath]: definitions\n  } : main : {\n    $ref: [\n      ...refs.$refStrategy === \"relative\" ? [] : refs.basePath,\n      refs.definitionPath,\n      name2\n    ].join(\"/\"),\n    [refs.definitionPath]: {\n      ...definitions,\n      [name2]: main\n    }\n  };\n  combined.$schema = \"http://json-schema.org/draft-07/schema#\";\n  return combined;\n};\n\n// src/schema.ts\nvar schemaSymbol = Symbol.for(\"vercel.ai.schema\");\nfunction lazySchema(createSchema) {\n  let schema;\n  return () => {\n    if (schema == null) {\n      schema = createSchema();\n    }\n    return schema;\n  };\n}\nfunction jsonSchema(jsonSchema2, {\n  validate\n} = {}) {\n  return {\n    [schemaSymbol]: true,\n    _type: void 0,\n    // should never be used directly\n    get jsonSchema() {\n      if (typeof jsonSchema2 === \"function\") {\n        jsonSchema2 = jsonSchema2();\n      }\n      return jsonSchema2;\n    },\n    validate\n  };\n}\nfunction isSchema(value) {\n  return typeof value === \"object\" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && \"jsonSchema\" in value && \"validate\" in value;\n}\nfunction asSchema(schema) {\n  return schema == null ? jsonSchema({ properties: {}, additionalProperties: false }) : isSchema(schema) ? schema : \"~standard\" in schema ? schema[\"~standard\"].vendor === \"zod\" ? zodSchema(schema) : standardSchema(schema) : schema();\n}\nfunction standardSchema(standardSchema2) {\n  return jsonSchema(\n    () => addAdditionalPropertiesToJsonSchema(\n      standardSchema2[\"~standard\"].jsonSchema.input({\n        target: \"draft-07\"\n      })\n    ),\n    {\n      validate: async (value) => {\n        const result = await standardSchema2[\"~standard\"].validate(value);\n        return \"value\" in result ? { success: true, value: result.value } : {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: result.issues\n          })\n        };\n      }\n    }\n  );\n}\nfunction zod3Schema(zodSchema2, options) {\n  var _a2;\n  const useReferences = (_a2 = options == null ? void 0 : options.useReferences) != null ? _a2 : false;\n  return jsonSchema(\n    // defer json schema creation to avoid unnecessary computation when only validation is needed\n    () => zod3ToJsonSchema(zodSchema2, {\n      $refStrategy: useReferences ? \"root\" : \"none\"\n    }),\n    {\n      validate: async (value) => {\n        const result = await zodSchema2.safeParseAsync(value);\n        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };\n      }\n    }\n  );\n}\nfunction zod4Schema(zodSchema2, options) {\n  var _a2;\n  const useReferences = (_a2 = options == null ? void 0 : options.useReferences) != null ? _a2 : false;\n  return jsonSchema(\n    // defer json schema creation to avoid unnecessary computation when only validation is needed\n    () => addAdditionalPropertiesToJsonSchema(\n      zod_v4__WEBPACK_IMPORTED_MODULE_2__.toJSONSchema(zodSchema2, {\n        target: \"draft-7\",\n        io: \"input\",\n        reused: useReferences ? \"ref\" : \"inline\"\n      })\n    ),\n    {\n      validate: async (value) => {\n        const result = await zod_v4__WEBPACK_IMPORTED_MODULE_3__.safeParseAsync(zodSchema2, value);\n        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };\n      }\n    }\n  );\n}\nfunction isZod4Schema(zodSchema2) {\n  return \"_zod\" in zodSchema2;\n}\nfunction zodSchema(zodSchema2, options) {\n  if (isZod4Schema(zodSchema2)) {\n    return zod4Schema(zodSchema2, options);\n  } else {\n    return zod3Schema(zodSchema2, options);\n  }\n}\n\n// src/validate-types.ts\nasync function validateTypes({\n  value,\n  schema,\n  context\n}) {\n  const result = await safeValidateTypes({ value, schema, context });\n  if (!result.success) {\n    throw _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError.wrap({ value, cause: result.error, context });\n  }\n  return result.value;\n}\nasync function safeValidateTypes({\n  value,\n  schema,\n  context\n}) {\n  const actualSchema = asSchema(schema);\n  try {\n    if (actualSchema.validate == null) {\n      return { success: true, value, rawValue: value };\n    }\n    const result = await actualSchema.validate(value);\n    if (result.success) {\n      return { success: true, value: result.value, rawValue: value };\n    }\n    return {\n      success: false,\n      error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError.wrap({ value, cause: result.error, context }),\n      rawValue: value\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError.wrap({ value, cause: error, context }),\n      rawValue: value\n    };\n  }\n}\n\n// src/parse-json.ts\nasync function parseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secureJsonParse(text);\n    if (schema == null) {\n      return value;\n    }\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError.isInstance(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError.isInstance(error)) {\n      throw error;\n    }\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError({ text, cause: error });\n  }\n}\nasync function safeParseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secureJsonParse(text);\n    if (schema == null) {\n      return { success: true, value, rawValue: value };\n    }\n    return await safeValidateTypes({ value, schema });\n  } catch (error) {\n    return {\n      success: false,\n      error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError.isInstance(error) ? error : new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError({ text, cause: error }),\n      rawValue: void 0\n    };\n  }\n}\nfunction isParsableJson(input) {\n  try {\n    secureJsonParse(input);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n// src/parse-json-event-stream.ts\n\nfunction parseJsonEventStream({\n  stream,\n  schema\n}) {\n  return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new eventsource_parser_stream__WEBPACK_IMPORTED_MODULE_4__.EventSourceParserStream()).pipeThrough(\n    new TransformStream({\n      async transform({ data }, controller) {\n        if (data === \"[DONE]\") {\n          return;\n        }\n        controller.enqueue(await safeParseJSON({ text: data, schema }));\n      }\n    })\n  );\n}\n\n// src/parse-provider-options.ts\n\nasync function parseProviderOptions({\n  provider,\n  providerOptions,\n  schema\n}) {\n  if ((providerOptions == null ? void 0 : providerOptions[provider]) == null) {\n    return void 0;\n  }\n  const parsedProviderOptions = await safeValidateTypes({\n    value: providerOptions[provider],\n    schema\n  });\n  if (!parsedProviderOptions.success) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError({\n      argument: \"providerOptions\",\n      message: `invalid ${provider} provider options`,\n      cause: parsedProviderOptions.error\n    });\n  }\n  return parsedProviderOptions.value;\n}\n\n// src/post-to-api.ts\n\nvar getOriginalFetch2 = () => globalThis.fetch;\nvar postJsonToApi = async ({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch: fetch2\n}) => postToApi({\n  url,\n  headers: {\n    \"Content-Type\": \"application/json\",\n    ...headers\n  },\n  body: {\n    content: JSON.stringify(body),\n    values: body\n  },\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch: fetch2\n});\nvar postFormDataToApi = async ({\n  url,\n  headers,\n  formData,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch: fetch2\n}) => postToApi({\n  url,\n  headers,\n  body: {\n    content: formData,\n    values: Object.fromEntries(formData.entries())\n  },\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch: fetch2\n});\nvar postToApi = async ({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch: fetch2 = getOriginalFetch2()\n}) => {\n  try {\n    const response = await fetch2(url, {\n      method: \"POST\",\n      headers: withUserAgentSuffix(\n        headers,\n        `ai-sdk/provider-utils/${VERSION}`,\n        getRuntimeEnvironmentUserAgent()\n      ),\n      body: body.content,\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values\n        });\n      } catch (error) {\n        if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError.isInstance(error)) {\n          throw error;\n        }\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n          message: \"Failed to process error response\",\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n        message: \"Failed to process successful response\",\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values\n      });\n    }\n  } catch (error) {\n    throw handleFetchError({ error, url, requestBodyValues: body.values });\n  }\n};\n\n// src/types/tool.ts\nfunction tool(tool2) {\n  return tool2;\n}\nfunction dynamicTool(tool2) {\n  return { ...tool2, type: \"dynamic\" };\n}\n\n// src/provider-tool-factory.ts\nfunction createProviderToolFactory({\n  id,\n  inputSchema\n}) {\n  return ({\n    execute,\n    outputSchema,\n    needsApproval,\n    toModelOutput,\n    onInputStart,\n    onInputDelta,\n    onInputAvailable,\n    ...args\n  }) => tool({\n    type: \"provider\",\n    id,\n    args,\n    inputSchema,\n    outputSchema,\n    execute,\n    needsApproval,\n    toModelOutput,\n    onInputStart,\n    onInputDelta,\n    onInputAvailable\n  });\n}\nfunction createProviderToolFactoryWithOutputSchema({\n  id,\n  inputSchema,\n  outputSchema,\n  supportsDeferredResults\n}) {\n  return ({\n    execute,\n    needsApproval,\n    toModelOutput,\n    onInputStart,\n    onInputDelta,\n    onInputAvailable,\n    ...args\n  }) => tool({\n    type: \"provider\",\n    id,\n    args,\n    inputSchema,\n    outputSchema,\n    execute,\n    needsApproval,\n    toModelOutput,\n    onInputStart,\n    onInputDelta,\n    onInputAvailable,\n    supportsDeferredResults\n  });\n}\n\n// src/remove-undefined-entries.ts\nfunction removeUndefinedEntries(record) {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null)\n  );\n}\n\n// src/resolve.ts\nasync function resolve(value) {\n  if (typeof value === \"function\") {\n    value = value();\n  }\n  return Promise.resolve(value);\n}\n\n// src/response-handler.ts\n\nvar createJsonErrorResponseHandler = ({\n  errorSchema,\n  errorToMessage,\n  isRetryable\n}) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const responseHeaders = extractResponseHeaders(response);\n  if (responseBody.trim() === \"\") {\n    return {\n      responseHeaders,\n      value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n  try {\n    const parsedError = await parseJSON({\n      text: responseBody,\n      schema: errorSchema\n    });\n    return {\n      responseHeaders,\n      value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n        message: errorToMessage(parsedError),\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        data: parsedError,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)\n      })\n    };\n  } catch (parseError) {\n    return {\n      responseHeaders,\n      value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n};\nvar createEventSourceResponseHandler = (chunkSchema) => async ({ response }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.EmptyResponseBodyError({});\n  }\n  return {\n    responseHeaders,\n    value: parseJsonEventStream({\n      stream: response.body,\n      schema: chunkSchema\n    })\n  };\n};\nvar createJsonResponseHandler = (responseSchema) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const parsedResult = await safeParseJSON({\n    text: responseBody,\n    schema: responseSchema\n  });\n  const responseHeaders = extractResponseHeaders(response);\n  if (!parsedResult.success) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n      message: \"Invalid JSON response\",\n      cause: parsedResult.error,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody,\n      url,\n      requestBodyValues\n    });\n  }\n  return {\n    responseHeaders,\n    value: parsedResult.value,\n    rawValue: parsedResult.rawValue\n  };\n};\nvar createBinaryResponseHandler = () => async ({ response, url, requestBodyValues }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (!response.body) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n      message: \"Response body is empty\",\n      url,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody: void 0\n    });\n  }\n  try {\n    const buffer = await response.arrayBuffer();\n    return {\n      responseHeaders,\n      value: new Uint8Array(buffer)\n    };\n  } catch (error) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n      message: \"Failed to read response as array buffer\",\n      url,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody: void 0,\n      cause: error\n    });\n  }\n};\nvar createStatusCodeErrorResponseHandler = () => async ({ response, url, requestBodyValues }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  const responseBody = await response.text();\n  return {\n    responseHeaders,\n    value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n      message: response.statusText,\n      url,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody\n    })\n  };\n};\n\n// src/without-trailing-slash.ts\nfunction withoutTrailingSlash(url) {\n  return url == null ? void 0 : url.replace(/\\/$/, \"\");\n}\n\n// src/is-async-iterable.ts\nfunction isAsyncIterable(obj) {\n  return obj != null && typeof obj[Symbol.asyncIterator] === \"function\";\n}\n\n// src/types/execute-tool.ts\nasync function* executeTool({\n  execute,\n  input,\n  options\n}) {\n  const result = execute(input, options);\n  if (isAsyncIterable(result)) {\n    let lastOutput;\n    for await (const output of result) {\n      lastOutput = output;\n      yield { type: \"preliminary\", output };\n    }\n    yield { type: \"final\", output: lastOutput };\n  } else {\n    yield { type: \"final\", output: await result };\n  }\n}\n\n// src/index.ts\n\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9yZWFjdC9ub2RlX21vZHVsZXMvQGFpLXNkay9wcm92aWRlci11dGlscy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25ELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FB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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUN5RTs7QUFFekU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlKQUFpSix5REFBcUI7QUFDdEs7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5REFBc0I7QUFDL0I7QUFDQSxTQUFTLHlEQUFzQjtBQUMvQjtBQUNBLFNBQVMseURBQXNCO0FBQy9CO0FBQ0EsU0FBUyx5REFBc0I7QUFDL0I7QUFDQSxTQUFTLHlEQUFzQjtBQUMvQjtBQUNBLFNBQVMseURBQXNCO0FBQy9CO0FBQ0EsU0FBUyx5REFBc0I7QUFDL0I7QUFDQSxTQUFTLHlEQUFzQjtBQUMvQjtBQUNBLFNBQVMseURBQXNCO0FBQy9CO0FBQ0EsU0FBUyx5REFBc0I7QUFDL0IsU0FBUyx5REFBc0I7QUFDL0I7QUFDQSxTQUFTLHlEQUFzQjtBQUMvQjtBQUNBLFNBQVMseURBQXNCO0FBQy9CO0FBQ0EsU0FBUyx5REFBc0I7QUFDL0I7QUFDQSxTQUFTLHlEQUFzQjtBQUMvQjtBQUNBLFNBQVMseURBQXNCO0FBQy9CO0FBQ0EsU0FBUyx5REFBc0I7QUFDL0I7QUFDQSxTQUFTLHlEQUFzQjtBQUMvQjtBQUNBLFNBQVMseURBQXNCO0FBQy9CO0FBQ0EsU0FBUyx5REFBc0I7QUFDL0I7QUFDQSxTQUFTLHlEQUFzQjtBQUMvQjtBQUNBLFNBQVMseURBQXNCO0FBQy9CO0FBQ0EsU0FBUyx5REFBc0I7QUFDL0I7QUFDQSxTQUFTLHlEQUFzQjtBQUMvQixTQUFTLHlEQUFzQjtBQUMvQjtBQUNBLFNBQVMseURBQXNCO0FBQy9CO0FBQ0EsU0FBUyx5REFBc0I7QUFDL0I7QUFDQSxTQUFTLHlEQUFzQjtBQUMvQjtBQUNBLFNBQVMseURBQXNCO0FBQy9CO0FBQ0EsU0FBUyx5REFBc0I7QUFDL0I7QUFDQSxTQUFTLHlEQUFzQjtBQUMvQjtBQUNBLFNBQVMseURBQXNCO0FBQy9CO0FBQ0EsU0FBUyx5REFBc0I7QUFDL0I7QUFDQSxTQUFTLHlEQUFzQjtBQUMvQixTQUFTLHlEQUFzQjtBQUMvQixTQUFTLHlEQUFzQjtB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QzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLFlBQVk7QUFDWixJQUFJO0FBQ0osWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFHbUM7QUE2RGpDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbGVldGZsb3cvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9yZWFjdC9ub2RlX21vZHVsZXMvQGFpLXNkay9wcm92aWRlci11dGlscy9kaXN0L2luZGV4Lm1qcz83MTEzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jb21iaW5lLWhlYWRlcnMudHNcbmZ1bmN0aW9uIGNvbWJpbmVIZWFkZXJzKC4uLmhlYWRlcnMpIHtcbiAgcmV0dXJuIGhlYWRlcnMucmVkdWNlKFxuICAgIChjb21iaW5lZEhlYWRlcnMsIGN1cnJlbnRIZWFkZXJzKSA9PiAoe1xuICAgICAgLi4uY29tYmluZWRIZWFkZXJzLFxuICAgICAgLi4uY3VycmVudEhlYWRlcnMgIT0gbnVsbCA/IGN1cnJlbnRIZWFkZXJzIDoge31cbiAgICB9KSxcbiAgICB7fVxuICApO1xufVxuXG4vLyBzcmMvY29udmVydC1hc3luYy1pdGVyYXRvci10by1yZWFkYWJsZS1zdHJlYW0udHNcbmZ1bmN0aW9uIGNvbnZlcnRBc3luY0l0ZXJhdG9yVG9SZWFkYWJsZVN0cmVhbShpdGVyYXRvcikge1xuICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb25zdW1lciB3YW50cyB0byBwdWxsIG1vcmUgZGF0YSBmcm9tIHRoZSBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8VD59IGNvbnRyb2xsZXIgLSBUaGUgY29udHJvbGxlciB0byBlbnF1ZXVlIGRhdGEgaW50byB0aGUgc3RyZWFtLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb25zdW1lciBjYW5jZWxzIHRoZSBzdHJlYW0uXG4gICAgICovXG4gICAgYXN5bmMgY2FuY2VsKHJlYXNvbikge1xuICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgIGlmIChpdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBpdGVyYXRvci5yZXR1cm4ocmVhc29uKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2NyZWF0ZS10b29sLW5hbWUtbWFwcGluZy50c1xuZnVuY3Rpb24gY3JlYXRlVG9vbE5hbWVNYXBwaW5nKHtcbiAgdG9vbHMgPSBbXSxcbiAgcHJvdmlkZXJUb29sTmFtZXNcbn0pIHtcbiAgY29uc3QgY3VzdG9tVG9vbE5hbWVUb1Byb3ZpZGVyVG9vbE5hbWUgPSB7fTtcbiAgY29uc3QgcHJvdmlkZXJUb29sTmFtZVRvQ3VzdG9tVG9vbE5hbWUgPSB7fTtcbiAgZm9yIChjb25zdCB0b29sMiBvZiB0b29scykge1xuICAgIGlmICh0b29sMi50eXBlID09PSBcInByb3ZpZGVyXCIgJiYgdG9vbDIuaWQgaW4gcHJvdmlkZXJUb29sTmFtZXMpIHtcbiAgICAgIGNvbnN0IHByb3ZpZGVyVG9vbE5hbWUgPSBwcm92aWRlclRvb2xOYW1lc1t0b29sMi5pZF07XG4gICAgICBjdXN0b21Ub29sTmFtZVRvUHJvdmlkZXJUb29sTmFtZVt0b29sMi5uYW1lXSA9IHByb3ZpZGVyVG9vbE5hbWU7XG4gICAgICBwcm92aWRlclRvb2xOYW1lVG9DdXN0b21Ub29sTmFtZVtwcm92aWRlclRvb2xOYW1lXSA9IHRvb2wyLm5hbWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgdG9Qcm92aWRlclRvb2xOYW1lOiAoY3VzdG9tVG9vbE5hbWUpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICByZXR1cm4gKF9hMiA9IGN1c3RvbVRvb2xOYW1lVG9Qcm92aWRlclRvb2xOYW1lW2N1c3RvbVRvb2xOYW1lXSkgIT0gbnVsbCA/IF9hMiA6IGN1c3RvbVRvb2xOYW1lO1xuICAgIH0sXG4gICAgdG9DdXN0b21Ub29sTmFtZTogKHByb3ZpZGVyVG9vbE5hbWUpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICByZXR1cm4gKF9hMiA9IHByb3ZpZGVyVG9vbE5hbWVUb0N1c3RvbVRvb2xOYW1lW3Byb3ZpZGVyVG9vbE5hbWVdKSAhPSBudWxsID8gX2EyIDogcHJvdmlkZXJUb29sTmFtZTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9kZWxheS50c1xuYXN5bmMgZnVuY3Rpb24gZGVsYXkoZGVsYXlJbk1zLCBvcHRpb25zKSB7XG4gIGlmIChkZWxheUluTXMgPT0gbnVsbCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICBjb25zdCBzaWduYWwgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmFib3J0U2lnbmFsO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUyLCByZWplY3QpID0+IHtcbiAgICBpZiAoc2lnbmFsID09IG51bGwgPyB2b2lkIDAgOiBzaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmVqZWN0KGNyZWF0ZUFib3J0RXJyb3IoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY2xlYW51cCgpO1xuICAgICAgcmVzb2x2ZTIoKTtcbiAgICB9LCBkZWxheUluTXMpO1xuICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIHNpZ25hbCA9PSBudWxsID8gdm9pZCAwIDogc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uQWJvcnQgPSAoKSA9PiB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgICByZWplY3QoY3JlYXRlQWJvcnRFcnJvcigpKTtcbiAgICB9O1xuICAgIHNpZ25hbCA9PSBudWxsID8gdm9pZCAwIDogc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVBYm9ydEVycm9yKCkge1xuICByZXR1cm4gbmV3IERPTUV4Y2VwdGlvbihcIkRlbGF5IHdhcyBhYm9ydGVkXCIsIFwiQWJvcnRFcnJvclwiKTtcbn1cblxuLy8gc3JjL2RlbGF5ZWQtcHJvbWlzZS50c1xudmFyIERlbGF5ZWRQcm9taXNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN0YXR1cyA9IHsgdHlwZTogXCJwZW5kaW5nXCIgfTtcbiAgICB0aGlzLl9yZXNvbHZlID0gdm9pZCAwO1xuICAgIHRoaXMuX3JlamVjdCA9IHZvaWQgMDtcbiAgfVxuICBnZXQgcHJvbWlzZSgpIHtcbiAgICBpZiAodGhpcy5fcHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Byb21pc2U7XG4gICAgfVxuICAgIHRoaXMuX3Byb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZTIsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdHVzLnR5cGUgPT09IFwicmVzb2x2ZWRcIikge1xuICAgICAgICByZXNvbHZlMih0aGlzLnN0YXR1cy52YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdHVzLnR5cGUgPT09IFwicmVqZWN0ZWRcIikge1xuICAgICAgICByZWplY3QodGhpcy5zdGF0dXMuZXJyb3IpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmUyO1xuICAgICAgdGhpcy5fcmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLl9wcm9taXNlO1xuICB9XG4gIHJlc29sdmUodmFsdWUpIHtcbiAgICB2YXIgX2EyO1xuICAgIHRoaXMuc3RhdHVzID0geyB0eXBlOiBcInJlc29sdmVkXCIsIHZhbHVlIH07XG4gICAgaWYgKHRoaXMuX3Byb21pc2UpIHtcbiAgICAgIChfYTIgPSB0aGlzLl9yZXNvbHZlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZWplY3QoZXJyb3IpIHtcbiAgICB2YXIgX2EyO1xuICAgIHRoaXMuc3RhdHVzID0geyB0eXBlOiBcInJlamVjdGVkXCIsIGVycm9yIH07XG4gICAgaWYgKHRoaXMuX3Byb21pc2UpIHtcbiAgICAgIChfYTIgPSB0aGlzLl9yZWplY3QpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgfVxuICB9XG4gIGlzUmVzb2x2ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzLnR5cGUgPT09IFwicmVzb2x2ZWRcIjtcbiAgfVxuICBpc1JlamVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXR1cy50eXBlID09PSBcInJlamVjdGVkXCI7XG4gIH1cbiAgaXNQZW5kaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXR1cy50eXBlID09PSBcInBlbmRpbmdcIjtcbiAgfVxufTtcblxuLy8gc3JjL2V4dHJhY3QtcmVzcG9uc2UtaGVhZGVycy50c1xuZnVuY3Rpb24gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSkge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFsuLi5yZXNwb25zZS5oZWFkZXJzXSk7XG59XG5cbi8vIHNyYy91aW50OC11dGlscy50c1xudmFyIHsgYnRvYSwgYXRvYiB9ID0gZ2xvYmFsVGhpcztcbmZ1bmN0aW9uIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkoYmFzZTY0U3RyaW5nKSB7XG4gIGNvbnN0IGJhc2U2NFVybCA9IGJhc2U2NFN0cmluZy5yZXBsYWNlKC8tL2csIFwiK1wiKS5yZXBsYWNlKC9fL2csIFwiL1wiKTtcbiAgY29uc3QgbGF0aW4xc3RyaW5nID0gYXRvYihiYXNlNjRVcmwpO1xuICByZXR1cm4gVWludDhBcnJheS5mcm9tKGxhdGluMXN0cmluZywgKGJ5dGUpID0+IGJ5dGUuY29kZVBvaW50QXQoMCkpO1xufVxuZnVuY3Rpb24gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NChhcnJheSkge1xuICBsZXQgbGF0aW4xc3RyaW5nID0gXCJcIjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGxhdGluMXN0cmluZyArPSBTdHJpbmcuZnJvbUNvZGVQb2ludChhcnJheVtpXSk7XG4gIH1cbiAgcmV0dXJuIGJ0b2EobGF0aW4xc3RyaW5nKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0Jhc2U2NCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NCh2YWx1ZSkgOiB2YWx1ZTtcbn1cblxuLy8gc3JjL2NvbnZlcnQtaW1hZ2UtbW9kZWwtZmlsZS10by1kYXRhLXVyaS50c1xuZnVuY3Rpb24gY29udmVydEltYWdlTW9kZWxGaWxlVG9EYXRhVXJpKGZpbGUpIHtcbiAgaWYgKGZpbGUudHlwZSA9PT0gXCJ1cmxcIikgcmV0dXJuIGZpbGUudXJsO1xuICByZXR1cm4gYGRhdGE6JHtmaWxlLm1lZGlhVHlwZX07YmFzZTY0LCR7dHlwZW9mIGZpbGUuZGF0YSA9PT0gXCJzdHJpbmdcIiA/IGZpbGUuZGF0YSA6IGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQoZmlsZS5kYXRhKX1gO1xufVxuXG4vLyBzcmMvY29udmVydC10by1mb3JtLWRhdGEudHNcbmZ1bmN0aW9uIGNvbnZlcnRUb0Zvcm1EYXRhKGlucHV0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyB1c2VBcnJheUJyYWNrZXRzID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaW5wdXQpKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKGtleSwgdmFsdWVbMF0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFycmF5S2V5ID0gdXNlQXJyYXlCcmFja2V0cyA/IGAke2tleX1bXWAgOiBrZXk7XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKGFycmF5S2V5LCBpdGVtKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmb3JtRGF0YS5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZvcm1EYXRhO1xufVxuXG4vLyBzcmMvZG93bmxvYWQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUgPSBcIkFJX0Rvd25sb2FkRXJyb3JcIjtcbnZhciBtYXJrZXIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZX1gO1xudmFyIHN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyKTtcbnZhciBfYSwgX2I7XG52YXIgRG93bmxvYWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgKF9iID0gQUlTREtFcnJvciwgX2EgPSBzeW1ib2wsIF9iKSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB1cmwsXG4gICAgc3RhdHVzQ29kZSxcbiAgICBzdGF0dXNUZXh0LFxuICAgIGNhdXNlLFxuICAgIG1lc3NhZ2UgPSBjYXVzZSA9PSBudWxsID8gYEZhaWxlZCB0byBkb3dubG9hZCAke3VybH06ICR7c3RhdHVzQ29kZX0gJHtzdGF0dXNUZXh0fWAgOiBgRmFpbGVkIHRvIGRvd25sb2FkICR7dXJsfTogJHtjYXVzZX1gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWUsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2FdID0gdHJ1ZTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQ7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcik7XG4gIH1cbn07XG5cbi8vIHNyYy9yZWFkLXJlc3BvbnNlLXdpdGgtc2l6ZS1saW1pdC50c1xudmFyIERFRkFVTFRfTUFYX0RPV05MT0FEX1NJWkUgPSAyICogMTAyNCAqIDEwMjQgKiAxMDI0O1xuYXN5bmMgZnVuY3Rpb24gcmVhZFJlc3BvbnNlV2l0aFNpemVMaW1pdCh7XG4gIHJlc3BvbnNlLFxuICB1cmwsXG4gIG1heEJ5dGVzID0gREVGQVVMVF9NQVhfRE9XTkxPQURfU0laRVxufSkge1xuICBjb25zdCBjb250ZW50TGVuZ3RoID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LWxlbmd0aFwiKTtcbiAgaWYgKGNvbnRlbnRMZW5ndGggIT0gbnVsbCkge1xuICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KGNvbnRlbnRMZW5ndGgsIDEwKTtcbiAgICBpZiAoIWlzTmFOKGxlbmd0aCkgJiYgbGVuZ3RoID4gbWF4Qnl0ZXMpIHtcbiAgICAgIHRocm93IG5ldyBEb3dubG9hZEVycm9yKHtcbiAgICAgICAgdXJsLFxuICAgICAgICBtZXNzYWdlOiBgRG93bmxvYWQgb2YgJHt1cmx9IGV4Y2VlZGVkIG1heGltdW0gc2l6ZSBvZiAke21heEJ5dGVzfSBieXRlcyAoQ29udGVudC1MZW5ndGg6ICR7bGVuZ3RofSkuYFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGJvZHkgPSByZXNwb25zZS5ib2R5O1xuICBpZiAoYm9keSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICB9XG4gIGNvbnN0IHJlYWRlciA9IGJvZHkuZ2V0UmVhZGVyKCk7XG4gIGNvbnN0IGNodW5rcyA9IFtdO1xuICBsZXQgdG90YWxCeXRlcyA9IDA7XG4gIHRyeSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRvdGFsQnl0ZXMgKz0gdmFsdWUubGVuZ3RoO1xuICAgICAgaWYgKHRvdGFsQnl0ZXMgPiBtYXhCeXRlcykge1xuICAgICAgICB0aHJvdyBuZXcgRG93bmxvYWRFcnJvcih7XG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIG1lc3NhZ2U6IGBEb3dubG9hZCBvZiAke3VybH0gZXhjZWVkZWQgbWF4aW11bSBzaXplIG9mICR7bWF4Qnl0ZXN9IGJ5dGVzLmBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjaHVua3MucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCByZWFkZXIuY2FuY2VsKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgIH1cbiAgfVxuICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSh0b3RhbEJ5dGVzKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgcmVzdWx0LnNldChjaHVuaywgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHNyYy9kb3dubG9hZC1ibG9iLnRzXG5hc3luYyBmdW5jdGlvbiBkb3dubG9hZEJsb2IodXJsLCBvcHRpb25zKSB7XG4gIHZhciBfYTIsIF9iMjtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgc2lnbmFsOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmFib3J0U2lnbmFsXG4gICAgfSk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IERvd25sb2FkRXJyb3Ioe1xuICAgICAgICB1cmwsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZWFkUmVzcG9uc2VXaXRoU2l6ZUxpbWl0KHtcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgdXJsLFxuICAgICAgbWF4Qnl0ZXM6IChfYTIgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1heEJ5dGVzKSAhPSBudWxsID8gX2EyIDogREVGQVVMVF9NQVhfRE9XTkxPQURfU0laRVxuICAgIH0pO1xuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gKF9iMiA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpKSAhPSBudWxsID8gX2IyIDogdm9pZCAwO1xuICAgIHJldHVybiBuZXcgQmxvYihbZGF0YV0sIGNvbnRlbnRUeXBlID8geyB0eXBlOiBjb250ZW50VHlwZSB9IDogdm9pZCAwKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoRG93bmxvYWRFcnJvci5pc0luc3RhbmNlKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHRocm93IG5ldyBEb3dubG9hZEVycm9yKHsgdXJsLCBjYXVzZTogZXJyb3IgfSk7XG4gIH1cbn1cblxuLy8gc3JjL2dlbmVyYXRlLWlkLnRzXG5pbXBvcnQgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgY3JlYXRlSWRHZW5lcmF0b3IgPSAoe1xuICBwcmVmaXgsXG4gIHNpemUgPSAxNixcbiAgYWxwaGFiZXQgPSBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCIsXG4gIHNlcGFyYXRvciA9IFwiLVwiXG59ID0ge30pID0+IHtcbiAgY29uc3QgZ2VuZXJhdG9yID0gKCkgPT4ge1xuICAgIGNvbnN0IGFscGhhYmV0TGVuZ3RoID0gYWxwaGFiZXQubGVuZ3RoO1xuICAgIGNvbnN0IGNoYXJzID0gbmV3IEFycmF5KHNpemUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICBjaGFyc1tpXSA9IGFscGhhYmV0W01hdGgucmFuZG9tKCkgKiBhbHBoYWJldExlbmd0aCB8IDBdO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnMuam9pbihcIlwiKTtcbiAgfTtcbiAgaWYgKHByZWZpeCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBpZiAoYWxwaGFiZXQuaW5jbHVkZXMoc2VwYXJhdG9yKSkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICBhcmd1bWVudDogXCJzZXBhcmF0b3JcIixcbiAgICAgIG1lc3NhZ2U6IGBUaGUgc2VwYXJhdG9yIFwiJHtzZXBhcmF0b3J9XCIgbXVzdCBub3QgYmUgcGFydCBvZiB0aGUgYWxwaGFiZXQgXCIke2FscGhhYmV0fVwiLmBcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gKCkgPT4gYCR7cHJlZml4fSR7c2VwYXJhdG9yfSR7Z2VuZXJhdG9yKCl9YDtcbn07XG52YXIgZ2VuZXJhdGVJZCA9IGNyZWF0ZUlkR2VuZXJhdG9yKCk7XG5cbi8vIHNyYy9nZXQtZXJyb3ItbWVzc2FnZS50c1xuZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlKGVycm9yKSB7XG4gIGlmIChlcnJvciA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFwidW5rbm93biBlcnJvclwiO1xuICB9XG4gIGlmICh0eXBlb2YgZXJyb3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZXJyb3IpO1xufVxuXG4vLyBzcmMvZ2V0LWZyb20tYXBpLnRzXG5pbXBvcnQgeyBBUElDYWxsRXJyb3IgYXMgQVBJQ2FsbEVycm9yMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5cbi8vIHNyYy9oYW5kbGUtZmV0Y2gtZXJyb3IudHNcbmltcG9ydCB7IEFQSUNhbGxFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5cbi8vIHNyYy9pcy1hYm9ydC1lcnJvci50c1xuZnVuY3Rpb24gaXNBYm9ydEVycm9yKGVycm9yKSB7XG4gIHJldHVybiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbikgJiYgKGVycm9yLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiIHx8IGVycm9yLm5hbWUgPT09IFwiUmVzcG9uc2VBYm9ydGVkXCIgfHwgLy8gTmV4dC5qc1xuICBlcnJvci5uYW1lID09PSBcIlRpbWVvdXRFcnJvclwiKTtcbn1cblxuLy8gc3JjL2hhbmRsZS1mZXRjaC1lcnJvci50c1xudmFyIEZFVENIX0ZBSUxFRF9FUlJPUl9NRVNTQUdFUyA9IFtcImZldGNoIGZhaWxlZFwiLCBcImZhaWxlZCB0byBmZXRjaFwiXTtcbnZhciBCVU5fRVJST1JfQ09ERVMgPSBbXG4gIFwiQ29ubmVjdGlvblJlZnVzZWRcIixcbiAgXCJDb25uZWN0aW9uQ2xvc2VkXCIsXG4gIFwiRmFpbGVkVG9PcGVuU29ja2V0XCIsXG4gIFwiRUNPTk5SRVNFVFwiLFxuICBcIkVDT05OUkVGVVNFRFwiLFxuICBcIkVUSU1FRE9VVFwiLFxuICBcIkVQSVBFXCJcbl07XG5mdW5jdGlvbiBpc0J1bk5ldHdvcmtFcnJvcihlcnJvcikge1xuICBpZiAoIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBjb2RlID0gZXJyb3IuY29kZTtcbiAgaWYgKHR5cGVvZiBjb2RlID09PSBcInN0cmluZ1wiICYmIEJVTl9FUlJPUl9DT0RFUy5pbmNsdWRlcyhjb2RlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUZldGNoRXJyb3Ioe1xuICBlcnJvcixcbiAgdXJsLFxuICByZXF1ZXN0Qm9keVZhbHVlc1xufSkge1xuICBpZiAoaXNBYm9ydEVycm9yKGVycm9yKSkge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiYgRkVUQ0hfRkFJTEVEX0VSUk9SX01FU1NBR0VTLmluY2x1ZGVzKGVycm9yLm1lc3NhZ2UudG9Mb3dlckNhc2UoKSkpIHtcbiAgICBjb25zdCBjYXVzZSA9IGVycm9yLmNhdXNlO1xuICAgIGlmIChjYXVzZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gbmV3IEFQSUNhbGxFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IGBDYW5ub3QgY29ubmVjdCB0byBBUEk6ICR7Y2F1c2UubWVzc2FnZX1gLFxuICAgICAgICBjYXVzZSxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICAgICAgaXNSZXRyeWFibGU6IHRydWVcbiAgICAgICAgLy8gcmV0cnkgd2hlbiBuZXR3b3JrIGVycm9yXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQnVuTmV0d29ya0Vycm9yKGVycm9yKSkge1xuICAgIHJldHVybiBuZXcgQVBJQ2FsbEVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGBDYW5ub3QgY29ubmVjdCB0byBBUEk6ICR7ZXJyb3IubWVzc2FnZX1gLFxuICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgdXJsLFxuICAgICAgcmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgICBpc1JldHJ5YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBlcnJvcjtcbn1cblxuLy8gc3JjL2dldC1ydW50aW1lLWVudmlyb25tZW50LXVzZXItYWdlbnQudHNcbmZ1bmN0aW9uIGdldFJ1bnRpbWVFbnZpcm9ubWVudFVzZXJBZ2VudChnbG9iYWxUaGlzQW55ID0gZ2xvYmFsVGhpcykge1xuICB2YXIgX2EyLCBfYjIsIF9jO1xuICBpZiAoZ2xvYmFsVGhpc0FueS53aW5kb3cpIHtcbiAgICByZXR1cm4gYHJ1bnRpbWUvYnJvd3NlcmA7XG4gIH1cbiAgaWYgKChfYTIgPSBnbG9iYWxUaGlzQW55Lm5hdmlnYXRvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi51c2VyQWdlbnQpIHtcbiAgICByZXR1cm4gYHJ1bnRpbWUvJHtnbG9iYWxUaGlzQW55Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKX1gO1xuICB9XG4gIGlmICgoX2MgPSAoX2IyID0gZ2xvYmFsVGhpc0FueS5wcm9jZXNzKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLnZlcnNpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2Mubm9kZSkge1xuICAgIHJldHVybiBgcnVudGltZS9ub2RlLmpzLyR7Z2xvYmFsVGhpc0FueS5wcm9jZXNzLnZlcnNpb24uc3Vic3RyaW5nKDApfWA7XG4gIH1cbiAgaWYgKGdsb2JhbFRoaXNBbnkuRWRnZVJ1bnRpbWUpIHtcbiAgICByZXR1cm4gYHJ1bnRpbWUvdmVyY2VsLWVkZ2VgO1xuICB9XG4gIHJldHVybiBcInJ1bnRpbWUvdW5rbm93blwiO1xufVxuXG4vLyBzcmMvbm9ybWFsaXplLWhlYWRlcnMudHNcbmZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlcnMoaGVhZGVycykge1xuICBpZiAoaGVhZGVycyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSB7fTtcbiAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBub3JtYWxpemVkW2tleS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgICAgaGVhZGVycyA9IE9iamVjdC5lbnRyaWVzKGhlYWRlcnMpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBoZWFkZXJzKSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBub3JtYWxpemVkW2tleS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cblxuLy8gc3JjL3dpdGgtdXNlci1hZ2VudC1zdWZmaXgudHNcbmZ1bmN0aW9uIHdpdGhVc2VyQWdlbnRTdWZmaXgoaGVhZGVycywgLi4udXNlckFnZW50U3VmZml4UGFydHMpIHtcbiAgY29uc3Qgbm9ybWFsaXplZEhlYWRlcnMgPSBuZXcgSGVhZGVycyhub3JtYWxpemVIZWFkZXJzKGhlYWRlcnMpKTtcbiAgY29uc3QgY3VycmVudFVzZXJBZ2VudEhlYWRlciA9IG5vcm1hbGl6ZWRIZWFkZXJzLmdldChcInVzZXItYWdlbnRcIikgfHwgXCJcIjtcbiAgbm9ybWFsaXplZEhlYWRlcnMuc2V0KFxuICAgIFwidXNlci1hZ2VudFwiLFxuICAgIFtjdXJyZW50VXNlckFnZW50SGVhZGVyLCAuLi51c2VyQWdlbnRTdWZmaXhQYXJ0c10uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpXG4gICk7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMobm9ybWFsaXplZEhlYWRlcnMuZW50cmllcygpKTtcbn1cblxuLy8gc3JjL3ZlcnNpb24udHNcbnZhciBWRVJTSU9OID0gdHJ1ZSA/IFwiNC4wLjE1XCIgOiBcIjAuMC4wLXRlc3RcIjtcblxuLy8gc3JjL2dldC1mcm9tLWFwaS50c1xudmFyIGdldE9yaWdpbmFsRmV0Y2ggPSAoKSA9PiBnbG9iYWxUaGlzLmZldGNoO1xudmFyIGdldEZyb21BcGkgPSBhc3luYyAoe1xuICB1cmwsXG4gIGhlYWRlcnMgPSB7fSxcbiAgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcixcbiAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyLFxuICBhYm9ydFNpZ25hbCxcbiAgZmV0Y2g6IGZldGNoMiA9IGdldE9yaWdpbmFsRmV0Y2goKVxufSkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gyKHVybCwge1xuICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgaGVhZGVyczogd2l0aFVzZXJBZ2VudFN1ZmZpeChcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgYGFpLXNkay9wcm92aWRlci11dGlscy8ke1ZFUlNJT059YCxcbiAgICAgICAgZ2V0UnVudGltZUVudmlyb25tZW50VXNlckFnZW50KClcbiAgICAgICksXG4gICAgICBzaWduYWw6IGFib3J0U2lnbmFsXG4gICAgfSk7XG4gICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgbGV0IGVycm9ySW5mb3JtYXRpb247XG4gICAgICB0cnkge1xuICAgICAgICBlcnJvckluZm9ybWF0aW9uID0gYXdhaXQgZmFpbGVkUmVzcG9uc2VIYW5kbGVyKHtcbiAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IHt9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikgfHwgQVBJQ2FsbEVycm9yMi5pc0luc3RhbmNlKGVycm9yKSkge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBBUElDYWxsRXJyb3IyKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byBwcm9jZXNzIGVycm9yIHJlc3BvbnNlXCIsXG4gICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiB7fVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9ySW5mb3JtYXRpb24udmFsdWU7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcih7XG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiB7fVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpIHx8IEFQSUNhbGxFcnJvcjIuaXNJbnN0YW5jZShlcnJvcikpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEFQSUNhbGxFcnJvcjIoe1xuICAgICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byBwcm9jZXNzIHN1Y2Nlc3NmdWwgcmVzcG9uc2VcIixcbiAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICByZXF1ZXN0Qm9keVZhbHVlczoge31cbiAgICAgIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVGZXRjaEVycm9yKHsgZXJyb3IsIHVybCwgcmVxdWVzdEJvZHlWYWx1ZXM6IHt9IH0pO1xuICB9XG59O1xuXG4vLyBzcmMvaW5qZWN0LWpzb24taW5zdHJ1Y3Rpb24udHNcbnZhciBERUZBVUxUX1NDSEVNQV9QUkVGSVggPSBcIkpTT04gc2NoZW1hOlwiO1xudmFyIERFRkFVTFRfU0NIRU1BX1NVRkZJWCA9IFwiWW91IE1VU1QgYW5zd2VyIHdpdGggYSBKU09OIG9iamVjdCB0aGF0IG1hdGNoZXMgdGhlIEpTT04gc2NoZW1hIGFib3ZlLlwiO1xudmFyIERFRkFVTFRfR0VORVJJQ19TVUZGSVggPSBcIllvdSBNVVNUIGFuc3dlciB3aXRoIEpTT04uXCI7XG5mdW5jdGlvbiBpbmplY3RKc29uSW5zdHJ1Y3Rpb24oe1xuICBwcm9tcHQsXG4gIHNjaGVtYSxcbiAgc2NoZW1hUHJlZml4ID0gc2NoZW1hICE9IG51bGwgPyBERUZBVUxUX1NDSEVNQV9QUkVGSVggOiB2b2lkIDAsXG4gIHNjaGVtYVN1ZmZpeCA9IHNjaGVtYSAhPSBudWxsID8gREVGQVVMVF9TQ0hFTUFfU1VGRklYIDogREVGQVVMVF9HRU5FUklDX1NVRkZJWFxufSkge1xuICByZXR1cm4gW1xuICAgIHByb21wdCAhPSBudWxsICYmIHByb21wdC5sZW5ndGggPiAwID8gcHJvbXB0IDogdm9pZCAwLFxuICAgIHByb21wdCAhPSBudWxsICYmIHByb21wdC5sZW5ndGggPiAwID8gXCJcIiA6IHZvaWQgMCxcbiAgICAvLyBhZGQgYSBuZXdsaW5lIGlmIHByb21wdCBpcyBub3QgbnVsbFxuICAgIHNjaGVtYVByZWZpeCxcbiAgICBzY2hlbWEgIT0gbnVsbCA/IEpTT04uc3RyaW5naWZ5KHNjaGVtYSkgOiB2b2lkIDAsXG4gICAgc2NoZW1hU3VmZml4XG4gIF0uZmlsdGVyKChsaW5lKSA9PiBsaW5lICE9IG51bGwpLmpvaW4oXCJcXG5cIik7XG59XG5mdW5jdGlvbiBpbmplY3RKc29uSW5zdHJ1Y3Rpb25JbnRvTWVzc2FnZXMoe1xuICBtZXNzYWdlcyxcbiAgc2NoZW1hLFxuICBzY2hlbWFQcmVmaXgsXG4gIHNjaGVtYVN1ZmZpeFxufSkge1xuICB2YXIgX2EyLCBfYjI7XG4gIGNvbnN0IHN5c3RlbU1lc3NhZ2UgPSAoKF9hMiA9IG1lc3NhZ2VzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnJvbGUpID09PSBcInN5c3RlbVwiID8geyAuLi5tZXNzYWdlc1swXSB9IDogeyByb2xlOiBcInN5c3RlbVwiLCBjb250ZW50OiBcIlwiIH07XG4gIHN5c3RlbU1lc3NhZ2UuY29udGVudCA9IGluamVjdEpzb25JbnN0cnVjdGlvbih7XG4gICAgcHJvbXB0OiBzeXN0ZW1NZXNzYWdlLmNvbnRlbnQsXG4gICAgc2NoZW1hLFxuICAgIHNjaGVtYVByZWZpeCxcbiAgICBzY2hlbWFTdWZmaXhcbiAgfSk7XG4gIHJldHVybiBbXG4gICAgc3lzdGVtTWVzc2FnZSxcbiAgICAuLi4oKF9iMiA9IG1lc3NhZ2VzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLnJvbGUpID09PSBcInN5c3RlbVwiID8gbWVzc2FnZXMuc2xpY2UoMSkgOiBtZXNzYWdlc1xuICBdO1xufVxuXG4vLyBzcmMvaXMtbm9uLW51bGxhYmxlLnRzXG5mdW5jdGlvbiBpc05vbk51bGxhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsO1xufVxuXG4vLyBzcmMvaXMtdXJsLXN1cHBvcnRlZC50c1xuZnVuY3Rpb24gaXNVcmxTdXBwb3J0ZWQoe1xuICBtZWRpYVR5cGUsXG4gIHVybCxcbiAgc3VwcG9ydGVkVXJsc1xufSkge1xuICB1cmwgPSB1cmwudG9Mb3dlckNhc2UoKTtcbiAgbWVkaWFUeXBlID0gbWVkaWFUeXBlLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhzdXBwb3J0ZWRVcmxzKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGNvbnN0IG1lZGlhVHlwZTIgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gbWVkaWFUeXBlMiA9PT0gXCIqXCIgfHwgbWVkaWFUeXBlMiA9PT0gXCIqLypcIiA/IHsgbWVkaWFUeXBlUHJlZml4OiBcIlwiLCByZWdleGVzOiB2YWx1ZSB9IDogeyBtZWRpYVR5cGVQcmVmaXg6IG1lZGlhVHlwZTIucmVwbGFjZSgvXFwqLywgXCJcIiksIHJlZ2V4ZXM6IHZhbHVlIH07XG4gIH0pLmZpbHRlcigoeyBtZWRpYVR5cGVQcmVmaXggfSkgPT4gbWVkaWFUeXBlLnN0YXJ0c1dpdGgobWVkaWFUeXBlUHJlZml4KSkuZmxhdE1hcCgoeyByZWdleGVzIH0pID0+IHJlZ2V4ZXMpLnNvbWUoKHBhdHRlcm4pID0+IHBhdHRlcm4udGVzdCh1cmwpKTtcbn1cblxuLy8gc3JjL2xvYWQtYXBpLWtleS50c1xuaW1wb3J0IHsgTG9hZEFQSUtleUVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmZ1bmN0aW9uIGxvYWRBcGlLZXkoe1xuICBhcGlLZXksXG4gIGVudmlyb25tZW50VmFyaWFibGVOYW1lLFxuICBhcGlLZXlQYXJhbWV0ZXJOYW1lID0gXCJhcGlLZXlcIixcbiAgZGVzY3JpcHRpb25cbn0pIHtcbiAgaWYgKHR5cGVvZiBhcGlLZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gYXBpS2V5O1xuICB9XG4gIGlmIChhcGlLZXkgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBMb2FkQVBJS2V5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IEFQSSBrZXkgbXVzdCBiZSBhIHN0cmluZy5gXG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IExvYWRBUElLZXlFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgJHtkZXNjcmlwdGlvbn0gQVBJIGtleSBpcyBtaXNzaW5nLiBQYXNzIGl0IHVzaW5nIHRoZSAnJHthcGlLZXlQYXJhbWV0ZXJOYW1lfScgcGFyYW1ldGVyLiBFbnZpcm9ubWVudCB2YXJpYWJsZXMgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50LmBcbiAgICB9KTtcbiAgfVxuICBhcGlLZXkgPSBwcm9jZXNzLmVudltlbnZpcm9ubWVudFZhcmlhYmxlTmFtZV07XG4gIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBMb2FkQVBJS2V5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IEFQSSBrZXkgaXMgbWlzc2luZy4gUGFzcyBpdCB1c2luZyB0aGUgJyR7YXBpS2V5UGFyYW1ldGVyTmFtZX0nIHBhcmFtZXRlciBvciB0aGUgJHtlbnZpcm9ubWVudFZhcmlhYmxlTmFtZX0gZW52aXJvbm1lbnQgdmFyaWFibGUuYFxuICAgIH0pO1xuICB9XG4gIGlmICh0eXBlb2YgYXBpS2V5ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IExvYWRBUElLZXlFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgJHtkZXNjcmlwdGlvbn0gQVBJIGtleSBtdXN0IGJlIGEgc3RyaW5nLiBUaGUgdmFsdWUgb2YgdGhlICR7ZW52aXJvbm1lbnRWYXJpYWJsZU5hbWV9IGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG5vdCBhIHN0cmluZy5gXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGFwaUtleTtcbn1cblxuLy8gc3JjL2xvYWQtb3B0aW9uYWwtc2V0dGluZy50c1xuZnVuY3Rpb24gbG9hZE9wdGlvbmFsU2V0dGluZyh7XG4gIHNldHRpbmdWYWx1ZSxcbiAgZW52aXJvbm1lbnRWYXJpYWJsZU5hbWVcbn0pIHtcbiAgaWYgKHR5cGVvZiBzZXR0aW5nVmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gc2V0dGluZ1ZhbHVlO1xuICB9XG4gIGlmIChzZXR0aW5nVmFsdWUgIT0gbnVsbCB8fCB0eXBlb2YgcHJvY2VzcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgc2V0dGluZ1ZhbHVlID0gcHJvY2Vzcy5lbnZbZW52aXJvbm1lbnRWYXJpYWJsZU5hbWVdO1xuICBpZiAoc2V0dGluZ1ZhbHVlID09IG51bGwgfHwgdHlwZW9mIHNldHRpbmdWYWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIHNldHRpbmdWYWx1ZTtcbn1cblxuLy8gc3JjL2xvYWQtc2V0dGluZy50c1xuaW1wb3J0IHsgTG9hZFNldHRpbmdFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5mdW5jdGlvbiBsb2FkU2V0dGluZyh7XG4gIHNldHRpbmdWYWx1ZSxcbiAgZW52aXJvbm1lbnRWYXJpYWJsZU5hbWUsXG4gIHNldHRpbmdOYW1lLFxuICBkZXNjcmlwdGlvblxufSkge1xuICBpZiAodHlwZW9mIHNldHRpbmdWYWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBzZXR0aW5nVmFsdWU7XG4gIH1cbiAgaWYgKHNldHRpbmdWYWx1ZSAhPSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IExvYWRTZXR0aW5nRXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IHNldHRpbmcgbXVzdCBiZSBhIHN0cmluZy5gXG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IExvYWRTZXR0aW5nRXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IHNldHRpbmcgaXMgbWlzc2luZy4gUGFzcyBpdCB1c2luZyB0aGUgJyR7c2V0dGluZ05hbWV9JyBwYXJhbWV0ZXIuIEVudmlyb25tZW50IHZhcmlhYmxlcyBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQuYFxuICAgIH0pO1xuICB9XG4gIHNldHRpbmdWYWx1ZSA9IHByb2Nlc3MuZW52W2Vudmlyb25tZW50VmFyaWFibGVOYW1lXTtcbiAgaWYgKHNldHRpbmdWYWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IExvYWRTZXR0aW5nRXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IHNldHRpbmcgaXMgbWlzc2luZy4gUGFzcyBpdCB1c2luZyB0aGUgJyR7c2V0dGluZ05hbWV9JyBwYXJhbWV0ZXIgb3IgdGhlICR7ZW52aXJvbm1lbnRWYXJpYWJsZU5hbWV9IGVudmlyb25tZW50IHZhcmlhYmxlLmBcbiAgICB9KTtcbiAgfVxuICBpZiAodHlwZW9mIHNldHRpbmdWYWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBMb2FkU2V0dGluZ0Vycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBzZXR0aW5nIG11c3QgYmUgYSBzdHJpbmcuIFRoZSB2YWx1ZSBvZiB0aGUgJHtlbnZpcm9ubWVudFZhcmlhYmxlTmFtZX0gZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbm90IGEgc3RyaW5nLmBcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gc2V0dGluZ1ZhbHVlO1xufVxuXG4vLyBzcmMvbWVkaWEtdHlwZS10by1leHRlbnNpb24udHNcbmZ1bmN0aW9uIG1lZGlhVHlwZVRvRXh0ZW5zaW9uKG1lZGlhVHlwZSkge1xuICB2YXIgX2EyO1xuICBjb25zdCBbX3R5cGUsIHN1YnR5cGUgPSBcIlwiXSA9IG1lZGlhVHlwZS50b0xvd2VyQ2FzZSgpLnNwbGl0KFwiL1wiKTtcbiAgcmV0dXJuIChfYTIgPSB7XG4gICAgbXBlZzogXCJtcDNcIixcbiAgICBcIngtd2F2XCI6IFwid2F2XCIsXG4gICAgb3B1czogXCJvZ2dcIixcbiAgICBtcDQ6IFwibTRhXCIsXG4gICAgXCJ4LW00YVwiOiBcIm00YVwiXG4gIH1bc3VidHlwZV0pICE9IG51bGwgPyBfYTIgOiBzdWJ0eXBlO1xufVxuXG4vLyBzcmMvcGFyc2UtanNvbi50c1xuaW1wb3J0IHtcbiAgSlNPTlBhcnNlRXJyb3IsXG4gIFR5cGVWYWxpZGF0aW9uRXJyb3IgYXMgVHlwZVZhbGlkYXRpb25FcnJvcjNcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcblxuLy8gc3JjL3NlY3VyZS1qc29uLXBhcnNlLnRzXG52YXIgc3VzcGVjdFByb3RvUnggPSAvXCJfX3Byb3RvX19cIlxccyo6LztcbnZhciBzdXNwZWN0Q29uc3RydWN0b3JSeCA9IC9cImNvbnN0cnVjdG9yXCJcXHMqOi87XG5mdW5jdGlvbiBfcGFyc2UodGV4dCkge1xuICBjb25zdCBvYmogPSBKU09OLnBhcnNlKHRleHQpO1xuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIGlmIChzdXNwZWN0UHJvdG9SeC50ZXN0KHRleHQpID09PSBmYWxzZSAmJiBzdXNwZWN0Q29uc3RydWN0b3JSeC50ZXN0KHRleHQpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgcmV0dXJuIGZpbHRlcihvYmopO1xufVxuZnVuY3Rpb24gZmlsdGVyKG9iaikge1xuICBsZXQgbmV4dCA9IFtvYmpdO1xuICB3aGlsZSAobmV4dC5sZW5ndGgpIHtcbiAgICBjb25zdCBub2RlcyA9IG5leHQ7XG4gICAgbmV4dCA9IFtdO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChub2RlLCBcIl9fcHJvdG9fX1wiKSkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJPYmplY3QgY29udGFpbnMgZm9yYmlkZGVuIHByb3RvdHlwZSBwcm9wZXJ0eVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZSwgXCJjb25zdHJ1Y3RvclwiKSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZS5jb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiT2JqZWN0IGNvbnRhaW5zIGZvcmJpZGRlbiBwcm90b3R5cGUgcHJvcGVydHlcIik7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBub2RlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbm9kZVtrZXldO1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgbmV4dC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gc2VjdXJlSnNvblBhcnNlKHRleHQpIHtcbiAgY29uc3QgeyBzdGFja1RyYWNlTGltaXQgfSA9IEVycm9yO1xuICB0cnkge1xuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IDA7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gX3BhcnNlKHRleHQpO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIF9wYXJzZSh0ZXh0KTtcbiAgfSBmaW5hbGx5IHtcbiAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBzdGFja1RyYWNlTGltaXQ7XG4gIH1cbn1cblxuLy8gc3JjL3ZhbGlkYXRlLXR5cGVzLnRzXG5pbXBvcnQgeyBUeXBlVmFsaWRhdGlvbkVycm9yIGFzIFR5cGVWYWxpZGF0aW9uRXJyb3IyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcblxuLy8gc3JjL3NjaGVtYS50c1xuaW1wb3J0IHsgVHlwZVZhbGlkYXRpb25FcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQgKiBhcyB6NCBmcm9tIFwiem9kL3Y0XCI7XG5cbi8vIHNyYy9hZGQtYWRkaXRpb25hbC1wcm9wZXJ0aWVzLXRvLWpzb24tc2NoZW1hLnRzXG5mdW5jdGlvbiBhZGRBZGRpdGlvbmFsUHJvcGVydGllc1RvSnNvblNjaGVtYShqc29uU2NoZW1hMikge1xuICBpZiAoanNvblNjaGVtYTIudHlwZSA9PT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KGpzb25TY2hlbWEyLnR5cGUpICYmIGpzb25TY2hlbWEyLnR5cGUuaW5jbHVkZXMoXCJvYmplY3RcIikpIHtcbiAgICBqc29uU2NoZW1hMi5hZGRpdGlvbmFsUHJvcGVydGllcyA9IGZhbHNlO1xuICAgIGNvbnN0IHsgcHJvcGVydGllcyB9ID0ganNvblNjaGVtYTI7XG4gICAgaWYgKHByb3BlcnRpZXMgIT0gbnVsbCkge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocHJvcGVydGllcykpIHtcbiAgICAgICAgcHJvcGVydGllc1trZXldID0gdmlzaXQocHJvcGVydGllc1trZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGpzb25TY2hlbWEyLml0ZW1zICE9IG51bGwpIHtcbiAgICBqc29uU2NoZW1hMi5pdGVtcyA9IEFycmF5LmlzQXJyYXkoanNvblNjaGVtYTIuaXRlbXMpID8ganNvblNjaGVtYTIuaXRlbXMubWFwKHZpc2l0KSA6IHZpc2l0KGpzb25TY2hlbWEyLml0ZW1zKTtcbiAgfVxuICBpZiAoanNvblNjaGVtYTIuYW55T2YgIT0gbnVsbCkge1xuICAgIGpzb25TY2hlbWEyLmFueU9mID0ganNvblNjaGVtYTIuYW55T2YubWFwKHZpc2l0KTtcbiAgfVxuICBpZiAoanNvblNjaGVtYTIuYWxsT2YgIT0gbnVsbCkge1xuICAgIGpzb25TY2hlbWEyLmFsbE9mID0ganNvblNjaGVtYTIuYWxsT2YubWFwKHZpc2l0KTtcbiAgfVxuICBpZiAoanNvblNjaGVtYTIub25lT2YgIT0gbnVsbCkge1xuICAgIGpzb25TY2hlbWEyLm9uZU9mID0ganNvblNjaGVtYTIub25lT2YubWFwKHZpc2l0KTtcbiAgfVxuICBjb25zdCB7IGRlZmluaXRpb25zIH0gPSBqc29uU2NoZW1hMjtcbiAgaWYgKGRlZmluaXRpb25zICE9IG51bGwpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhkZWZpbml0aW9ucykpIHtcbiAgICAgIGRlZmluaXRpb25zW2tleV0gPSB2aXNpdChkZWZpbml0aW9uc1trZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGpzb25TY2hlbWEyO1xufVxuZnVuY3Rpb24gdmlzaXQoZGVmKSB7XG4gIGlmICh0eXBlb2YgZGVmID09PSBcImJvb2xlYW5cIikgcmV0dXJuIGRlZjtcbiAgcmV0dXJuIGFkZEFkZGl0aW9uYWxQcm9wZXJ0aWVzVG9Kc29uU2NoZW1hKGRlZik7XG59XG5cbi8vIHNyYy90by1qc29uLXNjaGVtYS96b2QzLXRvLWpzb24tc2NoZW1hL29wdGlvbnMudHNcbnZhciBpZ25vcmVPdmVycmlkZSA9IFN5bWJvbChcbiAgXCJMZXQgem9kVG9Kc29uU2NoZW1hIGRlY2lkZSBvbiB3aGljaCBwYXJzZXIgdG8gdXNlXCJcbik7XG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIG5hbWU6IHZvaWQgMCxcbiAgJHJlZlN0cmF0ZWd5OiBcInJvb3RcIixcbiAgYmFzZVBhdGg6IFtcIiNcIl0sXG4gIGVmZmVjdFN0cmF0ZWd5OiBcImlucHV0XCIsXG4gIHBpcGVTdHJhdGVneTogXCJhbGxcIixcbiAgZGF0ZVN0cmF0ZWd5OiBcImZvcm1hdDpkYXRlLXRpbWVcIixcbiAgbWFwU3RyYXRlZ3k6IFwiZW50cmllc1wiLFxuICByZW1vdmVBZGRpdGlvbmFsU3RyYXRlZ3k6IFwicGFzc3Rocm91Z2hcIixcbiAgYWxsb3dlZEFkZGl0aW9uYWxQcm9wZXJ0aWVzOiB0cnVlLFxuICByZWplY3RlZEFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgZGVmaW5pdGlvblBhdGg6IFwiZGVmaW5pdGlvbnNcIixcbiAgc3RyaWN0VW5pb25zOiBmYWxzZSxcbiAgZGVmaW5pdGlvbnM6IHt9LFxuICBlcnJvck1lc3NhZ2VzOiBmYWxzZSxcbiAgcGF0dGVyblN0cmF0ZWd5OiBcImVzY2FwZVwiLFxuICBhcHBseVJlZ2V4RmxhZ3M6IGZhbHNlLFxuICBlbWFpbFN0cmF0ZWd5OiBcImZvcm1hdDplbWFpbFwiLFxuICBiYXNlNjRTdHJhdGVneTogXCJjb250ZW50RW5jb2Rpbmc6YmFzZTY0XCIsXG4gIG5hbWVTdHJhdGVneTogXCJyZWZcIlxufTtcbnZhciBnZXREZWZhdWx0T3B0aW9ucyA9IChvcHRpb25zKSA9PiB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/IHtcbiAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gIG5hbWU6IG9wdGlvbnNcbn0gOiB7XG4gIC4uLmRlZmF1bHRPcHRpb25zLFxuICAuLi5vcHRpb25zXG59O1xuXG4vLyBzcmMvdG8tanNvbi1zY2hlbWEvem9kMy10by1qc29uLXNjaGVtYS9zZWxlY3QtcGFyc2VyLnRzXG5pbXBvcnQgeyBab2RGaXJzdFBhcnR5VHlwZUtpbmQgYXMgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMyB9IGZyb20gXCJ6b2QvdjNcIjtcblxuLy8gc3JjL3RvLWpzb24tc2NoZW1hL3pvZDMtdG8tanNvbi1zY2hlbWEvcGFyc2Vycy9hbnkudHNcbmZ1bmN0aW9uIHBhcnNlQW55RGVmKCkge1xuICByZXR1cm4ge307XG59XG5cbi8vIHNyYy90by1qc29uLXNjaGVtYS96b2QzLXRvLWpzb24tc2NoZW1hL3BhcnNlcnMvYXJyYXkudHNcbmltcG9ydCB7IFpvZEZpcnN0UGFydHlUeXBlS2luZCB9IGZyb20gXCJ6b2QvdjNcIjtcbmZ1bmN0aW9uIHBhcnNlQXJyYXlEZWYoZGVmLCByZWZzKSB7XG4gIHZhciBfYTIsIF9iMiwgX2M7XG4gIGNvbnN0IHJlcyA9IHtcbiAgICB0eXBlOiBcImFycmF5XCJcbiAgfTtcbiAgaWYgKCgoX2EyID0gZGVmLnR5cGUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuX2RlZikgJiYgKChfYyA9IChfYjIgPSBkZWYudHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5fZGVmKSA9PSBudWxsID8gdm9pZCAwIDogX2MudHlwZU5hbWUpICE9PSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQW55KSB7XG4gICAgcmVzLml0ZW1zID0gcGFyc2VEZWYoZGVmLnR5cGUuX2RlZiwge1xuICAgICAgLi4ucmVmcyxcbiAgICAgIGN1cnJlbnRQYXRoOiBbLi4ucmVmcy5jdXJyZW50UGF0aCwgXCJpdGVtc1wiXVxuICAgIH0pO1xuICB9XG4gIGlmIChkZWYubWluTGVuZ3RoKSB7XG4gICAgcmVzLm1pbkl0ZW1zID0gZGVmLm1pbkxlbmd0aC52YWx1ZTtcbiAgfVxuICBpZiAoZGVmLm1heExlbmd0aCkge1xuICAgIHJlcy5tYXhJdGVtcyA9IGRlZi5tYXhMZW5ndGgudmFsdWU7XG4gIH1cbiAgaWYgKGRlZi5leGFjdExlbmd0aCkge1xuICAgIHJlcy5taW5JdGVtcyA9IGRlZi5leGFjdExlbmd0aC52YWx1ZTtcbiAgICByZXMubWF4SXRlbXMgPSBkZWYuZXhhY3RMZW5ndGgudmFsdWU7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3RvLWpzb24tc2NoZW1hL3pvZDMtdG8tanNvbi1zY2hlbWEvcGFyc2Vycy9iaWdpbnQudHNcbmZ1bmN0aW9uIHBhcnNlQmlnaW50RGVmKGRlZikge1xuICBjb25zdCByZXMgPSB7XG4gICAgdHlwZTogXCJpbnRlZ2VyXCIsXG4gICAgZm9ybWF0OiBcImludDY0XCJcbiAgfTtcbiAgaWYgKCFkZWYuY2hlY2tzKSByZXR1cm4gcmVzO1xuICBmb3IgKGNvbnN0IGNoZWNrIG9mIGRlZi5jaGVja3MpIHtcbiAgICBzd2l0Y2ggKGNoZWNrLmtpbmQpIHtcbiAgICAgIGNhc2UgXCJtaW5cIjpcbiAgICAgICAgaWYgKGNoZWNrLmluY2x1c2l2ZSkge1xuICAgICAgICAgIHJlcy5taW5pbXVtID0gY2hlY2sudmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzLmV4Y2x1c2l2ZU1pbmltdW0gPSBjaGVjay52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtYXhcIjpcbiAgICAgICAgaWYgKGNoZWNrLmluY2x1c2l2ZSkge1xuICAgICAgICAgIHJlcy5tYXhpbXVtID0gY2hlY2sudmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzLmV4Y2x1c2l2ZU1heGltdW0gPSBjaGVjay52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtdWx0aXBsZU9mXCI6XG4gICAgICAgIHJlcy5tdWx0aXBsZU9mID0gY2hlY2sudmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vLyBzcmMvdG8tanNvbi1zY2hlbWEvem9kMy10by1qc29uLXNjaGVtYS9wYXJzZXJzL2Jvb2xlYW4udHNcbmZ1bmN0aW9uIHBhcnNlQm9vbGVhbkRlZigpIHtcbiAgcmV0dXJuIHsgdHlwZTogXCJib29sZWFuXCIgfTtcbn1cblxuLy8gc3JjL3RvLWpzb24tc2NoZW1hL3pvZDMtdG8tanNvbi1zY2hlbWEvcGFyc2Vycy9icmFuZGVkLnRzXG5mdW5jdGlvbiBwYXJzZUJyYW5kZWREZWYoX2RlZiwgcmVmcykge1xuICByZXR1cm4gcGFyc2VEZWYoX2RlZi50eXBlLl9kZWYsIHJlZnMpO1xufVxuXG4vLyBzcmMvdG8tanNvbi1zY2hlbWEvem9kMy10by1qc29uLXNjaGVtYS9wYXJzZXJzL2NhdGNoLnRzXG52YXIgcGFyc2VDYXRjaERlZiA9IChkZWYsIHJlZnMpID0+IHtcbiAgcmV0dXJuIHBhcnNlRGVmKGRlZi5pbm5lclR5cGUuX2RlZiwgcmVmcyk7XG59O1xuXG4vLyBzcmMvdG8tanNvbi1zY2hlbWEvem9kMy10by1qc29uLXNjaGVtYS9wYXJzZXJzL2RhdGUudHNcbmZ1bmN0aW9uIHBhcnNlRGF0ZURlZihkZWYsIHJlZnMsIG92ZXJyaWRlRGF0ZVN0cmF0ZWd5KSB7XG4gIGNvbnN0IHN0cmF0ZWd5ID0gb3ZlcnJpZGVEYXRlU3RyYXRlZ3kgIT0gbnVsbCA/IG92ZXJyaWRlRGF0ZVN0cmF0ZWd5IDogcmVmcy5kYXRlU3RyYXRlZ3k7XG4gIGlmIChBcnJheS5pc0FycmF5KHN0cmF0ZWd5KSkge1xuICAgIHJldHVybiB7XG4gICAgICBhbnlPZjogc3RyYXRlZ3kubWFwKChpdGVtLCBpKSA9PiBwYXJzZURhdGVEZWYoZGVmLCByZWZzLCBpdGVtKSlcbiAgICB9O1xuICB9XG4gIHN3aXRjaCAoc3RyYXRlZ3kpIHtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgY2FzZSBcImZvcm1hdDpkYXRlLXRpbWVcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJkYXRlLXRpbWVcIlxuICAgICAgfTtcbiAgICBjYXNlIFwiZm9ybWF0OmRhdGVcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJkYXRlXCJcbiAgICAgIH07XG4gICAgY2FzZSBcImludGVnZXJcIjpcbiAgICAgIHJldHVybiBpbnRlZ2VyRGF0ZVBhcnNlcihkZWYpO1xuICB9XG59XG52YXIgaW50ZWdlckRhdGVQYXJzZXIgPSAoZGVmKSA9PiB7XG4gIGNvbnN0IHJlcyA9IHtcbiAgICB0eXBlOiBcImludGVnZXJcIixcbiAgICBmb3JtYXQ6IFwidW5peC10aW1lXCJcbiAgfTtcbiAgZm9yIChjb25zdCBjaGVjayBvZiBkZWYuY2hlY2tzKSB7XG4gICAgc3dpdGNoIChjaGVjay5raW5kKSB7XG4gICAgICBjYXNlIFwibWluXCI6XG4gICAgICAgIHJlcy5taW5pbXVtID0gY2hlY2sudmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1heFwiOlxuICAgICAgICByZXMubWF4aW11bSA9IGNoZWNrLnZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cbi8vIHNyYy90by1qc29uLXNjaGVtYS96b2QzLXRvLWpzb24tc2NoZW1hL3BhcnNlcnMvZGVmYXVsdC50c1xuZnVuY3Rpb24gcGFyc2VEZWZhdWx0RGVmKF9kZWYsIHJlZnMpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5wYXJzZURlZihfZGVmLmlubmVyVHlwZS5fZGVmLCByZWZzKSxcbiAgICBkZWZhdWx0OiBfZGVmLmRlZmF1bHRWYWx1ZSgpXG4gIH07XG59XG5cbi8vIHNyYy90by1qc29uLXNjaGVtYS96b2QzLXRvLWpzb24tc2NoZW1hL3BhcnNlcnMvZWZmZWN0cy50c1xuZnVuY3Rpb24gcGFyc2VFZmZlY3RzRGVmKF9kZWYsIHJlZnMpIHtcbiAgcmV0dXJuIHJlZnMuZWZmZWN0U3RyYXRlZ3kgPT09IFwiaW5wdXRcIiA/IHBhcnNlRGVmKF9kZWYuc2NoZW1hLl9kZWYsIHJlZnMpIDogcGFyc2VBbnlEZWYoKTtcbn1cblxuLy8gc3JjL3RvLWpzb24tc2NoZW1hL3pvZDMtdG8tanNvbi1zY2hlbWEvcGFyc2Vycy9lbnVtLnRzXG5mdW5jdGlvbiBwYXJzZUVudW1EZWYoZGVmKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBlbnVtOiBBcnJheS5mcm9tKGRlZi52YWx1ZXMpXG4gIH07XG59XG5cbi8vIHNyYy90by1qc29uLXNjaGVtYS96b2QzLXRvLWpzb24tc2NoZW1hL3BhcnNlcnMvaW50ZXJzZWN0aW9uLnRzXG52YXIgaXNKc29uU2NoZW1hN0FsbE9mVHlwZSA9ICh0eXBlKSA9PiB7XG4gIGlmIChcInR5cGVcIiBpbiB0eXBlICYmIHR5cGUudHlwZSA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gXCJhbGxPZlwiIGluIHR5cGU7XG59O1xuZnVuY3Rpb24gcGFyc2VJbnRlcnNlY3Rpb25EZWYoZGVmLCByZWZzKSB7XG4gIGNvbnN0IGFsbE9mID0gW1xuICAgIHBhcnNlRGVmKGRlZi5sZWZ0Ll9kZWYsIHtcbiAgICAgIC4uLnJlZnMsXG4gICAgICBjdXJyZW50UGF0aDogWy4uLnJlZnMuY3VycmVudFBhdGgsIFwiYWxsT2ZcIiwgXCIwXCJdXG4gICAgfSksXG4gICAgcGFyc2VEZWYoZGVmLnJpZ2h0Ll9kZWYsIHtcbiAgICAgIC4uLnJlZnMsXG4gICAgICBjdXJyZW50UGF0aDogWy4uLnJlZnMuY3VycmVudFBhdGgsIFwiYWxsT2ZcIiwgXCIxXCJdXG4gICAgfSlcbiAgXS5maWx0ZXIoKHgpID0+ICEheCk7XG4gIGNvbnN0IG1lcmdlZEFsbE9mID0gW107XG4gIGFsbE9mLmZvckVhY2goKHNjaGVtYSkgPT4ge1xuICAgIGlmIChpc0pzb25TY2hlbWE3QWxsT2ZUeXBlKHNjaGVtYSkpIHtcbiAgICAgIG1lcmdlZEFsbE9mLnB1c2goLi4uc2NoZW1hLmFsbE9mKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG5lc3RlZFNjaGVtYSA9IHNjaGVtYTtcbiAgICAgIGlmIChcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIgaW4gc2NoZW1hICYmIHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgeyBhZGRpdGlvbmFsUHJvcGVydGllcywgLi4ucmVzdCB9ID0gc2NoZW1hO1xuICAgICAgICBuZXN0ZWRTY2hlbWEgPSByZXN0O1xuICAgICAgfVxuICAgICAgbWVyZ2VkQWxsT2YucHVzaChuZXN0ZWRTY2hlbWEpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBtZXJnZWRBbGxPZi5sZW5ndGggPyB7IGFsbE9mOiBtZXJnZWRBbGxPZiB9IDogdm9pZCAwO1xufVxuXG4vLyBzcmMvdG8tanNvbi1zY2hlbWEvem9kMy10by1qc29uLXNjaGVtYS9wYXJzZXJzL2xpdGVyYWwudHNcbmZ1bmN0aW9uIHBhcnNlTGl0ZXJhbERlZihkZWYpIHtcbiAgY29uc3QgcGFyc2VkVHlwZSA9IHR5cGVvZiBkZWYudmFsdWU7XG4gIGlmIChwYXJzZWRUeXBlICE9PSBcImJpZ2ludFwiICYmIHBhcnNlZFR5cGUgIT09IFwibnVtYmVyXCIgJiYgcGFyc2VkVHlwZSAhPT0gXCJib29sZWFuXCIgJiYgcGFyc2VkVHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBBcnJheS5pc0FycmF5KGRlZi52YWx1ZSkgPyBcImFycmF5XCIgOiBcIm9iamVjdFwiXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IHBhcnNlZFR5cGUgPT09IFwiYmlnaW50XCIgPyBcImludGVnZXJcIiA6IHBhcnNlZFR5cGUsXG4gICAgY29uc3Q6IGRlZi52YWx1ZVxuICB9O1xufVxuXG4vLyBzcmMvdG8tanNvbi1zY2hlbWEvem9kMy10by1qc29uLXNjaGVtYS9wYXJzZXJzL3JlY29yZC50c1xuaW1wb3J0IHtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kIGFzIFpvZEZpcnN0UGFydHlUeXBlS2luZDJcbn0gZnJvbSBcInpvZC92M1wiO1xuXG4vLyBzcmMvdG8tanNvbi1zY2hlbWEvem9kMy10by1qc29uLXNjaGVtYS9wYXJzZXJzL3N0cmluZy50c1xudmFyIGVtb2ppUmVnZXggPSB2b2lkIDA7XG52YXIgem9kUGF0dGVybnMgPSB7XG4gIC8qKlxuICAgKiBgY2Agd2FzIGNoYW5nZWQgdG8gYFtjQ11gIHRvIHJlcGxpY2F0ZSAvaSBmbGFnXG4gICAqL1xuICBjdWlkOiAvXltjQ11bXlxccy1dezgsfSQvLFxuICBjdWlkMjogL15bMC05YS16XSskLyxcbiAgdWxpZDogL15bMC05QS1ISktNTlAtVFYtWl17MjZ9JC8sXG4gIC8qKlxuICAgKiBgYS16YCB3YXMgYWRkZWQgdG8gcmVwbGljYXRlIC9pIGZsYWdcbiAgICovXG4gIGVtYWlsOiAvXig/IVxcLikoPyEuKlxcLlxcLikoW2EtekEtWjAtOV8nK1xcLVxcLl0qKVthLXpBLVowLTlfKy1dQChbYS16QS1aMC05XVthLXpBLVowLTlcXC1dKlxcLikrW2EtekEtWl17Mix9JC8sXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RlZCBhIHZhbGlkIFVuaWNvZGUgUmVnRXhwXG4gICAqXG4gICAqIExhemlseSBpbnN0YW50aWF0ZSBzaW5jZSB0aGlzIHR5cGUgb2YgcmVnZXggaXNuJ3Qgc3VwcG9ydGVkXG4gICAqIGluIGFsbCBlbnZzIChlLmcuIFJlYWN0IE5hdGl2ZSkuXG4gICAqXG4gICAqIFNlZTpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2NvbGluaGFja3Mvem9kL2lzc3Vlcy8yNDMzXG4gICAqIEZpeCBpbiBab2Q6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2xpbmhhY2tzL3pvZC9jb21taXQvOTM0MGZkNTFlNDg1NzZhNzVhZGM5MTliZmY2NWRiYzRhNWQ0Yzk5YlxuICAgKi9cbiAgZW1vamk6ICgpID0+IHtcbiAgICBpZiAoZW1vamlSZWdleCA9PT0gdm9pZCAwKSB7XG4gICAgICBlbW9qaVJlZ2V4ID0gUmVnRXhwKFxuICAgICAgICBcIl4oXFxcXHB7RXh0ZW5kZWRfUGljdG9ncmFwaGljfXxcXFxccHtFbW9qaV9Db21wb25lbnR9KSskXCIsXG4gICAgICAgIFwidVwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZW1vamlSZWdleDtcbiAgfSxcbiAgLyoqXG4gICAqIFVudXNlZFxuICAgKi9cbiAgdXVpZDogL15bMC05YS1mQS1GXXs4fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXsxMn0kLyxcbiAgLyoqXG4gICAqIFVudXNlZFxuICAgKi9cbiAgaXB2NDogL14oPzooPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSkkLyxcbiAgaXB2NENpZHI6IC9eKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwvKDNbMC0yXXxbMTJdP1swLTldKSQvLFxuICAvKipcbiAgICogVW51c2VkXG4gICAqL1xuICBpcHY2OiAvXigoW2EtZjAtOV17MSw0fTopezd9fDo6KFthLWYwLTldezEsNH06KXswLDZ9fChbYS1mMC05XXsxLDR9Oil7MX06KFthLWYwLTldezEsNH06KXswLDV9fChbYS1mMC05XXsxLDR9Oil7Mn06KFthLWYwLTldezEsNH06KXswLDR9fChbYS1mMC05XXsxLDR9Oil7M306KFthLWYwLTldezEsNH06KXswLDN9fChbYS1mMC05XXsxLDR9Oil7NH06KFthLWYwLTldezEsNH06KXswLDJ9fChbYS1mMC05XXsxLDR9Oil7NX06KFthLWYwLTldezEsNH06KXswLDF9KShbYS1mMC05XXsxLDR9fCgoKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcLil7M30oKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKSkkLyxcbiAgaXB2NkNpZHI6IC9eKChbMC05YS1mQS1GXXsxLDR9Oil7Nyw3fVswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDd9OnwoWzAtOWEtZkEtRl17MSw0fTopezEsNn06WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsNX0oOlswLTlhLWZBLUZdezEsNH0pezEsMn18KFswLTlhLWZBLUZdezEsNH06KXsxLDR9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDN9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwzfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsMn0oOlswLTlhLWZBLUZdezEsNH0pezEsNX18WzAtOWEtZkEtRl17MSw0fTooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDZ9KXw6KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw3fXw6KXxmZTgwOig6WzAtOWEtZkEtRl17MCw0fSl7MCw0fSVbMC05YS16QS1aXXsxLH18OjooZmZmZig6MHsxLDR9KXswLDF9Oil7MCwxfSgoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH06KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pKVxcLygxMlswLThdfDFbMDFdWzAtOV18WzEtOV0/WzAtOV0pJC8sXG4gIGJhc2U2NDogL14oWzAtOWEtekEtWisvXXs0fSkqKChbMC05YS16QS1aKy9dezJ9PT0pfChbMC05YS16QS1aKy9dezN9PSkpPyQvLFxuICBiYXNlNjR1cmw6IC9eKFswLTlhLXpBLVotX117NH0pKigoWzAtOWEtekEtWi1fXXsyfSg9PSk/KXwoWzAtOWEtekEtWi1fXXszfSg9KT8pKT8kLyxcbiAgbmFub2lkOiAvXlthLXpBLVowLTlfLV17MjF9JC8sXG4gIGp3dDogL15bQS1aYS16MC05LV9dK1xcLltBLVphLXowLTktX10rXFwuW0EtWmEtejAtOS1fXSokL1xufTtcbmZ1bmN0aW9uIHBhcnNlU3RyaW5nRGVmKGRlZiwgcmVmcykge1xuICBjb25zdCByZXMgPSB7XG4gICAgdHlwZTogXCJzdHJpbmdcIlxuICB9O1xuICBpZiAoZGVmLmNoZWNrcykge1xuICAgIGZvciAoY29uc3QgY2hlY2sgb2YgZGVmLmNoZWNrcykge1xuICAgICAgc3dpdGNoIChjaGVjay5raW5kKSB7XG4gICAgICAgIGNhc2UgXCJtaW5cIjpcbiAgICAgICAgICByZXMubWluTGVuZ3RoID0gdHlwZW9mIHJlcy5taW5MZW5ndGggPT09IFwibnVtYmVyXCIgPyBNYXRoLm1heChyZXMubWluTGVuZ3RoLCBjaGVjay52YWx1ZSkgOiBjaGVjay52YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1heFwiOlxuICAgICAgICAgIHJlcy5tYXhMZW5ndGggPSB0eXBlb2YgcmVzLm1heExlbmd0aCA9PT0gXCJudW1iZXJcIiA/IE1hdGgubWluKHJlcy5tYXhMZW5ndGgsIGNoZWNrLnZhbHVlKSA6IGNoZWNrLnZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZW1haWxcIjpcbiAgICAgICAgICBzd2l0Y2ggKHJlZnMuZW1haWxTdHJhdGVneSkge1xuICAgICAgICAgICAgY2FzZSBcImZvcm1hdDplbWFpbFwiOlxuICAgICAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcImVtYWlsXCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJmb3JtYXQ6aWRuLWVtYWlsXCI6XG4gICAgICAgICAgICAgIGFkZEZvcm1hdChyZXMsIFwiaWRuLWVtYWlsXCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJwYXR0ZXJuOnpvZFwiOlxuICAgICAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgem9kUGF0dGVybnMuZW1haWwsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ1cmxcIjpcbiAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcInVyaVwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInV1aWRcIjpcbiAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcInV1aWRcIiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZWdleFwiOlxuICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCBjaGVjay5yZWdleCwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjdWlkXCI6XG4gICAgICAgICAgYWRkUGF0dGVybihyZXMsIHpvZFBhdHRlcm5zLmN1aWQsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY3VpZDJcIjpcbiAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgem9kUGF0dGVybnMuY3VpZDIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3RhcnRzV2l0aFwiOlxuICAgICAgICAgIGFkZFBhdHRlcm4oXG4gICAgICAgICAgICByZXMsXG4gICAgICAgICAgICBSZWdFeHAoYF4ke2VzY2FwZUxpdGVyYWxDaGVja1ZhbHVlKGNoZWNrLnZhbHVlLCByZWZzKX1gKSxcbiAgICAgICAgICAgIGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICByZWZzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImVuZHNXaXRoXCI6XG4gICAgICAgICAgYWRkUGF0dGVybihcbiAgICAgICAgICAgIHJlcyxcbiAgICAgICAgICAgIFJlZ0V4cChgJHtlc2NhcGVMaXRlcmFsQ2hlY2tWYWx1ZShjaGVjay52YWx1ZSwgcmVmcyl9JGApLFxuICAgICAgICAgICAgY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgIHJlZnNcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGF0ZXRpbWVcIjpcbiAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcImRhdGUtdGltZVwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRhdGVcIjpcbiAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcImRhdGVcIiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0aW1lXCI6XG4gICAgICAgICAgYWRkRm9ybWF0KHJlcywgXCJ0aW1lXCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZHVyYXRpb25cIjpcbiAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcImR1cmF0aW9uXCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGVuZ3RoXCI6XG4gICAgICAgICAgcmVzLm1pbkxlbmd0aCA9IHR5cGVvZiByZXMubWluTGVuZ3RoID09PSBcIm51bWJlclwiID8gTWF0aC5tYXgocmVzLm1pbkxlbmd0aCwgY2hlY2sudmFsdWUpIDogY2hlY2sudmFsdWU7XG4gICAgICAgICAgcmVzLm1heExlbmd0aCA9IHR5cGVvZiByZXMubWF4TGVuZ3RoID09PSBcIm51bWJlclwiID8gTWF0aC5taW4ocmVzLm1heExlbmd0aCwgY2hlY2sudmFsdWUpIDogY2hlY2sudmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJpbmNsdWRlc1wiOiB7XG4gICAgICAgICAgYWRkUGF0dGVybihcbiAgICAgICAgICAgIHJlcyxcbiAgICAgICAgICAgIFJlZ0V4cChlc2NhcGVMaXRlcmFsQ2hlY2tWYWx1ZShjaGVjay52YWx1ZSwgcmVmcykpLFxuICAgICAgICAgICAgY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgIHJlZnNcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJpcFwiOiB7XG4gICAgICAgICAgaWYgKGNoZWNrLnZlcnNpb24gIT09IFwidjZcIikge1xuICAgICAgICAgICAgYWRkRm9ybWF0KHJlcywgXCJpcHY0XCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2hlY2sudmVyc2lvbiAhPT0gXCJ2NFwiKSB7XG4gICAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcImlwdjZcIiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJiYXNlNjR1cmxcIjpcbiAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgem9kUGF0dGVybnMuYmFzZTY0dXJsLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImp3dFwiOlxuICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCB6b2RQYXR0ZXJucy5qd3QsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY2lkclwiOiB7XG4gICAgICAgICAgaWYgKGNoZWNrLnZlcnNpb24gIT09IFwidjZcIikge1xuICAgICAgICAgICAgYWRkUGF0dGVybihyZXMsIHpvZFBhdHRlcm5zLmlwdjRDaWRyLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoZWNrLnZlcnNpb24gIT09IFwidjRcIikge1xuICAgICAgICAgICAgYWRkUGF0dGVybihyZXMsIHpvZFBhdHRlcm5zLmlwdjZDaWRyLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImVtb2ppXCI6XG4gICAgICAgICAgYWRkUGF0dGVybihyZXMsIHpvZFBhdHRlcm5zLmVtb2ppKCksIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidWxpZFwiOiB7XG4gICAgICAgICAgYWRkUGF0dGVybihyZXMsIHpvZFBhdHRlcm5zLnVsaWQsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJiYXNlNjRcIjoge1xuICAgICAgICAgIHN3aXRjaCAocmVmcy5iYXNlNjRTdHJhdGVneSkge1xuICAgICAgICAgICAgY2FzZSBcImZvcm1hdDpiaW5hcnlcIjoge1xuICAgICAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcImJpbmFyeVwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiY29udGVudEVuY29kaW5nOmJhc2U2NFwiOiB7XG4gICAgICAgICAgICAgIHJlcy5jb250ZW50RW5jb2RpbmcgPSBcImJhc2U2NFwiO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJwYXR0ZXJuOnpvZFwiOiB7XG4gICAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCB6b2RQYXR0ZXJucy5iYXNlNjQsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIm5hbm9pZFwiOiB7XG4gICAgICAgICAgYWRkUGF0dGVybihyZXMsIHpvZFBhdHRlcm5zLm5hbm9pZCwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInRvTG93ZXJDYXNlXCI6XG4gICAgICAgIGNhc2UgXCJ0b1VwcGVyQ2FzZVwiOlxuICAgICAgICBjYXNlIFwidHJpbVwiOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoKF8pID0+IHtcbiAgICAgICAgICB9KShjaGVjayk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBlc2NhcGVMaXRlcmFsQ2hlY2tWYWx1ZShsaXRlcmFsLCByZWZzKSB7XG4gIHJldHVybiByZWZzLnBhdHRlcm5TdHJhdGVneSA9PT0gXCJlc2NhcGVcIiA/IGVzY2FwZU5vbkFscGhhTnVtZXJpYyhsaXRlcmFsKSA6IGxpdGVyYWw7XG59XG52YXIgQUxQSEFfTlVNRVJJQyA9IG5ldyBTZXQoXG4gIFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVlhZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ4eXowMTIzNDU2Nzg5XCJcbik7XG5mdW5jdGlvbiBlc2NhcGVOb25BbHBoYU51bWVyaWMoc291cmNlKSB7XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghQUxQSEFfTlVNRVJJQy5oYXMoc291cmNlW2ldKSkge1xuICAgICAgcmVzdWx0ICs9IFwiXFxcXFwiO1xuICAgIH1cbiAgICByZXN1bHQgKz0gc291cmNlW2ldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBhZGRGb3JtYXQoc2NoZW1hLCB2YWx1ZSwgbWVzc2FnZSwgcmVmcykge1xuICB2YXIgX2EyO1xuICBpZiAoc2NoZW1hLmZvcm1hdCB8fCAoKF9hMiA9IHNjaGVtYS5hbnlPZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5zb21lKCh4KSA9PiB4LmZvcm1hdCkpKSB7XG4gICAgaWYgKCFzY2hlbWEuYW55T2YpIHtcbiAgICAgIHNjaGVtYS5hbnlPZiA9IFtdO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hLmZvcm1hdCkge1xuICAgICAgc2NoZW1hLmFueU9mLnB1c2goe1xuICAgICAgICBmb3JtYXQ6IHNjaGVtYS5mb3JtYXRcbiAgICAgIH0pO1xuICAgICAgZGVsZXRlIHNjaGVtYS5mb3JtYXQ7XG4gICAgfVxuICAgIHNjaGVtYS5hbnlPZi5wdXNoKHtcbiAgICAgIGZvcm1hdDogdmFsdWUsXG4gICAgICAuLi5tZXNzYWdlICYmIHJlZnMuZXJyb3JNZXNzYWdlcyAmJiB7IGVycm9yTWVzc2FnZTogeyBmb3JtYXQ6IG1lc3NhZ2UgfSB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgc2NoZW1hLmZvcm1hdCA9IHZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBhZGRQYXR0ZXJuKHNjaGVtYSwgcmVnZXgsIG1lc3NhZ2UsIHJlZnMpIHtcbiAgdmFyIF9hMjtcbiAgaWYgKHNjaGVtYS5wYXR0ZXJuIHx8ICgoX2EyID0gc2NoZW1hLmFsbE9mKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnNvbWUoKHgpID0+IHgucGF0dGVybikpKSB7XG4gICAgaWYgKCFzY2hlbWEuYWxsT2YpIHtcbiAgICAgIHNjaGVtYS5hbGxPZiA9IFtdO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hLnBhdHRlcm4pIHtcbiAgICAgIHNjaGVtYS5hbGxPZi5wdXNoKHtcbiAgICAgICAgcGF0dGVybjogc2NoZW1hLnBhdHRlcm5cbiAgICAgIH0pO1xuICAgICAgZGVsZXRlIHNjaGVtYS5wYXR0ZXJuO1xuICAgIH1cbiAgICBzY2hlbWEuYWxsT2YucHVzaCh7XG4gICAgICBwYXR0ZXJuOiBzdHJpbmdpZnlSZWdFeHBXaXRoRmxhZ3MocmVnZXgsIHJlZnMpLFxuICAgICAgLi4ubWVzc2FnZSAmJiByZWZzLmVycm9yTWVzc2FnZXMgJiYgeyBlcnJvck1lc3NhZ2U6IHsgcGF0dGVybjogbWVzc2FnZSB9IH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBzY2hlbWEucGF0dGVybiA9IHN0cmluZ2lmeVJlZ0V4cFdpdGhGbGFncyhyZWdleCwgcmVmcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVJlZ0V4cFdpdGhGbGFncyhyZWdleCwgcmVmcykge1xuICB2YXIgX2EyO1xuICBpZiAoIXJlZnMuYXBwbHlSZWdleEZsYWdzIHx8ICFyZWdleC5mbGFncykge1xuICAgIHJldHVybiByZWdleC5zb3VyY2U7XG4gIH1cbiAgY29uc3QgZmxhZ3MgPSB7XG4gICAgaTogcmVnZXguZmxhZ3MuaW5jbHVkZXMoXCJpXCIpLFxuICAgIC8vIENhc2UtaW5zZW5zaXRpdmVcbiAgICBtOiByZWdleC5mbGFncy5pbmNsdWRlcyhcIm1cIiksXG4gICAgLy8gYF5gIGFuZCBgJGAgbWF0Y2hlcyBhZGphY2VudCB0byBuZXdsaW5lIGNoYXJhY3RlcnNcbiAgICBzOiByZWdleC5mbGFncy5pbmNsdWRlcyhcInNcIilcbiAgICAvLyBgLmAgbWF0Y2hlcyBuZXdsaW5lc1xuICB9O1xuICBjb25zdCBzb3VyY2UgPSBmbGFncy5pID8gcmVnZXguc291cmNlLnRvTG93ZXJDYXNlKCkgOiByZWdleC5zb3VyY2U7XG4gIGxldCBwYXR0ZXJuID0gXCJcIjtcbiAgbGV0IGlzRXNjYXBlZCA9IGZhbHNlO1xuICBsZXQgaW5DaGFyR3JvdXAgPSBmYWxzZTtcbiAgbGV0IGluQ2hhclJhbmdlID0gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGlzRXNjYXBlZCkge1xuICAgICAgcGF0dGVybiArPSBzb3VyY2VbaV07XG4gICAgICBpc0VzY2FwZWQgPSBmYWxzZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoZmxhZ3MuaSkge1xuICAgICAgaWYgKGluQ2hhckdyb3VwKSB7XG4gICAgICAgIGlmIChzb3VyY2VbaV0ubWF0Y2goL1thLXpdLykpIHtcbiAgICAgICAgICBpZiAoaW5DaGFyUmFuZ2UpIHtcbiAgICAgICAgICAgIHBhdHRlcm4gKz0gc291cmNlW2ldO1xuICAgICAgICAgICAgcGF0dGVybiArPSBgJHtzb3VyY2VbaSAtIDJdfS0ke3NvdXJjZVtpXX1gLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBpbkNoYXJSYW5nZSA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlW2kgKyAxXSA9PT0gXCItXCIgJiYgKChfYTIgPSBzb3VyY2VbaSArIDJdKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLm1hdGNoKC9bYS16XS8pKSkge1xuICAgICAgICAgICAgcGF0dGVybiArPSBzb3VyY2VbaV07XG4gICAgICAgICAgICBpbkNoYXJSYW5nZSA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhdHRlcm4gKz0gYCR7c291cmNlW2ldfSR7c291cmNlW2ldLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc291cmNlW2ldLm1hdGNoKC9bYS16XS8pKSB7XG4gICAgICAgIHBhdHRlcm4gKz0gYFske3NvdXJjZVtpXX0ke3NvdXJjZVtpXS50b1VwcGVyQ2FzZSgpfV1gO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZsYWdzLm0pIHtcbiAgICAgIGlmIChzb3VyY2VbaV0gPT09IFwiXlwiKSB7XG4gICAgICAgIHBhdHRlcm4gKz0gYChefCg/PD1bXFxyXG5dKSlgO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoc291cmNlW2ldID09PSBcIiRcIikge1xuICAgICAgICBwYXR0ZXJuICs9IGAoJHwoPz1bXFxyXG5dKSlgO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZsYWdzLnMgJiYgc291cmNlW2ldID09PSBcIi5cIikge1xuICAgICAgcGF0dGVybiArPSBpbkNoYXJHcm91cCA/IGAke3NvdXJjZVtpXX1cXHJcbmAgOiBgWyR7c291cmNlW2ldfVxcclxuXWA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcGF0dGVybiArPSBzb3VyY2VbaV07XG4gICAgaWYgKHNvdXJjZVtpXSA9PT0gXCJcXFxcXCIpIHtcbiAgICAgIGlzRXNjYXBlZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChpbkNoYXJHcm91cCAmJiBzb3VyY2VbaV0gPT09IFwiXVwiKSB7XG4gICAgICBpbkNoYXJHcm91cCA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoIWluQ2hhckdyb3VwICYmIHNvdXJjZVtpXSA9PT0gXCJbXCIpIHtcbiAgICAgIGluQ2hhckdyb3VwID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICBuZXcgUmVnRXhwKHBhdHRlcm4pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYENvdWxkIG5vdCBjb252ZXJ0IHJlZ2V4IHBhdHRlcm4gYXQgJHtyZWZzLmN1cnJlbnRQYXRoLmpvaW4oXG4gICAgICAgIFwiL1wiXG4gICAgICApfSB0byBhIGZsYWctaW5kZXBlbmRlbnQgZm9ybSEgRmFsbGluZyBiYWNrIHRvIHRoZSBmbGFnLWlnbm9yYW50IHNvdXJjZWBcbiAgICApO1xuICAgIHJldHVybiByZWdleC5zb3VyY2U7XG4gIH1cbiAgcmV0dXJuIHBhdHRlcm47XG59XG5cbi8vIHNyYy90by1qc29uLXNjaGVtYS96b2QzLXRvLWpzb24tc2NoZW1hL3BhcnNlcnMvcmVjb3JkLnRzXG5mdW5jdGlvbiBwYXJzZVJlY29yZERlZihkZWYsIHJlZnMpIHtcbiAgdmFyIF9hMiwgX2IyLCBfYywgX2QsIF9lLCBfZjtcbiAgY29uc3Qgc2NoZW1hID0ge1xuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IChfYTIgPSBwYXJzZURlZihkZWYudmFsdWVUeXBlLl9kZWYsIHtcbiAgICAgIC4uLnJlZnMsXG4gICAgICBjdXJyZW50UGF0aDogWy4uLnJlZnMuY3VycmVudFBhdGgsIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIl1cbiAgICB9KSkgIT0gbnVsbCA/IF9hMiA6IHJlZnMuYWxsb3dlZEFkZGl0aW9uYWxQcm9wZXJ0aWVzXG4gIH07XG4gIGlmICgoKF9iMiA9IGRlZi5rZXlUeXBlKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLl9kZWYudHlwZU5hbWUpID09PSBab2RGaXJzdFBhcnR5VHlwZUtpbmQyLlpvZFN0cmluZyAmJiAoKF9jID0gZGVmLmtleVR5cGUuX2RlZi5jaGVja3MpID09IG51bGwgPyB2b2lkIDAgOiBfYy5sZW5ndGgpKSB7XG4gICAgY29uc3QgeyB0eXBlLCAuLi5rZXlUeXBlIH0gPSBwYXJzZVN0cmluZ0RlZihkZWYua2V5VHlwZS5fZGVmLCByZWZzKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc2NoZW1hLFxuICAgICAgcHJvcGVydHlOYW1lczoga2V5VHlwZVxuICAgIH07XG4gIH0gZWxzZSBpZiAoKChfZCA9IGRlZi5rZXlUeXBlKSA9PSBudWxsID8gdm9pZCAwIDogX2QuX2RlZi50eXBlTmFtZSkgPT09IFpvZEZpcnN0UGFydHlUeXBlS2luZDIuWm9kRW51bSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zY2hlbWEsXG4gICAgICBwcm9wZXJ0eU5hbWVzOiB7XG4gICAgICAgIGVudW06IGRlZi5rZXlUeXBlLl9kZWYudmFsdWVzXG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIGlmICgoKF9lID0gZGVmLmtleVR5cGUpID09IG51bGwgPyB2b2lkIDAgOiBfZS5fZGVmLnR5cGVOYW1lKSA9PT0gWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMi5ab2RCcmFuZGVkICYmIGRlZi5rZXlUeXBlLl9kZWYudHlwZS5fZGVmLnR5cGVOYW1lID09PSBab2RGaXJzdFBhcnR5VHlwZUtpbmQyLlpvZFN0cmluZyAmJiAoKF9mID0gZGVmLmtleVR5cGUuX2RlZi50eXBlLl9kZWYuY2hlY2tzKSA9PSBudWxsID8gdm9pZCAwIDogX2YubGVuZ3RoKSkge1xuICAgIGNvbnN0IHsgdHlwZSwgLi4ua2V5VHlwZSB9ID0gcGFyc2VCcmFuZGVkRGVmKFxuICAgICAgZGVmLmtleVR5cGUuX2RlZixcbiAgICAgIHJlZnNcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zY2hlbWEsXG4gICAgICBwcm9wZXJ0eU5hbWVzOiBrZXlUeXBlXG4gICAgfTtcbiAgfVxuICByZXR1cm4gc2NoZW1hO1xufVxuXG4vLyBzcmMvdG8tanNvbi1zY2hlbWEvem9kMy10by1qc29uLXNjaGVtYS9wYXJzZXJzL21hcC50c1xuZnVuY3Rpb24gcGFyc2VNYXBEZWYoZGVmLCByZWZzKSB7XG4gIGlmIChyZWZzLm1hcFN0cmF0ZWd5ID09PSBcInJlY29yZFwiKSB7XG4gICAgcmV0dXJuIHBhcnNlUmVjb3JkRGVmKGRlZiwgcmVmcyk7XG4gIH1cbiAgY29uc3Qga2V5cyA9IHBhcnNlRGVmKGRlZi5rZXlUeXBlLl9kZWYsIHtcbiAgICAuLi5yZWZzLFxuICAgIGN1cnJlbnRQYXRoOiBbLi4ucmVmcy5jdXJyZW50UGF0aCwgXCJpdGVtc1wiLCBcIml0ZW1zXCIsIFwiMFwiXVxuICB9KSB8fCBwYXJzZUFueURlZigpO1xuICBjb25zdCB2YWx1ZXMgPSBwYXJzZURlZihkZWYudmFsdWVUeXBlLl9kZWYsIHtcbiAgICAuLi5yZWZzLFxuICAgIGN1cnJlbnRQYXRoOiBbLi4ucmVmcy5jdXJyZW50UGF0aCwgXCJpdGVtc1wiLCBcIml0ZW1zXCIsIFwiMVwiXVxuICB9KSB8fCBwYXJzZUFueURlZigpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBtYXhJdGVtczogMTI1LFxuICAgIGl0ZW1zOiB7XG4gICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICBpdGVtczogW2tleXMsIHZhbHVlc10sXG4gICAgICBtaW5JdGVtczogMixcbiAgICAgIG1heEl0ZW1zOiAyXG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdG8tanNvbi1zY2hlbWEvem9kMy10by1qc29uLXNjaGVtYS9wYXJzZXJzL25hdGl2ZS1lbnVtLnRzXG5mdW5jdGlvbiBwYXJzZU5hdGl2ZUVudW1EZWYoZGVmKSB7XG4gIGNvbnN0IG9iamVjdCA9IGRlZi52YWx1ZXM7XG4gIGNvbnN0IGFjdHVhbEtleXMgPSBPYmplY3Qua2V5cyhkZWYudmFsdWVzKS5maWx0ZXIoKGtleSkgPT4ge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0W29iamVjdFtrZXldXSAhPT0gXCJudW1iZXJcIjtcbiAgfSk7XG4gIGNvbnN0IGFjdHVhbFZhbHVlcyA9IGFjdHVhbEtleXMubWFwKChrZXkpID0+IG9iamVjdFtrZXldKTtcbiAgY29uc3QgcGFyc2VkVHlwZXMgPSBBcnJheS5mcm9tKFxuICAgIG5ldyBTZXQoYWN0dWFsVmFsdWVzLm1hcCgodmFsdWVzKSA9PiB0eXBlb2YgdmFsdWVzKSlcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBwYXJzZWRUeXBlcy5sZW5ndGggPT09IDEgPyBwYXJzZWRUeXBlc1swXSA9PT0gXCJzdHJpbmdcIiA/IFwic3RyaW5nXCIgOiBcIm51bWJlclwiIDogW1wic3RyaW5nXCIsIFwibnVtYmVyXCJdLFxuICAgIGVudW06IGFjdHVhbFZhbHVlc1xuICB9O1xufVxuXG4vLyBzcmMvdG8tanNvbi1zY2hlbWEvem9kMy10by1qc29uLXNjaGVtYS9wYXJzZXJzL25ldmVyLnRzXG5mdW5jdGlvbiBwYXJzZU5ldmVyRGVmKCkge1xuICByZXR1cm4geyBub3Q6IHBhcnNlQW55RGVmKCkgfTtcbn1cblxuLy8gc3JjL3RvLWpzb24tc2NoZW1hL3pvZDMtdG8tanNvbi1zY2hlbWEvcGFyc2Vycy9udWxsLnRzXG5mdW5jdGlvbiBwYXJzZU51bGxEZWYoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJudWxsXCJcbiAgfTtcbn1cblxuLy8gc3JjL3RvLWpzb24tc2NoZW1hL3pvZDMtdG8tanNvbi1zY2hlbWEvcGFyc2Vycy91bmlvbi50c1xudmFyIHByaW1pdGl2ZU1hcHBpbmdzID0ge1xuICBab2RTdHJpbmc6IFwic3RyaW5nXCIsXG4gIFpvZE51bWJlcjogXCJudW1iZXJcIixcbiAgWm9kQmlnSW50OiBcImludGVnZXJcIixcbiAgWm9kQm9vbGVhbjogXCJib29sZWFuXCIsXG4gIFpvZE51bGw6IFwibnVsbFwiXG59O1xuZnVuY3Rpb24gcGFyc2VVbmlvbkRlZihkZWYsIHJlZnMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGRlZi5vcHRpb25zIGluc3RhbmNlb2YgTWFwID8gQXJyYXkuZnJvbShkZWYub3B0aW9ucy52YWx1ZXMoKSkgOiBkZWYub3B0aW9ucztcbiAgaWYgKG9wdGlvbnMuZXZlcnkoXG4gICAgKHgpID0+IHguX2RlZi50eXBlTmFtZSBpbiBwcmltaXRpdmVNYXBwaW5ncyAmJiAoIXguX2RlZi5jaGVja3MgfHwgIXguX2RlZi5jaGVja3MubGVuZ3RoKVxuICApKSB7XG4gICAgY29uc3QgdHlwZXMgPSBvcHRpb25zLnJlZHVjZSgodHlwZXMyLCB4KSA9PiB7XG4gICAgICBjb25zdCB0eXBlID0gcHJpbWl0aXZlTWFwcGluZ3NbeC5fZGVmLnR5cGVOYW1lXTtcbiAgICAgIHJldHVybiB0eXBlICYmICF0eXBlczIuaW5jbHVkZXModHlwZSkgPyBbLi4udHlwZXMyLCB0eXBlXSA6IHR5cGVzMjtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHR5cGVzLmxlbmd0aCA+IDEgPyB0eXBlcyA6IHR5cGVzWzBdXG4gICAgfTtcbiAgfSBlbHNlIGlmIChvcHRpb25zLmV2ZXJ5KCh4KSA9PiB4Ll9kZWYudHlwZU5hbWUgPT09IFwiWm9kTGl0ZXJhbFwiICYmICF4LmRlc2NyaXB0aW9uKSkge1xuICAgIGNvbnN0IHR5cGVzID0gb3B0aW9ucy5yZWR1Y2UoXG4gICAgICAoYWNjLCB4KSA9PiB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgeC5fZGVmLnZhbHVlO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICByZXR1cm4gWy4uLmFjYywgdHlwZV07XG4gICAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgICAgcmV0dXJuIFsuLi5hY2MsIFwiaW50ZWdlclwiXTtcbiAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICBpZiAoeC5fZGVmLnZhbHVlID09PSBudWxsKSByZXR1cm4gWy4uLmFjYywgXCJudWxsXCJdO1xuICAgICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBbXVxuICAgICk7XG4gICAgaWYgKHR5cGVzLmxlbmd0aCA9PT0gb3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHVuaXF1ZVR5cGVzID0gdHlwZXMuZmlsdGVyKCh4LCBpLCBhKSA9PiBhLmluZGV4T2YoeCkgPT09IGkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdW5pcXVlVHlwZXMubGVuZ3RoID4gMSA/IHVuaXF1ZVR5cGVzIDogdW5pcXVlVHlwZXNbMF0sXG4gICAgICAgIGVudW06IG9wdGlvbnMucmVkdWNlKFxuICAgICAgICAgIChhY2MsIHgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhY2MuaW5jbHVkZXMoeC5fZGVmLnZhbHVlKSA/IGFjYyA6IFsuLi5hY2MsIHguX2RlZi52YWx1ZV07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBbXVxuICAgICAgICApXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChvcHRpb25zLmV2ZXJ5KCh4KSA9PiB4Ll9kZWYudHlwZU5hbWUgPT09IFwiWm9kRW51bVwiKSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgZW51bTogb3B0aW9ucy5yZWR1Y2UoXG4gICAgICAgIChhY2MsIHgpID0+IFtcbiAgICAgICAgICAuLi5hY2MsXG4gICAgICAgICAgLi4ueC5fZGVmLnZhbHVlcy5maWx0ZXIoKHgyKSA9PiAhYWNjLmluY2x1ZGVzKHgyKSlcbiAgICAgICAgXSxcbiAgICAgICAgW11cbiAgICAgIClcbiAgICB9O1xuICB9XG4gIHJldHVybiBhc0FueU9mKGRlZiwgcmVmcyk7XG59XG52YXIgYXNBbnlPZiA9IChkZWYsIHJlZnMpID0+IHtcbiAgY29uc3QgYW55T2YgPSAoZGVmLm9wdGlvbnMgaW5zdGFuY2VvZiBNYXAgPyBBcnJheS5mcm9tKGRlZi5vcHRpb25zLnZhbHVlcygpKSA6IGRlZi5vcHRpb25zKS5tYXAoXG4gICAgKHgsIGkpID0+IHBhcnNlRGVmKHguX2RlZiwge1xuICAgICAgLi4ucmVmcyxcbiAgICAgIGN1cnJlbnRQYXRoOiBbLi4ucmVmcy5jdXJyZW50UGF0aCwgXCJhbnlPZlwiLCBgJHtpfWBdXG4gICAgfSlcbiAgKS5maWx0ZXIoXG4gICAgKHgpID0+ICEheCAmJiAoIXJlZnMuc3RyaWN0VW5pb25zIHx8IHR5cGVvZiB4ID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5rZXlzKHgpLmxlbmd0aCA+IDApXG4gICk7XG4gIHJldHVybiBhbnlPZi5sZW5ndGggPyB7IGFueU9mIH0gOiB2b2lkIDA7XG59O1xuXG4vLyBzcmMvdG8tanNvbi1zY2hlbWEvem9kMy10by1qc29uLXNjaGVtYS9wYXJzZXJzL251bGxhYmxlLnRzXG5mdW5jdGlvbiBwYXJzZU51bGxhYmxlRGVmKGRlZiwgcmVmcykge1xuICBpZiAoW1wiWm9kU3RyaW5nXCIsIFwiWm9kTnVtYmVyXCIsIFwiWm9kQmlnSW50XCIsIFwiWm9kQm9vbGVhblwiLCBcIlpvZE51bGxcIl0uaW5jbHVkZXMoXG4gICAgZGVmLmlubmVyVHlwZS5fZGVmLnR5cGVOYW1lXG4gICkgJiYgKCFkZWYuaW5uZXJUeXBlLl9kZWYuY2hlY2tzIHx8ICFkZWYuaW5uZXJUeXBlLl9kZWYuY2hlY2tzLmxlbmd0aCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogW1xuICAgICAgICBwcmltaXRpdmVNYXBwaW5nc1tkZWYuaW5uZXJUeXBlLl9kZWYudHlwZU5hbWVdLFxuICAgICAgICBcIm51bGxcIlxuICAgICAgXVxuICAgIH07XG4gIH1cbiAgY29uc3QgYmFzZSA9IHBhcnNlRGVmKGRlZi5pbm5lclR5cGUuX2RlZiwge1xuICAgIC4uLnJlZnMsXG4gICAgY3VycmVudFBhdGg6IFsuLi5yZWZzLmN1cnJlbnRQYXRoLCBcImFueU9mXCIsIFwiMFwiXVxuICB9KTtcbiAgcmV0dXJuIGJhc2UgJiYgeyBhbnlPZjogW2Jhc2UsIHsgdHlwZTogXCJudWxsXCIgfV0gfTtcbn1cblxuLy8gc3JjL3RvLWpzb24tc2NoZW1hL3pvZDMtdG8tanNvbi1zY2hlbWEvcGFyc2Vycy9udW1iZXIudHNcbmZ1bmN0aW9uIHBhcnNlTnVtYmVyRGVmKGRlZikge1xuICBjb25zdCByZXMgPSB7XG4gICAgdHlwZTogXCJudW1iZXJcIlxuICB9O1xuICBpZiAoIWRlZi5jaGVja3MpIHJldHVybiByZXM7XG4gIGZvciAoY29uc3QgY2hlY2sgb2YgZGVmLmNoZWNrcykge1xuICAgIHN3aXRjaCAoY2hlY2sua2luZCkge1xuICAgICAgY2FzZSBcImludFwiOlxuICAgICAgICByZXMudHlwZSA9IFwiaW50ZWdlclwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtaW5cIjpcbiAgICAgICAgaWYgKGNoZWNrLmluY2x1c2l2ZSkge1xuICAgICAgICAgIHJlcy5taW5pbXVtID0gY2hlY2sudmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzLmV4Y2x1c2l2ZU1pbmltdW0gPSBjaGVjay52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtYXhcIjpcbiAgICAgICAgaWYgKGNoZWNrLmluY2x1c2l2ZSkge1xuICAgICAgICAgIHJlcy5tYXhpbXVtID0gY2hlY2sudmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzLmV4Y2x1c2l2ZU1heGltdW0gPSBjaGVjay52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtdWx0aXBsZU9mXCI6XG4gICAgICAgIHJlcy5tdWx0aXBsZU9mID0gY2hlY2sudmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vLyBzcmMvdG8tanNvbi1zY2hlbWEvem9kMy10by1qc29uLXNjaGVtYS9wYXJzZXJzL29iamVjdC50c1xuZnVuY3Rpb24gcGFyc2VPYmplY3REZWYoZGVmLCByZWZzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHByb3BlcnRpZXM6IHt9XG4gIH07XG4gIGNvbnN0IHJlcXVpcmVkID0gW107XG4gIGNvbnN0IHNoYXBlID0gZGVmLnNoYXBlKCk7XG4gIGZvciAoY29uc3QgcHJvcE5hbWUgaW4gc2hhcGUpIHtcbiAgICBsZXQgcHJvcERlZiA9IHNoYXBlW3Byb3BOYW1lXTtcbiAgICBpZiAocHJvcERlZiA9PT0gdm9pZCAwIHx8IHByb3BEZWYuX2RlZiA9PT0gdm9pZCAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgcHJvcE9wdGlvbmFsID0gc2FmZUlzT3B0aW9uYWwocHJvcERlZik7XG4gICAgY29uc3QgcGFyc2VkRGVmID0gcGFyc2VEZWYocHJvcERlZi5fZGVmLCB7XG4gICAgICAuLi5yZWZzLFxuICAgICAgY3VycmVudFBhdGg6IFsuLi5yZWZzLmN1cnJlbnRQYXRoLCBcInByb3BlcnRpZXNcIiwgcHJvcE5hbWVdLFxuICAgICAgcHJvcGVydHlQYXRoOiBbLi4ucmVmcy5jdXJyZW50UGF0aCwgXCJwcm9wZXJ0aWVzXCIsIHByb3BOYW1lXVxuICAgIH0pO1xuICAgIGlmIChwYXJzZWREZWYgPT09IHZvaWQgMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJlc3VsdC5wcm9wZXJ0aWVzW3Byb3BOYW1lXSA9IHBhcnNlZERlZjtcbiAgICBpZiAoIXByb3BPcHRpb25hbCkge1xuICAgICAgcmVxdWlyZWQucHVzaChwcm9wTmFtZSk7XG4gICAgfVxuICB9XG4gIGlmIChyZXF1aXJlZC5sZW5ndGgpIHtcbiAgICByZXN1bHQucmVxdWlyZWQgPSByZXF1aXJlZDtcbiAgfVxuICBjb25zdCBhZGRpdGlvbmFsUHJvcGVydGllcyA9IGRlY2lkZUFkZGl0aW9uYWxQcm9wZXJ0aWVzKGRlZiwgcmVmcyk7XG4gIGlmIChhZGRpdGlvbmFsUHJvcGVydGllcyAhPT0gdm9pZCAwKSB7XG4gICAgcmVzdWx0LmFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gYWRkaXRpb25hbFByb3BlcnRpZXM7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGRlY2lkZUFkZGl0aW9uYWxQcm9wZXJ0aWVzKGRlZiwgcmVmcykge1xuICBpZiAoZGVmLmNhdGNoYWxsLl9kZWYudHlwZU5hbWUgIT09IFwiWm9kTmV2ZXJcIikge1xuICAgIHJldHVybiBwYXJzZURlZihkZWYuY2F0Y2hhbGwuX2RlZiwge1xuICAgICAgLi4ucmVmcyxcbiAgICAgIGN1cnJlbnRQYXRoOiBbLi4ucmVmcy5jdXJyZW50UGF0aCwgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiXVxuICAgIH0pO1xuICB9XG4gIHN3aXRjaCAoZGVmLnVua25vd25LZXlzKSB7XG4gICAgY2FzZSBcInBhc3N0aHJvdWdoXCI6XG4gICAgICByZXR1cm4gcmVmcy5hbGxvd2VkQWRkaXRpb25hbFByb3BlcnRpZXM7XG4gICAgY2FzZSBcInN0cmljdFwiOlxuICAgICAgcmV0dXJuIHJlZnMucmVqZWN0ZWRBZGRpdGlvbmFsUHJvcGVydGllcztcbiAgICBjYXNlIFwic3RyaXBcIjpcbiAgICAgIHJldHVybiByZWZzLnJlbW92ZUFkZGl0aW9uYWxTdHJhdGVneSA9PT0gXCJzdHJpY3RcIiA/IHJlZnMuYWxsb3dlZEFkZGl0aW9uYWxQcm9wZXJ0aWVzIDogcmVmcy5yZWplY3RlZEFkZGl0aW9uYWxQcm9wZXJ0aWVzO1xuICB9XG59XG5mdW5jdGlvbiBzYWZlSXNPcHRpb25hbChzY2hlbWEpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gc2NoZW1hLmlzT3B0aW9uYWwoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8vIHNyYy90by1qc29uLXNjaGVtYS96b2QzLXRvLWpzb24tc2NoZW1hL3BhcnNlcnMvb3B0aW9uYWwudHNcbnZhciBwYXJzZU9wdGlvbmFsRGVmID0gKGRlZiwgcmVmcykgPT4ge1xuICB2YXIgX2EyO1xuICBpZiAocmVmcy5jdXJyZW50UGF0aC50b1N0cmluZygpID09PSAoKF9hMiA9IHJlZnMucHJvcGVydHlQYXRoKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnRvU3RyaW5nKCkpKSB7XG4gICAgcmV0dXJuIHBhcnNlRGVmKGRlZi5pbm5lclR5cGUuX2RlZiwgcmVmcyk7XG4gIH1cbiAgY29uc3QgaW5uZXJTY2hlbWEgPSBwYXJzZURlZihkZWYuaW5uZXJUeXBlLl9kZWYsIHtcbiAgICAuLi5yZWZzLFxuICAgIGN1cnJlbnRQYXRoOiBbLi4ucmVmcy5jdXJyZW50UGF0aCwgXCJhbnlPZlwiLCBcIjFcIl1cbiAgfSk7XG4gIHJldHVybiBpbm5lclNjaGVtYSA/IHsgYW55T2Y6IFt7IG5vdDogcGFyc2VBbnlEZWYoKSB9LCBpbm5lclNjaGVtYV0gfSA6IHBhcnNlQW55RGVmKCk7XG59O1xuXG4vLyBzcmMvdG8tanNvbi1zY2hlbWEvem9kMy10by1qc29uLXNjaGVtYS9wYXJzZXJzL3BpcGVsaW5lLnRzXG52YXIgcGFyc2VQaXBlbGluZURlZiA9IChkZWYsIHJlZnMpID0+IHtcbiAgaWYgKHJlZnMucGlwZVN0cmF0ZWd5ID09PSBcImlucHV0XCIpIHtcbiAgICByZXR1cm4gcGFyc2VEZWYoZGVmLmluLl9kZWYsIHJlZnMpO1xuICB9IGVsc2UgaWYgKHJlZnMucGlwZVN0cmF0ZWd5ID09PSBcIm91dHB1dFwiKSB7XG4gICAgcmV0dXJuIHBhcnNlRGVmKGRlZi5vdXQuX2RlZiwgcmVmcyk7XG4gIH1cbiAgY29uc3QgYSA9IHBhcnNlRGVmKGRlZi5pbi5fZGVmLCB7XG4gICAgLi4ucmVmcyxcbiAgICBjdXJyZW50UGF0aDogWy4uLnJlZnMuY3VycmVudFBhdGgsIFwiYWxsT2ZcIiwgXCIwXCJdXG4gIH0pO1xuICBjb25zdCBiID0gcGFyc2VEZWYoZGVmLm91dC5fZGVmLCB7XG4gICAgLi4ucmVmcyxcbiAgICBjdXJyZW50UGF0aDogWy4uLnJlZnMuY3VycmVudFBhdGgsIFwiYWxsT2ZcIiwgYSA/IFwiMVwiIDogXCIwXCJdXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGFsbE9mOiBbYSwgYl0uZmlsdGVyKCh4KSA9PiB4ICE9PSB2b2lkIDApXG4gIH07XG59O1xuXG4vLyBzcmMvdG8tanNvbi1zY2hlbWEvem9kMy10by1qc29uLXNjaGVtYS9wYXJzZXJzL3Byb21pc2UudHNcbmZ1bmN0aW9uIHBhcnNlUHJvbWlzZURlZihkZWYsIHJlZnMpIHtcbiAgcmV0dXJuIHBhcnNlRGVmKGRlZi50eXBlLl9kZWYsIHJlZnMpO1xufVxuXG4vLyBzcmMvdG8tanNvbi1zY2hlbWEvem9kMy10by1qc29uLXNjaGVtYS9wYXJzZXJzL3NldC50c1xuZnVuY3Rpb24gcGFyc2VTZXREZWYoZGVmLCByZWZzKSB7XG4gIGNvbnN0IGl0ZW1zID0gcGFyc2VEZWYoZGVmLnZhbHVlVHlwZS5fZGVmLCB7XG4gICAgLi4ucmVmcyxcbiAgICBjdXJyZW50UGF0aDogWy4uLnJlZnMuY3VycmVudFBhdGgsIFwiaXRlbXNcIl1cbiAgfSk7XG4gIGNvbnN0IHNjaGVtYSA9IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgdW5pcXVlSXRlbXM6IHRydWUsXG4gICAgaXRlbXNcbiAgfTtcbiAgaWYgKGRlZi5taW5TaXplKSB7XG4gICAgc2NoZW1hLm1pbkl0ZW1zID0gZGVmLm1pblNpemUudmFsdWU7XG4gIH1cbiAgaWYgKGRlZi5tYXhTaXplKSB7XG4gICAgc2NoZW1hLm1heEl0ZW1zID0gZGVmLm1heFNpemUudmFsdWU7XG4gIH1cbiAgcmV0dXJuIHNjaGVtYTtcbn1cblxuLy8gc3JjL3RvLWpzb24tc2NoZW1hL3pvZDMtdG8tanNvbi1zY2hlbWEvcGFyc2Vycy90dXBsZS50c1xuZnVuY3Rpb24gcGFyc2VUdXBsZURlZihkZWYsIHJlZnMpIHtcbiAgaWYgKGRlZi5yZXN0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgIG1pbkl0ZW1zOiBkZWYuaXRlbXMubGVuZ3RoLFxuICAgICAgaXRlbXM6IGRlZi5pdGVtcy5tYXAoXG4gICAgICAgICh4LCBpKSA9PiBwYXJzZURlZih4Ll9kZWYsIHtcbiAgICAgICAgICAuLi5yZWZzLFxuICAgICAgICAgIGN1cnJlbnRQYXRoOiBbLi4ucmVmcy5jdXJyZW50UGF0aCwgXCJpdGVtc1wiLCBgJHtpfWBdXG4gICAgICAgIH0pXG4gICAgICApLnJlZHVjZShcbiAgICAgICAgKGFjYywgeCkgPT4geCA9PT0gdm9pZCAwID8gYWNjIDogWy4uLmFjYywgeF0sXG4gICAgICAgIFtdXG4gICAgICApLFxuICAgICAgYWRkaXRpb25hbEl0ZW1zOiBwYXJzZURlZihkZWYucmVzdC5fZGVmLCB7XG4gICAgICAgIC4uLnJlZnMsXG4gICAgICAgIGN1cnJlbnRQYXRoOiBbLi4ucmVmcy5jdXJyZW50UGF0aCwgXCJhZGRpdGlvbmFsSXRlbXNcIl1cbiAgICAgIH0pXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgbWluSXRlbXM6IGRlZi5pdGVtcy5sZW5ndGgsXG4gICAgICBtYXhJdGVtczogZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgIGl0ZW1zOiBkZWYuaXRlbXMubWFwKFxuICAgICAgICAoeCwgaSkgPT4gcGFyc2VEZWYoeC5fZGVmLCB7XG4gICAgICAgICAgLi4ucmVmcyxcbiAgICAgICAgICBjdXJyZW50UGF0aDogWy4uLnJlZnMuY3VycmVudFBhdGgsIFwiaXRlbXNcIiwgYCR7aX1gXVxuICAgICAgICB9KVxuICAgICAgKS5yZWR1Y2UoXG4gICAgICAgIChhY2MsIHgpID0+IHggPT09IHZvaWQgMCA/IGFjYyA6IFsuLi5hY2MsIHhdLFxuICAgICAgICBbXVxuICAgICAgKVxuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL3RvLWpzb24tc2NoZW1hL3pvZDMtdG8tanNvbi1zY2hlbWEvcGFyc2Vycy91bmRlZmluZWQudHNcbmZ1bmN0aW9uIHBhcnNlVW5kZWZpbmVkRGVmKCkge1xuICByZXR1cm4ge1xuICAgIG5vdDogcGFyc2VBbnlEZWYoKVxuICB9O1xufVxuXG4vLyBzcmMvdG8tanNvbi1zY2hlbWEvem9kMy10by1qc29uLXNjaGVtYS9wYXJzZXJzL3Vua25vd24udHNcbmZ1bmN0aW9uIHBhcnNlVW5rbm93bkRlZigpIHtcbiAgcmV0dXJuIHBhcnNlQW55RGVmKCk7XG59XG5cbi8vIHNyYy90by1qc29uLXNjaGVtYS96b2QzLXRvLWpzb24tc2NoZW1hL3BhcnNlcnMvcmVhZG9ubHkudHNcbnZhciBwYXJzZVJlYWRvbmx5RGVmID0gKGRlZiwgcmVmcykgPT4ge1xuICByZXR1cm4gcGFyc2VEZWYoZGVmLmlubmVyVHlwZS5fZGVmLCByZWZzKTtcbn07XG5cbi8vIHNyYy90by1qc29uLXNjaGVtYS96b2QzLXRvLWpzb24tc2NoZW1hL3NlbGVjdC1wYXJzZXIudHNcbnZhciBzZWxlY3RQYXJzZXIgPSAoZGVmLCB0eXBlTmFtZSwgcmVmcykgPT4ge1xuICBzd2l0Y2ggKHR5cGVOYW1lKSB7XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQzLlpvZFN0cmluZzpcbiAgICAgIHJldHVybiBwYXJzZVN0cmluZ0RlZihkZWYsIHJlZnMpO1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMy5ab2ROdW1iZXI6XG4gICAgICByZXR1cm4gcGFyc2VOdW1iZXJEZWYoZGVmKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZDMuWm9kT2JqZWN0OlxuICAgICAgcmV0dXJuIHBhcnNlT2JqZWN0RGVmKGRlZiwgcmVmcyk7XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQzLlpvZEJpZ0ludDpcbiAgICAgIHJldHVybiBwYXJzZUJpZ2ludERlZihkZWYpO1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMy5ab2RCb29sZWFuOlxuICAgICAgcmV0dXJuIHBhcnNlQm9vbGVhbkRlZigpO1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMy5ab2REYXRlOlxuICAgICAgcmV0dXJuIHBhcnNlRGF0ZURlZihkZWYsIHJlZnMpO1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMy5ab2RVbmRlZmluZWQ6XG4gICAgICByZXR1cm4gcGFyc2VVbmRlZmluZWREZWYoKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZDMuWm9kTnVsbDpcbiAgICAgIHJldHVybiBwYXJzZU51bGxEZWYoKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZDMuWm9kQXJyYXk6XG4gICAgICByZXR1cm4gcGFyc2VBcnJheURlZihkZWYsIHJlZnMpO1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMy5ab2RVbmlvbjpcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZDMuWm9kRGlzY3JpbWluYXRlZFVuaW9uOlxuICAgICAgcmV0dXJuIHBhcnNlVW5pb25EZWYoZGVmLCByZWZzKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZDMuWm9kSW50ZXJzZWN0aW9uOlxuICAgICAgcmV0dXJuIHBhcnNlSW50ZXJzZWN0aW9uRGVmKGRlZiwgcmVmcyk7XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQzLlpvZFR1cGxlOlxuICAgICAgcmV0dXJuIHBhcnNlVHVwbGVEZWYoZGVmLCByZWZzKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZDMuWm9kUmVjb3JkOlxuICAgICAgcmV0dXJuIHBhcnNlUmVjb3JkRGVmKGRlZiwgcmVmcyk7XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQzLlpvZExpdGVyYWw6XG4gICAgICByZXR1cm4gcGFyc2VMaXRlcmFsRGVmKGRlZik7XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQzLlpvZEVudW06XG4gICAgICByZXR1cm4gcGFyc2VFbnVtRGVmKGRlZik7XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQzLlpvZE5hdGl2ZUVudW06XG4gICAgICByZXR1cm4gcGFyc2VOYXRpdmVFbnVtRGVmKGRlZik7XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQzLlpvZE51bGxhYmxlOlxuICAgICAgcmV0dXJuIHBhcnNlTnVsbGFibGVEZWYoZGVmLCByZWZzKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZDMuWm9kT3B0aW9uYWw6XG4gICAgICByZXR1cm4gcGFyc2VPcHRpb25hbERlZihkZWYsIHJlZnMpO1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMy5ab2RNYXA6XG4gICAgICByZXR1cm4gcGFyc2VNYXBEZWYoZGVmLCByZWZzKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZDMuWm9kU2V0OlxuICAgICAgcmV0dXJuIHBhcnNlU2V0RGVmKGRlZiwgcmVmcyk7XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQzLlpvZExhenk6XG4gICAgICByZXR1cm4gKCkgPT4gZGVmLmdldHRlcigpLl9kZWY7XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQzLlpvZFByb21pc2U6XG4gICAgICByZXR1cm4gcGFyc2VQcm9taXNlRGVmKGRlZiwgcmVmcyk7XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQzLlpvZE5hTjpcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZDMuWm9kTmV2ZXI6XG4gICAgICByZXR1cm4gcGFyc2VOZXZlckRlZigpO1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMy5ab2RFZmZlY3RzOlxuICAgICAgcmV0dXJuIHBhcnNlRWZmZWN0c0RlZihkZWYsIHJlZnMpO1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMy5ab2RBbnk6XG4gICAgICByZXR1cm4gcGFyc2VBbnlEZWYoKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZDMuWm9kVW5rbm93bjpcbiAgICAgIHJldHVybiBwYXJzZVVua25vd25EZWYoKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZDMuWm9kRGVmYXVsdDpcbiAgICAgIHJldHVybiBwYXJzZURlZmF1bHREZWYoZGVmLCByZWZzKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZDMuWm9kQnJhbmRlZDpcbiAgICAgIHJldHVybiBwYXJzZUJyYW5kZWREZWYoZGVmLCByZWZzKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZDMuWm9kUmVhZG9ubHk6XG4gICAgICByZXR1cm4gcGFyc2VSZWFkb25seURlZihkZWYsIHJlZnMpO1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMy5ab2RDYXRjaDpcbiAgICAgIHJldHVybiBwYXJzZUNhdGNoRGVmKGRlZiwgcmVmcyk7XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQzLlpvZFBpcGVsaW5lOlxuICAgICAgcmV0dXJuIHBhcnNlUGlwZWxpbmVEZWYoZGVmLCByZWZzKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZDMuWm9kRnVuY3Rpb246XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQzLlpvZFZvaWQ6XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQzLlpvZFN5bWJvbDpcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gKChfKSA9PiB2b2lkIDApKHR5cGVOYW1lKTtcbiAgfVxufTtcblxuLy8gc3JjL3RvLWpzb24tc2NoZW1hL3pvZDMtdG8tanNvbi1zY2hlbWEvZ2V0LXJlbGF0aXZlLXBhdGgudHNcbnZhciBnZXRSZWxhdGl2ZVBhdGggPSAocGF0aEEsIHBhdGhCKSA9PiB7XG4gIGxldCBpID0gMDtcbiAgZm9yICg7IGkgPCBwYXRoQS5sZW5ndGggJiYgaSA8IHBhdGhCLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHBhdGhBW2ldICE9PSBwYXRoQltpXSkgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIFsocGF0aEEubGVuZ3RoIC0gaSkudG9TdHJpbmcoKSwgLi4ucGF0aEIuc2xpY2UoaSldLmpvaW4oXCIvXCIpO1xufTtcblxuLy8gc3JjL3RvLWpzb24tc2NoZW1hL3pvZDMtdG8tanNvbi1zY2hlbWEvcGFyc2UtZGVmLnRzXG5mdW5jdGlvbiBwYXJzZURlZihkZWYsIHJlZnMsIGZvcmNlUmVzb2x1dGlvbiA9IGZhbHNlKSB7XG4gIHZhciBfYTI7XG4gIGNvbnN0IHNlZW5JdGVtID0gcmVmcy5zZWVuLmdldChkZWYpO1xuICBpZiAocmVmcy5vdmVycmlkZSkge1xuICAgIGNvbnN0IG92ZXJyaWRlUmVzdWx0ID0gKF9hMiA9IHJlZnMub3ZlcnJpZGUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY2FsbChcbiAgICAgIHJlZnMsXG4gICAgICBkZWYsXG4gICAgICByZWZzLFxuICAgICAgc2Vlbkl0ZW0sXG4gICAgICBmb3JjZVJlc29sdXRpb25cbiAgICApO1xuICAgIGlmIChvdmVycmlkZVJlc3VsdCAhPT0gaWdub3JlT3ZlcnJpZGUpIHtcbiAgICAgIHJldHVybiBvdmVycmlkZVJlc3VsdDtcbiAgICB9XG4gIH1cbiAgaWYgKHNlZW5JdGVtICYmICFmb3JjZVJlc29sdXRpb24pIHtcbiAgICBjb25zdCBzZWVuU2NoZW1hID0gZ2V0JHJlZihzZWVuSXRlbSwgcmVmcyk7XG4gICAgaWYgKHNlZW5TY2hlbWEgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHNlZW5TY2hlbWE7XG4gICAgfVxuICB9XG4gIGNvbnN0IG5ld0l0ZW0gPSB7IGRlZiwgcGF0aDogcmVmcy5jdXJyZW50UGF0aCwganNvblNjaGVtYTogdm9pZCAwIH07XG4gIHJlZnMuc2Vlbi5zZXQoZGVmLCBuZXdJdGVtKTtcbiAgY29uc3QganNvblNjaGVtYU9yR2V0dGVyID0gc2VsZWN0UGFyc2VyKGRlZiwgZGVmLnR5cGVOYW1lLCByZWZzKTtcbiAgY29uc3QganNvblNjaGVtYTIgPSB0eXBlb2YganNvblNjaGVtYU9yR2V0dGVyID09PSBcImZ1bmN0aW9uXCIgPyBwYXJzZURlZihqc29uU2NoZW1hT3JHZXR0ZXIoKSwgcmVmcykgOiBqc29uU2NoZW1hT3JHZXR0ZXI7XG4gIGlmIChqc29uU2NoZW1hMikge1xuICAgIGFkZE1ldGEoZGVmLCByZWZzLCBqc29uU2NoZW1hMik7XG4gIH1cbiAgaWYgKHJlZnMucG9zdFByb2Nlc3MpIHtcbiAgICBjb25zdCBwb3N0UHJvY2Vzc1Jlc3VsdCA9IHJlZnMucG9zdFByb2Nlc3MoanNvblNjaGVtYTIsIGRlZiwgcmVmcyk7XG4gICAgbmV3SXRlbS5qc29uU2NoZW1hID0ganNvblNjaGVtYTI7XG4gICAgcmV0dXJuIHBvc3RQcm9jZXNzUmVzdWx0O1xuICB9XG4gIG5ld0l0ZW0uanNvblNjaGVtYSA9IGpzb25TY2hlbWEyO1xuICByZXR1cm4ganNvblNjaGVtYTI7XG59XG52YXIgZ2V0JHJlZiA9IChpdGVtLCByZWZzKSA9PiB7XG4gIHN3aXRjaCAocmVmcy4kcmVmU3RyYXRlZ3kpIHtcbiAgICBjYXNlIFwicm9vdFwiOlxuICAgICAgcmV0dXJuIHsgJHJlZjogaXRlbS5wYXRoLmpvaW4oXCIvXCIpIH07XG4gICAgY2FzZSBcInJlbGF0aXZlXCI6XG4gICAgICByZXR1cm4geyAkcmVmOiBnZXRSZWxhdGl2ZVBhdGgocmVmcy5jdXJyZW50UGF0aCwgaXRlbS5wYXRoKSB9O1xuICAgIGNhc2UgXCJub25lXCI6XG4gICAgY2FzZSBcInNlZW5cIjoge1xuICAgICAgaWYgKGl0ZW0ucGF0aC5sZW5ndGggPCByZWZzLmN1cnJlbnRQYXRoLmxlbmd0aCAmJiBpdGVtLnBhdGguZXZlcnkoKHZhbHVlLCBpbmRleCkgPT4gcmVmcy5jdXJyZW50UGF0aFtpbmRleF0gPT09IHZhbHVlKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYFJlY3Vyc2l2ZSByZWZlcmVuY2UgZGV0ZWN0ZWQgYXQgJHtyZWZzLmN1cnJlbnRQYXRoLmpvaW4oXG4gICAgICAgICAgICBcIi9cIlxuICAgICAgICAgICl9ISBEZWZhdWx0aW5nIHRvIGFueWBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlQW55RGVmKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVmcy4kcmVmU3RyYXRlZ3kgPT09IFwic2VlblwiID8gcGFyc2VBbnlEZWYoKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbn07XG52YXIgYWRkTWV0YSA9IChkZWYsIHJlZnMsIGpzb25TY2hlbWEyKSA9PiB7XG4gIGlmIChkZWYuZGVzY3JpcHRpb24pIHtcbiAgICBqc29uU2NoZW1hMi5kZXNjcmlwdGlvbiA9IGRlZi5kZXNjcmlwdGlvbjtcbiAgfVxuICByZXR1cm4ganNvblNjaGVtYTI7XG59O1xuXG4vLyBzcmMvdG8tanNvbi1zY2hlbWEvem9kMy10by1qc29uLXNjaGVtYS9yZWZzLnRzXG52YXIgZ2V0UmVmcyA9IChvcHRpb25zKSA9PiB7XG4gIGNvbnN0IF9vcHRpb25zID0gZ2V0RGVmYXVsdE9wdGlvbnMob3B0aW9ucyk7XG4gIGNvbnN0IGN1cnJlbnRQYXRoID0gX29wdGlvbnMubmFtZSAhPT0gdm9pZCAwID8gWy4uLl9vcHRpb25zLmJhc2VQYXRoLCBfb3B0aW9ucy5kZWZpbml0aW9uUGF0aCwgX29wdGlvbnMubmFtZV0gOiBfb3B0aW9ucy5iYXNlUGF0aDtcbiAgcmV0dXJuIHtcbiAgICAuLi5fb3B0aW9ucyxcbiAgICBjdXJyZW50UGF0aCxcbiAgICBwcm9wZXJ0eVBhdGg6IHZvaWQgMCxcbiAgICBzZWVuOiBuZXcgTWFwKFxuICAgICAgT2JqZWN0LmVudHJpZXMoX29wdGlvbnMuZGVmaW5pdGlvbnMpLm1hcCgoW25hbWUyLCBkZWZdKSA9PiBbXG4gICAgICAgIGRlZi5fZGVmLFxuICAgICAgICB7XG4gICAgICAgICAgZGVmOiBkZWYuX2RlZixcbiAgICAgICAgICBwYXRoOiBbLi4uX29wdGlvbnMuYmFzZVBhdGgsIF9vcHRpb25zLmRlZmluaXRpb25QYXRoLCBuYW1lMl0sXG4gICAgICAgICAgLy8gUmVzb2x1dGlvbiBvZiByZWZlcmVuY2VzIHdpbGwgYmUgZm9yY2VkIGV2ZW4gdGhvdWdoIHNlZW4sIHNvIGl0J3Mgb2sgdGhhdCB0aGUgc2NoZW1hIGlzIHVuZGVmaW5lZCBoZXJlIGZvciBub3cuXG4gICAgICAgICAganNvblNjaGVtYTogdm9pZCAwXG4gICAgICAgIH1cbiAgICAgIF0pXG4gICAgKVxuICB9O1xufTtcblxuLy8gc3JjL3RvLWpzb24tc2NoZW1hL3pvZDMtdG8tanNvbi1zY2hlbWEvem9kMy10by1qc29uLXNjaGVtYS50c1xudmFyIHpvZDNUb0pzb25TY2hlbWEgPSAoc2NoZW1hLCBvcHRpb25zKSA9PiB7XG4gIHZhciBfYTI7XG4gIGNvbnN0IHJlZnMgPSBnZXRSZWZzKG9wdGlvbnMpO1xuICBsZXQgZGVmaW5pdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmRlZmluaXRpb25zID8gT2JqZWN0LmVudHJpZXMob3B0aW9ucy5kZWZpbml0aW9ucykucmVkdWNlKFxuICAgIChhY2MsIFtuYW1lMywgc2NoZW1hMl0pID0+IHtcbiAgICAgIHZhciBfYTM7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hY2MsXG4gICAgICAgIFtuYW1lM106IChfYTMgPSBwYXJzZURlZihcbiAgICAgICAgICBzY2hlbWEyLl9kZWYsXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4ucmVmcyxcbiAgICAgICAgICAgIGN1cnJlbnRQYXRoOiBbLi4ucmVmcy5iYXNlUGF0aCwgcmVmcy5kZWZpbml0aW9uUGF0aCwgbmFtZTNdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICkpICE9IG51bGwgPyBfYTMgOiBwYXJzZUFueURlZigpXG4gICAgICB9O1xuICAgIH0sXG4gICAge31cbiAgKSA6IHZvaWQgMDtcbiAgY29uc3QgbmFtZTIgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/IG9wdGlvbnMgOiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5uYW1lU3RyYXRlZ3kpID09PSBcInRpdGxlXCIgPyB2b2lkIDAgOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm5hbWU7XG4gIGNvbnN0IG1haW4gPSAoX2EyID0gcGFyc2VEZWYoXG4gICAgc2NoZW1hLl9kZWYsXG4gICAgbmFtZTIgPT09IHZvaWQgMCA/IHJlZnMgOiB7XG4gICAgICAuLi5yZWZzLFxuICAgICAgY3VycmVudFBhdGg6IFsuLi5yZWZzLmJhc2VQYXRoLCByZWZzLmRlZmluaXRpb25QYXRoLCBuYW1lMl1cbiAgICB9LFxuICAgIGZhbHNlXG4gICkpICE9IG51bGwgPyBfYTIgOiBwYXJzZUFueURlZigpO1xuICBjb25zdCB0aXRsZSA9IHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMubmFtZSAhPT0gdm9pZCAwICYmIG9wdGlvbnMubmFtZVN0cmF0ZWd5ID09PSBcInRpdGxlXCIgPyBvcHRpb25zLm5hbWUgOiB2b2lkIDA7XG4gIGlmICh0aXRsZSAhPT0gdm9pZCAwKSB7XG4gICAgbWFpbi50aXRsZSA9IHRpdGxlO1xuICB9XG4gIGNvbnN0IGNvbWJpbmVkID0gbmFtZTIgPT09IHZvaWQgMCA/IGRlZmluaXRpb25zID8ge1xuICAgIC4uLm1haW4sXG4gICAgW3JlZnMuZGVmaW5pdGlvblBhdGhdOiBkZWZpbml0aW9uc1xuICB9IDogbWFpbiA6IHtcbiAgICAkcmVmOiBbXG4gICAgICAuLi5yZWZzLiRyZWZTdHJhdGVneSA9PT0gXCJyZWxhdGl2ZVwiID8gW10gOiByZWZzLmJhc2VQYXRoLFxuICAgICAgcmVmcy5kZWZpbml0aW9uUGF0aCxcbiAgICAgIG5hbWUyXG4gICAgXS5qb2luKFwiL1wiKSxcbiAgICBbcmVmcy5kZWZpbml0aW9uUGF0aF06IHtcbiAgICAgIC4uLmRlZmluaXRpb25zLFxuICAgICAgW25hbWUyXTogbWFpblxuICAgIH1cbiAgfTtcbiAgY29tYmluZWQuJHNjaGVtYSA9IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCI7XG4gIHJldHVybiBjb21iaW5lZDtcbn07XG5cbi8vIHNyYy9zY2hlbWEudHNcbnZhciBzY2hlbWFTeW1ib2wgPSBTeW1ib2wuZm9yKFwidmVyY2VsLmFpLnNjaGVtYVwiKTtcbmZ1bmN0aW9uIGxhenlTY2hlbWEoY3JlYXRlU2NoZW1hKSB7XG4gIGxldCBzY2hlbWE7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgICBzY2hlbWEgPSBjcmVhdGVTY2hlbWEoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjaGVtYTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGpzb25TY2hlbWEoanNvblNjaGVtYTIsIHtcbiAgdmFsaWRhdGVcbn0gPSB7fSkge1xuICByZXR1cm4ge1xuICAgIFtzY2hlbWFTeW1ib2xdOiB0cnVlLFxuICAgIF90eXBlOiB2b2lkIDAsXG4gICAgLy8gc2hvdWxkIG5ldmVyIGJlIHVzZWQgZGlyZWN0bHlcbiAgICBnZXQganNvblNjaGVtYSgpIHtcbiAgICAgIGlmICh0eXBlb2YganNvblNjaGVtYTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBqc29uU2NoZW1hMiA9IGpzb25TY2hlbWEyKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ganNvblNjaGVtYTI7XG4gICAgfSxcbiAgICB2YWxpZGF0ZVxuICB9O1xufVxuZnVuY3Rpb24gaXNTY2hlbWEodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiBzY2hlbWFTeW1ib2wgaW4gdmFsdWUgJiYgdmFsdWVbc2NoZW1hU3ltYm9sXSA9PT0gdHJ1ZSAmJiBcImpzb25TY2hlbWFcIiBpbiB2YWx1ZSAmJiBcInZhbGlkYXRlXCIgaW4gdmFsdWU7XG59XG5mdW5jdGlvbiBhc1NjaGVtYShzY2hlbWEpIHtcbiAgcmV0dXJuIHNjaGVtYSA9PSBudWxsID8ganNvblNjaGVtYSh7IHByb3BlcnRpZXM6IHt9LCBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2UgfSkgOiBpc1NjaGVtYShzY2hlbWEpID8gc2NoZW1hIDogXCJ+c3RhbmRhcmRcIiBpbiBzY2hlbWEgPyBzY2hlbWFbXCJ+c3RhbmRhcmRcIl0udmVuZG9yID09PSBcInpvZFwiID8gem9kU2NoZW1hKHNjaGVtYSkgOiBzdGFuZGFyZFNjaGVtYShzY2hlbWEpIDogc2NoZW1hKCk7XG59XG5mdW5jdGlvbiBzdGFuZGFyZFNjaGVtYShzdGFuZGFyZFNjaGVtYTIpIHtcbiAgcmV0dXJuIGpzb25TY2hlbWEoXG4gICAgKCkgPT4gYWRkQWRkaXRpb25hbFByb3BlcnRpZXNUb0pzb25TY2hlbWEoXG4gICAgICBzdGFuZGFyZFNjaGVtYTJbXCJ+c3RhbmRhcmRcIl0uanNvblNjaGVtYS5pbnB1dCh7XG4gICAgICAgIHRhcmdldDogXCJkcmFmdC0wN1wiXG4gICAgICB9KVxuICAgICksXG4gICAge1xuICAgICAgdmFsaWRhdGU6IGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdGFuZGFyZFNjaGVtYTJbXCJ+c3RhbmRhcmRcIl0udmFsaWRhdGUodmFsdWUpO1xuICAgICAgICByZXR1cm4gXCJ2YWx1ZVwiIGluIHJlc3VsdCA/IHsgc3VjY2VzczogdHJ1ZSwgdmFsdWU6IHJlc3VsdC52YWx1ZSB9IDoge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcih7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGNhdXNlOiByZXN1bHQuaXNzdWVzXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiB6b2QzU2NoZW1hKHpvZFNjaGVtYTIsIG9wdGlvbnMpIHtcbiAgdmFyIF9hMjtcbiAgY29uc3QgdXNlUmVmZXJlbmNlcyA9IChfYTIgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnVzZVJlZmVyZW5jZXMpICE9IG51bGwgPyBfYTIgOiBmYWxzZTtcbiAgcmV0dXJuIGpzb25TY2hlbWEoXG4gICAgLy8gZGVmZXIganNvbiBzY2hlbWEgY3JlYXRpb24gdG8gYXZvaWQgdW5uZWNlc3NhcnkgY29tcHV0YXRpb24gd2hlbiBvbmx5IHZhbGlkYXRpb24gaXMgbmVlZGVkXG4gICAgKCkgPT4gem9kM1RvSnNvblNjaGVtYSh6b2RTY2hlbWEyLCB7XG4gICAgICAkcmVmU3RyYXRlZ3k6IHVzZVJlZmVyZW5jZXMgPyBcInJvb3RcIiA6IFwibm9uZVwiXG4gICAgfSksXG4gICAge1xuICAgICAgdmFsaWRhdGU6IGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB6b2RTY2hlbWEyLnNhZmVQYXJzZUFzeW5jKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zdWNjZXNzID8geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogcmVzdWx0LmRhdGEgfSA6IHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiByZXN1bHQuZXJyb3IgfTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiB6b2Q0U2NoZW1hKHpvZFNjaGVtYTIsIG9wdGlvbnMpIHtcbiAgdmFyIF9hMjtcbiAgY29uc3QgdXNlUmVmZXJlbmNlcyA9IChfYTIgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnVzZVJlZmVyZW5jZXMpICE9IG51bGwgPyBfYTIgOiBmYWxzZTtcbiAgcmV0dXJuIGpzb25TY2hlbWEoXG4gICAgLy8gZGVmZXIganNvbiBzY2hlbWEgY3JlYXRpb24gdG8gYXZvaWQgdW5uZWNlc3NhcnkgY29tcHV0YXRpb24gd2hlbiBvbmx5IHZhbGlkYXRpb24gaXMgbmVlZGVkXG4gICAgKCkgPT4gYWRkQWRkaXRpb25hbFByb3BlcnRpZXNUb0pzb25TY2hlbWEoXG4gICAgICB6NC50b0pTT05TY2hlbWEoem9kU2NoZW1hMiwge1xuICAgICAgICB0YXJnZXQ6IFwiZHJhZnQtN1wiLFxuICAgICAgICBpbzogXCJpbnB1dFwiLFxuICAgICAgICByZXVzZWQ6IHVzZVJlZmVyZW5jZXMgPyBcInJlZlwiIDogXCJpbmxpbmVcIlxuICAgICAgfSlcbiAgICApLFxuICAgIHtcbiAgICAgIHZhbGlkYXRlOiBhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgejQuc2FmZVBhcnNlQXN5bmMoem9kU2NoZW1hMiwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LnN1Y2Nlc3MgPyB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlOiByZXN1bHQuZGF0YSB9IDogeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IHJlc3VsdC5lcnJvciB9O1xuICAgICAgfVxuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIGlzWm9kNFNjaGVtYSh6b2RTY2hlbWEyKSB7XG4gIHJldHVybiBcIl96b2RcIiBpbiB6b2RTY2hlbWEyO1xufVxuZnVuY3Rpb24gem9kU2NoZW1hKHpvZFNjaGVtYTIsIG9wdGlvbnMpIHtcbiAgaWYgKGlzWm9kNFNjaGVtYSh6b2RTY2hlbWEyKSkge1xuICAgIHJldHVybiB6b2Q0U2NoZW1hKHpvZFNjaGVtYTIsIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB6b2QzU2NoZW1hKHpvZFNjaGVtYTIsIG9wdGlvbnMpO1xuICB9XG59XG5cbi8vIHNyYy92YWxpZGF0ZS10eXBlcy50c1xuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVUeXBlcyh7XG4gIHZhbHVlLFxuICBzY2hlbWEsXG4gIGNvbnRleHRcbn0pIHtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2FmZVZhbGlkYXRlVHlwZXMoeyB2YWx1ZSwgc2NoZW1hLCBjb250ZXh0IH0pO1xuICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgdGhyb3cgVHlwZVZhbGlkYXRpb25FcnJvcjIud3JhcCh7IHZhbHVlLCBjYXVzZTogcmVzdWx0LmVycm9yLCBjb250ZXh0IH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQudmFsdWU7XG59XG5hc3luYyBmdW5jdGlvbiBzYWZlVmFsaWRhdGVUeXBlcyh7XG4gIHZhbHVlLFxuICBzY2hlbWEsXG4gIGNvbnRleHRcbn0pIHtcbiAgY29uc3QgYWN0dWFsU2NoZW1hID0gYXNTY2hlbWEoc2NoZW1hKTtcbiAgdHJ5IHtcbiAgICBpZiAoYWN0dWFsU2NoZW1hLnZhbGlkYXRlID09IG51bGwpIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlLCByYXdWYWx1ZTogdmFsdWUgfTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYWN0dWFsU2NoZW1hLnZhbGlkYXRlKHZhbHVlKTtcbiAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlOiByZXN1bHQudmFsdWUsIHJhd1ZhbHVlOiB2YWx1ZSB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogVHlwZVZhbGlkYXRpb25FcnJvcjIud3JhcCh7IHZhbHVlLCBjYXVzZTogcmVzdWx0LmVycm9yLCBjb250ZXh0IH0pLFxuICAgICAgcmF3VmFsdWU6IHZhbHVlXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogVHlwZVZhbGlkYXRpb25FcnJvcjIud3JhcCh7IHZhbHVlLCBjYXVzZTogZXJyb3IsIGNvbnRleHQgfSksXG4gICAgICByYXdWYWx1ZTogdmFsdWVcbiAgICB9O1xuICB9XG59XG5cbi8vIHNyYy9wYXJzZS1qc29uLnRzXG5hc3luYyBmdW5jdGlvbiBwYXJzZUpTT04oe1xuICB0ZXh0LFxuICBzY2hlbWFcbn0pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB2YWx1ZSA9IHNlY3VyZUpzb25QYXJzZSh0ZXh0KTtcbiAgICBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkYXRlVHlwZXMoeyB2YWx1ZSwgc2NoZW1hIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChKU09OUGFyc2VFcnJvci5pc0luc3RhbmNlKGVycm9yKSB8fCBUeXBlVmFsaWRhdGlvbkVycm9yMy5pc0luc3RhbmNlKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHRocm93IG5ldyBKU09OUGFyc2VFcnJvcih7IHRleHQsIGNhdXNlOiBlcnJvciB9KTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gc2FmZVBhcnNlSlNPTih7XG4gIHRleHQsXG4gIHNjaGVtYVxufSkge1xuICB0cnkge1xuICAgIGNvbnN0IHZhbHVlID0gc2VjdXJlSnNvblBhcnNlKHRleHQpO1xuICAgIGlmIChzY2hlbWEgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgdmFsdWUsIHJhd1ZhbHVlOiB2YWx1ZSB9O1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgc2FmZVZhbGlkYXRlVHlwZXMoeyB2YWx1ZSwgc2NoZW1hIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBKU09OUGFyc2VFcnJvci5pc0luc3RhbmNlKGVycm9yKSA/IGVycm9yIDogbmV3IEpTT05QYXJzZUVycm9yKHsgdGV4dCwgY2F1c2U6IGVycm9yIH0pLFxuICAgICAgcmF3VmFsdWU6IHZvaWQgMFxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGlzUGFyc2FibGVKc29uKGlucHV0KSB7XG4gIHRyeSB7XG4gICAgc2VjdXJlSnNvblBhcnNlKGlucHV0KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBzcmMvcGFyc2UtanNvbi1ldmVudC1zdHJlYW0udHNcbmltcG9ydCB7XG4gIEV2ZW50U291cmNlUGFyc2VyU3RyZWFtXG59IGZyb20gXCJldmVudHNvdXJjZS1wYXJzZXIvc3RyZWFtXCI7XG5mdW5jdGlvbiBwYXJzZUpzb25FdmVudFN0cmVhbSh7XG4gIHN0cmVhbSxcbiAgc2NoZW1hXG59KSB7XG4gIHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2gobmV3IFRleHREZWNvZGVyU3RyZWFtKCkpLnBpcGVUaHJvdWdoKG5ldyBFdmVudFNvdXJjZVBhcnNlclN0cmVhbSgpKS5waXBlVGhyb3VnaChcbiAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIGFzeW5jIHRyYW5zZm9ybSh7IGRhdGEgfSwgY29udHJvbGxlcikge1xuICAgICAgICBpZiAoZGF0YSA9PT0gXCJbRE9ORV1cIikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoYXdhaXQgc2FmZVBhcnNlSlNPTih7IHRleHQ6IGRhdGEsIHNjaGVtYSB9KSk7XG4gICAgICB9XG4gICAgfSlcbiAgKTtcbn1cblxuLy8gc3JjL3BhcnNlLXByb3ZpZGVyLW9wdGlvbnMudHNcbmltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yIGFzIEludmFsaWRBcmd1bWVudEVycm9yMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5hc3luYyBmdW5jdGlvbiBwYXJzZVByb3ZpZGVyT3B0aW9ucyh7XG4gIHByb3ZpZGVyLFxuICBwcm92aWRlck9wdGlvbnMsXG4gIHNjaGVtYVxufSkge1xuICBpZiAoKHByb3ZpZGVyT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogcHJvdmlkZXJPcHRpb25zW3Byb3ZpZGVyXSkgPT0gbnVsbCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3QgcGFyc2VkUHJvdmlkZXJPcHRpb25zID0gYXdhaXQgc2FmZVZhbGlkYXRlVHlwZXMoe1xuICAgIHZhbHVlOiBwcm92aWRlck9wdGlvbnNbcHJvdmlkZXJdLFxuICAgIHNjaGVtYVxuICB9KTtcbiAgaWYgKCFwYXJzZWRQcm92aWRlck9wdGlvbnMuc3VjY2Vzcykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcjIoe1xuICAgICAgYXJndW1lbnQ6IFwicHJvdmlkZXJPcHRpb25zXCIsXG4gICAgICBtZXNzYWdlOiBgaW52YWxpZCAke3Byb3ZpZGVyfSBwcm92aWRlciBvcHRpb25zYCxcbiAgICAgIGNhdXNlOiBwYXJzZWRQcm92aWRlck9wdGlvbnMuZXJyb3JcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcGFyc2VkUHJvdmlkZXJPcHRpb25zLnZhbHVlO1xufVxuXG4vLyBzcmMvcG9zdC10by1hcGkudHNcbmltcG9ydCB7IEFQSUNhbGxFcnJvciBhcyBBUElDYWxsRXJyb3IzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBnZXRPcmlnaW5hbEZldGNoMiA9ICgpID0+IGdsb2JhbFRoaXMuZmV0Y2g7XG52YXIgcG9zdEpzb25Ub0FwaSA9IGFzeW5jICh7XG4gIHVybCxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyLFxuICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyLFxuICBhYm9ydFNpZ25hbCxcbiAgZmV0Y2g6IGZldGNoMlxufSkgPT4gcG9zdFRvQXBpKHtcbiAgdXJsLFxuICBoZWFkZXJzOiB7XG4gICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgLi4uaGVhZGVyc1xuICB9LFxuICBib2R5OiB7XG4gICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgdmFsdWVzOiBib2R5XG4gIH0sXG4gIGZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcixcbiAgYWJvcnRTaWduYWwsXG4gIGZldGNoOiBmZXRjaDJcbn0pO1xudmFyIHBvc3RGb3JtRGF0YVRvQXBpID0gYXN5bmMgKHtcbiAgdXJsLFxuICBoZWFkZXJzLFxuICBmb3JtRGF0YSxcbiAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyLFxuICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyLFxuICBhYm9ydFNpZ25hbCxcbiAgZmV0Y2g6IGZldGNoMlxufSkgPT4gcG9zdFRvQXBpKHtcbiAgdXJsLFxuICBoZWFkZXJzLFxuICBib2R5OiB7XG4gICAgY29udGVudDogZm9ybURhdGEsXG4gICAgdmFsdWVzOiBPYmplY3QuZnJvbUVudHJpZXMoZm9ybURhdGEuZW50cmllcygpKVxuICB9LFxuICBmYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXIsXG4gIGFib3J0U2lnbmFsLFxuICBmZXRjaDogZmV0Y2gyXG59KTtcbnZhciBwb3N0VG9BcGkgPSBhc3luYyAoe1xuICB1cmwsXG4gIGhlYWRlcnMgPSB7fSxcbiAgYm9keSxcbiAgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcixcbiAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyLFxuICBhYm9ydFNpZ25hbCxcbiAgZmV0Y2g6IGZldGNoMiA9IGdldE9yaWdpbmFsRmV0Y2gyKClcbn0pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoMih1cmwsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB3aXRoVXNlckFnZW50U3VmZml4KFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBgYWktc2RrL3Byb3ZpZGVyLXV0aWxzLyR7VkVSU0lPTn1gLFxuICAgICAgICBnZXRSdW50aW1lRW52aXJvbm1lbnRVc2VyQWdlbnQoKVxuICAgICAgKSxcbiAgICAgIGJvZHk6IGJvZHkuY29udGVudCxcbiAgICAgIHNpZ25hbDogYWJvcnRTaWduYWxcbiAgICB9KTtcbiAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBsZXQgZXJyb3JJbmZvcm1hdGlvbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVycm9ySW5mb3JtYXRpb24gPSBhd2FpdCBmYWlsZWRSZXNwb25zZUhhbmRsZXIoe1xuICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgIHVybCxcbiAgICAgICAgICByZXF1ZXN0Qm9keVZhbHVlczogYm9keS52YWx1ZXNcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoaXNBYm9ydEVycm9yKGVycm9yKSB8fCBBUElDYWxsRXJyb3IzLmlzSW5zdGFuY2UoZXJyb3IpKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEFQSUNhbGxFcnJvcjMoe1xuICAgICAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIHByb2Nlc3MgZXJyb3IgcmVzcG9uc2VcIixcbiAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgIHVybCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IGJvZHkudmFsdWVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JJbmZvcm1hdGlvbi52YWx1ZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyKHtcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IGJvZHkudmFsdWVzXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikgfHwgQVBJQ2FsbEVycm9yMy5pc0luc3RhbmNlKGVycm9yKSkge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQVBJQ2FsbEVycm9yMyh7XG4gICAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIHByb2Nlc3Mgc3VjY2Vzc2Z1bCByZXNwb25zZVwiLFxuICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlc1xuICAgICAgfSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGhhbmRsZUZldGNoRXJyb3IoeyBlcnJvciwgdXJsLCByZXF1ZXN0Qm9keVZhbHVlczogYm9keS52YWx1ZXMgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy90eXBlcy90b29sLnRzXG5mdW5jdGlvbiB0b29sKHRvb2wyKSB7XG4gIHJldHVybiB0b29sMjtcbn1cbmZ1bmN0aW9uIGR5bmFtaWNUb29sKHRvb2wyKSB7XG4gIHJldHVybiB7IC4uLnRvb2wyLCB0eXBlOiBcImR5bmFtaWNcIiB9O1xufVxuXG4vLyBzcmMvcHJvdmlkZXItdG9vbC1mYWN0b3J5LnRzXG5mdW5jdGlvbiBjcmVhdGVQcm92aWRlclRvb2xGYWN0b3J5KHtcbiAgaWQsXG4gIGlucHV0U2NoZW1hXG59KSB7XG4gIHJldHVybiAoe1xuICAgIGV4ZWN1dGUsXG4gICAgb3V0cHV0U2NoZW1hLFxuICAgIG5lZWRzQXBwcm92YWwsXG4gICAgdG9Nb2RlbE91dHB1dCxcbiAgICBvbklucHV0U3RhcnQsXG4gICAgb25JbnB1dERlbHRhLFxuICAgIG9uSW5wdXRBdmFpbGFibGUsXG4gICAgLi4uYXJnc1xuICB9KSA9PiB0b29sKHtcbiAgICB0eXBlOiBcInByb3ZpZGVyXCIsXG4gICAgaWQsXG4gICAgYXJncyxcbiAgICBpbnB1dFNjaGVtYSxcbiAgICBvdXRwdXRTY2hlbWEsXG4gICAgZXhlY3V0ZSxcbiAgICBuZWVkc0FwcHJvdmFsLFxuICAgIHRvTW9kZWxPdXRwdXQsXG4gICAgb25JbnB1dFN0YXJ0LFxuICAgIG9uSW5wdXREZWx0YSxcbiAgICBvbklucHV0QXZhaWxhYmxlXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlUHJvdmlkZXJUb29sRmFjdG9yeVdpdGhPdXRwdXRTY2hlbWEoe1xuICBpZCxcbiAgaW5wdXRTY2hlbWEsXG4gIG91dHB1dFNjaGVtYSxcbiAgc3VwcG9ydHNEZWZlcnJlZFJlc3VsdHNcbn0pIHtcbiAgcmV0dXJuICh7XG4gICAgZXhlY3V0ZSxcbiAgICBuZWVkc0FwcHJvdmFsLFxuICAgIHRvTW9kZWxPdXRwdXQsXG4gICAgb25JbnB1dFN0YXJ0LFxuICAgIG9uSW5wdXREZWx0YSxcbiAgICBvbklucHV0QXZhaWxhYmxlLFxuICAgIC4uLmFyZ3NcbiAgfSkgPT4gdG9vbCh7XG4gICAgdHlwZTogXCJwcm92aWRlclwiLFxuICAgIGlkLFxuICAgIGFyZ3MsXG4gICAgaW5wdXRTY2hlbWEsXG4gICAgb3V0cHV0U2NoZW1hLFxuICAgIGV4ZWN1dGUsXG4gICAgbmVlZHNBcHByb3ZhbCxcbiAgICB0b01vZGVsT3V0cHV0LFxuICAgIG9uSW5wdXRTdGFydCxcbiAgICBvbklucHV0RGVsdGEsXG4gICAgb25JbnB1dEF2YWlsYWJsZSxcbiAgICBzdXBwb3J0c0RlZmVycmVkUmVzdWx0c1xuICB9KTtcbn1cblxuLy8gc3JjL3JlbW92ZS11bmRlZmluZWQtZW50cmllcy50c1xuZnVuY3Rpb24gcmVtb3ZlVW5kZWZpbmVkRW50cmllcyhyZWNvcmQpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhyZWNvcmQpLmZpbHRlcigoW19rZXksIHZhbHVlXSkgPT4gdmFsdWUgIT0gbnVsbClcbiAgKTtcbn1cblxuLy8gc3JjL3Jlc29sdmUudHNcbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmUodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFsdWUgPSB2YWx1ZSgpO1xuICB9XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpO1xufVxuXG4vLyBzcmMvcmVzcG9uc2UtaGFuZGxlci50c1xuaW1wb3J0IHsgQVBJQ2FsbEVycm9yIGFzIEFQSUNhbGxFcnJvcjQsIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIGNyZWF0ZUpzb25FcnJvclJlc3BvbnNlSGFuZGxlciA9ICh7XG4gIGVycm9yU2NoZW1hLFxuICBlcnJvclRvTWVzc2FnZSxcbiAgaXNSZXRyeWFibGVcbn0pID0+IGFzeW5jICh7IHJlc3BvbnNlLCB1cmwsIHJlcXVlc3RCb2R5VmFsdWVzIH0pID0+IHtcbiAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgaWYgKHJlc3BvbnNlQm9keS50cmltKCkgPT09IFwiXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgdmFsdWU6IG5ldyBBUElDYWxsRXJyb3I0KHtcbiAgICAgICAgbWVzc2FnZTogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIHJlc3BvbnNlQm9keSxcbiAgICAgICAgaXNSZXRyeWFibGU6IGlzUmV0cnlhYmxlID09IG51bGwgPyB2b2lkIDAgOiBpc1JldHJ5YWJsZShyZXNwb25zZSlcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHBhcnNlZEVycm9yID0gYXdhaXQgcGFyc2VKU09OKHtcbiAgICAgIHRleHQ6IHJlc3BvbnNlQm9keSxcbiAgICAgIHNjaGVtYTogZXJyb3JTY2hlbWFcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgdmFsdWU6IG5ldyBBUElDYWxsRXJyb3I0KHtcbiAgICAgICAgbWVzc2FnZTogZXJyb3JUb01lc3NhZ2UocGFyc2VkRXJyb3IpLFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgcmVzcG9uc2VCb2R5LFxuICAgICAgICBkYXRhOiBwYXJzZWRFcnJvcixcbiAgICAgICAgaXNSZXRyeWFibGU6IGlzUmV0cnlhYmxlID09IG51bGwgPyB2b2lkIDAgOiBpc1JldHJ5YWJsZShyZXNwb25zZSwgcGFyc2VkRXJyb3IpXG4gICAgICB9KVxuICAgIH07XG4gIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgdmFsdWU6IG5ldyBBUElDYWxsRXJyb3I0KHtcbiAgICAgICAgbWVzc2FnZTogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIHJlc3BvbnNlQm9keSxcbiAgICAgICAgaXNSZXRyeWFibGU6IGlzUmV0cnlhYmxlID09IG51bGwgPyB2b2lkIDAgOiBpc1JldHJ5YWJsZShyZXNwb25zZSlcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxufTtcbnZhciBjcmVhdGVFdmVudFNvdXJjZVJlc3BvbnNlSGFuZGxlciA9IChjaHVua1NjaGVtYSkgPT4gYXN5bmMgKHsgcmVzcG9uc2UgfSkgPT4ge1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgaWYgKHJlc3BvbnNlLmJvZHkgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFbXB0eVJlc3BvbnNlQm9keUVycm9yKHt9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICB2YWx1ZTogcGFyc2VKc29uRXZlbnRTdHJlYW0oe1xuICAgICAgc3RyZWFtOiByZXNwb25zZS5ib2R5LFxuICAgICAgc2NoZW1hOiBjaHVua1NjaGVtYVxuICAgIH0pXG4gIH07XG59O1xudmFyIGNyZWF0ZUpzb25SZXNwb25zZUhhbmRsZXIgPSAocmVzcG9uc2VTY2hlbWEpID0+IGFzeW5jICh7IHJlc3BvbnNlLCB1cmwsIHJlcXVlc3RCb2R5VmFsdWVzIH0pID0+IHtcbiAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICBjb25zdCBwYXJzZWRSZXN1bHQgPSBhd2FpdCBzYWZlUGFyc2VKU09OKHtcbiAgICB0ZXh0OiByZXNwb25zZUJvZHksXG4gICAgc2NoZW1hOiByZXNwb25zZVNjaGVtYVxuICB9KTtcbiAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gIGlmICghcGFyc2VkUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICB0aHJvdyBuZXcgQVBJQ2FsbEVycm9yNCh7XG4gICAgICBtZXNzYWdlOiBcIkludmFsaWQgSlNPTiByZXNwb25zZVwiLFxuICAgICAgY2F1c2U6IHBhcnNlZFJlc3VsdC5lcnJvcixcbiAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIHJlc3BvbnNlQm9keSxcbiAgICAgIHVybCxcbiAgICAgIHJlcXVlc3RCb2R5VmFsdWVzXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgdmFsdWU6IHBhcnNlZFJlc3VsdC52YWx1ZSxcbiAgICByYXdWYWx1ZTogcGFyc2VkUmVzdWx0LnJhd1ZhbHVlXG4gIH07XG59O1xudmFyIGNyZWF0ZUJpbmFyeVJlc3BvbnNlSGFuZGxlciA9ICgpID0+IGFzeW5jICh7IHJlc3BvbnNlLCB1cmwsIHJlcXVlc3RCb2R5VmFsdWVzIH0pID0+IHtcbiAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgIHRocm93IG5ldyBBUElDYWxsRXJyb3I0KHtcbiAgICAgIG1lc3NhZ2U6IFwiUmVzcG9uc2UgYm9keSBpcyBlbXB0eVwiLFxuICAgICAgdXJsLFxuICAgICAgcmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICByZXNwb25zZUJvZHk6IHZvaWQgMFxuICAgIH0pO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgYnVmZmVyID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgdmFsdWU6IG5ldyBVaW50OEFycmF5KGJ1ZmZlcilcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBBUElDYWxsRXJyb3I0KHtcbiAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIHJlYWQgcmVzcG9uc2UgYXMgYXJyYXkgYnVmZmVyXCIsXG4gICAgICB1cmwsXG4gICAgICByZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIHJlc3BvbnNlQm9keTogdm9pZCAwLFxuICAgICAgY2F1c2U6IGVycm9yXG4gICAgfSk7XG4gIH1cbn07XG52YXIgY3JlYXRlU3RhdHVzQ29kZUVycm9yUmVzcG9uc2VIYW5kbGVyID0gKCkgPT4gYXN5bmMgKHsgcmVzcG9uc2UsIHVybCwgcmVxdWVzdEJvZHlWYWx1ZXMgfSkgPT4ge1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICByZXR1cm4ge1xuICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICB2YWx1ZTogbmV3IEFQSUNhbGxFcnJvcjQoe1xuICAgICAgbWVzc2FnZTogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgIHVybCxcbiAgICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgcmVzcG9uc2VCb2R5XG4gICAgfSlcbiAgfTtcbn07XG5cbi8vIHNyYy93aXRob3V0LXRyYWlsaW5nLXNsYXNoLnRzXG5mdW5jdGlvbiB3aXRob3V0VHJhaWxpbmdTbGFzaCh1cmwpIHtcbiAgcmV0dXJuIHVybCA9PSBudWxsID8gdm9pZCAwIDogdXJsLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcbn1cblxuLy8gc3JjL2lzLWFzeW5jLWl0ZXJhYmxlLnRzXG5mdW5jdGlvbiBpc0FzeW5jSXRlcmFibGUob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG4vLyBzcmMvdHlwZXMvZXhlY3V0ZS10b29sLnRzXG5hc3luYyBmdW5jdGlvbiogZXhlY3V0ZVRvb2woe1xuICBleGVjdXRlLFxuICBpbnB1dCxcbiAgb3B0aW9uc1xufSkge1xuICBjb25zdCByZXN1bHQgPSBleGVjdXRlKGlucHV0LCBvcHRpb25zKTtcbiAgaWYgKGlzQXN5bmNJdGVyYWJsZShyZXN1bHQpKSB7XG4gICAgbGV0IGxhc3RPdXRwdXQ7XG4gICAgZm9yIGF3YWl0IChjb25zdCBvdXRwdXQgb2YgcmVzdWx0KSB7XG4gICAgICBsYXN0T3V0cHV0ID0gb3V0cHV0O1xuICAgICAgeWllbGQgeyB0eXBlOiBcInByZWxpbWluYXJ5XCIsIG91dHB1dCB9O1xuICAgIH1cbiAgICB5aWVsZCB7IHR5cGU6IFwiZmluYWxcIiwgb3V0cHV0OiBsYXN0T3V0cHV0IH07XG4gIH0gZWxzZSB7XG4gICAgeWllbGQgeyB0eXBlOiBcImZpbmFsXCIsIG91dHB1dDogYXdhaXQgcmVzdWx0IH07XG4gIH1cbn1cblxuLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQge1xuICBFdmVudFNvdXJjZVBhcnNlclN0cmVhbSBhcyBFdmVudFNvdXJjZVBhcnNlclN0cmVhbTJcbn0gZnJvbSBcImV2ZW50c291cmNlLXBhcnNlci9zdHJlYW1cIjtcbmV4cG9ydCB7XG4gIERFRkFVTFRfTUFYX0RPV05MT0FEX1NJWkUsXG4gIERlbGF5ZWRQcm9taXNlLFxuICBEb3dubG9hZEVycm9yLFxuICBFdmVudFNvdXJjZVBhcnNlclN0cmVhbTIgYXMgRXZlbnRTb3VyY2VQYXJzZXJTdHJlYW0sXG4gIFZFUlNJT04sXG4gIGFzU2NoZW1hLFxuICBjb21iaW5lSGVhZGVycyxcbiAgY29udmVydEFzeW5jSXRlcmF0b3JUb1JlYWRhYmxlU3RyZWFtLFxuICBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5LFxuICBjb252ZXJ0SW1hZ2VNb2RlbEZpbGVUb0RhdGFVcmksXG4gIGNvbnZlcnRUb0Jhc2U2NCxcbiAgY29udmVydFRvRm9ybURhdGEsXG4gIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQsXG4gIGNyZWF0ZUJpbmFyeVJlc3BvbnNlSGFuZGxlcixcbiAgY3JlYXRlRXZlbnRTb3VyY2VSZXNwb25zZUhhbmRsZXIsXG4gIGNyZWF0ZUlkR2VuZXJhdG9yLFxuICBjcmVhdGVKc29uRXJyb3JSZXNwb25zZUhhbmRsZXIsXG4gIGNyZWF0ZUpzb25SZXNwb25zZUhhbmRsZXIsXG4gIGNyZWF0ZVByb3ZpZGVyVG9vbEZhY3RvcnksXG4gIGNyZWF0ZVByb3ZpZGVyVG9vbEZhY3RvcnlXaXRoT3V0cHV0U2NoZW1hLFxuICBjcmVhdGVTdGF0dXNDb2RlRXJyb3JSZXNwb25zZUhhbmRsZXIsXG4gIGNyZWF0ZVRvb2xOYW1lTWFwcGluZyxcbiAgZGVsYXksXG4gIGRvd25sb2FkQmxvYixcbiAgZHluYW1pY1Rvb2wsXG4gIGV4ZWN1dGVUb29sLFxuICBleHRyYWN0UmVzcG9uc2VIZWFkZXJzLFxuICBnZW5lcmF0ZUlkLFxuICBnZXRFcnJvck1lc3NhZ2UsXG4gIGdldEZyb21BcGksXG4gIGdldFJ1bnRpbWVFbnZpcm9ubWVudFVzZXJBZ2VudCxcbiAgaW5qZWN0SnNvbkluc3RydWN0aW9uSW50b01lc3NhZ2VzLFxuICBpc0Fib3J0RXJyb3IsXG4gIGlzTm9uTnVsbGFibGUsXG4gIGlzUGFyc2FibGVKc29uLFxuICBpc1VybFN1cHBvcnRlZCxcbiAganNvblNjaGVtYSxcbiAgbGF6eVNjaGVtYSxcbiAgbG9hZEFwaUtleSxcbiAgbG9hZE9wdGlvbmFsU2V0dGluZyxcbiAgbG9hZFNldHRpbmcsXG4gIG1lZGlhVHlwZVRvRXh0ZW5zaW9uLFxuICBub3JtYWxpemVIZWFkZXJzLFxuICBwYXJzZUpTT04sXG4gIHBhcnNlSnNvbkV2ZW50U3RyZWFtLFxuICBwYXJzZVByb3ZpZGVyT3B0aW9ucyxcbiAgcG9zdEZvcm1EYXRhVG9BcGksXG4gIHBvc3RKc29uVG9BcGksXG4gIHBvc3RUb0FwaSxcbiAgcmVhZFJlc3BvbnNlV2l0aFNpemVMaW1pdCxcbiAgcmVtb3ZlVW5kZWZpbmVkRW50cmllcyxcbiAgcmVzb2x2ZSxcbiAgc2FmZVBhcnNlSlNPTixcbiAgc2FmZVZhbGlkYXRlVHlwZXMsXG4gIHRvb2wsXG4gIHZhbGlkYXRlVHlwZXMsXG4gIHdpdGhVc2VyQWdlbnRTdWZmaXgsXG4gIHdpdGhvdXRUcmFpbGluZ1NsYXNoLFxuICB6b2RTY2hlbWFcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider/dist/index.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider/dist/index.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISDKError: () => (/* binding */ AISDKError),\n/* harmony export */   APICallError: () => (/* binding */ APICallError),\n/* harmony export */   EmptyResponseBodyError: () => (/* binding */ EmptyResponseBodyError),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidPromptError: () => (/* binding */ InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* binding */ InvalidResponseDataError),\n/* harmony export */   JSONParseError: () => (/* binding */ JSONParseError),\n/* harmony export */   LoadAPIKeyError: () => (/* binding */ LoadAPIKeyError),\n/* harmony export */   LoadSettingError: () => (/* binding */ LoadSettingError),\n/* harmony export */   NoContentGeneratedError: () => (/* binding */ NoContentGeneratedError),\n/* harmony export */   NoSuchModelError: () => (/* binding */ NoSuchModelError),\n/* harmony export */   TooManyEmbeddingValuesForCallError: () => (/* binding */ TooManyEmbeddingValuesForCallError),\n/* harmony export */   TypeValidationError: () => (/* binding */ TypeValidationError),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* binding */ UnsupportedFunctionalityError),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   isJSONArray: () => (/* binding */ isJSONArray),\n/* harmony export */   isJSONObject: () => (/* binding */ isJSONObject),\n/* harmony export */   isJSONValue: () => (/* binding */ isJSONValue)\n/* harmony export */ });\n// src/errors/ai-sdk-error.ts\nvar marker = \"vercel.ai.error\";\nvar symbol = Symbol.for(marker);\nvar _a, _b;\nvar AISDKError = class _AISDKError extends (_b = Error, _a = symbol, _b) {\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name: name14,\n    message,\n    cause\n  }) {\n    super(message);\n    this[_a] = true;\n    this.name = name14;\n    this.cause = cause;\n  }\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error) {\n    return _AISDKError.hasMarker(error, marker);\n  }\n  static hasMarker(error, marker15) {\n    const markerSymbol = Symbol.for(marker15);\n    return error != null && typeof error === \"object\" && markerSymbol in error && typeof error[markerSymbol] === \"boolean\" && error[markerSymbol] === true;\n  }\n};\n\n// src/errors/api-call-error.ts\nvar name = \"AI_APICallError\";\nvar marker2 = `vercel.ai.error.${name}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2, _b2;\nvar APICallError = class extends (_b2 = AISDKError, _a2 = symbol2, _b2) {\n  constructor({\n    message,\n    url,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null && (statusCode === 408 || // request timeout\n    statusCode === 409 || // conflict\n    statusCode === 429 || // too many requests\n    statusCode >= 500),\n    // server error\n    data\n  }) {\n    super({ name, message, cause });\n    this[_a2] = true;\n    this.url = url;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker2);\n  }\n};\n\n// src/errors/empty-response-body-error.ts\nvar name2 = \"AI_EmptyResponseBodyError\";\nvar marker3 = `vercel.ai.error.${name2}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3, _b3;\nvar EmptyResponseBodyError = class extends (_b3 = AISDKError, _a3 = symbol3, _b3) {\n  // used in isInstance\n  constructor({ message = \"Empty response body\" } = {}) {\n    super({ name: name2, message });\n    this[_a3] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker3);\n  }\n};\n\n// src/errors/get-error-message.ts\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\n\n// src/errors/invalid-argument-error.ts\nvar name3 = \"AI_InvalidArgumentError\";\nvar marker4 = `vercel.ai.error.${name3}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4, _b4;\nvar InvalidArgumentError = class extends (_b4 = AISDKError, _a4 = symbol4, _b4) {\n  constructor({\n    message,\n    cause,\n    argument\n  }) {\n    super({ name: name3, message, cause });\n    this[_a4] = true;\n    this.argument = argument;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker4);\n  }\n};\n\n// src/errors/invalid-prompt-error.ts\nvar name4 = \"AI_InvalidPromptError\";\nvar marker5 = `vercel.ai.error.${name4}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5, _b5;\nvar InvalidPromptError = class extends (_b5 = AISDKError, _a5 = symbol5, _b5) {\n  constructor({\n    prompt,\n    message,\n    cause\n  }) {\n    super({ name: name4, message: `Invalid prompt: ${message}`, cause });\n    this[_a5] = true;\n    this.prompt = prompt;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker5);\n  }\n};\n\n// src/errors/invalid-response-data-error.ts\nvar name5 = \"AI_InvalidResponseDataError\";\nvar marker6 = `vercel.ai.error.${name5}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6, _b6;\nvar InvalidResponseDataError = class extends (_b6 = AISDKError, _a6 = symbol6, _b6) {\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`\n  }) {\n    super({ name: name5, message });\n    this[_a6] = true;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker6);\n  }\n};\n\n// src/errors/json-parse-error.ts\nvar name6 = \"AI_JSONParseError\";\nvar marker7 = `vercel.ai.error.${name6}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7, _b7;\nvar JSONParseError = class extends (_b7 = AISDKError, _a7 = symbol7, _b7) {\n  constructor({ text, cause }) {\n    super({\n      name: name6,\n      message: `JSON parsing failed: Text: ${text}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a7] = true;\n    this.text = text;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker7);\n  }\n};\n\n// src/errors/load-api-key-error.ts\nvar name7 = \"AI_LoadAPIKeyError\";\nvar marker8 = `vercel.ai.error.${name7}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8, _b8;\nvar LoadAPIKeyError = class extends (_b8 = AISDKError, _a8 = symbol8, _b8) {\n  // used in isInstance\n  constructor({ message }) {\n    super({ name: name7, message });\n    this[_a8] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker8);\n  }\n};\n\n// src/errors/load-setting-error.ts\nvar name8 = \"AI_LoadSettingError\";\nvar marker9 = `vercel.ai.error.${name8}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9, _b9;\nvar LoadSettingError = class extends (_b9 = AISDKError, _a9 = symbol9, _b9) {\n  // used in isInstance\n  constructor({ message }) {\n    super({ name: name8, message });\n    this[_a9] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker9);\n  }\n};\n\n// src/errors/no-content-generated-error.ts\nvar name9 = \"AI_NoContentGeneratedError\";\nvar marker10 = `vercel.ai.error.${name9}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10, _b10;\nvar NoContentGeneratedError = class extends (_b10 = AISDKError, _a10 = symbol10, _b10) {\n  // used in isInstance\n  constructor({\n    message = \"No content generated.\"\n  } = {}) {\n    super({ name: name9, message });\n    this[_a10] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker10);\n  }\n};\n\n// src/errors/no-such-model-error.ts\nvar name10 = \"AI_NoSuchModelError\";\nvar marker11 = `vercel.ai.error.${name10}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11, _b11;\nvar NoSuchModelError = class extends (_b11 = AISDKError, _a11 = symbol11, _b11) {\n  constructor({\n    errorName = name10,\n    modelId,\n    modelType,\n    message = `No such ${modelType}: ${modelId}`\n  }) {\n    super({ name: errorName, message });\n    this[_a11] = true;\n    this.modelId = modelId;\n    this.modelType = modelType;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker11);\n  }\n};\n\n// src/errors/too-many-embedding-values-for-call-error.ts\nvar name11 = \"AI_TooManyEmbeddingValuesForCallError\";\nvar marker12 = `vercel.ai.error.${name11}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12, _b12;\nvar TooManyEmbeddingValuesForCallError = class extends (_b12 = AISDKError, _a12 = symbol12, _b12) {\n  constructor(options) {\n    super({\n      name: name11,\n      message: `Too many values for a single embedding call. The ${options.provider} model \"${options.modelId}\" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`\n    });\n    this[_a12] = true;\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n    this.values = options.values;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker12);\n  }\n};\n\n// src/errors/type-validation-error.ts\nvar name12 = \"AI_TypeValidationError\";\nvar marker13 = `vercel.ai.error.${name12}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13, _b13;\nvar TypeValidationError = class _TypeValidationError extends (_b13 = AISDKError, _a13 = symbol13, _b13) {\n  constructor({\n    value,\n    cause,\n    context\n  }) {\n    let contextPrefix = \"Type validation failed\";\n    if (context == null ? void 0 : context.field) {\n      contextPrefix += ` for ${context.field}`;\n    }\n    if ((context == null ? void 0 : context.entityName) || (context == null ? void 0 : context.entityId)) {\n      contextPrefix += \" (\";\n      const parts = [];\n      if (context.entityName) {\n        parts.push(context.entityName);\n      }\n      if (context.entityId) {\n        parts.push(`id: \"${context.entityId}\"`);\n      }\n      contextPrefix += parts.join(\", \");\n      contextPrefix += \")\";\n    }\n    super({\n      name: name12,\n      message: `${contextPrefix}: Value: ${JSON.stringify(value)}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a13] = true;\n    this.value = value;\n    this.context = context;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker13);\n  }\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value and context, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @param {TypeValidationContext} params.context - Optional context about what is being validated.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause,\n    context\n  }) {\n    var _a15, _b15, _c;\n    if (_TypeValidationError.isInstance(cause) && cause.value === value && ((_a15 = cause.context) == null ? void 0 : _a15.field) === (context == null ? void 0 : context.field) && ((_b15 = cause.context) == null ? void 0 : _b15.entityName) === (context == null ? void 0 : context.entityName) && ((_c = cause.context) == null ? void 0 : _c.entityId) === (context == null ? void 0 : context.entityId)) {\n      return cause;\n    }\n    return new _TypeValidationError({ value, cause, context });\n  }\n};\n\n// src/errors/unsupported-functionality-error.ts\nvar name13 = \"AI_UnsupportedFunctionalityError\";\nvar marker14 = `vercel.ai.error.${name13}`;\nvar symbol14 = Symbol.for(marker14);\nvar _a14, _b14;\nvar UnsupportedFunctionalityError = class extends (_b14 = AISDKError, _a14 = symbol14, _b14) {\n  constructor({\n    functionality,\n    message = `'${functionality}' functionality not supported.`\n  }) {\n    super({ name: name13, message });\n    this[_a14] = true;\n    this.functionality = functionality;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker14);\n  }\n};\n\n// src/json-value/is-json.ts\nfunction isJSONValue(value) {\n  if (value === null || typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n    return true;\n  }\n  if (Array.isArray(value)) {\n    return value.every(isJSONValue);\n  }\n  if (typeof value === \"object\") {\n    return Object.entries(value).every(\n      ([key, val]) => typeof key === \"string\" && (val === void 0 || isJSONValue(val))\n    );\n  }\n  return false;\n}\nfunction isJSONArray(value) {\n  return Array.isArray(value) && value.every(isJSONValue);\n}\nfunction isJSONObject(value) {\n  return value != null && typeof value === \"object\" && Object.entries(value).every(\n    ([key, val]) => typeof key === \"string\" && (val === void 0 || isJSONValue(val))\n  );\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9yZWFjdC9ub2RlX21vZHVsZXMvQGFpLXNkay9wcm92aWRlci9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLEtBQUs7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0NBQWtDLElBQUk7QUFDdEQsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsTUFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLDZCQUE2QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBb0JFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbGVldGZsb3cvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9yZWFjdC9ub2RlX21vZHVsZXMvQGFpLXNkay9wcm92aWRlci9kaXN0L2luZGV4Lm1qcz8zMTM3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9lcnJvcnMvYWktc2RrLWVycm9yLnRzXG52YXIgbWFya2VyID0gXCJ2ZXJjZWwuYWkuZXJyb3JcIjtcbnZhciBzeW1ib2wgPSBTeW1ib2wuZm9yKG1hcmtlcik7XG52YXIgX2EsIF9iO1xudmFyIEFJU0RLRXJyb3IgPSBjbGFzcyBfQUlTREtFcnJvciBleHRlbmRzIChfYiA9IEVycm9yLCBfYSA9IHN5bWJvbCwgX2IpIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gQUkgU0RLIEVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGNyZWF0aW5nIHRoZSBlcnJvci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGVycm9yLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm1lc3NhZ2UgLSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAgICogQHBhcmFtIHt1bmtub3dufSBbcGFyYW1zLmNhdXNlXSAtIFRoZSB1bmRlcmx5aW5nIGNhdXNlIG9mIHRoZSBlcnJvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBuYW1lOiBuYW1lMTQsXG4gICAgbWVzc2FnZSxcbiAgICBjYXVzZVxuICB9KSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpc1tfYV0gPSB0cnVlO1xuICAgIHRoaXMubmFtZSA9IG5hbWUxNDtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gZXJyb3IgaXMgYW4gQUkgU0RLIEVycm9yLlxuICAgKiBAcGFyYW0ge3Vua25vd259IGVycm9yIC0gVGhlIGVycm9yIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXJyb3IgaXMgYW4gQUkgU0RLIEVycm9yLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBfQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcik7XG4gIH1cbiAgc3RhdGljIGhhc01hcmtlcihlcnJvciwgbWFya2VyMTUpIHtcbiAgICBjb25zdCBtYXJrZXJTeW1ib2wgPSBTeW1ib2wuZm9yKG1hcmtlcjE1KTtcbiAgICByZXR1cm4gZXJyb3IgIT0gbnVsbCAmJiB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiYgbWFya2VyU3ltYm9sIGluIGVycm9yICYmIHR5cGVvZiBlcnJvclttYXJrZXJTeW1ib2xdID09PSBcImJvb2xlYW5cIiAmJiBlcnJvclttYXJrZXJTeW1ib2xdID09PSB0cnVlO1xuICB9XG59O1xuXG4vLyBzcmMvZXJyb3JzL2FwaS1jYWxsLWVycm9yLnRzXG52YXIgbmFtZSA9IFwiQUlfQVBJQ2FsbEVycm9yXCI7XG52YXIgbWFya2VyMiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lfWA7XG52YXIgc3ltYm9sMiA9IFN5bWJvbC5mb3IobWFya2VyMik7XG52YXIgX2EyLCBfYjI7XG52YXIgQVBJQ2FsbEVycm9yID0gY2xhc3MgZXh0ZW5kcyAoX2IyID0gQUlTREtFcnJvciwgX2EyID0gc3ltYm9sMiwgX2IyKSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlLFxuICAgIHVybCxcbiAgICByZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICBzdGF0dXNDb2RlLFxuICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICByZXNwb25zZUJvZHksXG4gICAgY2F1c2UsXG4gICAgaXNSZXRyeWFibGUgPSBzdGF0dXNDb2RlICE9IG51bGwgJiYgKHN0YXR1c0NvZGUgPT09IDQwOCB8fCAvLyByZXF1ZXN0IHRpbWVvdXRcbiAgICBzdGF0dXNDb2RlID09PSA0MDkgfHwgLy8gY29uZmxpY3RcbiAgICBzdGF0dXNDb2RlID09PSA0MjkgfHwgLy8gdG9vIG1hbnkgcmVxdWVzdHNcbiAgICBzdGF0dXNDb2RlID49IDUwMCksXG4gICAgLy8gc2VydmVyIGVycm9yXG4gICAgZGF0YVxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lLCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hMl0gPSB0cnVlO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMucmVxdWVzdEJvZHlWYWx1ZXMgPSByZXF1ZXN0Qm9keVZhbHVlcztcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzO1xuICAgIHRoaXMucmVzcG9uc2VCb2R5ID0gcmVzcG9uc2VCb2R5O1xuICAgIHRoaXMuaXNSZXRyeWFibGUgPSBpc1JldHJ5YWJsZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIyKTtcbiAgfVxufTtcblxuLy8gc3JjL2Vycm9ycy9lbXB0eS1yZXNwb25zZS1ib2R5LWVycm9yLnRzXG52YXIgbmFtZTIgPSBcIkFJX0VtcHR5UmVzcG9uc2VCb2R5RXJyb3JcIjtcbnZhciBtYXJrZXIzID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUyfWA7XG52YXIgc3ltYm9sMyA9IFN5bWJvbC5mb3IobWFya2VyMyk7XG52YXIgX2EzLCBfYjM7XG52YXIgRW1wdHlSZXNwb25zZUJvZHlFcnJvciA9IGNsYXNzIGV4dGVuZHMgKF9iMyA9IEFJU0RLRXJyb3IsIF9hMyA9IHN5bWJvbDMsIF9iMykge1xuICAvLyB1c2VkIGluIGlzSW5zdGFuY2VcbiAgY29uc3RydWN0b3IoeyBtZXNzYWdlID0gXCJFbXB0eSByZXNwb25zZSBib2R5XCIgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMiwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hM10gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIzKTtcbiAgfVxufTtcblxuLy8gc3JjL2Vycm9ycy9nZXQtZXJyb3ItbWVzc2FnZS50c1xuZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlKGVycm9yKSB7XG4gIGlmIChlcnJvciA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFwidW5rbm93biBlcnJvclwiO1xuICB9XG4gIGlmICh0eXBlb2YgZXJyb3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZXJyb3IpO1xufVxuXG4vLyBzcmMvZXJyb3JzL2ludmFsaWQtYXJndW1lbnQtZXJyb3IudHNcbnZhciBuYW1lMyA9IFwiQUlfSW52YWxpZEFyZ3VtZW50RXJyb3JcIjtcbnZhciBtYXJrZXI0ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUzfWA7XG52YXIgc3ltYm9sNCA9IFN5bWJvbC5mb3IobWFya2VyNCk7XG52YXIgX2E0LCBfYjQ7XG52YXIgSW52YWxpZEFyZ3VtZW50RXJyb3IgPSBjbGFzcyBleHRlbmRzIChfYjQgPSBBSVNES0Vycm9yLCBfYTQgPSBzeW1ib2w0LCBfYjQpIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UsXG4gICAgY2F1c2UsXG4gICAgYXJndW1lbnRcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTMsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2E0XSA9IHRydWU7XG4gICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI0KTtcbiAgfVxufTtcblxuLy8gc3JjL2Vycm9ycy9pbnZhbGlkLXByb21wdC1lcnJvci50c1xudmFyIG5hbWU0ID0gXCJBSV9JbnZhbGlkUHJvbXB0RXJyb3JcIjtcbnZhciBtYXJrZXI1ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU0fWA7XG52YXIgc3ltYm9sNSA9IFN5bWJvbC5mb3IobWFya2VyNSk7XG52YXIgX2E1LCBfYjU7XG52YXIgSW52YWxpZFByb21wdEVycm9yID0gY2xhc3MgZXh0ZW5kcyAoX2I1ID0gQUlTREtFcnJvciwgX2E1ID0gc3ltYm9sNSwgX2I1KSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwcm9tcHQsXG4gICAgbWVzc2FnZSxcbiAgICBjYXVzZVxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNCwgbWVzc2FnZTogYEludmFsaWQgcHJvbXB0OiAke21lc3NhZ2V9YCwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTVdID0gdHJ1ZTtcbiAgICB0aGlzLnByb21wdCA9IHByb21wdDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyNSk7XG4gIH1cbn07XG5cbi8vIHNyYy9lcnJvcnMvaW52YWxpZC1yZXNwb25zZS1kYXRhLWVycm9yLnRzXG52YXIgbmFtZTUgPSBcIkFJX0ludmFsaWRSZXNwb25zZURhdGFFcnJvclwiO1xudmFyIG1hcmtlcjYgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTV9YDtcbnZhciBzeW1ib2w2ID0gU3ltYm9sLmZvcihtYXJrZXI2KTtcbnZhciBfYTYsIF9iNjtcbnZhciBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IgPSBjbGFzcyBleHRlbmRzIChfYjYgPSBBSVNES0Vycm9yLCBfYTYgPSBzeW1ib2w2LCBfYjYpIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGRhdGEsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIHJlc3BvbnNlIGRhdGE6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSl9LmBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTUsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTZdID0gdHJ1ZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI2KTtcbiAgfVxufTtcblxuLy8gc3JjL2Vycm9ycy9qc29uLXBhcnNlLWVycm9yLnRzXG52YXIgbmFtZTYgPSBcIkFJX0pTT05QYXJzZUVycm9yXCI7XG52YXIgbWFya2VyNyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNn1gO1xudmFyIHN5bWJvbDcgPSBTeW1ib2wuZm9yKG1hcmtlcjcpO1xudmFyIF9hNywgX2I3O1xudmFyIEpTT05QYXJzZUVycm9yID0gY2xhc3MgZXh0ZW5kcyAoX2I3ID0gQUlTREtFcnJvciwgX2E3ID0gc3ltYm9sNywgX2I3KSB7XG4gIGNvbnN0cnVjdG9yKHsgdGV4dCwgY2F1c2UgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IG5hbWU2LFxuICAgICAgbWVzc2FnZTogYEpTT04gcGFyc2luZyBmYWlsZWQ6IFRleHQ6ICR7dGV4dH0uXG5FcnJvciBtZXNzYWdlOiAke2dldEVycm9yTWVzc2FnZShjYXVzZSl9YCxcbiAgICAgIGNhdXNlXG4gICAgfSk7XG4gICAgdGhpc1tfYTddID0gdHJ1ZTtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI3KTtcbiAgfVxufTtcblxuLy8gc3JjL2Vycm9ycy9sb2FkLWFwaS1rZXktZXJyb3IudHNcbnZhciBuYW1lNyA9IFwiQUlfTG9hZEFQSUtleUVycm9yXCI7XG52YXIgbWFya2VyOCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lN31gO1xudmFyIHN5bWJvbDggPSBTeW1ib2wuZm9yKG1hcmtlcjgpO1xudmFyIF9hOCwgX2I4O1xudmFyIExvYWRBUElLZXlFcnJvciA9IGNsYXNzIGV4dGVuZHMgKF9iOCA9IEFJU0RLRXJyb3IsIF9hOCA9IHN5bWJvbDgsIF9iOCkge1xuICAvLyB1c2VkIGluIGlzSW5zdGFuY2VcbiAgY29uc3RydWN0b3IoeyBtZXNzYWdlIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU3LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2E4XSA9IHRydWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjgpO1xuICB9XG59O1xuXG4vLyBzcmMvZXJyb3JzL2xvYWQtc2V0dGluZy1lcnJvci50c1xudmFyIG5hbWU4ID0gXCJBSV9Mb2FkU2V0dGluZ0Vycm9yXCI7XG52YXIgbWFya2VyOSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lOH1gO1xudmFyIHN5bWJvbDkgPSBTeW1ib2wuZm9yKG1hcmtlcjkpO1xudmFyIF9hOSwgX2I5O1xudmFyIExvYWRTZXR0aW5nRXJyb3IgPSBjbGFzcyBleHRlbmRzIChfYjkgPSBBSVNES0Vycm9yLCBfYTkgPSBzeW1ib2w5LCBfYjkpIHtcbiAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lOCwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hOV0gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI5KTtcbiAgfVxufTtcblxuLy8gc3JjL2Vycm9ycy9uby1jb250ZW50LWdlbmVyYXRlZC1lcnJvci50c1xudmFyIG5hbWU5ID0gXCJBSV9Ob0NvbnRlbnRHZW5lcmF0ZWRFcnJvclwiO1xudmFyIG1hcmtlcjEwID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU5fWA7XG52YXIgc3ltYm9sMTAgPSBTeW1ib2wuZm9yKG1hcmtlcjEwKTtcbnZhciBfYTEwLCBfYjEwO1xudmFyIE5vQ29udGVudEdlbmVyYXRlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyAoX2IxMCA9IEFJU0RLRXJyb3IsIF9hMTAgPSBzeW1ib2wxMCwgX2IxMCkge1xuICAvLyB1c2VkIGluIGlzSW5zdGFuY2VcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UgPSBcIk5vIGNvbnRlbnQgZ2VuZXJhdGVkLlwiXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTksIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTEwXSA9IHRydWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjEwKTtcbiAgfVxufTtcblxuLy8gc3JjL2Vycm9ycy9uby1zdWNoLW1vZGVsLWVycm9yLnRzXG52YXIgbmFtZTEwID0gXCJBSV9Ob1N1Y2hNb2RlbEVycm9yXCI7XG52YXIgbWFya2VyMTEgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTEwfWA7XG52YXIgc3ltYm9sMTEgPSBTeW1ib2wuZm9yKG1hcmtlcjExKTtcbnZhciBfYTExLCBfYjExO1xudmFyIE5vU3VjaE1vZGVsRXJyb3IgPSBjbGFzcyBleHRlbmRzIChfYjExID0gQUlTREtFcnJvciwgX2ExMSA9IHN5bWJvbDExLCBfYjExKSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBlcnJvck5hbWUgPSBuYW1lMTAsXG4gICAgbW9kZWxJZCxcbiAgICBtb2RlbFR5cGUsXG4gICAgbWVzc2FnZSA9IGBObyBzdWNoICR7bW9kZWxUeXBlfTogJHttb2RlbElkfWBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogZXJyb3JOYW1lLCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2ExMV0gPSB0cnVlO1xuICAgIHRoaXMubW9kZWxJZCA9IG1vZGVsSWQ7XG4gICAgdGhpcy5tb2RlbFR5cGUgPSBtb2RlbFR5cGU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjExKTtcbiAgfVxufTtcblxuLy8gc3JjL2Vycm9ycy90b28tbWFueS1lbWJlZGRpbmctdmFsdWVzLWZvci1jYWxsLWVycm9yLnRzXG52YXIgbmFtZTExID0gXCJBSV9Ub29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yXCI7XG52YXIgbWFya2VyMTIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTExfWA7XG52YXIgc3ltYm9sMTIgPSBTeW1ib2wuZm9yKG1hcmtlcjEyKTtcbnZhciBfYTEyLCBfYjEyO1xudmFyIFRvb01hbnlFbWJlZGRpbmdWYWx1ZXNGb3JDYWxsRXJyb3IgPSBjbGFzcyBleHRlbmRzIChfYjEyID0gQUlTREtFcnJvciwgX2ExMiA9IHN5bWJvbDEyLCBfYjEyKSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBuYW1lMTEsXG4gICAgICBtZXNzYWdlOiBgVG9vIG1hbnkgdmFsdWVzIGZvciBhIHNpbmdsZSBlbWJlZGRpbmcgY2FsbC4gVGhlICR7b3B0aW9ucy5wcm92aWRlcn0gbW9kZWwgXCIke29wdGlvbnMubW9kZWxJZH1cIiBjYW4gb25seSBlbWJlZCB1cCB0byAke29wdGlvbnMubWF4RW1iZWRkaW5nc1BlckNhbGx9IHZhbHVlcyBwZXIgY2FsbCwgYnV0ICR7b3B0aW9ucy52YWx1ZXMubGVuZ3RofSB2YWx1ZXMgd2VyZSBwcm92aWRlZC5gXG4gICAgfSk7XG4gICAgdGhpc1tfYTEyXSA9IHRydWU7XG4gICAgdGhpcy5wcm92aWRlciA9IG9wdGlvbnMucHJvdmlkZXI7XG4gICAgdGhpcy5tb2RlbElkID0gb3B0aW9ucy5tb2RlbElkO1xuICAgIHRoaXMubWF4RW1iZWRkaW5nc1BlckNhbGwgPSBvcHRpb25zLm1heEVtYmVkZGluZ3NQZXJDYWxsO1xuICAgIHRoaXMudmFsdWVzID0gb3B0aW9ucy52YWx1ZXM7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjEyKTtcbiAgfVxufTtcblxuLy8gc3JjL2Vycm9ycy90eXBlLXZhbGlkYXRpb24tZXJyb3IudHNcbnZhciBuYW1lMTIgPSBcIkFJX1R5cGVWYWxpZGF0aW9uRXJyb3JcIjtcbnZhciBtYXJrZXIxMyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTJ9YDtcbnZhciBzeW1ib2wxMyA9IFN5bWJvbC5mb3IobWFya2VyMTMpO1xudmFyIF9hMTMsIF9iMTM7XG52YXIgVHlwZVZhbGlkYXRpb25FcnJvciA9IGNsYXNzIF9UeXBlVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgKF9iMTMgPSBBSVNES0Vycm9yLCBfYTEzID0gc3ltYm9sMTMsIF9iMTMpIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHZhbHVlLFxuICAgIGNhdXNlLFxuICAgIGNvbnRleHRcbiAgfSkge1xuICAgIGxldCBjb250ZXh0UHJlZml4ID0gXCJUeXBlIHZhbGlkYXRpb24gZmFpbGVkXCI7XG4gICAgaWYgKGNvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRleHQuZmllbGQpIHtcbiAgICAgIGNvbnRleHRQcmVmaXggKz0gYCBmb3IgJHtjb250ZXh0LmZpZWxkfWA7XG4gICAgfVxuICAgIGlmICgoY29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogY29udGV4dC5lbnRpdHlOYW1lKSB8fCAoY29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogY29udGV4dC5lbnRpdHlJZCkpIHtcbiAgICAgIGNvbnRleHRQcmVmaXggKz0gXCIgKFwiO1xuICAgICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICAgIGlmIChjb250ZXh0LmVudGl0eU5hbWUpIHtcbiAgICAgICAgcGFydHMucHVzaChjb250ZXh0LmVudGl0eU5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRleHQuZW50aXR5SWQpIHtcbiAgICAgICAgcGFydHMucHVzaChgaWQ6IFwiJHtjb250ZXh0LmVudGl0eUlkfVwiYCk7XG4gICAgICB9XG4gICAgICBjb250ZXh0UHJlZml4ICs9IHBhcnRzLmpvaW4oXCIsIFwiKTtcbiAgICAgIGNvbnRleHRQcmVmaXggKz0gXCIpXCI7XG4gICAgfVxuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IG5hbWUxMixcbiAgICAgIG1lc3NhZ2U6IGAke2NvbnRleHRQcmVmaXh9OiBWYWx1ZTogJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9LlxuRXJyb3IgbWVzc2FnZTogJHtnZXRFcnJvck1lc3NhZ2UoY2F1c2UpfWAsXG4gICAgICBjYXVzZVxuICAgIH0pO1xuICAgIHRoaXNbX2ExM10gPSB0cnVlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMyk7XG4gIH1cbiAgLyoqXG4gICAqIFdyYXBzIGFuIGVycm9yIGludG8gYSBUeXBlVmFsaWRhdGlvbkVycm9yLlxuICAgKiBJZiB0aGUgY2F1c2UgaXMgYWxyZWFkeSBhIFR5cGVWYWxpZGF0aW9uRXJyb3Igd2l0aCB0aGUgc2FtZSB2YWx1ZSBhbmQgY29udGV4dCwgaXQgcmV0dXJucyB0aGUgY2F1c2UuXG4gICAqIE90aGVyd2lzZSwgaXQgY3JlYXRlcyBhIG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHdyYXBwaW5nIHRoZSBlcnJvci5cbiAgICogQHBhcmFtIHt1bmtub3dufSBwYXJhbXMudmFsdWUgLSBUaGUgdmFsdWUgdGhhdCBmYWlsZWQgdmFsaWRhdGlvbi5cbiAgICogQHBhcmFtIHt1bmtub3dufSBwYXJhbXMuY2F1c2UgLSBUaGUgb3JpZ2luYWwgZXJyb3Igb3IgY2F1c2Ugb2YgdGhlIHZhbGlkYXRpb24gZmFpbHVyZS5cbiAgICogQHBhcmFtIHtUeXBlVmFsaWRhdGlvbkNvbnRleHR9IHBhcmFtcy5jb250ZXh0IC0gT3B0aW9uYWwgY29udGV4dCBhYm91dCB3aGF0IGlzIGJlaW5nIHZhbGlkYXRlZC5cbiAgICogQHJldHVybnMge1R5cGVWYWxpZGF0aW9uRXJyb3J9IEEgVHlwZVZhbGlkYXRpb25FcnJvciBpbnN0YW5jZS5cbiAgICovXG4gIHN0YXRpYyB3cmFwKHtcbiAgICB2YWx1ZSxcbiAgICBjYXVzZSxcbiAgICBjb250ZXh0XG4gIH0pIHtcbiAgICB2YXIgX2ExNSwgX2IxNSwgX2M7XG4gICAgaWYgKF9UeXBlVmFsaWRhdGlvbkVycm9yLmlzSW5zdGFuY2UoY2F1c2UpICYmIGNhdXNlLnZhbHVlID09PSB2YWx1ZSAmJiAoKF9hMTUgPSBjYXVzZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2ExNS5maWVsZCkgPT09IChjb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBjb250ZXh0LmZpZWxkKSAmJiAoKF9iMTUgPSBjYXVzZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2IxNS5lbnRpdHlOYW1lKSA9PT0gKGNvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRleHQuZW50aXR5TmFtZSkgJiYgKChfYyA9IGNhdXNlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfYy5lbnRpdHlJZCkgPT09IChjb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBjb250ZXh0LmVudGl0eUlkKSkge1xuICAgICAgcmV0dXJuIGNhdXNlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9UeXBlVmFsaWRhdGlvbkVycm9yKHsgdmFsdWUsIGNhdXNlLCBjb250ZXh0IH0pO1xuICB9XG59O1xuXG4vLyBzcmMvZXJyb3JzL3Vuc3VwcG9ydGVkLWZ1bmN0aW9uYWxpdHktZXJyb3IudHNcbnZhciBuYW1lMTMgPSBcIkFJX1Vuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yXCI7XG52YXIgbWFya2VyMTQgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTEzfWA7XG52YXIgc3ltYm9sMTQgPSBTeW1ib2wuZm9yKG1hcmtlcjE0KTtcbnZhciBfYTE0LCBfYjE0O1xudmFyIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yID0gY2xhc3MgZXh0ZW5kcyAoX2IxNCA9IEFJU0RLRXJyb3IsIF9hMTQgPSBzeW1ib2wxNCwgX2IxNCkge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZnVuY3Rpb25hbGl0eSxcbiAgICBtZXNzYWdlID0gYCcke2Z1bmN0aW9uYWxpdHl9JyBmdW5jdGlvbmFsaXR5IG5vdCBzdXBwb3J0ZWQuYFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMTMsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTE0XSA9IHRydWU7XG4gICAgdGhpcy5mdW5jdGlvbmFsaXR5ID0gZnVuY3Rpb25hbGl0eTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTQpO1xuICB9XG59O1xuXG4vLyBzcmMvanNvbi12YWx1ZS9pcy1qc29uLnRzXG5mdW5jdGlvbiBpc0pTT05WYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGlzSlNPTlZhbHVlKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5ldmVyeShcbiAgICAgIChba2V5LCB2YWxdKSA9PiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICYmICh2YWwgPT09IHZvaWQgMCB8fCBpc0pTT05WYWx1ZSh2YWwpKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNKU09OQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KGlzSlNPTlZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzSlNPTk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmVudHJpZXModmFsdWUpLmV2ZXJ5KFxuICAgIChba2V5LCB2YWxdKSA9PiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICYmICh2YWwgPT09IHZvaWQgMCB8fCBpc0pTT05WYWx1ZSh2YWwpKVxuICApO1xufVxuZXhwb3J0IHtcbiAgQUlTREtFcnJvcixcbiAgQVBJQ2FsbEVycm9yLFxuICBFbXB0eVJlc3BvbnNlQm9keUVycm9yLFxuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgSW52YWxpZFByb21wdEVycm9yLFxuICBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IsXG4gIEpTT05QYXJzZUVycm9yLFxuICBMb2FkQVBJS2V5RXJyb3IsXG4gIExvYWRTZXR0aW5nRXJyb3IsXG4gIE5vQ29udGVudEdlbmVyYXRlZEVycm9yLFxuICBOb1N1Y2hNb2RlbEVycm9yLFxuICBUb29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yLFxuICBUeXBlVmFsaWRhdGlvbkVycm9yLFxuICBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcixcbiAgZ2V0RXJyb3JNZXNzYWdlLFxuICBpc0pTT05BcnJheSxcbiAgaXNKU09OT2JqZWN0LFxuICBpc0pTT05WYWx1ZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ai-sdk/react/node_modules/ai/dist/index.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@ai-sdk/react/node_modules/ai/dist/index.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISDKError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError),\n/* harmony export */   APICallError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError),\n/* harmony export */   AbstractChat: () => (/* binding */ AbstractChat),\n/* harmony export */   DefaultChatTransport: () => (/* binding */ DefaultChatTransport),\n/* harmony export */   DefaultGeneratedFile: () => (/* binding */ DefaultGeneratedFile),\n/* harmony export */   DirectChatTransport: () => (/* binding */ DirectChatTransport),\n/* harmony export */   DownloadError: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DownloadError),\n/* harmony export */   EmptyResponseBodyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.EmptyResponseBodyError),\n/* harmony export */   Experimental_Agent: () => (/* binding */ ToolLoopAgent),\n/* harmony export */   HttpChatTransport: () => (/* binding */ HttpChatTransport),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidDataContentError: () => (/* binding */ InvalidDataContentError),\n/* harmony export */   InvalidMessageRoleError: () => (/* binding */ InvalidMessageRoleError),\n/* harmony export */   InvalidPromptError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidResponseDataError),\n/* harmony export */   InvalidStreamPartError: () => (/* binding */ InvalidStreamPartError),\n/* harmony export */   InvalidToolApprovalError: () => (/* binding */ InvalidToolApprovalError),\n/* harmony export */   InvalidToolInputError: () => (/* binding */ InvalidToolInputError),\n/* harmony export */   JSONParseError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError),\n/* harmony export */   JsonToSseTransformStream: () => (/* binding */ JsonToSseTransformStream),\n/* harmony export */   LoadAPIKeyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadAPIKeyError),\n/* harmony export */   LoadSettingError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadSettingError),\n/* harmony export */   MessageConversionError: () => (/* binding */ MessageConversionError),\n/* harmony export */   MissingToolResultsError: () => (/* binding */ MissingToolResultsError),\n/* harmony export */   NoContentGeneratedError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoContentGeneratedError),\n/* harmony export */   NoImageGeneratedError: () => (/* binding */ NoImageGeneratedError),\n/* harmony export */   NoObjectGeneratedError: () => (/* binding */ NoObjectGeneratedError),\n/* harmony export */   NoOutputGeneratedError: () => (/* binding */ NoOutputGeneratedError),\n/* harmony export */   NoSpeechGeneratedError: () => (/* binding */ NoSpeechGeneratedError),\n/* harmony export */   NoSuchModelError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError),\n/* harmony export */   NoSuchProviderError: () => (/* binding */ NoSuchProviderError),\n/* harmony export */   NoSuchToolError: () => (/* binding */ NoSuchToolError),\n/* harmony export */   NoTranscriptGeneratedError: () => (/* binding */ NoTranscriptGeneratedError),\n/* harmony export */   NoVideoGeneratedError: () => (/* binding */ NoVideoGeneratedError),\n/* harmony export */   Output: () => (/* binding */ output_exports),\n/* harmony export */   RetryError: () => (/* binding */ RetryError),\n/* harmony export */   SerialJobExecutor: () => (/* binding */ SerialJobExecutor),\n/* harmony export */   TextStreamChatTransport: () => (/* binding */ TextStreamChatTransport),\n/* harmony export */   TooManyEmbeddingValuesForCallError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TooManyEmbeddingValuesForCallError),\n/* harmony export */   ToolCallNotFoundForApprovalError: () => (/* binding */ ToolCallNotFoundForApprovalError),\n/* harmony export */   ToolCallRepairError: () => (/* binding */ ToolCallRepairError),\n/* harmony export */   ToolLoopAgent: () => (/* binding */ ToolLoopAgent),\n/* harmony export */   TypeValidationError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError),\n/* harmony export */   UIMessageStreamError: () => (/* binding */ UIMessageStreamError),\n/* harmony export */   UI_MESSAGE_STREAM_HEADERS: () => (/* binding */ UI_MESSAGE_STREAM_HEADERS),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError),\n/* harmony export */   UnsupportedModelVersionError: () => (/* binding */ UnsupportedModelVersionError),\n/* harmony export */   addToolInputExamplesMiddleware: () => (/* binding */ addToolInputExamplesMiddleware),\n/* harmony export */   asSchema: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema),\n/* harmony export */   assistantModelMessageSchema: () => (/* binding */ assistantModelMessageSchema),\n/* harmony export */   callCompletionApi: () => (/* binding */ callCompletionApi),\n/* harmony export */   consumeStream: () => (/* binding */ consumeStream),\n/* harmony export */   convertFileListToFileUIParts: () => (/* binding */ convertFileListToFileUIParts),\n/* harmony export */   convertToModelMessages: () => (/* binding */ convertToModelMessages),\n/* harmony export */   cosineSimilarity: () => (/* binding */ cosineSimilarity),\n/* harmony export */   createAgentUIStream: () => (/* binding */ createAgentUIStream),\n/* harmony export */   createAgentUIStreamResponse: () => (/* binding */ createAgentUIStreamResponse),\n/* harmony export */   createDownload: () => (/* binding */ createDownload),\n/* harmony export */   createGateway: () => (/* reexport safe */ _ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__.createGateway),\n/* harmony export */   createIdGenerator: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator),\n/* harmony export */   createProviderRegistry: () => (/* binding */ createProviderRegistry),\n/* harmony export */   createTextStreamResponse: () => (/* binding */ createTextStreamResponse),\n/* harmony export */   createUIMessageStream: () => (/* binding */ createUIMessageStream),\n/* harmony export */   createUIMessageStreamResponse: () => (/* binding */ createUIMessageStreamResponse),\n/* harmony export */   customProvider: () => (/* binding */ customProvider),\n/* harmony export */   defaultEmbeddingSettingsMiddleware: () => (/* binding */ defaultEmbeddingSettingsMiddleware),\n/* harmony export */   defaultSettingsMiddleware: () => (/* binding */ defaultSettingsMiddleware),\n/* harmony export */   dynamicTool: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.dynamicTool),\n/* harmony export */   embed: () => (/* binding */ embed),\n/* harmony export */   embedMany: () => (/* binding */ embedMany),\n/* harmony export */   experimental_createProviderRegistry: () => (/* binding */ experimental_createProviderRegistry),\n/* harmony export */   experimental_customProvider: () => (/* binding */ experimental_customProvider),\n/* harmony export */   experimental_generateImage: () => (/* binding */ experimental_generateImage),\n/* harmony export */   experimental_generateSpeech: () => (/* binding */ generateSpeech),\n/* harmony export */   experimental_generateVideo: () => (/* binding */ experimental_generateVideo),\n/* harmony export */   experimental_transcribe: () => (/* binding */ transcribe),\n/* harmony export */   extractJsonMiddleware: () => (/* binding */ extractJsonMiddleware),\n/* harmony export */   extractReasoningMiddleware: () => (/* binding */ extractReasoningMiddleware),\n/* harmony export */   gateway: () => (/* reexport safe */ _ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__.gateway),\n/* harmony export */   generateId: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.generateId),\n/* harmony export */   generateImage: () => (/* binding */ generateImage),\n/* harmony export */   generateObject: () => (/* binding */ generateObject),\n/* harmony export */   generateText: () => (/* binding */ generateText),\n/* harmony export */   getStaticToolName: () => (/* binding */ getStaticToolName),\n/* harmony export */   getTextFromDataUrl: () => (/* binding */ getTextFromDataUrl),\n/* harmony export */   getToolName: () => (/* binding */ getToolName),\n/* harmony export */   getToolOrDynamicToolName: () => (/* binding */ getToolOrDynamicToolName),\n/* harmony export */   hasToolCall: () => (/* binding */ hasToolCall),\n/* harmony export */   isDataUIPart: () => (/* binding */ isDataUIPart),\n/* harmony export */   isDeepEqualData: () => (/* binding */ isDeepEqualData),\n/* harmony export */   isFileUIPart: () => (/* binding */ isFileUIPart),\n/* harmony export */   isReasoningUIPart: () => (/* binding */ isReasoningUIPart),\n/* harmony export */   isStaticToolUIPart: () => (/* binding */ isStaticToolUIPart),\n/* harmony export */   isTextUIPart: () => (/* binding */ isTextUIPart),\n/* harmony export */   isToolOrDynamicToolUIPart: () => (/* binding */ isToolOrDynamicToolUIPart),\n/* harmony export */   isToolUIPart: () => (/* binding */ isToolUIPart),\n/* harmony export */   jsonSchema: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.jsonSchema),\n/* harmony export */   lastAssistantMessageIsCompleteWithApprovalResponses: () => (/* binding */ lastAssistantMessageIsCompleteWithApprovalResponses),\n/* harmony export */   lastAssistantMessageIsCompleteWithToolCalls: () => (/* binding */ lastAssistantMessageIsCompleteWithToolCalls),\n/* harmony export */   modelMessageSchema: () => (/* binding */ modelMessageSchema),\n/* harmony export */   parseJsonEventStream: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.parseJsonEventStream),\n/* harmony export */   parsePartialJson: () => (/* binding */ parsePartialJson),\n/* harmony export */   pipeAgentUIStreamToResponse: () => (/* binding */ pipeAgentUIStreamToResponse),\n/* harmony export */   pipeTextStreamToResponse: () => (/* binding */ pipeTextStreamToResponse),\n/* harmony export */   pipeUIMessageStreamToResponse: () => (/* binding */ pipeUIMessageStreamToResponse),\n/* harmony export */   pruneMessages: () => (/* binding */ pruneMessages),\n/* harmony export */   readUIMessageStream: () => (/* binding */ readUIMessageStream),\n/* harmony export */   rerank: () => (/* binding */ rerank),\n/* harmony export */   safeValidateUIMessages: () => (/* binding */ safeValidateUIMessages),\n/* harmony export */   simulateReadableStream: () => (/* binding */ simulateReadableStream),\n/* harmony export */   simulateStreamingMiddleware: () => (/* binding */ simulateStreamingMiddleware),\n/* harmony export */   smoothStream: () => (/* binding */ smoothStream),\n/* harmony export */   stepCountIs: () => (/* binding */ stepCountIs),\n/* harmony export */   streamObject: () => (/* binding */ streamObject),\n/* harmony export */   streamText: () => (/* binding */ streamText),\n/* harmony export */   systemModelMessageSchema: () => (/* binding */ systemModelMessageSchema),\n/* harmony export */   tool: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.tool),\n/* harmony export */   toolModelMessageSchema: () => (/* binding */ toolModelMessageSchema),\n/* harmony export */   uiMessageChunkSchema: () => (/* binding */ uiMessageChunkSchema),\n/* harmony export */   userModelMessageSchema: () => (/* binding */ userModelMessageSchema),\n/* harmony export */   validateUIMessages: () => (/* binding */ validateUIMessages),\n/* harmony export */   wrapEmbeddingModel: () => (/* binding */ wrapEmbeddingModel),\n/* harmony export */   wrapImageModel: () => (/* binding */ wrapImageModel),\n/* harmony export */   wrapLanguageModel: () => (/* binding */ wrapLanguageModel),\n/* harmony export */   wrapProvider: () => (/* binding */ wrapProvider),\n/* harmony export */   zodSchema: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.zodSchema)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/gateway */ \"(ssr)/./node_modules/@ai-sdk/gateway/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(ssr)/./node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/provider */ \"(ssr)/./node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var zod_v4__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zod/v4 */ \"(ssr)/./node_modules/zod/v4/classic/schemas.js\");\n/* harmony import */ var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @opentelemetry/api */ \"(ssr)/./node_modules/@opentelemetry/api/build/esm/trace-api.js\");\n/* harmony import */ var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @opentelemetry/api */ \"(ssr)/./node_modules/@opentelemetry/api/build/esm/context-api.js\");\n/* harmony import */ var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @opentelemetry/api */ \"(ssr)/./node_modules/@opentelemetry/api/build/esm/trace/status.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name21 in all)\n    __defProp(target, name21, { get: all[name21], enumerable: true });\n};\n\n// src/index.ts\n\n\n\n// src/generate-text/generate-text.ts\n\n\n// src/error/index.ts\n\n\n// src/error/invalid-argument-error.ts\n\nvar name = \"AI_InvalidArgumentError\";\nvar marker = `vercel.ai.error.${name}`;\nvar symbol = Symbol.for(marker);\nvar _a;\nvar InvalidArgumentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    parameter,\n    value,\n    message\n  }) {\n    super({\n      name,\n      message: `Invalid argument for parameter ${parameter}: ${message}`\n    });\n    this[_a] = true;\n    this.parameter = parameter;\n    this.value = value;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker);\n  }\n};\n_a = symbol;\n\n// src/error/invalid-stream-part-error.ts\n\nvar name2 = \"AI_InvalidStreamPartError\";\nvar marker2 = `vercel.ai.error.${name2}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar InvalidStreamPartError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    chunk,\n    message\n  }) {\n    super({ name: name2, message });\n    this[_a2] = true;\n    this.chunk = chunk;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker2);\n  }\n};\n_a2 = symbol2;\n\n// src/error/invalid-tool-approval-error.ts\n\nvar name3 = \"AI_InvalidToolApprovalError\";\nvar marker3 = `vercel.ai.error.${name3}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar InvalidToolApprovalError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({ approvalId }) {\n    super({\n      name: name3,\n      message: `Tool approval response references unknown approvalId: \"${approvalId}\". No matching tool-approval-request found in message history.`\n    });\n    this[_a3] = true;\n    this.approvalId = approvalId;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker3);\n  }\n};\n_a3 = symbol3;\n\n// src/error/invalid-tool-input-error.ts\n\nvar name4 = \"AI_InvalidToolInputError\";\nvar marker4 = `vercel.ai.error.${name4}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidToolInputError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    toolInput,\n    toolName,\n    cause,\n    message = `Invalid input for tool ${toolName}: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(cause)}`\n  }) {\n    super({ name: name4, message, cause });\n    this[_a4] = true;\n    this.toolInput = toolInput;\n    this.toolName = toolName;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker4);\n  }\n};\n_a4 = symbol4;\n\n// src/error/tool-call-not-found-for-approval-error.ts\n\nvar name5 = \"AI_ToolCallNotFoundForApprovalError\";\nvar marker5 = `vercel.ai.error.${name5}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar ToolCallNotFoundForApprovalError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    toolCallId,\n    approvalId\n  }) {\n    super({\n      name: name5,\n      message: `Tool call \"${toolCallId}\" not found for approval request \"${approvalId}\".`\n    });\n    this[_a5] = true;\n    this.toolCallId = toolCallId;\n    this.approvalId = approvalId;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker5);\n  }\n};\n_a5 = symbol5;\n\n// src/error/missing-tool-result-error.ts\n\nvar name6 = \"AI_MissingToolResultsError\";\nvar marker6 = `vercel.ai.error.${name6}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar MissingToolResultsError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({ toolCallIds }) {\n    super({\n      name: name6,\n      message: `Tool result${toolCallIds.length > 1 ? \"s are\" : \" is\"} missing for tool call${toolCallIds.length > 1 ? \"s\" : \"\"} ${toolCallIds.join(\n        \", \"\n      )}.`\n    });\n    this[_a6] = true;\n    this.toolCallIds = toolCallIds;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker6);\n  }\n};\n_a6 = symbol6;\n\n// src/error/no-image-generated-error.ts\n\nvar name7 = \"AI_NoImageGeneratedError\";\nvar marker7 = `vercel.ai.error.${name7}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar NoImageGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    message = \"No image generated.\",\n    cause,\n    responses\n  }) {\n    super({ name: name7, message, cause });\n    this[_a7] = true;\n    this.responses = responses;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker7);\n  }\n};\n_a7 = symbol7;\n\n// src/error/no-object-generated-error.ts\n\nvar name8 = \"AI_NoObjectGeneratedError\";\nvar marker8 = `vercel.ai.error.${name8}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar NoObjectGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    message = \"No object generated.\",\n    cause,\n    text: text2,\n    response,\n    usage,\n    finishReason\n  }) {\n    super({ name: name8, message, cause });\n    this[_a8] = true;\n    this.text = text2;\n    this.response = response;\n    this.usage = usage;\n    this.finishReason = finishReason;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker8);\n  }\n};\n_a8 = symbol8;\n\n// src/error/no-output-generated-error.ts\n\nvar name9 = \"AI_NoOutputGeneratedError\";\nvar marker9 = `vercel.ai.error.${name9}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar NoOutputGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  // used in isInstance\n  constructor({\n    message = \"No output generated.\",\n    cause\n  } = {}) {\n    super({ name: name9, message, cause });\n    this[_a9] = true;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker9);\n  }\n};\n_a9 = symbol9;\n\n// src/error/no-speech-generated-error.ts\n\nvar name10 = \"AI_NoSpeechGeneratedError\";\nvar marker10 = `vercel.ai.error.${name10}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar NoSpeechGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor(options) {\n    super({\n      name: name10,\n      message: \"No speech audio generated.\"\n    });\n    this[_a10] = true;\n    this.responses = options.responses;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker10);\n  }\n};\n_a10 = symbol10;\n\n// src/error/no-transcript-generated-error.ts\n\nvar name11 = \"AI_NoTranscriptGeneratedError\";\nvar marker11 = `vercel.ai.error.${name11}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\nvar NoTranscriptGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor(options) {\n    super({\n      name: name11,\n      message: \"No transcript generated.\"\n    });\n    this[_a11] = true;\n    this.responses = options.responses;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker11);\n  }\n};\n_a11 = symbol11;\n\n// src/error/no-video-generated-error.ts\n\nvar name12 = \"AI_NoVideoGeneratedError\";\nvar marker12 = `vercel.ai.error.${name12}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\nvar NoVideoGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    message = \"No video generated.\",\n    cause,\n    responses\n  }) {\n    super({ name: name12, message, cause });\n    this[_a12] = true;\n    this.responses = responses;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker12);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isNoVideoGeneratedError(error) {\n    return error instanceof Error && error.name === name12 && typeof error.responses !== \"undefined\" ? true : false;\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      cause: this.cause,\n      responses: this.responses\n    };\n  }\n};\n_a12 = symbol12;\n\n// src/error/no-such-tool-error.ts\n\nvar name13 = \"AI_NoSuchToolError\";\nvar marker13 = `vercel.ai.error.${name13}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13;\nvar NoSuchToolError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    toolName,\n    availableTools = void 0,\n    message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? \"No tools are available.\" : `Available tools: ${availableTools.join(\", \")}.`}`\n  }) {\n    super({ name: name13, message });\n    this[_a13] = true;\n    this.toolName = toolName;\n    this.availableTools = availableTools;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker13);\n  }\n};\n_a13 = symbol13;\n\n// src/error/tool-call-repair-error.ts\n\nvar name14 = \"AI_ToolCallRepairError\";\nvar marker14 = `vercel.ai.error.${name14}`;\nvar symbol14 = Symbol.for(marker14);\nvar _a14;\nvar ToolCallRepairError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    cause,\n    originalError,\n    message = `Error repairing tool call: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(cause)}`\n  }) {\n    super({ name: name14, message, cause });\n    this[_a14] = true;\n    this.originalError = originalError;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker14);\n  }\n};\n_a14 = symbol14;\n\n// src/error/unsupported-model-version-error.ts\n\nvar UnsupportedModelVersionError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor(options) {\n    super({\n      name: \"AI_UnsupportedModelVersionError\",\n      message: `Unsupported model version ${options.version} for provider \"${options.provider}\" and model \"${options.modelId}\". AI SDK 5 only supports models that implement specification version \"v2\".`\n    });\n    this.version = options.version;\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n  }\n};\n\n// src/error/ui-message-stream-error.ts\n\nvar name15 = \"AI_UIMessageStreamError\";\nvar marker15 = `vercel.ai.error.${name15}`;\nvar symbol15 = Symbol.for(marker15);\nvar _a15;\nvar UIMessageStreamError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    chunkType,\n    chunkId,\n    message\n  }) {\n    super({ name: name15, message });\n    this[_a15] = true;\n    this.chunkType = chunkType;\n    this.chunkId = chunkId;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker15);\n  }\n};\n_a15 = symbol15;\n\n// src/prompt/invalid-data-content-error.ts\n\nvar name16 = \"AI_InvalidDataContentError\";\nvar marker16 = `vercel.ai.error.${name16}`;\nvar symbol16 = Symbol.for(marker16);\nvar _a16;\nvar InvalidDataContentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    content,\n    cause,\n    message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.`\n  }) {\n    super({ name: name16, message, cause });\n    this[_a16] = true;\n    this.content = content;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker16);\n  }\n};\n_a16 = symbol16;\n\n// src/prompt/invalid-message-role-error.ts\n\nvar name17 = \"AI_InvalidMessageRoleError\";\nvar marker17 = `vercel.ai.error.${name17}`;\nvar symbol17 = Symbol.for(marker17);\nvar _a17;\nvar InvalidMessageRoleError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    role,\n    message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".`\n  }) {\n    super({ name: name17, message });\n    this[_a17] = true;\n    this.role = role;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker17);\n  }\n};\n_a17 = symbol17;\n\n// src/prompt/message-conversion-error.ts\n\nvar name18 = \"AI_MessageConversionError\";\nvar marker18 = `vercel.ai.error.${name18}`;\nvar symbol18 = Symbol.for(marker18);\nvar _a18;\nvar MessageConversionError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    originalMessage,\n    message\n  }) {\n    super({ name: name18, message });\n    this[_a18] = true;\n    this.originalMessage = originalMessage;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker18);\n  }\n};\n_a18 = symbol18;\n\n// src/error/index.ts\n\n\n// src/util/retry-error.ts\n\nvar name19 = \"AI_RetryError\";\nvar marker19 = `vercel.ai.error.${name19}`;\nvar symbol19 = Symbol.for(marker19);\nvar _a19;\nvar RetryError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    message,\n    reason,\n    errors\n  }) {\n    super({ name: name19, message });\n    this[_a19] = true;\n    this.reason = reason;\n    this.errors = errors;\n    this.lastError = errors[errors.length - 1];\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker19);\n  }\n};\n_a19 = symbol19;\n\n// src/logger/log-warnings.ts\nfunction formatWarning({\n  warning,\n  provider,\n  model\n}) {\n  const prefix = `AI SDK Warning (${provider} / ${model}):`;\n  switch (warning.type) {\n    case \"unsupported\": {\n      let message = `${prefix} The feature \"${warning.feature}\" is not supported.`;\n      if (warning.details) {\n        message += ` ${warning.details}`;\n      }\n      return message;\n    }\n    case \"compatibility\": {\n      let message = `${prefix} The feature \"${warning.feature}\" is used in a compatibility mode.`;\n      if (warning.details) {\n        message += ` ${warning.details}`;\n      }\n      return message;\n    }\n    case \"other\": {\n      return `${prefix} ${warning.message}`;\n    }\n    default: {\n      return `${prefix} ${JSON.stringify(warning, null, 2)}`;\n    }\n  }\n}\nvar FIRST_WARNING_INFO_MESSAGE = \"AI SDK Warning System: To turn off warning logging, set the AI_SDK_LOG_WARNINGS global to false.\";\nvar hasLoggedBefore = false;\nvar logWarnings = (options) => {\n  if (options.warnings.length === 0) {\n    return;\n  }\n  const logger = globalThis.AI_SDK_LOG_WARNINGS;\n  if (logger === false) {\n    return;\n  }\n  if (typeof logger === \"function\") {\n    logger(options);\n    return;\n  }\n  if (!hasLoggedBefore) {\n    hasLoggedBefore = true;\n    console.info(FIRST_WARNING_INFO_MESSAGE);\n  }\n  for (const warning of options.warnings) {\n    console.warn(\n      formatWarning({\n        warning,\n        provider: options.provider,\n        model: options.model\n      })\n    );\n  }\n};\n\n// src/model/resolve-model.ts\n\n\n// src/util/log-v2-compatibility-warning.ts\nfunction logV2CompatibilityWarning({\n  provider,\n  modelId\n}) {\n  logWarnings({\n    warnings: [\n      {\n        type: \"compatibility\",\n        feature: \"specificationVersion\",\n        details: `Using v2 specification compatibility mode. Some features may not be available.`\n      }\n    ],\n    provider,\n    model: modelId\n  });\n}\n\n// src/model/as-embedding-model-v3.ts\nfunction asEmbeddingModelV3(model) {\n  if (model.specificationVersion === \"v3\") {\n    return model;\n  }\n  logV2CompatibilityWarning({\n    provider: model.provider,\n    modelId: model.modelId\n  });\n  return new Proxy(model, {\n    get(target, prop) {\n      if (prop === \"specificationVersion\")\n        return \"v3\";\n      return target[prop];\n    }\n  });\n}\n\n// src/model/as-image-model-v3.ts\nfunction asImageModelV3(model) {\n  if (model.specificationVersion === \"v3\") {\n    return model;\n  }\n  logV2CompatibilityWarning({\n    provider: model.provider,\n    modelId: model.modelId\n  });\n  return new Proxy(model, {\n    get(target, prop) {\n      if (prop === \"specificationVersion\")\n        return \"v3\";\n      return target[prop];\n    }\n  });\n}\n\n// src/model/as-language-model-v3.ts\nfunction asLanguageModelV3(model) {\n  if (model.specificationVersion === \"v3\") {\n    return model;\n  }\n  logV2CompatibilityWarning({\n    provider: model.provider,\n    modelId: model.modelId\n  });\n  return new Proxy(model, {\n    get(target, prop) {\n      switch (prop) {\n        case \"specificationVersion\":\n          return \"v3\";\n        case \"doGenerate\":\n          return async (...args) => {\n            const result = await target.doGenerate(...args);\n            return {\n              ...result,\n              finishReason: convertV2FinishReasonToV3(result.finishReason),\n              usage: convertV2UsageToV3(result.usage)\n            };\n          };\n        case \"doStream\":\n          return async (...args) => {\n            const result = await target.doStream(...args);\n            return {\n              ...result,\n              stream: convertV2StreamToV3(result.stream)\n            };\n          };\n        default:\n          return target[prop];\n      }\n    }\n  });\n}\nfunction convertV2StreamToV3(stream) {\n  return stream.pipeThrough(\n    new TransformStream({\n      transform(chunk, controller) {\n        switch (chunk.type) {\n          case \"finish\":\n            controller.enqueue({\n              ...chunk,\n              finishReason: convertV2FinishReasonToV3(chunk.finishReason),\n              usage: convertV2UsageToV3(chunk.usage)\n            });\n            break;\n          default:\n            controller.enqueue(chunk);\n            break;\n        }\n      }\n    })\n  );\n}\nfunction convertV2FinishReasonToV3(finishReason) {\n  return {\n    unified: finishReason === \"unknown\" ? \"other\" : finishReason,\n    raw: void 0\n  };\n}\nfunction convertV2UsageToV3(usage) {\n  return {\n    inputTokens: {\n      total: usage.inputTokens,\n      noCache: void 0,\n      cacheRead: usage.cachedInputTokens,\n      cacheWrite: void 0\n    },\n    outputTokens: {\n      total: usage.outputTokens,\n      text: void 0,\n      reasoning: usage.reasoningTokens\n    }\n  };\n}\n\n// src/model/as-speech-model-v3.ts\nfunction asSpeechModelV3(model) {\n  if (model.specificationVersion === \"v3\") {\n    return model;\n  }\n  logV2CompatibilityWarning({\n    provider: model.provider,\n    modelId: model.modelId\n  });\n  return new Proxy(model, {\n    get(target, prop) {\n      if (prop === \"specificationVersion\")\n        return \"v3\";\n      return target[prop];\n    }\n  });\n}\n\n// src/model/as-transcription-model-v3.ts\nfunction asTranscriptionModelV3(model) {\n  if (model.specificationVersion === \"v3\") {\n    return model;\n  }\n  logV2CompatibilityWarning({\n    provider: model.provider,\n    modelId: model.modelId\n  });\n  return new Proxy(model, {\n    get(target, prop) {\n      if (prop === \"specificationVersion\")\n        return \"v3\";\n      return target[prop];\n    }\n  });\n}\n\n// src/model/resolve-model.ts\nfunction resolveLanguageModel(model) {\n  if (typeof model !== \"string\") {\n    if (model.specificationVersion !== \"v3\" && model.specificationVersion !== \"v2\") {\n      const unsupportedModel = model;\n      throw new UnsupportedModelVersionError({\n        version: unsupportedModel.specificationVersion,\n        provider: unsupportedModel.provider,\n        modelId: unsupportedModel.modelId\n      });\n    }\n    return asLanguageModelV3(model);\n  }\n  return getGlobalProvider().languageModel(model);\n}\nfunction resolveEmbeddingModel(model) {\n  if (typeof model !== \"string\") {\n    if (model.specificationVersion !== \"v3\" && model.specificationVersion !== \"v2\") {\n      const unsupportedModel = model;\n      throw new UnsupportedModelVersionError({\n        version: unsupportedModel.specificationVersion,\n        provider: unsupportedModel.provider,\n        modelId: unsupportedModel.modelId\n      });\n    }\n    return asEmbeddingModelV3(model);\n  }\n  return getGlobalProvider().embeddingModel(model);\n}\nfunction resolveTranscriptionModel(model) {\n  var _a21, _b;\n  if (typeof model !== \"string\") {\n    if (model.specificationVersion !== \"v3\" && model.specificationVersion !== \"v2\") {\n      const unsupportedModel = model;\n      throw new UnsupportedModelVersionError({\n        version: unsupportedModel.specificationVersion,\n        provider: unsupportedModel.provider,\n        modelId: unsupportedModel.modelId\n      });\n    }\n    return asTranscriptionModelV3(model);\n  }\n  return (_b = (_a21 = getGlobalProvider()).transcriptionModel) == null ? void 0 : _b.call(_a21, model);\n}\nfunction resolveSpeechModel(model) {\n  var _a21, _b;\n  if (typeof model !== \"string\") {\n    if (model.specificationVersion !== \"v3\" && model.specificationVersion !== \"v2\") {\n      const unsupportedModel = model;\n      throw new UnsupportedModelVersionError({\n        version: unsupportedModel.specificationVersion,\n        provider: unsupportedModel.provider,\n        modelId: unsupportedModel.modelId\n      });\n    }\n    return asSpeechModelV3(model);\n  }\n  return (_b = (_a21 = getGlobalProvider()).speechModel) == null ? void 0 : _b.call(_a21, model);\n}\nfunction resolveImageModel(model) {\n  if (typeof model !== \"string\") {\n    if (model.specificationVersion !== \"v3\" && model.specificationVersion !== \"v2\") {\n      const unsupportedModel = model;\n      throw new UnsupportedModelVersionError({\n        version: unsupportedModel.specificationVersion,\n        provider: unsupportedModel.provider,\n        modelId: unsupportedModel.modelId\n      });\n    }\n    return asImageModelV3(model);\n  }\n  return getGlobalProvider().imageModel(model);\n}\nfunction resolveVideoModel(model) {\n  if (typeof model === \"string\") {\n    const provider = getGlobalProvider();\n    const videoModel = provider.videoModel;\n    if (!videoModel) {\n      throw new Error(\n        'The default provider does not support video models. Please use a Experimental_VideoModelV3 object from a provider (e.g., vertex.video(\"model-id\")).'\n      );\n    }\n    return videoModel(model);\n  }\n  if (model.specificationVersion !== \"v3\") {\n    const unsupportedModel = model;\n    throw new UnsupportedModelVersionError({\n      version: unsupportedModel.specificationVersion,\n      provider: unsupportedModel.provider,\n      modelId: unsupportedModel.modelId\n    });\n  }\n  return model;\n}\nfunction getGlobalProvider() {\n  var _a21;\n  return (_a21 = globalThis.AI_SDK_DEFAULT_PROVIDER) != null ? _a21 : _ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__.gateway;\n}\n\n// src/prompt/call-settings.ts\nfunction getTotalTimeoutMs(timeout) {\n  if (timeout == null) {\n    return void 0;\n  }\n  if (typeof timeout === \"number\") {\n    return timeout;\n  }\n  return timeout.totalMs;\n}\nfunction getStepTimeoutMs(timeout) {\n  if (timeout == null || typeof timeout === \"number\") {\n    return void 0;\n  }\n  return timeout.stepMs;\n}\nfunction getChunkTimeoutMs(timeout) {\n  if (timeout == null || typeof timeout === \"number\") {\n    return void 0;\n  }\n  return timeout.chunkMs;\n}\n\n// src/prompt/convert-to-language-model-prompt.ts\n\n\n// src/util/detect-media-type.ts\n\nvar imageMediaTypeSignatures = [\n  {\n    mediaType: \"image/gif\",\n    bytesPrefix: [71, 73, 70]\n    // GIF\n  },\n  {\n    mediaType: \"image/png\",\n    bytesPrefix: [137, 80, 78, 71]\n    // PNG\n  },\n  {\n    mediaType: \"image/jpeg\",\n    bytesPrefix: [255, 216]\n    // JPEG\n  },\n  {\n    mediaType: \"image/webp\",\n    bytesPrefix: [\n      82,\n      73,\n      70,\n      70,\n      // \"RIFF\"\n      null,\n      null,\n      null,\n      null,\n      // file size (variable)\n      87,\n      69,\n      66,\n      80\n      // \"WEBP\"\n    ]\n  },\n  {\n    mediaType: \"image/bmp\",\n    bytesPrefix: [66, 77]\n  },\n  {\n    mediaType: \"image/tiff\",\n    bytesPrefix: [73, 73, 42, 0]\n  },\n  {\n    mediaType: \"image/tiff\",\n    bytesPrefix: [77, 77, 0, 42]\n  },\n  {\n    mediaType: \"image/avif\",\n    bytesPrefix: [\n      0,\n      0,\n      0,\n      32,\n      102,\n      116,\n      121,\n      112,\n      97,\n      118,\n      105,\n      102\n    ]\n  },\n  {\n    mediaType: \"image/heic\",\n    bytesPrefix: [\n      0,\n      0,\n      0,\n      32,\n      102,\n      116,\n      121,\n      112,\n      104,\n      101,\n      105,\n      99\n    ]\n  }\n];\nvar audioMediaTypeSignatures = [\n  {\n    mediaType: \"audio/mpeg\",\n    bytesPrefix: [255, 251]\n  },\n  {\n    mediaType: \"audio/mpeg\",\n    bytesPrefix: [255, 250]\n  },\n  {\n    mediaType: \"audio/mpeg\",\n    bytesPrefix: [255, 243]\n  },\n  {\n    mediaType: \"audio/mpeg\",\n    bytesPrefix: [255, 242]\n  },\n  {\n    mediaType: \"audio/mpeg\",\n    bytesPrefix: [255, 227]\n  },\n  {\n    mediaType: \"audio/mpeg\",\n    bytesPrefix: [255, 226]\n  },\n  {\n    mediaType: \"audio/wav\",\n    bytesPrefix: [\n      82,\n      // R\n      73,\n      // I\n      70,\n      // F\n      70,\n      // F\n      null,\n      null,\n      null,\n      null,\n      87,\n      // W\n      65,\n      // A\n      86,\n      // V\n      69\n      // E\n    ]\n  },\n  {\n    mediaType: \"audio/ogg\",\n    bytesPrefix: [79, 103, 103, 83]\n  },\n  {\n    mediaType: \"audio/flac\",\n    bytesPrefix: [102, 76, 97, 67]\n  },\n  {\n    mediaType: \"audio/aac\",\n    bytesPrefix: [64, 21, 0, 0]\n  },\n  {\n    mediaType: \"audio/mp4\",\n    bytesPrefix: [102, 116, 121, 112]\n  },\n  {\n    mediaType: \"audio/webm\",\n    bytesPrefix: [26, 69, 223, 163]\n  }\n];\nvar videoMediaTypeSignatures = [\n  {\n    mediaType: \"video/mp4\",\n    bytesPrefix: [\n      0,\n      0,\n      0,\n      null,\n      102,\n      116,\n      121,\n      112\n      // ftyp\n    ]\n  },\n  {\n    mediaType: \"video/webm\",\n    bytesPrefix: [26, 69, 223, 163]\n    // EBML\n  },\n  {\n    mediaType: \"video/quicktime\",\n    bytesPrefix: [\n      0,\n      0,\n      0,\n      20,\n      102,\n      116,\n      121,\n      112,\n      113,\n      116\n      // ftypqt\n    ]\n  },\n  {\n    mediaType: \"video/x-msvideo\",\n    bytesPrefix: [82, 73, 70, 70]\n    // RIFF (AVI)\n  }\n];\nvar stripID3 = (data) => {\n  const bytes = typeof data === \"string\" ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(data) : data;\n  const id3Size = (bytes[6] & 127) << 21 | (bytes[7] & 127) << 14 | (bytes[8] & 127) << 7 | bytes[9] & 127;\n  return bytes.slice(id3Size + 10);\n};\nfunction stripID3TagsIfPresent(data) {\n  const hasId3 = typeof data === \"string\" && data.startsWith(\"SUQz\") || typeof data !== \"string\" && data.length > 10 && data[0] === 73 && // 'I'\n  data[1] === 68 && // 'D'\n  data[2] === 51;\n  return hasId3 ? stripID3(data) : data;\n}\nfunction detectMediaType({\n  data,\n  signatures\n}) {\n  const processedData = stripID3TagsIfPresent(data);\n  const bytes = typeof processedData === \"string\" ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(\n    processedData.substring(0, Math.min(processedData.length, 24))\n  ) : processedData;\n  for (const signature of signatures) {\n    if (bytes.length >= signature.bytesPrefix.length && signature.bytesPrefix.every(\n      (byte, index) => byte === null || bytes[index] === byte\n    )) {\n      return signature.mediaType;\n    }\n  }\n  return void 0;\n}\n\n// src/util/download/download.ts\n\n\n\n// src/version.ts\nvar VERSION =  true ? \"6.0.97\" : 0;\n\n// src/util/download/download.ts\nvar download = async ({\n  url,\n  maxBytes,\n  abortSignal\n}) => {\n  var _a21;\n  const urlText = url.toString();\n  try {\n    const response = await fetch(urlText, {\n      headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(\n        {},\n        `ai-sdk/${VERSION}`,\n        (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getRuntimeEnvironmentUserAgent)()\n      ),\n      signal: abortSignal\n    });\n    if (!response.ok) {\n      throw new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DownloadError({\n        url: urlText,\n        statusCode: response.status,\n        statusText: response.statusText\n      });\n    }\n    const data = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.readResponseWithSizeLimit)({\n      response,\n      url: urlText,\n      maxBytes: maxBytes != null ? maxBytes : _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_MAX_DOWNLOAD_SIZE\n    });\n    return {\n      data,\n      mediaType: (_a21 = response.headers.get(\"content-type\")) != null ? _a21 : void 0\n    };\n  } catch (error) {\n    if (_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DownloadError.isInstance(error)) {\n      throw error;\n    }\n    throw new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DownloadError({ url: urlText, cause: error });\n  }\n};\n\n// src/util/download/download-function.ts\nvar createDefaultDownloadFunction = (download2 = download) => (requestedDownloads) => Promise.all(\n  requestedDownloads.map(\n    async (requestedDownload) => requestedDownload.isUrlSupportedByModel ? null : download2(requestedDownload)\n  )\n);\n\n// src/prompt/data-content.ts\n\n\n\n\n// src/prompt/split-data-url.ts\nfunction splitDataUrl(dataUrl) {\n  try {\n    const [header, base64Content] = dataUrl.split(\",\");\n    return {\n      mediaType: header.split(\";\")[0].split(\":\")[1],\n      base64Content\n    };\n  } catch (error) {\n    return {\n      mediaType: void 0,\n      base64Content: void 0\n    };\n  }\n}\n\n// src/prompt/data-content.ts\nvar dataContentSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"instanceof\"](Uint8Array),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"instanceof\"](ArrayBuffer),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.custom(\n    // Buffer might not be available in some environments such as CloudFlare:\n    (value) => {\n      var _a21, _b;\n      return (_b = (_a21 = globalThis.Buffer) == null ? void 0 : _a21.isBuffer(value)) != null ? _b : false;\n    },\n    { message: \"Must be a Buffer\" }\n  )\n]);\nfunction convertToLanguageModelV3DataContent(content) {\n  if (content instanceof Uint8Array) {\n    return { data: content, mediaType: void 0 };\n  }\n  if (content instanceof ArrayBuffer) {\n    return { data: new Uint8Array(content), mediaType: void 0 };\n  }\n  if (typeof content === \"string\") {\n    try {\n      content = new URL(content);\n    } catch (error) {\n    }\n  }\n  if (content instanceof URL && content.protocol === \"data:\") {\n    const { mediaType: dataUrlMediaType, base64Content } = splitDataUrl(\n      content.toString()\n    );\n    if (dataUrlMediaType == null || base64Content == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError({\n        name: \"InvalidDataContentError\",\n        message: `Invalid data URL format in content ${content.toString()}`\n      });\n    }\n    return { data: base64Content, mediaType: dataUrlMediaType };\n  }\n  return { data: content, mediaType: void 0 };\n}\nfunction convertDataContentToBase64String(content) {\n  if (typeof content === \"string\") {\n    return content;\n  }\n  if (content instanceof ArrayBuffer) {\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertUint8ArrayToBase64)(new Uint8Array(content));\n  }\n  return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertUint8ArrayToBase64)(content);\n}\nfunction convertDataContentToUint8Array(content) {\n  if (content instanceof Uint8Array) {\n    return content;\n  }\n  if (typeof content === \"string\") {\n    try {\n      return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(content);\n    } catch (error) {\n      throw new InvalidDataContentError({\n        message: \"Invalid data content. Content string is not a base64-encoded media.\",\n        content,\n        cause: error\n      });\n    }\n  }\n  if (content instanceof ArrayBuffer) {\n    return new Uint8Array(content);\n  }\n  throw new InvalidDataContentError({ content });\n}\n\n// src/util/as-array.ts\nfunction asArray(value) {\n  return value === void 0 ? [] : Array.isArray(value) ? value : [value];\n}\n\n// src/prompt/convert-to-language-model-prompt.ts\nasync function convertToLanguageModelPrompt({\n  prompt,\n  supportedUrls,\n  download: download2 = createDefaultDownloadFunction()\n}) {\n  const downloadedAssets = await downloadAssets(\n    prompt.messages,\n    download2,\n    supportedUrls\n  );\n  const approvalIdToToolCallId = /* @__PURE__ */ new Map();\n  for (const message of prompt.messages) {\n    if (message.role === \"assistant\" && Array.isArray(message.content)) {\n      for (const part of message.content) {\n        if (part.type === \"tool-approval-request\" && \"approvalId\" in part && \"toolCallId\" in part) {\n          approvalIdToToolCallId.set(\n            part.approvalId,\n            part.toolCallId\n          );\n        }\n      }\n    }\n  }\n  const approvedToolCallIds = /* @__PURE__ */ new Set();\n  for (const message of prompt.messages) {\n    if (message.role === \"tool\") {\n      for (const part of message.content) {\n        if (part.type === \"tool-approval-response\") {\n          const toolCallId = approvalIdToToolCallId.get(part.approvalId);\n          if (toolCallId) {\n            approvedToolCallIds.add(toolCallId);\n          }\n        }\n      }\n    }\n  }\n  const messages = [\n    ...prompt.system != null ? typeof prompt.system === \"string\" ? [{ role: \"system\", content: prompt.system }] : asArray(prompt.system).map((message) => ({\n      role: \"system\",\n      content: message.content,\n      providerOptions: message.providerOptions\n    })) : [],\n    ...prompt.messages.map(\n      (message) => convertToLanguageModelMessage({ message, downloadedAssets })\n    )\n  ];\n  const combinedMessages = [];\n  for (const message of messages) {\n    if (message.role !== \"tool\") {\n      combinedMessages.push(message);\n      continue;\n    }\n    const lastCombinedMessage = combinedMessages.at(-1);\n    if ((lastCombinedMessage == null ? void 0 : lastCombinedMessage.role) === \"tool\") {\n      lastCombinedMessage.content.push(...message.content);\n    } else {\n      combinedMessages.push(message);\n    }\n  }\n  const toolCallIds = /* @__PURE__ */ new Set();\n  for (const message of combinedMessages) {\n    switch (message.role) {\n      case \"assistant\": {\n        for (const content of message.content) {\n          if (content.type === \"tool-call\" && !content.providerExecuted) {\n            toolCallIds.add(content.toolCallId);\n          }\n        }\n        break;\n      }\n      case \"tool\": {\n        for (const content of message.content) {\n          if (content.type === \"tool-result\") {\n            toolCallIds.delete(content.toolCallId);\n          }\n        }\n        break;\n      }\n      case \"user\":\n      case \"system\":\n        for (const id of approvedToolCallIds) {\n          toolCallIds.delete(id);\n        }\n        if (toolCallIds.size > 0) {\n          throw new MissingToolResultsError({\n            toolCallIds: Array.from(toolCallIds)\n          });\n        }\n        break;\n    }\n  }\n  for (const id of approvedToolCallIds) {\n    toolCallIds.delete(id);\n  }\n  if (toolCallIds.size > 0) {\n    throw new MissingToolResultsError({ toolCallIds: Array.from(toolCallIds) });\n  }\n  return combinedMessages.filter(\n    // Filter out empty tool messages (e.g. if they only contained\n    // tool-approval-response parts that were removed).\n    // This prevents sending invalid empty messages to the provider.\n    // Note: provider-executed tool-approval-response parts are preserved.\n    (message) => message.role !== \"tool\" || message.content.length > 0\n  );\n}\nfunction convertToLanguageModelMessage({\n  message,\n  downloadedAssets\n}) {\n  const role = message.role;\n  switch (role) {\n    case \"system\": {\n      return {\n        role: \"system\",\n        content: message.content,\n        providerOptions: message.providerOptions\n      };\n    }\n    case \"user\": {\n      if (typeof message.content === \"string\") {\n        return {\n          role: \"user\",\n          content: [{ type: \"text\", text: message.content }],\n          providerOptions: message.providerOptions\n        };\n      }\n      return {\n        role: \"user\",\n        content: message.content.map((part) => convertPartToLanguageModelPart(part, downloadedAssets)).filter((part) => part.type !== \"text\" || part.text !== \"\"),\n        providerOptions: message.providerOptions\n      };\n    }\n    case \"assistant\": {\n      if (typeof message.content === \"string\") {\n        return {\n          role: \"assistant\",\n          content: [{ type: \"text\", text: message.content }],\n          providerOptions: message.providerOptions\n        };\n      }\n      return {\n        role: \"assistant\",\n        content: message.content.filter(\n          // remove empty text parts (no text, and no provider options):\n          (part) => part.type !== \"text\" || part.text !== \"\" || part.providerOptions != null\n        ).filter(\n          (part) => part.type !== \"tool-approval-request\"\n        ).map((part) => {\n          const providerOptions = part.providerOptions;\n          switch (part.type) {\n            case \"file\": {\n              const { data, mediaType } = convertToLanguageModelV3DataContent(\n                part.data\n              );\n              return {\n                type: \"file\",\n                data,\n                filename: part.filename,\n                mediaType: mediaType != null ? mediaType : part.mediaType,\n                providerOptions\n              };\n            }\n            case \"reasoning\": {\n              return {\n                type: \"reasoning\",\n                text: part.text,\n                providerOptions\n              };\n            }\n            case \"text\": {\n              return {\n                type: \"text\",\n                text: part.text,\n                providerOptions\n              };\n            }\n            case \"tool-call\": {\n              return {\n                type: \"tool-call\",\n                toolCallId: part.toolCallId,\n                toolName: part.toolName,\n                input: part.input,\n                providerExecuted: part.providerExecuted,\n                providerOptions\n              };\n            }\n            case \"tool-result\": {\n              return {\n                type: \"tool-result\",\n                toolCallId: part.toolCallId,\n                toolName: part.toolName,\n                output: mapToolResultOutput(part.output),\n                providerOptions\n              };\n            }\n          }\n        }),\n        providerOptions: message.providerOptions\n      };\n    }\n    case \"tool\": {\n      return {\n        role: \"tool\",\n        content: message.content.filter(\n          // Only include tool-approval-response for provider-executed tools\n          (part) => part.type !== \"tool-approval-response\" || part.providerExecuted\n        ).map((part) => {\n          switch (part.type) {\n            case \"tool-result\": {\n              return {\n                type: \"tool-result\",\n                toolCallId: part.toolCallId,\n                toolName: part.toolName,\n                output: mapToolResultOutput(part.output),\n                providerOptions: part.providerOptions\n              };\n            }\n            case \"tool-approval-response\": {\n              return {\n                type: \"tool-approval-response\",\n                approvalId: part.approvalId,\n                approved: part.approved,\n                reason: part.reason\n              };\n            }\n          }\n        }),\n        providerOptions: message.providerOptions\n      };\n    }\n    default: {\n      const _exhaustiveCheck = role;\n      throw new InvalidMessageRoleError({ role: _exhaustiveCheck });\n    }\n  }\n}\nasync function downloadAssets(messages, download2, supportedUrls) {\n  const plannedDownloads = messages.filter((message) => message.role === \"user\").map((message) => message.content).filter(\n    (content) => Array.isArray(content)\n  ).flat().filter(\n    (part) => part.type === \"image\" || part.type === \"file\"\n  ).map((part) => {\n    var _a21;\n    const mediaType = (_a21 = part.mediaType) != null ? _a21 : part.type === \"image\" ? \"image/*\" : void 0;\n    let data = part.type === \"image\" ? part.image : part.data;\n    if (typeof data === \"string\") {\n      try {\n        data = new URL(data);\n      } catch (ignored) {\n      }\n    }\n    return { mediaType, data };\n  }).filter(\n    (part) => part.data instanceof URL\n  ).map((part) => ({\n    url: part.data,\n    isUrlSupportedByModel: part.mediaType != null && (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.isUrlSupported)({\n      url: part.data.toString(),\n      mediaType: part.mediaType,\n      supportedUrls\n    })\n  }));\n  const downloadedFiles = await download2(plannedDownloads);\n  return Object.fromEntries(\n    downloadedFiles.map(\n      (file, index) => file == null ? null : [\n        plannedDownloads[index].url.toString(),\n        { data: file.data, mediaType: file.mediaType }\n      ]\n    ).filter((file) => file != null)\n  );\n}\nfunction convertPartToLanguageModelPart(part, downloadedAssets) {\n  var _a21;\n  if (part.type === \"text\") {\n    return {\n      type: \"text\",\n      text: part.text,\n      providerOptions: part.providerOptions\n    };\n  }\n  let originalData;\n  const type = part.type;\n  switch (type) {\n    case \"image\":\n      originalData = part.image;\n      break;\n    case \"file\":\n      originalData = part.data;\n      break;\n    default:\n      throw new Error(`Unsupported part type: ${type}`);\n  }\n  const { data: convertedData, mediaType: convertedMediaType } = convertToLanguageModelV3DataContent(originalData);\n  let mediaType = convertedMediaType != null ? convertedMediaType : part.mediaType;\n  let data = convertedData;\n  if (data instanceof URL) {\n    const downloadedFile = downloadedAssets[data.toString()];\n    if (downloadedFile) {\n      data = downloadedFile.data;\n      mediaType != null ? mediaType : mediaType = downloadedFile.mediaType;\n    }\n  }\n  switch (type) {\n    case \"image\": {\n      if (data instanceof Uint8Array || typeof data === \"string\") {\n        mediaType = (_a21 = detectMediaType({ data, signatures: imageMediaTypeSignatures })) != null ? _a21 : mediaType;\n      }\n      return {\n        type: \"file\",\n        mediaType: mediaType != null ? mediaType : \"image/*\",\n        // any image\n        filename: void 0,\n        data,\n        providerOptions: part.providerOptions\n      };\n    }\n    case \"file\": {\n      if (mediaType == null) {\n        throw new Error(`Media type is missing for file part`);\n      }\n      return {\n        type: \"file\",\n        mediaType,\n        filename: part.filename,\n        data,\n        providerOptions: part.providerOptions\n      };\n    }\n  }\n}\nfunction mapToolResultOutput(output) {\n  if (output.type !== \"content\") {\n    return output;\n  }\n  return {\n    type: \"content\",\n    value: output.value.map((item) => {\n      if (item.type !== \"media\") {\n        return item;\n      }\n      if (item.mediaType.startsWith(\"image/\")) {\n        return {\n          type: \"image-data\",\n          data: item.data,\n          mediaType: item.mediaType\n        };\n      }\n      return {\n        type: \"file-data\",\n        data: item.data,\n        mediaType: item.mediaType\n      };\n    })\n  };\n}\n\n// src/prompt/create-tool-model-output.ts\n\nasync function createToolModelOutput({\n  toolCallId,\n  input,\n  output,\n  tool: tool2,\n  errorMode\n}) {\n  if (errorMode === \"text\") {\n    return { type: \"error-text\", value: (0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(output) };\n  } else if (errorMode === \"json\") {\n    return { type: \"error-json\", value: toJSONValue(output) };\n  }\n  if (tool2 == null ? void 0 : tool2.toModelOutput) {\n    return await tool2.toModelOutput({ toolCallId, input, output });\n  }\n  return typeof output === \"string\" ? { type: \"text\", value: output } : { type: \"json\", value: toJSONValue(output) };\n}\nfunction toJSONValue(value) {\n  return value === void 0 ? null : value;\n}\n\n// src/prompt/prepare-call-settings.ts\nfunction prepareCallSettings({\n  maxOutputTokens,\n  temperature,\n  topP,\n  topK,\n  presencePenalty,\n  frequencyPenalty,\n  seed,\n  stopSequences\n}) {\n  if (maxOutputTokens != null) {\n    if (!Number.isInteger(maxOutputTokens)) {\n      throw new InvalidArgumentError({\n        parameter: \"maxOutputTokens\",\n        value: maxOutputTokens,\n        message: \"maxOutputTokens must be an integer\"\n      });\n    }\n    if (maxOutputTokens < 1) {\n      throw new InvalidArgumentError({\n        parameter: \"maxOutputTokens\",\n        value: maxOutputTokens,\n        message: \"maxOutputTokens must be >= 1\"\n      });\n    }\n  }\n  if (temperature != null) {\n    if (typeof temperature !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"temperature\",\n        value: temperature,\n        message: \"temperature must be a number\"\n      });\n    }\n  }\n  if (topP != null) {\n    if (typeof topP !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"topP\",\n        value: topP,\n        message: \"topP must be a number\"\n      });\n    }\n  }\n  if (topK != null) {\n    if (typeof topK !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"topK\",\n        value: topK,\n        message: \"topK must be a number\"\n      });\n    }\n  }\n  if (presencePenalty != null) {\n    if (typeof presencePenalty !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"presencePenalty\",\n        value: presencePenalty,\n        message: \"presencePenalty must be a number\"\n      });\n    }\n  }\n  if (frequencyPenalty != null) {\n    if (typeof frequencyPenalty !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"frequencyPenalty\",\n        value: frequencyPenalty,\n        message: \"frequencyPenalty must be a number\"\n      });\n    }\n  }\n  if (seed != null) {\n    if (!Number.isInteger(seed)) {\n      throw new InvalidArgumentError({\n        parameter: \"seed\",\n        value: seed,\n        message: \"seed must be an integer\"\n      });\n    }\n  }\n  return {\n    maxOutputTokens,\n    temperature,\n    topP,\n    topK,\n    presencePenalty,\n    frequencyPenalty,\n    stopSequences,\n    seed\n  };\n}\n\n// src/prompt/prepare-tools-and-tool-choice.ts\n\n\n// src/util/is-non-empty-object.ts\nfunction isNonEmptyObject(object2) {\n  return object2 != null && Object.keys(object2).length > 0;\n}\n\n// src/prompt/prepare-tools-and-tool-choice.ts\nasync function prepareToolsAndToolChoice({\n  tools,\n  toolChoice,\n  activeTools\n}) {\n  if (!isNonEmptyObject(tools)) {\n    return {\n      tools: void 0,\n      toolChoice: void 0\n    };\n  }\n  const filteredTools = activeTools != null ? Object.entries(tools).filter(\n    ([name21]) => activeTools.includes(name21)\n  ) : Object.entries(tools);\n  const languageModelTools = [];\n  for (const [name21, tool2] of filteredTools) {\n    const toolType = tool2.type;\n    switch (toolType) {\n      case void 0:\n      case \"dynamic\":\n      case \"function\":\n        languageModelTools.push({\n          type: \"function\",\n          name: name21,\n          description: tool2.description,\n          inputSchema: await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(tool2.inputSchema).jsonSchema,\n          ...tool2.inputExamples != null ? { inputExamples: tool2.inputExamples } : {},\n          providerOptions: tool2.providerOptions,\n          ...tool2.strict != null ? { strict: tool2.strict } : {}\n        });\n        break;\n      case \"provider\":\n        languageModelTools.push({\n          type: \"provider\",\n          name: name21,\n          id: tool2.id,\n          args: tool2.args\n        });\n        break;\n      default: {\n        const exhaustiveCheck = toolType;\n        throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);\n      }\n    }\n  }\n  return {\n    tools: languageModelTools,\n    toolChoice: toolChoice == null ? { type: \"auto\" } : typeof toolChoice === \"string\" ? { type: toolChoice } : { type: \"tool\", toolName: toolChoice.toolName }\n  };\n}\n\n// src/prompt/standardize-prompt.ts\n\n\n\n\n// src/prompt/message.ts\n\n\n// src/types/provider-metadata.ts\n\n\n// src/types/json-value.ts\n\nvar jsonValueSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.lazy(\n  () => zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"null\"](),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.number(),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean(),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.record(zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(), jsonValueSchema.optional()),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(jsonValueSchema)\n  ])\n);\n\n// src/types/provider-metadata.ts\nvar providerMetadataSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.record(\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.record(zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(), jsonValueSchema.optional())\n);\n\n// src/prompt/content-part.ts\n\nvar textPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"text\"),\n  text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar imagePartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"image\"),\n  image: zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([dataContentSchema, zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"instanceof\"](URL)]),\n  mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar filePartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"file\"),\n  data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([dataContentSchema, zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"instanceof\"](URL)]),\n  filename: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n  mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar reasoningPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"reasoning\"),\n  text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar toolCallPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-call\"),\n  toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n  providerOptions: providerMetadataSchema.optional(),\n  providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional()\n});\nvar outputSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.discriminatedUnion(\n  \"type\",\n  [\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n      type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"text\"),\n      value: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n      providerOptions: providerMetadataSchema.optional()\n    }),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n      type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"json\"),\n      value: jsonValueSchema,\n      providerOptions: providerMetadataSchema.optional()\n    }),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n      type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"execution-denied\"),\n      reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n      providerOptions: providerMetadataSchema.optional()\n    }),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n      type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"error-text\"),\n      value: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n      providerOptions: providerMetadataSchema.optional()\n    }),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n      type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"error-json\"),\n      value: jsonValueSchema,\n      providerOptions: providerMetadataSchema.optional()\n    }),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n      type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"content\"),\n      value: zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n          zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"text\"),\n            text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            providerOptions: providerMetadataSchema.optional()\n          }),\n          zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"media\"),\n            data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n          }),\n          zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"file-data\"),\n            data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            filename: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n            providerOptions: providerMetadataSchema.optional()\n          }),\n          zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"file-url\"),\n            url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            providerOptions: providerMetadataSchema.optional()\n          }),\n          zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"file-id\"),\n            fileId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(), zod_v4__WEBPACK_IMPORTED_MODULE_3__.record(zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(), zod_v4__WEBPACK_IMPORTED_MODULE_3__.string())]),\n            providerOptions: providerMetadataSchema.optional()\n          }),\n          zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"image-data\"),\n            data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            providerOptions: providerMetadataSchema.optional()\n          }),\n          zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"image-url\"),\n            url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            providerOptions: providerMetadataSchema.optional()\n          }),\n          zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"image-file-id\"),\n            fileId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(), zod_v4__WEBPACK_IMPORTED_MODULE_3__.record(zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(), zod_v4__WEBPACK_IMPORTED_MODULE_3__.string())]),\n            providerOptions: providerMetadataSchema.optional()\n          }),\n          zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"custom\"),\n            providerOptions: providerMetadataSchema.optional()\n          })\n        ])\n      )\n    })\n  ]\n);\nvar toolResultPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-result\"),\n  toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  output: outputSchema,\n  providerOptions: providerMetadataSchema.optional()\n});\nvar toolApprovalRequestSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-approval-request\"),\n  approvalId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n});\nvar toolApprovalResponseSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-approval-response\"),\n  approvalId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean(),\n  reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional()\n});\n\n// src/prompt/message.ts\nvar systemModelMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object(\n  {\n    role: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"system\"),\n    content: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    providerOptions: providerMetadataSchema.optional()\n  }\n);\nvar userModelMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  role: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"user\"),\n  content: zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([textPartSchema, imagePartSchema, filePartSchema]))\n  ]),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar assistantModelMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  role: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"assistant\"),\n  content: zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n        textPartSchema,\n        filePartSchema,\n        reasoningPartSchema,\n        toolCallPartSchema,\n        toolResultPartSchema,\n        toolApprovalRequestSchema\n      ])\n    )\n  ]),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar toolModelMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  role: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool\"),\n  content: zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([toolResultPartSchema, toolApprovalResponseSchema])),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar modelMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n  systemModelMessageSchema,\n  userModelMessageSchema,\n  assistantModelMessageSchema,\n  toolModelMessageSchema\n]);\n\n// src/prompt/standardize-prompt.ts\nasync function standardizePrompt(prompt) {\n  if (prompt.prompt == null && prompt.messages == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"prompt or messages must be defined\"\n    });\n  }\n  if (prompt.prompt != null && prompt.messages != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"prompt and messages cannot be defined at the same time\"\n    });\n  }\n  if (prompt.system != null && typeof prompt.system !== \"string\" && !asArray(prompt.system).every(\n    (message) => typeof message === \"object\" && message !== null && \"role\" in message && message.role === \"system\"\n  )) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"system must be a string, SystemModelMessage, or array of SystemModelMessage\"\n    });\n  }\n  let messages;\n  if (prompt.prompt != null && typeof prompt.prompt === \"string\") {\n    messages = [{ role: \"user\", content: prompt.prompt }];\n  } else if (prompt.prompt != null && Array.isArray(prompt.prompt)) {\n    messages = prompt.prompt;\n  } else if (prompt.messages != null) {\n    messages = prompt.messages;\n  } else {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"prompt or messages must be defined\"\n    });\n  }\n  if (messages.length === 0) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"messages must not be empty\"\n    });\n  }\n  const validationResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n    value: messages,\n    schema: zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(modelMessageSchema)\n  });\n  if (!validationResult.success) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"The messages do not match the ModelMessage[] schema.\",\n      cause: validationResult.error\n    });\n  }\n  return {\n    messages,\n    system: prompt.system\n  };\n}\n\n// src/prompt/wrap-gateway-error.ts\n\n\nfunction wrapGatewayError(error) {\n  if (!_ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__.GatewayAuthenticationError.isInstance(error))\n    return error;\n  const isProductionEnv = (process == null ? void 0 : \"development\") === \"production\";\n  const moreInfoURL = \"https://ai-sdk.dev/unauthenticated-ai-gateway\";\n  if (isProductionEnv) {\n    return new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError({\n      name: \"GatewayError\",\n      message: `Unauthenticated. Configure AI_GATEWAY_API_KEY or use a provider module. Learn more: ${moreInfoURL}`\n    });\n  }\n  return Object.assign(\n    new Error(`\\x1B[1m\\x1B[31mUnauthenticated request to AI Gateway.\\x1B[0m\n\nTo authenticate, set the \\x1B[33mAI_GATEWAY_API_KEY\\x1B[0m environment variable with your API key.\n\nAlternatively, you can use a provider module instead of the AI Gateway.\n\nLearn more: \\x1B[34m${moreInfoURL}\\x1B[0m\n\n`),\n    { name: \"GatewayAuthenticationError\" }\n  );\n}\n\n// src/telemetry/assemble-operation-name.ts\nfunction assembleOperationName({\n  operationId,\n  telemetry\n}) {\n  return {\n    // standardized operation and resource name:\n    \"operation.name\": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : \"\"}`,\n    \"resource.name\": telemetry == null ? void 0 : telemetry.functionId,\n    // detailed, AI SDK specific data:\n    \"ai.operationId\": operationId,\n    \"ai.telemetry.functionId\": telemetry == null ? void 0 : telemetry.functionId\n  };\n}\n\n// src/telemetry/get-base-telemetry-attributes.ts\nfunction getBaseTelemetryAttributes({\n  model,\n  settings,\n  telemetry,\n  headers\n}) {\n  var _a21;\n  return {\n    \"ai.model.provider\": model.provider,\n    \"ai.model.id\": model.modelId,\n    // settings:\n    ...Object.entries(settings).reduce((attributes, [key, value]) => {\n      if (key === \"timeout\") {\n        const totalTimeoutMs = getTotalTimeoutMs(\n          value\n        );\n        if (totalTimeoutMs != null) {\n          attributes[`ai.settings.${key}`] = totalTimeoutMs;\n        }\n      } else {\n        attributes[`ai.settings.${key}`] = value;\n      }\n      return attributes;\n    }, {}),\n    // add metadata as attributes:\n    ...Object.entries((_a21 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a21 : {}).reduce(\n      (attributes, [key, value]) => {\n        attributes[`ai.telemetry.metadata.${key}`] = value;\n        return attributes;\n      },\n      {}\n    ),\n    // request headers\n    ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value]) => {\n      if (value !== void 0) {\n        attributes[`ai.request.headers.${key}`] = value;\n      }\n      return attributes;\n    }, {})\n  };\n}\n\n// src/telemetry/get-tracer.ts\n\n\n// src/telemetry/noop-tracer.ts\nvar noopTracer = {\n  startSpan() {\n    return noopSpan;\n  },\n  startActiveSpan(name21, arg1, arg2, arg3) {\n    if (typeof arg1 === \"function\") {\n      return arg1(noopSpan);\n    }\n    if (typeof arg2 === \"function\") {\n      return arg2(noopSpan);\n    }\n    if (typeof arg3 === \"function\") {\n      return arg3(noopSpan);\n    }\n  }\n};\nvar noopSpan = {\n  spanContext() {\n    return noopSpanContext;\n  },\n  setAttribute() {\n    return this;\n  },\n  setAttributes() {\n    return this;\n  },\n  addEvent() {\n    return this;\n  },\n  addLink() {\n    return this;\n  },\n  addLinks() {\n    return this;\n  },\n  setStatus() {\n    return this;\n  },\n  updateName() {\n    return this;\n  },\n  end() {\n    return this;\n  },\n  isRecording() {\n    return false;\n  },\n  recordException() {\n    return this;\n  }\n};\nvar noopSpanContext = {\n  traceId: \"\",\n  spanId: \"\",\n  traceFlags: 0\n};\n\n// src/telemetry/get-tracer.ts\nfunction getTracer({\n  isEnabled = false,\n  tracer\n} = {}) {\n  if (!isEnabled) {\n    return noopTracer;\n  }\n  if (tracer) {\n    return tracer;\n  }\n  return _opentelemetry_api__WEBPACK_IMPORTED_MODULE_4__.trace.getTracer(\"ai\");\n}\n\n// src/telemetry/record-span.ts\n\nasync function recordSpan({\n  name: name21,\n  tracer,\n  attributes,\n  fn,\n  endWhenDone = true\n}) {\n  return tracer.startActiveSpan(\n    name21,\n    { attributes: await attributes },\n    async (span) => {\n      const ctx = _opentelemetry_api__WEBPACK_IMPORTED_MODULE_5__.context.active();\n      try {\n        const result = await _opentelemetry_api__WEBPACK_IMPORTED_MODULE_5__.context.with(ctx, () => fn(span));\n        if (endWhenDone) {\n          span.end();\n        }\n        return result;\n      } catch (error) {\n        try {\n          recordErrorOnSpan(span, error);\n        } finally {\n          span.end();\n        }\n        throw error;\n      }\n    }\n  );\n}\nfunction recordErrorOnSpan(span, error) {\n  if (error instanceof Error) {\n    span.recordException({\n      name: error.name,\n      message: error.message,\n      stack: error.stack\n    });\n    span.setStatus({\n      code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_6__.SpanStatusCode.ERROR,\n      message: error.message\n    });\n  } else {\n    span.setStatus({ code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_6__.SpanStatusCode.ERROR });\n  }\n}\n\n// src/telemetry/select-telemetry-attributes.ts\nasync function selectTelemetryAttributes({\n  telemetry,\n  attributes\n}) {\n  if ((telemetry == null ? void 0 : telemetry.isEnabled) !== true) {\n    return {};\n  }\n  const resultAttributes = {};\n  for (const [key, value] of Object.entries(attributes)) {\n    if (value == null) {\n      continue;\n    }\n    if (typeof value === \"object\" && \"input\" in value && typeof value.input === \"function\") {\n      if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {\n        continue;\n      }\n      const result = await value.input();\n      if (result != null) {\n        resultAttributes[key] = result;\n      }\n      continue;\n    }\n    if (typeof value === \"object\" && \"output\" in value && typeof value.output === \"function\") {\n      if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {\n        continue;\n      }\n      const result = await value.output();\n      if (result != null) {\n        resultAttributes[key] = result;\n      }\n      continue;\n    }\n    resultAttributes[key] = value;\n  }\n  return resultAttributes;\n}\n\n// src/telemetry/stringify-for-telemetry.ts\nfunction stringifyForTelemetry(prompt) {\n  return JSON.stringify(\n    prompt.map((message) => ({\n      ...message,\n      content: typeof message.content === \"string\" ? message.content : message.content.map(\n        (part) => part.type === \"file\" ? {\n          ...part,\n          data: part.data instanceof Uint8Array ? convertDataContentToBase64String(part.data) : part.data\n        } : part\n      )\n    }))\n  );\n}\n\n// src/types/usage.ts\nfunction asLanguageModelUsage(usage) {\n  return {\n    inputTokens: usage.inputTokens.total,\n    inputTokenDetails: {\n      noCacheTokens: usage.inputTokens.noCache,\n      cacheReadTokens: usage.inputTokens.cacheRead,\n      cacheWriteTokens: usage.inputTokens.cacheWrite\n    },\n    outputTokens: usage.outputTokens.total,\n    outputTokenDetails: {\n      textTokens: usage.outputTokens.text,\n      reasoningTokens: usage.outputTokens.reasoning\n    },\n    totalTokens: addTokenCounts(\n      usage.inputTokens.total,\n      usage.outputTokens.total\n    ),\n    raw: usage.raw,\n    reasoningTokens: usage.outputTokens.reasoning,\n    cachedInputTokens: usage.inputTokens.cacheRead\n  };\n}\nfunction createNullLanguageModelUsage() {\n  return {\n    inputTokens: void 0,\n    inputTokenDetails: {\n      noCacheTokens: void 0,\n      cacheReadTokens: void 0,\n      cacheWriteTokens: void 0\n    },\n    outputTokens: void 0,\n    outputTokenDetails: {\n      textTokens: void 0,\n      reasoningTokens: void 0\n    },\n    totalTokens: void 0,\n    raw: void 0\n  };\n}\nfunction addLanguageModelUsage(usage1, usage2) {\n  var _a21, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n  return {\n    inputTokens: addTokenCounts(usage1.inputTokens, usage2.inputTokens),\n    inputTokenDetails: {\n      noCacheTokens: addTokenCounts(\n        (_a21 = usage1.inputTokenDetails) == null ? void 0 : _a21.noCacheTokens,\n        (_b = usage2.inputTokenDetails) == null ? void 0 : _b.noCacheTokens\n      ),\n      cacheReadTokens: addTokenCounts(\n        (_c = usage1.inputTokenDetails) == null ? void 0 : _c.cacheReadTokens,\n        (_d = usage2.inputTokenDetails) == null ? void 0 : _d.cacheReadTokens\n      ),\n      cacheWriteTokens: addTokenCounts(\n        (_e = usage1.inputTokenDetails) == null ? void 0 : _e.cacheWriteTokens,\n        (_f = usage2.inputTokenDetails) == null ? void 0 : _f.cacheWriteTokens\n      )\n    },\n    outputTokens: addTokenCounts(usage1.outputTokens, usage2.outputTokens),\n    outputTokenDetails: {\n      textTokens: addTokenCounts(\n        (_g = usage1.outputTokenDetails) == null ? void 0 : _g.textTokens,\n        (_h = usage2.outputTokenDetails) == null ? void 0 : _h.textTokens\n      ),\n      reasoningTokens: addTokenCounts(\n        (_i = usage1.outputTokenDetails) == null ? void 0 : _i.reasoningTokens,\n        (_j = usage2.outputTokenDetails) == null ? void 0 : _j.reasoningTokens\n      )\n    },\n    totalTokens: addTokenCounts(usage1.totalTokens, usage2.totalTokens),\n    reasoningTokens: addTokenCounts(\n      usage1.reasoningTokens,\n      usage2.reasoningTokens\n    ),\n    cachedInputTokens: addTokenCounts(\n      usage1.cachedInputTokens,\n      usage2.cachedInputTokens\n    )\n  };\n}\nfunction addTokenCounts(tokenCount1, tokenCount2) {\n  return tokenCount1 == null && tokenCount2 == null ? void 0 : (tokenCount1 != null ? tokenCount1 : 0) + (tokenCount2 != null ? tokenCount2 : 0);\n}\nfunction addImageModelUsage(usage1, usage2) {\n  return {\n    inputTokens: addTokenCounts(usage1.inputTokens, usage2.inputTokens),\n    outputTokens: addTokenCounts(usage1.outputTokens, usage2.outputTokens),\n    totalTokens: addTokenCounts(usage1.totalTokens, usage2.totalTokens)\n  };\n}\n\n// src/util/merge-objects.ts\nfunction mergeObjects(base, overrides) {\n  if (base === void 0 && overrides === void 0) {\n    return void 0;\n  }\n  if (base === void 0) {\n    return overrides;\n  }\n  if (overrides === void 0) {\n    return base;\n  }\n  const result = { ...base };\n  for (const key in overrides) {\n    if (Object.prototype.hasOwnProperty.call(overrides, key)) {\n      const overridesValue = overrides[key];\n      if (overridesValue === void 0)\n        continue;\n      const baseValue = key in base ? base[key] : void 0;\n      const isSourceObject = overridesValue !== null && typeof overridesValue === \"object\" && !Array.isArray(overridesValue) && !(overridesValue instanceof Date) && !(overridesValue instanceof RegExp);\n      const isTargetObject = baseValue !== null && baseValue !== void 0 && typeof baseValue === \"object\" && !Array.isArray(baseValue) && !(baseValue instanceof Date) && !(baseValue instanceof RegExp);\n      if (isSourceObject && isTargetObject) {\n        result[key] = mergeObjects(\n          baseValue,\n          overridesValue\n        );\n      } else {\n        result[key] = overridesValue;\n      }\n    }\n  }\n  return result;\n}\n\n// src/util/retry-with-exponential-backoff.ts\n\n\nfunction getRetryDelayInMs({\n  error,\n  exponentialBackoffDelay\n}) {\n  const headers = error.responseHeaders;\n  if (!headers)\n    return exponentialBackoffDelay;\n  let ms;\n  const retryAfterMs = headers[\"retry-after-ms\"];\n  if (retryAfterMs) {\n    const timeoutMs = parseFloat(retryAfterMs);\n    if (!Number.isNaN(timeoutMs)) {\n      ms = timeoutMs;\n    }\n  }\n  const retryAfter = headers[\"retry-after\"];\n  if (retryAfter && ms === void 0) {\n    const timeoutSeconds = parseFloat(retryAfter);\n    if (!Number.isNaN(timeoutSeconds)) {\n      ms = timeoutSeconds * 1e3;\n    } else {\n      ms = Date.parse(retryAfter) - Date.now();\n    }\n  }\n  if (ms != null && !Number.isNaN(ms) && 0 <= ms && (ms < 60 * 1e3 || ms < exponentialBackoffDelay)) {\n    return ms;\n  }\n  return exponentialBackoffDelay;\n}\nvar retryWithExponentialBackoffRespectingRetryHeaders = ({\n  maxRetries = 2,\n  initialDelayInMs = 2e3,\n  backoffFactor = 2,\n  abortSignal\n} = {}) => async (f) => _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs: initialDelayInMs,\n  backoffFactor,\n  abortSignal\n});\nasync function _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs,\n  backoffFactor,\n  abortSignal\n}, errors = []) {\n  try {\n    return await f();\n  } catch (error) {\n    if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.isAbortError)(error)) {\n      throw error;\n    }\n    if (maxRetries === 0) {\n      throw error;\n    }\n    const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getErrorMessage)(error);\n    const newErrors = [...errors, error];\n    const tryNumber = newErrors.length;\n    if (tryNumber > maxRetries) {\n      throw new RetryError({\n        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n        reason: \"maxRetriesExceeded\",\n        errors: newErrors\n      });\n    }\n    if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError.isInstance(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n      await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.delay)(\n        getRetryDelayInMs({\n          error,\n          exponentialBackoffDelay: delayInMs\n        }),\n        { abortSignal }\n      );\n      return _retryWithExponentialBackoff(\n        f,\n        {\n          maxRetries,\n          delayInMs: backoffFactor * delayInMs,\n          backoffFactor,\n          abortSignal\n        },\n        newErrors\n      );\n    }\n    if (tryNumber === 1) {\n      throw error;\n    }\n    throw new RetryError({\n      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n      reason: \"errorNotRetryable\",\n      errors: newErrors\n    });\n  }\n}\n\n// src/util/prepare-retries.ts\nfunction prepareRetries({\n  maxRetries,\n  abortSignal\n}) {\n  if (maxRetries != null) {\n    if (!Number.isInteger(maxRetries)) {\n      throw new InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be an integer\"\n      });\n    }\n    if (maxRetries < 0) {\n      throw new InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be >= 0\"\n      });\n    }\n  }\n  const maxRetriesResult = maxRetries != null ? maxRetries : 2;\n  return {\n    maxRetries: maxRetriesResult,\n    retry: retryWithExponentialBackoffRespectingRetryHeaders({\n      maxRetries: maxRetriesResult,\n      abortSignal\n    })\n  };\n}\n\n// src/generate-text/collect-tool-approvals.ts\nfunction collectToolApprovals({\n  messages\n}) {\n  const lastMessage = messages.at(-1);\n  if ((lastMessage == null ? void 0 : lastMessage.role) != \"tool\") {\n    return {\n      approvedToolApprovals: [],\n      deniedToolApprovals: []\n    };\n  }\n  const toolCallsByToolCallId = {};\n  for (const message of messages) {\n    if (message.role === \"assistant\" && typeof message.content !== \"string\") {\n      const content = message.content;\n      for (const part of content) {\n        if (part.type === \"tool-call\") {\n          toolCallsByToolCallId[part.toolCallId] = part;\n        }\n      }\n    }\n  }\n  const toolApprovalRequestsByApprovalId = {};\n  for (const message of messages) {\n    if (message.role === \"assistant\" && typeof message.content !== \"string\") {\n      const content = message.content;\n      for (const part of content) {\n        if (part.type === \"tool-approval-request\") {\n          toolApprovalRequestsByApprovalId[part.approvalId] = part;\n        }\n      }\n    }\n  }\n  const toolResults = {};\n  for (const part of lastMessage.content) {\n    if (part.type === \"tool-result\") {\n      toolResults[part.toolCallId] = part;\n    }\n  }\n  const approvedToolApprovals = [];\n  const deniedToolApprovals = [];\n  const approvalResponses = lastMessage.content.filter(\n    (part) => part.type === \"tool-approval-response\"\n  );\n  for (const approvalResponse of approvalResponses) {\n    const approvalRequest = toolApprovalRequestsByApprovalId[approvalResponse.approvalId];\n    if (approvalRequest == null) {\n      throw new InvalidToolApprovalError({\n        approvalId: approvalResponse.approvalId\n      });\n    }\n    if (toolResults[approvalRequest.toolCallId] != null) {\n      continue;\n    }\n    const toolCall = toolCallsByToolCallId[approvalRequest.toolCallId];\n    if (toolCall == null) {\n      throw new ToolCallNotFoundForApprovalError({\n        toolCallId: approvalRequest.toolCallId,\n        approvalId: approvalRequest.approvalId\n      });\n    }\n    const approval = {\n      approvalRequest,\n      approvalResponse,\n      toolCall\n    };\n    if (approvalResponse.approved) {\n      approvedToolApprovals.push(approval);\n    } else {\n      deniedToolApprovals.push(approval);\n    }\n  }\n  return { approvedToolApprovals, deniedToolApprovals };\n}\n\n// src/generate-text/execute-tool-call.ts\n\n\n// src/util/now.ts\nfunction now() {\n  var _a21, _b;\n  return (_b = (_a21 = globalThis == null ? void 0 : globalThis.performance) == null ? void 0 : _a21.now()) != null ? _b : Date.now();\n}\n\n// src/generate-text/execute-tool-call.ts\nasync function executeToolCall({\n  toolCall,\n  tools,\n  tracer,\n  telemetry,\n  messages,\n  abortSignal,\n  experimental_context,\n  stepNumber,\n  model,\n  onPreliminaryToolResult,\n  onToolCallStart,\n  onToolCallFinish\n}) {\n  const { toolName, toolCallId, input } = toolCall;\n  const tool2 = tools == null ? void 0 : tools[toolName];\n  if ((tool2 == null ? void 0 : tool2.execute) == null) {\n    return void 0;\n  }\n  const baseCallbackEvent = {\n    stepNumber,\n    model,\n    toolCall,\n    messages,\n    abortSignal,\n    functionId: telemetry == null ? void 0 : telemetry.functionId,\n    metadata: telemetry == null ? void 0 : telemetry.metadata,\n    experimental_context\n  };\n  return recordSpan({\n    name: \"ai.toolCall\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationId: \"ai.toolCall\",\n          telemetry\n        }),\n        \"ai.toolCall.name\": toolName,\n        \"ai.toolCall.id\": toolCallId,\n        \"ai.toolCall.args\": {\n          output: () => JSON.stringify(input)\n        }\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      let output;\n      try {\n        await (onToolCallStart == null ? void 0 : onToolCallStart(baseCallbackEvent));\n      } catch (_ignored) {\n      }\n      const startTime = now();\n      try {\n        const stream = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.executeTool)({\n          execute: tool2.execute.bind(tool2),\n          input,\n          options: {\n            toolCallId,\n            messages,\n            abortSignal,\n            experimental_context\n          }\n        });\n        for await (const part of stream) {\n          if (part.type === \"preliminary\") {\n            onPreliminaryToolResult == null ? void 0 : onPreliminaryToolResult({\n              ...toolCall,\n              type: \"tool-result\",\n              output: part.output,\n              preliminary: true\n            });\n          } else {\n            output = part.output;\n          }\n        }\n      } catch (error) {\n        const durationMs2 = now() - startTime;\n        try {\n          await (onToolCallFinish == null ? void 0 : onToolCallFinish({\n            ...baseCallbackEvent,\n            success: false,\n            error,\n            durationMs: durationMs2\n          }));\n        } catch (_ignored) {\n        }\n        recordErrorOnSpan(span, error);\n        return {\n          type: \"tool-error\",\n          toolCallId,\n          toolName,\n          input,\n          error,\n          dynamic: tool2.type === \"dynamic\",\n          ...toolCall.providerMetadata != null ? { providerMetadata: toolCall.providerMetadata } : {}\n        };\n      }\n      const durationMs = now() - startTime;\n      try {\n        await (onToolCallFinish == null ? void 0 : onToolCallFinish({\n          ...baseCallbackEvent,\n          success: true,\n          output,\n          durationMs\n        }));\n      } catch (_ignored) {\n      }\n      try {\n        span.setAttributes(\n          await selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              \"ai.toolCall.result\": {\n                output: () => JSON.stringify(output)\n              }\n            }\n          })\n        );\n      } catch (ignored) {\n      }\n      return {\n        type: \"tool-result\",\n        toolCallId,\n        toolName,\n        input,\n        output,\n        dynamic: tool2.type === \"dynamic\",\n        ...toolCall.providerMetadata != null ? { providerMetadata: toolCall.providerMetadata } : {}\n      };\n    }\n  });\n}\n\n// src/generate-text/extract-reasoning-content.ts\nfunction extractReasoningContent(content) {\n  const parts = content.filter(\n    (content2) => content2.type === \"reasoning\"\n  );\n  return parts.length === 0 ? void 0 : parts.map((content2) => content2.text).join(\"\\n\");\n}\n\n// src/generate-text/extract-text-content.ts\nfunction extractTextContent(content) {\n  const parts = content.filter(\n    (content2) => content2.type === \"text\"\n  );\n  if (parts.length === 0) {\n    return void 0;\n  }\n  return parts.map((content2) => content2.text).join(\"\");\n}\n\n// src/generate-text/generated-file.ts\n\nvar DefaultGeneratedFile = class {\n  constructor({\n    data,\n    mediaType\n  }) {\n    const isUint8Array = data instanceof Uint8Array;\n    this.base64Data = isUint8Array ? void 0 : data;\n    this.uint8ArrayData = isUint8Array ? data : void 0;\n    this.mediaType = mediaType;\n  }\n  // lazy conversion with caching to avoid unnecessary conversion overhead:\n  get base64() {\n    if (this.base64Data == null) {\n      this.base64Data = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertUint8ArrayToBase64)(this.uint8ArrayData);\n    }\n    return this.base64Data;\n  }\n  // lazy conversion with caching to avoid unnecessary conversion overhead:\n  get uint8Array() {\n    if (this.uint8ArrayData == null) {\n      this.uint8ArrayData = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(this.base64Data);\n    }\n    return this.uint8ArrayData;\n  }\n};\nvar DefaultGeneratedFileWithType = class extends DefaultGeneratedFile {\n  constructor(options) {\n    super(options);\n    this.type = \"file\";\n  }\n};\n\n// src/generate-text/is-approval-needed.ts\nasync function isApprovalNeeded({\n  tool: tool2,\n  toolCall,\n  messages,\n  experimental_context\n}) {\n  if (tool2.needsApproval == null) {\n    return false;\n  }\n  if (typeof tool2.needsApproval === \"boolean\") {\n    return tool2.needsApproval;\n  }\n  return await tool2.needsApproval(toolCall.input, {\n    toolCallId: toolCall.toolCallId,\n    messages,\n    experimental_context\n  });\n}\n\n// src/generate-text/output.ts\nvar output_exports = {};\n__export(output_exports, {\n  array: () => array,\n  choice: () => choice,\n  json: () => json,\n  object: () => object,\n  text: () => text\n});\n\n\n\n// src/util/parse-partial-json.ts\n\n\n// src/util/fix-json.ts\nfunction fixJson(input) {\n  const stack = [\"ROOT\"];\n  let lastValidIndex = -1;\n  let literalStart = null;\n  function processValueStart(char, i, swapState) {\n    {\n      switch (char) {\n        case '\"': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_STRING\");\n          break;\n        }\n        case \"f\":\n        case \"t\":\n        case \"n\": {\n          lastValidIndex = i;\n          literalStart = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_LITERAL\");\n          break;\n        }\n        case \"-\": {\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n          break;\n        }\n        case \"0\":\n        case \"1\":\n        case \"2\":\n        case \"3\":\n        case \"4\":\n        case \"5\":\n        case \"6\":\n        case \"7\":\n        case \"8\":\n        case \"9\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n          break;\n        }\n        case \"{\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_OBJECT_START\");\n          break;\n        }\n        case \"[\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_ARRAY_START\");\n          break;\n        }\n      }\n    }\n  }\n  function processAfterObjectValue(char, i) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_OBJECT_AFTER_COMMA\");\n        break;\n      }\n      case \"}\": {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  function processAfterArrayValue(char, i) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n        break;\n      }\n      case \"]\": {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    const currentState = stack[stack.length - 1];\n    switch (currentState) {\n      case \"ROOT\":\n        processValueStart(char, i, \"FINISH\");\n        break;\n      case \"INSIDE_OBJECT_START\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            break;\n          }\n          case \"}\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_COMMA\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_KEY\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_AFTER_KEY\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_KEY\": {\n        switch (char) {\n          case \":\": {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_BEFORE_VALUE\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_BEFORE_VALUE\": {\n        processValueStart(char, i, \"INSIDE_OBJECT_AFTER_VALUE\");\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        processAfterObjectValue(char, i);\n        break;\n      }\n      case \"INSIDE_STRING\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            lastValidIndex = i;\n            break;\n          }\n          case \"\\\\\": {\n            stack.push(\"INSIDE_STRING_ESCAPE\");\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_START\": {\n        switch (char) {\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n            processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        switch (char) {\n          case \",\": {\n            stack.pop();\n            stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n            break;\n          }\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_AFTER_COMMA\": {\n        processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n        break;\n      }\n      case \"INSIDE_STRING_ESCAPE\": {\n        stack.pop();\n        lastValidIndex = i;\n        break;\n      }\n      case \"INSIDE_NUMBER\": {\n        switch (char) {\n          case \"0\":\n          case \"1\":\n          case \"2\":\n          case \"3\":\n          case \"4\":\n          case \"5\":\n          case \"6\":\n          case \"7\":\n          case \"8\":\n          case \"9\": {\n            lastValidIndex = i;\n            break;\n          }\n          case \"e\":\n          case \"E\":\n          case \"-\":\n          case \".\": {\n            break;\n          }\n          case \",\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n            break;\n          }\n          case \"}\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n            break;\n          }\n          case \"]\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n            break;\n          }\n          default: {\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart, i + 1);\n        if (!\"false\".startsWith(partialLiteral) && !\"true\".startsWith(partialLiteral) && !\"null\".startsWith(partialLiteral)) {\n          stack.pop();\n          if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n            processAfterObjectValue(char, i);\n          } else if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n            processAfterArrayValue(char, i);\n          }\n        } else {\n          lastValidIndex = i;\n        }\n        break;\n      }\n    }\n  }\n  let result = input.slice(0, lastValidIndex + 1);\n  for (let i = stack.length - 1; i >= 0; i--) {\n    const state = stack[i];\n    switch (state) {\n      case \"INSIDE_STRING\": {\n        result += '\"';\n        break;\n      }\n      case \"INSIDE_OBJECT_KEY\":\n      case \"INSIDE_OBJECT_AFTER_KEY\":\n      case \"INSIDE_OBJECT_AFTER_COMMA\":\n      case \"INSIDE_OBJECT_START\":\n      case \"INSIDE_OBJECT_BEFORE_VALUE\":\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        result += \"}\";\n        break;\n      }\n      case \"INSIDE_ARRAY_START\":\n      case \"INSIDE_ARRAY_AFTER_COMMA\":\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        result += \"]\";\n        break;\n      }\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart, input.length);\n        if (\"true\".startsWith(partialLiteral)) {\n          result += \"true\".slice(partialLiteral.length);\n        } else if (\"false\".startsWith(partialLiteral)) {\n          result += \"false\".slice(partialLiteral.length);\n        } else if (\"null\".startsWith(partialLiteral)) {\n          result += \"null\".slice(partialLiteral.length);\n        }\n      }\n    }\n  }\n  return result;\n}\n\n// src/util/parse-partial-json.ts\nasync function parsePartialJson(jsonText) {\n  if (jsonText === void 0) {\n    return { value: void 0, state: \"undefined-input\" };\n  }\n  let result = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: jsonText });\n  if (result.success) {\n    return { value: result.value, state: \"successful-parse\" };\n  }\n  result = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: fixJson(jsonText) });\n  if (result.success) {\n    return { value: result.value, state: \"repaired-parse\" };\n  }\n  return { value: void 0, state: \"failed-parse\" };\n}\n\n// src/generate-text/output.ts\nvar text = () => ({\n  name: \"text\",\n  responseFormat: Promise.resolve({ type: \"text\" }),\n  async parseCompleteOutput({ text: text2 }) {\n    return text2;\n  },\n  async parsePartialOutput({ text: text2 }) {\n    return { partial: text2 };\n  },\n  createElementStreamTransform() {\n    return void 0;\n  }\n});\nvar object = ({\n  schema: inputSchema,\n  name: name21,\n  description\n}) => {\n  const schema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(inputSchema);\n  return {\n    name: \"object\",\n    responseFormat: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(schema.jsonSchema).then((jsonSchema2) => ({\n      type: \"json\",\n      schema: jsonSchema2,\n      ...name21 != null && { name: name21 },\n      ...description != null && { description }\n    })),\n    async parseCompleteOutput({ text: text2 }, context2) {\n      const parseResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: text2 });\n      if (!parseResult.success) {\n        throw new NoObjectGeneratedError({\n          message: \"No object generated: could not parse the response.\",\n          cause: parseResult.error,\n          text: text2,\n          response: context2.response,\n          usage: context2.usage,\n          finishReason: context2.finishReason\n        });\n      }\n      const validationResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n        value: parseResult.value,\n        schema\n      });\n      if (!validationResult.success) {\n        throw new NoObjectGeneratedError({\n          message: \"No object generated: response did not match schema.\",\n          cause: validationResult.error,\n          text: text2,\n          response: context2.response,\n          usage: context2.usage,\n          finishReason: context2.finishReason\n        });\n      }\n      return validationResult.value;\n    },\n    async parsePartialOutput({ text: text2 }) {\n      const result = await parsePartialJson(text2);\n      switch (result.state) {\n        case \"failed-parse\":\n        case \"undefined-input\": {\n          return void 0;\n        }\n        case \"repaired-parse\":\n        case \"successful-parse\": {\n          return {\n            // Note: currently no validation of partial results:\n            partial: result.value\n          };\n        }\n      }\n    },\n    createElementStreamTransform() {\n      return void 0;\n    }\n  };\n};\nvar array = ({\n  element: inputElementSchema,\n  name: name21,\n  description\n}) => {\n  const elementSchema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(inputElementSchema);\n  return {\n    name: \"array\",\n    // JSON schema that describes an array of elements:\n    responseFormat: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(elementSchema.jsonSchema).then((jsonSchema2) => {\n      const { $schema, ...itemSchema } = jsonSchema2;\n      return {\n        type: \"json\",\n        schema: {\n          $schema: \"http://json-schema.org/draft-07/schema#\",\n          type: \"object\",\n          properties: {\n            elements: { type: \"array\", items: itemSchema }\n          },\n          required: [\"elements\"],\n          additionalProperties: false\n        },\n        ...name21 != null && { name: name21 },\n        ...description != null && { description }\n      };\n    }),\n    async parseCompleteOutput({ text: text2 }, context2) {\n      const parseResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: text2 });\n      if (!parseResult.success) {\n        throw new NoObjectGeneratedError({\n          message: \"No object generated: could not parse the response.\",\n          cause: parseResult.error,\n          text: text2,\n          response: context2.response,\n          usage: context2.usage,\n          finishReason: context2.finishReason\n        });\n      }\n      const outerValue = parseResult.value;\n      if (outerValue == null || typeof outerValue !== \"object\" || !(\"elements\" in outerValue) || !Array.isArray(outerValue.elements)) {\n        throw new NoObjectGeneratedError({\n          message: \"No object generated: response did not match schema.\",\n          cause: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value: outerValue,\n            cause: \"response must be an object with an elements array\"\n          }),\n          text: text2,\n          response: context2.response,\n          usage: context2.usage,\n          finishReason: context2.finishReason\n        });\n      }\n      for (const element of outerValue.elements) {\n        const validationResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n          value: element,\n          schema: elementSchema\n        });\n        if (!validationResult.success) {\n          throw new NoObjectGeneratedError({\n            message: \"No object generated: response did not match schema.\",\n            cause: validationResult.error,\n            text: text2,\n            response: context2.response,\n            usage: context2.usage,\n            finishReason: context2.finishReason\n          });\n        }\n      }\n      return outerValue.elements;\n    },\n    async parsePartialOutput({ text: text2 }) {\n      const result = await parsePartialJson(text2);\n      switch (result.state) {\n        case \"failed-parse\":\n        case \"undefined-input\": {\n          return void 0;\n        }\n        case \"repaired-parse\":\n        case \"successful-parse\": {\n          const outerValue = result.value;\n          if (outerValue == null || typeof outerValue !== \"object\" || !(\"elements\" in outerValue) || !Array.isArray(outerValue.elements)) {\n            return void 0;\n          }\n          const rawElements = result.state === \"repaired-parse\" && outerValue.elements.length > 0 ? outerValue.elements.slice(0, -1) : outerValue.elements;\n          const parsedElements = [];\n          for (const rawElement of rawElements) {\n            const validationResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n              value: rawElement,\n              schema: elementSchema\n            });\n            if (validationResult.success) {\n              parsedElements.push(validationResult.value);\n            }\n          }\n          return { partial: parsedElements };\n        }\n      }\n    },\n    createElementStreamTransform() {\n      let publishedElements = 0;\n      return new TransformStream({\n        transform({ partialOutput }, controller) {\n          if (partialOutput != null) {\n            for (; publishedElements < partialOutput.length; publishedElements++) {\n              controller.enqueue(partialOutput[publishedElements]);\n            }\n          }\n        }\n      });\n    }\n  };\n};\nvar choice = ({\n  options: choiceOptions,\n  name: name21,\n  description\n}) => {\n  return {\n    name: \"choice\",\n    // JSON schema that describes an enumeration:\n    responseFormat: Promise.resolve({\n      type: \"json\",\n      schema: {\n        $schema: \"http://json-schema.org/draft-07/schema#\",\n        type: \"object\",\n        properties: {\n          result: { type: \"string\", enum: choiceOptions }\n        },\n        required: [\"result\"],\n        additionalProperties: false\n      },\n      ...name21 != null && { name: name21 },\n      ...description != null && { description }\n    }),\n    async parseCompleteOutput({ text: text2 }, context2) {\n      const parseResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: text2 });\n      if (!parseResult.success) {\n        throw new NoObjectGeneratedError({\n          message: \"No object generated: could not parse the response.\",\n          cause: parseResult.error,\n          text: text2,\n          response: context2.response,\n          usage: context2.usage,\n          finishReason: context2.finishReason\n        });\n      }\n      const outerValue = parseResult.value;\n      if (outerValue == null || typeof outerValue !== \"object\" || !(\"result\" in outerValue) || typeof outerValue.result !== \"string\" || !choiceOptions.includes(outerValue.result)) {\n        throw new NoObjectGeneratedError({\n          message: \"No object generated: response did not match schema.\",\n          cause: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value: outerValue,\n            cause: \"response must be an object that contains a choice value.\"\n          }),\n          text: text2,\n          response: context2.response,\n          usage: context2.usage,\n          finishReason: context2.finishReason\n        });\n      }\n      return outerValue.result;\n    },\n    async parsePartialOutput({ text: text2 }) {\n      const result = await parsePartialJson(text2);\n      switch (result.state) {\n        case \"failed-parse\":\n        case \"undefined-input\": {\n          return void 0;\n        }\n        case \"repaired-parse\":\n        case \"successful-parse\": {\n          const outerValue = result.value;\n          if (outerValue == null || typeof outerValue !== \"object\" || !(\"result\" in outerValue) || typeof outerValue.result !== \"string\") {\n            return void 0;\n          }\n          const potentialMatches = choiceOptions.filter(\n            (choiceOption) => choiceOption.startsWith(outerValue.result)\n          );\n          if (result.state === \"successful-parse\") {\n            return potentialMatches.includes(outerValue.result) ? { partial: outerValue.result } : void 0;\n          } else {\n            return potentialMatches.length === 1 ? { partial: potentialMatches[0] } : void 0;\n          }\n        }\n      }\n    },\n    createElementStreamTransform() {\n      return void 0;\n    }\n  };\n};\nvar json = ({\n  name: name21,\n  description\n} = {}) => {\n  return {\n    name: \"json\",\n    responseFormat: Promise.resolve({\n      type: \"json\",\n      ...name21 != null && { name: name21 },\n      ...description != null && { description }\n    }),\n    async parseCompleteOutput({ text: text2 }, context2) {\n      const parseResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: text2 });\n      if (!parseResult.success) {\n        throw new NoObjectGeneratedError({\n          message: \"No object generated: could not parse the response.\",\n          cause: parseResult.error,\n          text: text2,\n          response: context2.response,\n          usage: context2.usage,\n          finishReason: context2.finishReason\n        });\n      }\n      return parseResult.value;\n    },\n    async parsePartialOutput({ text: text2 }) {\n      const result = await parsePartialJson(text2);\n      switch (result.state) {\n        case \"failed-parse\":\n        case \"undefined-input\": {\n          return void 0;\n        }\n        case \"repaired-parse\":\n        case \"successful-parse\": {\n          return result.value === void 0 ? void 0 : { partial: result.value };\n        }\n      }\n    },\n    createElementStreamTransform() {\n      return void 0;\n    }\n  };\n};\n\n// src/generate-text/parse-tool-call.ts\n\nasync function parseToolCall({\n  toolCall,\n  tools,\n  repairToolCall,\n  system,\n  messages\n}) {\n  var _a21;\n  try {\n    if (tools == null) {\n      if (toolCall.providerExecuted && toolCall.dynamic) {\n        return await parseProviderExecutedDynamicToolCall(toolCall);\n      }\n      throw new NoSuchToolError({ toolName: toolCall.toolName });\n    }\n    try {\n      return await doParseToolCall({ toolCall, tools });\n    } catch (error) {\n      if (repairToolCall == null || !(NoSuchToolError.isInstance(error) || InvalidToolInputError.isInstance(error))) {\n        throw error;\n      }\n      let repairedToolCall = null;\n      try {\n        repairedToolCall = await repairToolCall({\n          toolCall,\n          tools,\n          inputSchema: async ({ toolName }) => {\n            const { inputSchema } = tools[toolName];\n            return await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(inputSchema).jsonSchema;\n          },\n          system,\n          messages,\n          error\n        });\n      } catch (repairError) {\n        throw new ToolCallRepairError({\n          cause: repairError,\n          originalError: error\n        });\n      }\n      if (repairedToolCall == null) {\n        throw error;\n      }\n      return await doParseToolCall({ toolCall: repairedToolCall, tools });\n    }\n  } catch (error) {\n    const parsedInput = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: toolCall.input });\n    const input = parsedInput.success ? parsedInput.value : toolCall.input;\n    return {\n      type: \"tool-call\",\n      toolCallId: toolCall.toolCallId,\n      toolName: toolCall.toolName,\n      input,\n      dynamic: true,\n      invalid: true,\n      error,\n      title: (_a21 = tools == null ? void 0 : tools[toolCall.toolName]) == null ? void 0 : _a21.title,\n      providerExecuted: toolCall.providerExecuted,\n      providerMetadata: toolCall.providerMetadata\n    };\n  }\n}\nasync function parseProviderExecutedDynamicToolCall(toolCall) {\n  const parseResult = toolCall.input.trim() === \"\" ? { success: true, value: {} } : await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: toolCall.input });\n  if (parseResult.success === false) {\n    throw new InvalidToolInputError({\n      toolName: toolCall.toolName,\n      toolInput: toolCall.input,\n      cause: parseResult.error\n    });\n  }\n  return {\n    type: \"tool-call\",\n    toolCallId: toolCall.toolCallId,\n    toolName: toolCall.toolName,\n    input: parseResult.value,\n    providerExecuted: true,\n    dynamic: true,\n    providerMetadata: toolCall.providerMetadata\n  };\n}\nasync function doParseToolCall({\n  toolCall,\n  tools\n}) {\n  const toolName = toolCall.toolName;\n  const tool2 = tools[toolName];\n  if (tool2 == null) {\n    if (toolCall.providerExecuted && toolCall.dynamic) {\n      return await parseProviderExecutedDynamicToolCall(toolCall);\n    }\n    throw new NoSuchToolError({\n      toolName: toolCall.toolName,\n      availableTools: Object.keys(tools)\n    });\n  }\n  const schema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(tool2.inputSchema);\n  const parseResult = toolCall.input.trim() === \"\" ? await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({ value: {}, schema }) : await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: toolCall.input, schema });\n  if (parseResult.success === false) {\n    throw new InvalidToolInputError({\n      toolName,\n      toolInput: toolCall.input,\n      cause: parseResult.error\n    });\n  }\n  return tool2.type === \"dynamic\" ? {\n    type: \"tool-call\",\n    toolCallId: toolCall.toolCallId,\n    toolName: toolCall.toolName,\n    input: parseResult.value,\n    providerExecuted: toolCall.providerExecuted,\n    providerMetadata: toolCall.providerMetadata,\n    dynamic: true,\n    title: tool2.title\n  } : {\n    type: \"tool-call\",\n    toolCallId: toolCall.toolCallId,\n    toolName,\n    input: parseResult.value,\n    providerExecuted: toolCall.providerExecuted,\n    providerMetadata: toolCall.providerMetadata,\n    title: tool2.title\n  };\n}\n\n// src/generate-text/step-result.ts\nvar DefaultStepResult = class {\n  constructor({\n    stepNumber,\n    model,\n    functionId,\n    metadata,\n    experimental_context,\n    content,\n    finishReason,\n    rawFinishReason,\n    usage,\n    warnings,\n    request,\n    response,\n    providerMetadata\n  }) {\n    this.stepNumber = stepNumber;\n    this.model = model;\n    this.functionId = functionId;\n    this.metadata = metadata;\n    this.experimental_context = experimental_context;\n    this.content = content;\n    this.finishReason = finishReason;\n    this.rawFinishReason = rawFinishReason;\n    this.usage = usage;\n    this.warnings = warnings;\n    this.request = request;\n    this.response = response;\n    this.providerMetadata = providerMetadata;\n  }\n  get text() {\n    return this.content.filter((part) => part.type === \"text\").map((part) => part.text).join(\"\");\n  }\n  get reasoning() {\n    return this.content.filter((part) => part.type === \"reasoning\");\n  }\n  get reasoningText() {\n    return this.reasoning.length === 0 ? void 0 : this.reasoning.map((part) => part.text).join(\"\");\n  }\n  get files() {\n    return this.content.filter((part) => part.type === \"file\").map((part) => part.file);\n  }\n  get sources() {\n    return this.content.filter((part) => part.type === \"source\");\n  }\n  get toolCalls() {\n    return this.content.filter((part) => part.type === \"tool-call\");\n  }\n  get staticToolCalls() {\n    return this.toolCalls.filter(\n      (toolCall) => toolCall.dynamic !== true\n    );\n  }\n  get dynamicToolCalls() {\n    return this.toolCalls.filter(\n      (toolCall) => toolCall.dynamic === true\n    );\n  }\n  get toolResults() {\n    return this.content.filter((part) => part.type === \"tool-result\");\n  }\n  get staticToolResults() {\n    return this.toolResults.filter(\n      (toolResult) => toolResult.dynamic !== true\n    );\n  }\n  get dynamicToolResults() {\n    return this.toolResults.filter(\n      (toolResult) => toolResult.dynamic === true\n    );\n  }\n};\n\n// src/generate-text/stop-condition.ts\nfunction stepCountIs(stepCount) {\n  return ({ steps }) => steps.length === stepCount;\n}\nfunction hasToolCall(toolName) {\n  return ({ steps }) => {\n    var _a21, _b, _c;\n    return (_c = (_b = (_a21 = steps[steps.length - 1]) == null ? void 0 : _a21.toolCalls) == null ? void 0 : _b.some(\n      (toolCall) => toolCall.toolName === toolName\n    )) != null ? _c : false;\n  };\n}\nasync function isStopConditionMet({\n  stopConditions,\n  steps\n}) {\n  return (await Promise.all(stopConditions.map((condition) => condition({ steps })))).some((result) => result);\n}\n\n// src/generate-text/to-response-messages.ts\nasync function toResponseMessages({\n  content: inputContent,\n  tools\n}) {\n  const responseMessages = [];\n  const content = [];\n  for (const part of inputContent) {\n    if (part.type === \"source\") {\n      continue;\n    }\n    if ((part.type === \"tool-result\" || part.type === \"tool-error\") && !part.providerExecuted) {\n      continue;\n    }\n    if (part.type === \"text\" && part.text.length === 0) {\n      continue;\n    }\n    switch (part.type) {\n      case \"text\":\n        content.push({\n          type: \"text\",\n          text: part.text,\n          providerOptions: part.providerMetadata\n        });\n        break;\n      case \"reasoning\":\n        content.push({\n          type: \"reasoning\",\n          text: part.text,\n          providerOptions: part.providerMetadata\n        });\n        break;\n      case \"file\":\n        content.push({\n          type: \"file\",\n          data: part.file.base64,\n          mediaType: part.file.mediaType,\n          providerOptions: part.providerMetadata\n        });\n        break;\n      case \"tool-call\":\n        content.push({\n          type: \"tool-call\",\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          input: part.input,\n          providerExecuted: part.providerExecuted,\n          providerOptions: part.providerMetadata\n        });\n        break;\n      case \"tool-result\": {\n        const output = await createToolModelOutput({\n          toolCallId: part.toolCallId,\n          input: part.input,\n          tool: tools == null ? void 0 : tools[part.toolName],\n          output: part.output,\n          errorMode: \"none\"\n        });\n        content.push({\n          type: \"tool-result\",\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          output,\n          providerOptions: part.providerMetadata\n        });\n        break;\n      }\n      case \"tool-error\": {\n        const output = await createToolModelOutput({\n          toolCallId: part.toolCallId,\n          input: part.input,\n          tool: tools == null ? void 0 : tools[part.toolName],\n          output: part.error,\n          errorMode: \"json\"\n        });\n        content.push({\n          type: \"tool-result\",\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          output,\n          providerOptions: part.providerMetadata\n        });\n        break;\n      }\n      case \"tool-approval-request\":\n        content.push({\n          type: \"tool-approval-request\",\n          approvalId: part.approvalId,\n          toolCallId: part.toolCall.toolCallId\n        });\n        break;\n    }\n  }\n  if (content.length > 0) {\n    responseMessages.push({\n      role: \"assistant\",\n      content\n    });\n  }\n  const toolResultContent = [];\n  for (const part of inputContent) {\n    if (!(part.type === \"tool-result\" || part.type === \"tool-error\") || part.providerExecuted) {\n      continue;\n    }\n    const output = await createToolModelOutput({\n      toolCallId: part.toolCallId,\n      input: part.input,\n      tool: tools == null ? void 0 : tools[part.toolName],\n      output: part.type === \"tool-result\" ? part.output : part.error,\n      errorMode: part.type === \"tool-error\" ? \"text\" : \"none\"\n    });\n    toolResultContent.push({\n      type: \"tool-result\",\n      toolCallId: part.toolCallId,\n      toolName: part.toolName,\n      output,\n      ...part.providerMetadata != null ? { providerOptions: part.providerMetadata } : {}\n    });\n  }\n  if (toolResultContent.length > 0) {\n    responseMessages.push({\n      role: \"tool\",\n      content: toolResultContent\n    });\n  }\n  return responseMessages;\n}\n\n// src/util/merge-abort-signals.ts\nfunction mergeAbortSignals(...signals) {\n  const validSignals = signals.filter(\n    (signal) => signal != null\n  );\n  if (validSignals.length === 0) {\n    return void 0;\n  }\n  if (validSignals.length === 1) {\n    return validSignals[0];\n  }\n  const controller = new AbortController();\n  for (const signal of validSignals) {\n    if (signal.aborted) {\n      controller.abort(signal.reason);\n      return controller.signal;\n    }\n    signal.addEventListener(\n      \"abort\",\n      () => {\n        controller.abort(signal.reason);\n      },\n      { once: true }\n    );\n  }\n  return controller.signal;\n}\n\n// src/generate-text/generate-text.ts\nvar originalGenerateId = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n  prefix: \"aitxt\",\n  size: 24\n});\nasync function generateText({\n  model: modelArg,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  timeout,\n  headers,\n  stopWhen = stepCountIs(1),\n  experimental_output,\n  output = experimental_output,\n  experimental_telemetry: telemetry,\n  providerOptions,\n  experimental_activeTools,\n  activeTools = experimental_activeTools,\n  experimental_prepareStep,\n  prepareStep = experimental_prepareStep,\n  experimental_repairToolCall: repairToolCall,\n  experimental_download: download2,\n  experimental_context,\n  experimental_include: include,\n  _internal: { generateId: generateId2 = originalGenerateId } = {},\n  experimental_onStart: onStart,\n  experimental_onStepStart: onStepStart,\n  experimental_onToolCallStart: onToolCallStart,\n  experimental_onToolCallFinish: onToolCallFinish,\n  onStepFinish,\n  onFinish,\n  ...settings\n}) {\n  const model = resolveLanguageModel(modelArg);\n  const stopConditions = asArray(stopWhen);\n  const totalTimeoutMs = getTotalTimeoutMs(timeout);\n  const stepTimeoutMs = getStepTimeoutMs(timeout);\n  const stepAbortController = stepTimeoutMs != null ? new AbortController() : void 0;\n  const mergedAbortSignal = mergeAbortSignals(\n    abortSignal,\n    totalTimeoutMs != null ? AbortSignal.timeout(totalTimeoutMs) : void 0,\n    stepAbortController == null ? void 0 : stepAbortController.signal\n  );\n  const { maxRetries, retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal: mergedAbortSignal\n  });\n  const callSettings = prepareCallSettings(settings);\n  const headersWithUserAgent = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(\n    headers != null ? headers : {},\n    `ai/${VERSION}`\n  );\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers: headersWithUserAgent,\n    settings: { ...callSettings, maxRetries }\n  });\n  const modelInfo = { provider: model.provider, modelId: model.modelId };\n  const initialPrompt = await standardizePrompt({\n    system,\n    prompt,\n    messages\n  });\n  try {\n    await (onStart == null ? void 0 : onStart({\n      model: modelInfo,\n      system,\n      prompt,\n      messages,\n      tools,\n      toolChoice,\n      activeTools,\n      maxOutputTokens: callSettings.maxOutputTokens,\n      temperature: callSettings.temperature,\n      topP: callSettings.topP,\n      topK: callSettings.topK,\n      presencePenalty: callSettings.presencePenalty,\n      frequencyPenalty: callSettings.frequencyPenalty,\n      stopSequences: callSettings.stopSequences,\n      seed: callSettings.seed,\n      maxRetries,\n      timeout,\n      headers,\n      providerOptions,\n      stopWhen,\n      output,\n      abortSignal,\n      include,\n      functionId: telemetry == null ? void 0 : telemetry.functionId,\n      metadata: telemetry == null ? void 0 : telemetry.metadata,\n      experimental_context\n    }));\n  } catch (_ignored) {\n  }\n  const tracer = getTracer(telemetry);\n  try {\n    return await recordSpan({\n      name: \"ai.generateText\",\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({\n            operationId: \"ai.generateText\",\n            telemetry\n          }),\n          ...baseTelemetryAttributes,\n          // model:\n          \"ai.model.provider\": model.provider,\n          \"ai.model.id\": model.modelId,\n          // specific settings that only make sense on the outer level:\n          \"ai.prompt\": {\n            input: () => JSON.stringify({ system, prompt, messages })\n          }\n        }\n      }),\n      tracer,\n      fn: async (span) => {\n        var _a21, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;\n        const initialMessages = initialPrompt.messages;\n        const responseMessages = [];\n        const { approvedToolApprovals, deniedToolApprovals } = collectToolApprovals({ messages: initialMessages });\n        const localApprovedToolApprovals = approvedToolApprovals.filter(\n          (toolApproval) => !toolApproval.toolCall.providerExecuted\n        );\n        if (deniedToolApprovals.length > 0 || localApprovedToolApprovals.length > 0) {\n          const toolOutputs = await executeTools({\n            toolCalls: localApprovedToolApprovals.map(\n              (toolApproval) => toolApproval.toolCall\n            ),\n            tools,\n            tracer,\n            telemetry,\n            messages: initialMessages,\n            abortSignal: mergedAbortSignal,\n            experimental_context,\n            stepNumber: 0,\n            model: modelInfo,\n            onToolCallStart,\n            onToolCallFinish\n          });\n          const toolContent = [];\n          for (const output2 of toolOutputs) {\n            const modelOutput = await createToolModelOutput({\n              toolCallId: output2.toolCallId,\n              input: output2.input,\n              tool: tools == null ? void 0 : tools[output2.toolName],\n              output: output2.type === \"tool-result\" ? output2.output : output2.error,\n              errorMode: output2.type === \"tool-error\" ? \"json\" : \"none\"\n            });\n            toolContent.push({\n              type: \"tool-result\",\n              toolCallId: output2.toolCallId,\n              toolName: output2.toolName,\n              output: modelOutput\n            });\n          }\n          for (const toolApproval of deniedToolApprovals) {\n            toolContent.push({\n              type: \"tool-result\",\n              toolCallId: toolApproval.toolCall.toolCallId,\n              toolName: toolApproval.toolCall.toolName,\n              output: {\n                type: \"execution-denied\",\n                reason: toolApproval.approvalResponse.reason,\n                // For provider-executed tools, include approvalId so provider can correlate\n                ...toolApproval.toolCall.providerExecuted && {\n                  providerOptions: {\n                    openai: {\n                      approvalId: toolApproval.approvalResponse.approvalId\n                    }\n                  }\n                }\n              }\n            });\n          }\n          responseMessages.push({\n            role: \"tool\",\n            content: toolContent\n          });\n        }\n        const providerExecutedToolApprovals = [\n          ...approvedToolApprovals,\n          ...deniedToolApprovals\n        ].filter((toolApproval) => toolApproval.toolCall.providerExecuted);\n        if (providerExecutedToolApprovals.length > 0) {\n          responseMessages.push({\n            role: \"tool\",\n            content: providerExecutedToolApprovals.map(\n              (toolApproval) => ({\n                type: \"tool-approval-response\",\n                approvalId: toolApproval.approvalResponse.approvalId,\n                approved: toolApproval.approvalResponse.approved,\n                reason: toolApproval.approvalResponse.reason,\n                providerExecuted: true\n              })\n            )\n          });\n        }\n        const callSettings2 = prepareCallSettings(settings);\n        let currentModelResponse;\n        let clientToolCalls = [];\n        let clientToolOutputs = [];\n        const steps = [];\n        const pendingDeferredToolCalls = /* @__PURE__ */ new Map();\n        do {\n          const stepTimeoutId = stepTimeoutMs != null ? setTimeout(() => stepAbortController.abort(), stepTimeoutMs) : void 0;\n          try {\n            const stepInputMessages = [...initialMessages, ...responseMessages];\n            const prepareStepResult = await (prepareStep == null ? void 0 : prepareStep({\n              model,\n              steps,\n              stepNumber: steps.length,\n              messages: stepInputMessages,\n              experimental_context\n            }));\n            const stepModel = resolveLanguageModel(\n              (_a21 = prepareStepResult == null ? void 0 : prepareStepResult.model) != null ? _a21 : model\n            );\n            const stepModelInfo = {\n              provider: stepModel.provider,\n              modelId: stepModel.modelId\n            };\n            const promptMessages = await convertToLanguageModelPrompt({\n              prompt: {\n                system: (_b = prepareStepResult == null ? void 0 : prepareStepResult.system) != null ? _b : initialPrompt.system,\n                messages: (_c = prepareStepResult == null ? void 0 : prepareStepResult.messages) != null ? _c : stepInputMessages\n              },\n              supportedUrls: await stepModel.supportedUrls,\n              download: download2\n            });\n            experimental_context = (_d = prepareStepResult == null ? void 0 : prepareStepResult.experimental_context) != null ? _d : experimental_context;\n            const stepActiveTools = (_e = prepareStepResult == null ? void 0 : prepareStepResult.activeTools) != null ? _e : activeTools;\n            const { toolChoice: stepToolChoice, tools: stepTools } = await prepareToolsAndToolChoice({\n              tools,\n              toolChoice: (_f = prepareStepResult == null ? void 0 : prepareStepResult.toolChoice) != null ? _f : toolChoice,\n              activeTools: stepActiveTools\n            });\n            const stepMessages = (_g = prepareStepResult == null ? void 0 : prepareStepResult.messages) != null ? _g : stepInputMessages;\n            const stepSystem = (_h = prepareStepResult == null ? void 0 : prepareStepResult.system) != null ? _h : initialPrompt.system;\n            const stepProviderOptions = mergeObjects(\n              providerOptions,\n              prepareStepResult == null ? void 0 : prepareStepResult.providerOptions\n            );\n            try {\n              await (onStepStart == null ? void 0 : onStepStart({\n                stepNumber: steps.length,\n                model: stepModelInfo,\n                system: stepSystem,\n                messages: stepMessages,\n                tools,\n                toolChoice: stepToolChoice,\n                activeTools: stepActiveTools,\n                steps: [...steps],\n                providerOptions: stepProviderOptions,\n                timeout,\n                headers,\n                stopWhen,\n                output,\n                abortSignal,\n                include,\n                functionId: telemetry == null ? void 0 : telemetry.functionId,\n                metadata: telemetry == null ? void 0 : telemetry.metadata,\n                experimental_context\n              }));\n            } catch (_ignored) {\n            }\n            currentModelResponse = await retry(\n              () => {\n                var _a22;\n                return recordSpan({\n                  name: \"ai.generateText.doGenerate\",\n                  attributes: selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      ...assembleOperationName({\n                        operationId: \"ai.generateText.doGenerate\",\n                        telemetry\n                      }),\n                      ...baseTelemetryAttributes,\n                      // model:\n                      \"ai.model.provider\": stepModel.provider,\n                      \"ai.model.id\": stepModel.modelId,\n                      // prompt:\n                      \"ai.prompt.messages\": {\n                        input: () => stringifyForTelemetry(promptMessages)\n                      },\n                      \"ai.prompt.tools\": {\n                        // convert the language model level tools:\n                        input: () => stepTools == null ? void 0 : stepTools.map((tool2) => JSON.stringify(tool2))\n                      },\n                      \"ai.prompt.toolChoice\": {\n                        input: () => stepToolChoice != null ? JSON.stringify(stepToolChoice) : void 0\n                      },\n                      // standardized gen-ai llm span attributes:\n                      \"gen_ai.system\": stepModel.provider,\n                      \"gen_ai.request.model\": stepModel.modelId,\n                      \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                      \"gen_ai.request.max_tokens\": settings.maxOutputTokens,\n                      \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                      \"gen_ai.request.stop_sequences\": settings.stopSequences,\n                      \"gen_ai.request.temperature\": (_a22 = settings.temperature) != null ? _a22 : void 0,\n                      \"gen_ai.request.top_k\": settings.topK,\n                      \"gen_ai.request.top_p\": settings.topP\n                    }\n                  }),\n                  tracer,\n                  fn: async (span2) => {\n                    var _a23, _b2, _c2, _d2, _e2, _f2, _g2, _h2;\n                    const result = await stepModel.doGenerate({\n                      ...callSettings2,\n                      tools: stepTools,\n                      toolChoice: stepToolChoice,\n                      responseFormat: await (output == null ? void 0 : output.responseFormat),\n                      prompt: promptMessages,\n                      providerOptions: stepProviderOptions,\n                      abortSignal: mergedAbortSignal,\n                      headers: headersWithUserAgent\n                    });\n                    const responseData = {\n                      id: (_b2 = (_a23 = result.response) == null ? void 0 : _a23.id) != null ? _b2 : generateId2(),\n                      timestamp: (_d2 = (_c2 = result.response) == null ? void 0 : _c2.timestamp) != null ? _d2 : /* @__PURE__ */ new Date(),\n                      modelId: (_f2 = (_e2 = result.response) == null ? void 0 : _e2.modelId) != null ? _f2 : stepModel.modelId,\n                      headers: (_g2 = result.response) == null ? void 0 : _g2.headers,\n                      body: (_h2 = result.response) == null ? void 0 : _h2.body\n                    };\n                    span2.setAttributes(\n                      await selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                          \"ai.response.finishReason\": result.finishReason.unified,\n                          \"ai.response.text\": {\n                            output: () => extractTextContent(result.content)\n                          },\n                          \"ai.response.reasoning\": {\n                            output: () => extractReasoningContent(result.content)\n                          },\n                          \"ai.response.toolCalls\": {\n                            output: () => {\n                              const toolCalls = asToolCalls(result.content);\n                              return toolCalls == null ? void 0 : JSON.stringify(toolCalls);\n                            }\n                          },\n                          \"ai.response.id\": responseData.id,\n                          \"ai.response.model\": responseData.modelId,\n                          \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                          \"ai.response.providerMetadata\": JSON.stringify(\n                            result.providerMetadata\n                          ),\n                          // TODO rename telemetry attributes to inputTokens and outputTokens\n                          \"ai.usage.promptTokens\": result.usage.inputTokens.total,\n                          \"ai.usage.completionTokens\": result.usage.outputTokens.total,\n                          // standardized gen-ai llm span attributes:\n                          \"gen_ai.response.finish_reasons\": [\n                            result.finishReason.unified\n                          ],\n                          \"gen_ai.response.id\": responseData.id,\n                          \"gen_ai.response.model\": responseData.modelId,\n                          \"gen_ai.usage.input_tokens\": result.usage.inputTokens.total,\n                          \"gen_ai.usage.output_tokens\": result.usage.outputTokens.total\n                        }\n                      })\n                    );\n                    return { ...result, response: responseData };\n                  }\n                });\n              }\n            );\n            const stepToolCalls = await Promise.all(\n              currentModelResponse.content.filter(\n                (part) => part.type === \"tool-call\"\n              ).map(\n                (toolCall) => parseToolCall({\n                  toolCall,\n                  tools,\n                  repairToolCall,\n                  system,\n                  messages: stepInputMessages\n                })\n              )\n            );\n            const toolApprovalRequests = {};\n            for (const toolCall of stepToolCalls) {\n              if (toolCall.invalid) {\n                continue;\n              }\n              const tool2 = tools == null ? void 0 : tools[toolCall.toolName];\n              if (tool2 == null) {\n                continue;\n              }\n              if ((tool2 == null ? void 0 : tool2.onInputAvailable) != null) {\n                await tool2.onInputAvailable({\n                  input: toolCall.input,\n                  toolCallId: toolCall.toolCallId,\n                  messages: stepInputMessages,\n                  abortSignal: mergedAbortSignal,\n                  experimental_context\n                });\n              }\n              if (await isApprovalNeeded({\n                tool: tool2,\n                toolCall,\n                messages: stepInputMessages,\n                experimental_context\n              })) {\n                toolApprovalRequests[toolCall.toolCallId] = {\n                  type: \"tool-approval-request\",\n                  approvalId: generateId2(),\n                  toolCall\n                };\n              }\n            }\n            const invalidToolCalls = stepToolCalls.filter(\n              (toolCall) => toolCall.invalid && toolCall.dynamic\n            );\n            clientToolOutputs = [];\n            for (const toolCall of invalidToolCalls) {\n              clientToolOutputs.push({\n                type: \"tool-error\",\n                toolCallId: toolCall.toolCallId,\n                toolName: toolCall.toolName,\n                input: toolCall.input,\n                error: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getErrorMessage)(toolCall.error),\n                dynamic: true\n              });\n            }\n            clientToolCalls = stepToolCalls.filter(\n              (toolCall) => !toolCall.providerExecuted\n            );\n            if (tools != null) {\n              clientToolOutputs.push(\n                ...await executeTools({\n                  toolCalls: clientToolCalls.filter(\n                    (toolCall) => !toolCall.invalid && toolApprovalRequests[toolCall.toolCallId] == null\n                  ),\n                  tools,\n                  tracer,\n                  telemetry,\n                  messages: stepInputMessages,\n                  abortSignal: mergedAbortSignal,\n                  experimental_context,\n                  stepNumber: steps.length,\n                  model: stepModelInfo,\n                  onToolCallStart,\n                  onToolCallFinish\n                })\n              );\n            }\n            for (const toolCall of stepToolCalls) {\n              if (!toolCall.providerExecuted)\n                continue;\n              const tool2 = tools == null ? void 0 : tools[toolCall.toolName];\n              if ((tool2 == null ? void 0 : tool2.type) === \"provider\" && tool2.supportsDeferredResults) {\n                const hasResultInResponse = currentModelResponse.content.some(\n                  (part) => part.type === \"tool-result\" && part.toolCallId === toolCall.toolCallId\n                );\n                if (!hasResultInResponse) {\n                  pendingDeferredToolCalls.set(toolCall.toolCallId, {\n                    toolName: toolCall.toolName\n                  });\n                }\n              }\n            }\n            for (const part of currentModelResponse.content) {\n              if (part.type === \"tool-result\") {\n                pendingDeferredToolCalls.delete(part.toolCallId);\n              }\n            }\n            const stepContent = asContent({\n              content: currentModelResponse.content,\n              toolCalls: stepToolCalls,\n              toolOutputs: clientToolOutputs,\n              toolApprovalRequests: Object.values(toolApprovalRequests),\n              tools\n            });\n            responseMessages.push(\n              ...await toResponseMessages({\n                content: stepContent,\n                tools\n              })\n            );\n            const stepRequest = ((_i = include == null ? void 0 : include.requestBody) != null ? _i : true) ? (_j = currentModelResponse.request) != null ? _j : {} : { ...currentModelResponse.request, body: void 0 };\n            const stepResponse = {\n              ...currentModelResponse.response,\n              // deep clone msgs to avoid mutating past messages in multi-step:\n              messages: structuredClone(responseMessages),\n              // Conditionally include response body:\n              body: ((_k = include == null ? void 0 : include.responseBody) != null ? _k : true) ? (_l = currentModelResponse.response) == null ? void 0 : _l.body : void 0\n            };\n            const stepNumber = steps.length;\n            const currentStepResult = new DefaultStepResult({\n              stepNumber,\n              model: stepModelInfo,\n              functionId: telemetry == null ? void 0 : telemetry.functionId,\n              metadata: telemetry == null ? void 0 : telemetry.metadata,\n              experimental_context,\n              content: stepContent,\n              finishReason: currentModelResponse.finishReason.unified,\n              rawFinishReason: currentModelResponse.finishReason.raw,\n              usage: asLanguageModelUsage(currentModelResponse.usage),\n              warnings: currentModelResponse.warnings,\n              providerMetadata: currentModelResponse.providerMetadata,\n              request: stepRequest,\n              response: stepResponse\n            });\n            logWarnings({\n              warnings: (_m = currentModelResponse.warnings) != null ? _m : [],\n              provider: stepModelInfo.provider,\n              model: stepModelInfo.modelId\n            });\n            steps.push(currentStepResult);\n            await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));\n          } finally {\n            if (stepTimeoutId != null) {\n              clearTimeout(stepTimeoutId);\n            }\n          }\n        } while (\n          // Continue if:\n          // 1. There are client tool calls that have all been executed, OR\n          // 2. There are pending deferred results from provider-executed tools\n          (clientToolCalls.length > 0 && clientToolOutputs.length === clientToolCalls.length || pendingDeferredToolCalls.size > 0) && // continue until a stop condition is met:\n          !await isStopConditionMet({ stopConditions, steps })\n        );\n        span.setAttributes(\n          await selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              \"ai.response.finishReason\": currentModelResponse.finishReason.unified,\n              \"ai.response.text\": {\n                output: () => extractTextContent(currentModelResponse.content)\n              },\n              \"ai.response.reasoning\": {\n                output: () => extractReasoningContent(currentModelResponse.content)\n              },\n              \"ai.response.toolCalls\": {\n                output: () => {\n                  const toolCalls = asToolCalls(currentModelResponse.content);\n                  return toolCalls == null ? void 0 : JSON.stringify(toolCalls);\n                }\n              },\n              \"ai.response.providerMetadata\": JSON.stringify(\n                currentModelResponse.providerMetadata\n              ),\n              // TODO rename telemetry attributes to inputTokens and outputTokens\n              \"ai.usage.promptTokens\": currentModelResponse.usage.inputTokens.total,\n              \"ai.usage.completionTokens\": currentModelResponse.usage.outputTokens.total\n            }\n          })\n        );\n        const lastStep = steps[steps.length - 1];\n        const totalUsage = steps.reduce(\n          (totalUsage2, step) => {\n            return addLanguageModelUsage(totalUsage2, step.usage);\n          },\n          {\n            inputTokens: void 0,\n            outputTokens: void 0,\n            totalTokens: void 0,\n            reasoningTokens: void 0,\n            cachedInputTokens: void 0\n          }\n        );\n        await (onFinish == null ? void 0 : onFinish({\n          stepNumber: lastStep.stepNumber,\n          model: lastStep.model,\n          functionId: lastStep.functionId,\n          metadata: lastStep.metadata,\n          experimental_context: lastStep.experimental_context,\n          finishReason: lastStep.finishReason,\n          rawFinishReason: lastStep.rawFinishReason,\n          usage: lastStep.usage,\n          content: lastStep.content,\n          text: lastStep.text,\n          reasoningText: lastStep.reasoningText,\n          reasoning: lastStep.reasoning,\n          files: lastStep.files,\n          sources: lastStep.sources,\n          toolCalls: lastStep.toolCalls,\n          staticToolCalls: lastStep.staticToolCalls,\n          dynamicToolCalls: lastStep.dynamicToolCalls,\n          toolResults: lastStep.toolResults,\n          staticToolResults: lastStep.staticToolResults,\n          dynamicToolResults: lastStep.dynamicToolResults,\n          request: lastStep.request,\n          response: lastStep.response,\n          warnings: lastStep.warnings,\n          providerMetadata: lastStep.providerMetadata,\n          steps,\n          totalUsage\n        }));\n        let resolvedOutput;\n        if (lastStep.finishReason === \"stop\") {\n          const outputSpecification = output != null ? output : text();\n          resolvedOutput = await outputSpecification.parseCompleteOutput(\n            { text: lastStep.text },\n            {\n              response: lastStep.response,\n              usage: lastStep.usage,\n              finishReason: lastStep.finishReason\n            }\n          );\n        }\n        return new DefaultGenerateTextResult({\n          steps,\n          totalUsage,\n          output: resolvedOutput\n        });\n      }\n    });\n  } catch (error) {\n    throw wrapGatewayError(error);\n  }\n}\nasync function executeTools({\n  toolCalls,\n  tools,\n  tracer,\n  telemetry,\n  messages,\n  abortSignal,\n  experimental_context,\n  stepNumber,\n  model,\n  onToolCallStart,\n  onToolCallFinish\n}) {\n  const toolOutputs = await Promise.all(\n    toolCalls.map(\n      async (toolCall) => executeToolCall({\n        toolCall,\n        tools,\n        tracer,\n        telemetry,\n        messages,\n        abortSignal,\n        experimental_context,\n        stepNumber,\n        model,\n        onToolCallStart,\n        onToolCallFinish\n      })\n    )\n  );\n  return toolOutputs.filter(\n    (output) => output != null\n  );\n}\nvar DefaultGenerateTextResult = class {\n  constructor(options) {\n    this.steps = options.steps;\n    this._output = options.output;\n    this.totalUsage = options.totalUsage;\n  }\n  get finalStep() {\n    return this.steps[this.steps.length - 1];\n  }\n  get content() {\n    return this.finalStep.content;\n  }\n  get text() {\n    return this.finalStep.text;\n  }\n  get files() {\n    return this.finalStep.files;\n  }\n  get reasoningText() {\n    return this.finalStep.reasoningText;\n  }\n  get reasoning() {\n    return this.finalStep.reasoning;\n  }\n  get toolCalls() {\n    return this.finalStep.toolCalls;\n  }\n  get staticToolCalls() {\n    return this.finalStep.staticToolCalls;\n  }\n  get dynamicToolCalls() {\n    return this.finalStep.dynamicToolCalls;\n  }\n  get toolResults() {\n    return this.finalStep.toolResults;\n  }\n  get staticToolResults() {\n    return this.finalStep.staticToolResults;\n  }\n  get dynamicToolResults() {\n    return this.finalStep.dynamicToolResults;\n  }\n  get sources() {\n    return this.finalStep.sources;\n  }\n  get finishReason() {\n    return this.finalStep.finishReason;\n  }\n  get rawFinishReason() {\n    return this.finalStep.rawFinishReason;\n  }\n  get warnings() {\n    return this.finalStep.warnings;\n  }\n  get providerMetadata() {\n    return this.finalStep.providerMetadata;\n  }\n  get response() {\n    return this.finalStep.response;\n  }\n  get request() {\n    return this.finalStep.request;\n  }\n  get usage() {\n    return this.finalStep.usage;\n  }\n  get experimental_output() {\n    return this.output;\n  }\n  get output() {\n    if (this._output == null) {\n      throw new NoOutputGeneratedError();\n    }\n    return this._output;\n  }\n};\nfunction asToolCalls(content) {\n  const parts = content.filter(\n    (part) => part.type === \"tool-call\"\n  );\n  if (parts.length === 0) {\n    return void 0;\n  }\n  return parts.map((toolCall) => ({\n    toolCallId: toolCall.toolCallId,\n    toolName: toolCall.toolName,\n    input: toolCall.input\n  }));\n}\nfunction asContent({\n  content,\n  toolCalls,\n  toolOutputs,\n  toolApprovalRequests,\n  tools\n}) {\n  const contentParts = [];\n  for (const part of content) {\n    switch (part.type) {\n      case \"text\":\n      case \"reasoning\":\n      case \"source\":\n        contentParts.push(part);\n        break;\n      case \"file\": {\n        contentParts.push({\n          type: \"file\",\n          file: new DefaultGeneratedFile(part),\n          ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n        });\n        break;\n      }\n      case \"tool-call\": {\n        contentParts.push(\n          toolCalls.find((toolCall) => toolCall.toolCallId === part.toolCallId)\n        );\n        break;\n      }\n      case \"tool-result\": {\n        const toolCall = toolCalls.find(\n          (toolCall2) => toolCall2.toolCallId === part.toolCallId\n        );\n        if (toolCall == null) {\n          const tool2 = tools == null ? void 0 : tools[part.toolName];\n          const supportsDeferredResults = (tool2 == null ? void 0 : tool2.type) === \"provider\" && tool2.supportsDeferredResults;\n          if (!supportsDeferredResults) {\n            throw new Error(`Tool call ${part.toolCallId} not found.`);\n          }\n          if (part.isError) {\n            contentParts.push({\n              type: \"tool-error\",\n              toolCallId: part.toolCallId,\n              toolName: part.toolName,\n              input: void 0,\n              error: part.result,\n              providerExecuted: true,\n              dynamic: part.dynamic\n            });\n          } else {\n            contentParts.push({\n              type: \"tool-result\",\n              toolCallId: part.toolCallId,\n              toolName: part.toolName,\n              input: void 0,\n              output: part.result,\n              providerExecuted: true,\n              dynamic: part.dynamic\n            });\n          }\n          break;\n        }\n        if (part.isError) {\n          contentParts.push({\n            type: \"tool-error\",\n            toolCallId: part.toolCallId,\n            toolName: part.toolName,\n            input: toolCall.input,\n            error: part.result,\n            providerExecuted: true,\n            dynamic: toolCall.dynamic\n          });\n        } else {\n          contentParts.push({\n            type: \"tool-result\",\n            toolCallId: part.toolCallId,\n            toolName: part.toolName,\n            input: toolCall.input,\n            output: part.result,\n            providerExecuted: true,\n            dynamic: toolCall.dynamic\n          });\n        }\n        break;\n      }\n      case \"tool-approval-request\": {\n        const toolCall = toolCalls.find(\n          (toolCall2) => toolCall2.toolCallId === part.toolCallId\n        );\n        if (toolCall == null) {\n          throw new ToolCallNotFoundForApprovalError({\n            toolCallId: part.toolCallId,\n            approvalId: part.approvalId\n          });\n        }\n        contentParts.push({\n          type: \"tool-approval-request\",\n          approvalId: part.approvalId,\n          toolCall\n        });\n        break;\n      }\n    }\n  }\n  return [...contentParts, ...toolOutputs, ...toolApprovalRequests];\n}\n\n// src/generate-text/stream-text.ts\n\n\n\n// src/util/prepare-headers.ts\nfunction prepareHeaders(headers, defaultHeaders) {\n  const responseHeaders = new Headers(headers != null ? headers : {});\n  for (const [key, value] of Object.entries(defaultHeaders)) {\n    if (!responseHeaders.has(key)) {\n      responseHeaders.set(key, value);\n    }\n  }\n  return responseHeaders;\n}\n\n// src/text-stream/create-text-stream-response.ts\nfunction createTextStreamResponse({\n  status,\n  statusText,\n  headers,\n  textStream\n}) {\n  return new Response(textStream.pipeThrough(new TextEncoderStream()), {\n    status: status != null ? status : 200,\n    statusText,\n    headers: prepareHeaders(headers, {\n      \"content-type\": \"text/plain; charset=utf-8\"\n    })\n  });\n}\n\n// src/util/write-to-server-response.ts\nfunction writeToServerResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  stream\n}) {\n  const statusCode = status != null ? status : 200;\n  if (statusText !== void 0) {\n    response.writeHead(statusCode, statusText, headers);\n  } else {\n    response.writeHead(statusCode, headers);\n  }\n  const reader = stream.getReader();\n  const read = async () => {\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done)\n          break;\n        const canContinue = response.write(value);\n        if (!canContinue) {\n          await new Promise((resolve3) => {\n            response.once(\"drain\", resolve3);\n          });\n        }\n      }\n    } catch (error) {\n      throw error;\n    } finally {\n      response.end();\n    }\n  };\n  read();\n}\n\n// src/text-stream/pipe-text-stream-to-response.ts\nfunction pipeTextStreamToResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  textStream\n}) {\n  writeToServerResponse({\n    response,\n    status,\n    statusText,\n    headers: Object.fromEntries(\n      prepareHeaders(headers, {\n        \"content-type\": \"text/plain; charset=utf-8\"\n      }).entries()\n    ),\n    stream: textStream.pipeThrough(new TextEncoderStream())\n  });\n}\n\n// src/ui-message-stream/json-to-sse-transform-stream.ts\nvar JsonToSseTransformStream = class extends TransformStream {\n  constructor() {\n    super({\n      transform(part, controller) {\n        controller.enqueue(`data: ${JSON.stringify(part)}\n\n`);\n      },\n      flush(controller) {\n        controller.enqueue(\"data: [DONE]\\n\\n\");\n      }\n    });\n  }\n};\n\n// src/ui-message-stream/ui-message-stream-headers.ts\nvar UI_MESSAGE_STREAM_HEADERS = {\n  \"content-type\": \"text/event-stream\",\n  \"cache-control\": \"no-cache\",\n  connection: \"keep-alive\",\n  \"x-vercel-ai-ui-message-stream\": \"v1\",\n  \"x-accel-buffering\": \"no\"\n  // disable nginx buffering\n};\n\n// src/ui-message-stream/create-ui-message-stream-response.ts\nfunction createUIMessageStreamResponse({\n  status,\n  statusText,\n  headers,\n  stream,\n  consumeSseStream\n}) {\n  let sseStream = stream.pipeThrough(new JsonToSseTransformStream());\n  if (consumeSseStream) {\n    const [stream1, stream2] = sseStream.tee();\n    sseStream = stream1;\n    consumeSseStream({ stream: stream2 });\n  }\n  return new Response(sseStream.pipeThrough(new TextEncoderStream()), {\n    status,\n    statusText,\n    headers: prepareHeaders(headers, UI_MESSAGE_STREAM_HEADERS)\n  });\n}\n\n// src/ui-message-stream/get-response-ui-message-id.ts\nfunction getResponseUIMessageId({\n  originalMessages,\n  responseMessageId\n}) {\n  if (originalMessages == null) {\n    return void 0;\n  }\n  const lastMessage = originalMessages[originalMessages.length - 1];\n  return (lastMessage == null ? void 0 : lastMessage.role) === \"assistant\" ? lastMessage.id : typeof responseMessageId === \"function\" ? responseMessageId() : responseMessageId;\n}\n\n// src/ui/process-ui-message-stream.ts\n\n\n// src/ui-message-stream/ui-message-chunks.ts\n\n\nvar uiMessageChunkSchema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.lazySchema)(\n  () => (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.zodSchema)(\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"text-start\"),\n        id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        providerMetadata: providerMetadataSchema.optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"text-delta\"),\n        id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        delta: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        providerMetadata: providerMetadataSchema.optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"text-end\"),\n        id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        providerMetadata: providerMetadataSchema.optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"error\"),\n        errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-input-start\"),\n        toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n        providerMetadata: providerMetadataSchema.optional(),\n        dynamic: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n        title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-input-delta\"),\n        toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        inputTextDelta: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-input-available\"),\n        toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n        providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n        providerMetadata: providerMetadataSchema.optional(),\n        dynamic: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n        title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-input-error\"),\n        toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n        providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n        providerMetadata: providerMetadataSchema.optional(),\n        dynamic: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n        errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-approval-request\"),\n        approvalId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-output-available\"),\n        toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n        providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n        dynamic: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n        preliminary: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-output-error\"),\n        toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n        dynamic: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-output-denied\"),\n        toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"reasoning-start\"),\n        id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        providerMetadata: providerMetadataSchema.optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"reasoning-delta\"),\n        id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        delta: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        providerMetadata: providerMetadataSchema.optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"reasoning-end\"),\n        id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        providerMetadata: providerMetadataSchema.optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"source-url\"),\n        sourceId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n        providerMetadata: providerMetadataSchema.optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"source-document\"),\n        sourceId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        filename: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n        providerMetadata: providerMetadataSchema.optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"file\"),\n        url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        providerMetadata: providerMetadataSchema.optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.custom(\n          (value) => typeof value === \"string\" && value.startsWith(\"data-\"),\n          { message: 'Type must start with \"data-\"' }\n        ),\n        id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n        data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n        transient: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"start-step\")\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"finish-step\")\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"start\"),\n        messageId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n        messageMetadata: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown().optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"finish\"),\n        finishReason: zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"enum\"]([\n          \"stop\",\n          \"length\",\n          \"content-filter\",\n          \"tool-calls\",\n          \"error\",\n          \"other\"\n        ]).optional(),\n        messageMetadata: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown().optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"abort\"),\n        reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"message-metadata\"),\n        messageMetadata: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown()\n      })\n    ])\n  )\n);\nfunction isDataUIMessageChunk(chunk) {\n  return chunk.type.startsWith(\"data-\");\n}\n\n// src/ui/ui-messages.ts\nfunction isDataUIPart(part) {\n  return part.type.startsWith(\"data-\");\n}\nfunction isTextUIPart(part) {\n  return part.type === \"text\";\n}\nfunction isFileUIPart(part) {\n  return part.type === \"file\";\n}\nfunction isReasoningUIPart(part) {\n  return part.type === \"reasoning\";\n}\nfunction isStaticToolUIPart(part) {\n  return part.type.startsWith(\"tool-\");\n}\nfunction isDynamicToolUIPart(part) {\n  return part.type === \"dynamic-tool\";\n}\nfunction isToolUIPart(part) {\n  return isStaticToolUIPart(part) || isDynamicToolUIPart(part);\n}\nvar isToolOrDynamicToolUIPart = isToolUIPart;\nfunction getStaticToolName(part) {\n  return part.type.split(\"-\").slice(1).join(\"-\");\n}\nfunction getToolName(part) {\n  return isDynamicToolUIPart(part) ? part.toolName : getStaticToolName(part);\n}\nvar getToolOrDynamicToolName = getToolName;\n\n// src/ui/process-ui-message-stream.ts\nfunction createStreamingUIMessageState({\n  lastMessage,\n  messageId\n}) {\n  return {\n    message: (lastMessage == null ? void 0 : lastMessage.role) === \"assistant\" ? lastMessage : {\n      id: messageId,\n      metadata: void 0,\n      role: \"assistant\",\n      parts: []\n    },\n    activeTextParts: {},\n    activeReasoningParts: {},\n    partialToolCalls: {}\n  };\n}\nfunction processUIMessageStream({\n  stream,\n  messageMetadataSchema,\n  dataPartSchemas,\n  runUpdateMessageJob,\n  onError,\n  onToolCall,\n  onData\n}) {\n  return stream.pipeThrough(\n    new TransformStream({\n      async transform(chunk, controller) {\n        await runUpdateMessageJob(async ({ state, write }) => {\n          var _a21, _b, _c, _d;\n          function getToolInvocation(toolCallId) {\n            const toolInvocations = state.message.parts.filter(isToolUIPart);\n            const toolInvocation = toolInvocations.find(\n              (invocation) => invocation.toolCallId === toolCallId\n            );\n            if (toolInvocation == null) {\n              throw new UIMessageStreamError({\n                chunkType: \"tool-invocation\",\n                chunkId: toolCallId,\n                message: `No tool invocation found for tool call ID \"${toolCallId}\".`\n              });\n            }\n            return toolInvocation;\n          }\n          function updateToolPart(options) {\n            var _a22;\n            const part = state.message.parts.find(\n              (part2) => isStaticToolUIPart(part2) && part2.toolCallId === options.toolCallId\n            );\n            const anyOptions = options;\n            const anyPart = part;\n            if (part != null) {\n              part.state = options.state;\n              anyPart.input = anyOptions.input;\n              anyPart.output = anyOptions.output;\n              anyPart.errorText = anyOptions.errorText;\n              anyPart.rawInput = anyOptions.rawInput;\n              anyPart.preliminary = anyOptions.preliminary;\n              if (options.title !== void 0) {\n                anyPart.title = options.title;\n              }\n              anyPart.providerExecuted = (_a22 = anyOptions.providerExecuted) != null ? _a22 : part.providerExecuted;\n              if (anyOptions.providerMetadata != null) {\n                part.callProviderMetadata = anyOptions.providerMetadata;\n              }\n            } else {\n              state.message.parts.push({\n                type: `tool-${options.toolName}`,\n                toolCallId: options.toolCallId,\n                state: options.state,\n                title: options.title,\n                input: anyOptions.input,\n                output: anyOptions.output,\n                rawInput: anyOptions.rawInput,\n                errorText: anyOptions.errorText,\n                providerExecuted: anyOptions.providerExecuted,\n                preliminary: anyOptions.preliminary,\n                ...anyOptions.providerMetadata != null ? { callProviderMetadata: anyOptions.providerMetadata } : {}\n              });\n            }\n          }\n          function updateDynamicToolPart(options) {\n            var _a22, _b2;\n            const part = state.message.parts.find(\n              (part2) => part2.type === \"dynamic-tool\" && part2.toolCallId === options.toolCallId\n            );\n            const anyOptions = options;\n            const anyPart = part;\n            if (part != null) {\n              part.state = options.state;\n              anyPart.toolName = options.toolName;\n              anyPart.input = anyOptions.input;\n              anyPart.output = anyOptions.output;\n              anyPart.errorText = anyOptions.errorText;\n              anyPart.rawInput = (_a22 = anyOptions.rawInput) != null ? _a22 : anyPart.rawInput;\n              anyPart.preliminary = anyOptions.preliminary;\n              if (options.title !== void 0) {\n                anyPart.title = options.title;\n              }\n              anyPart.providerExecuted = (_b2 = anyOptions.providerExecuted) != null ? _b2 : part.providerExecuted;\n              if (anyOptions.providerMetadata != null) {\n                part.callProviderMetadata = anyOptions.providerMetadata;\n              }\n            } else {\n              state.message.parts.push({\n                type: \"dynamic-tool\",\n                toolName: options.toolName,\n                toolCallId: options.toolCallId,\n                state: options.state,\n                input: anyOptions.input,\n                output: anyOptions.output,\n                errorText: anyOptions.errorText,\n                preliminary: anyOptions.preliminary,\n                providerExecuted: anyOptions.providerExecuted,\n                title: options.title,\n                ...anyOptions.providerMetadata != null ? { callProviderMetadata: anyOptions.providerMetadata } : {}\n              });\n            }\n          }\n          async function updateMessageMetadata(metadata) {\n            if (metadata != null) {\n              const mergedMetadata = state.message.metadata != null ? mergeObjects(state.message.metadata, metadata) : metadata;\n              if (messageMetadataSchema != null) {\n                await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n                  value: mergedMetadata,\n                  schema: messageMetadataSchema,\n                  context: {\n                    field: \"message.metadata\",\n                    entityId: state.message.id\n                  }\n                });\n              }\n              state.message.metadata = mergedMetadata;\n            }\n          }\n          switch (chunk.type) {\n            case \"text-start\": {\n              const textPart = {\n                type: \"text\",\n                text: \"\",\n                providerMetadata: chunk.providerMetadata,\n                state: \"streaming\"\n              };\n              state.activeTextParts[chunk.id] = textPart;\n              state.message.parts.push(textPart);\n              write();\n              break;\n            }\n            case \"text-delta\": {\n              const textPart = state.activeTextParts[chunk.id];\n              if (textPart == null) {\n                throw new UIMessageStreamError({\n                  chunkType: \"text-delta\",\n                  chunkId: chunk.id,\n                  message: `Received text-delta for missing text part with ID \"${chunk.id}\". Ensure a \"text-start\" chunk is sent before any \"text-delta\" chunks.`\n                });\n              }\n              textPart.text += chunk.delta;\n              textPart.providerMetadata = (_a21 = chunk.providerMetadata) != null ? _a21 : textPart.providerMetadata;\n              write();\n              break;\n            }\n            case \"text-end\": {\n              const textPart = state.activeTextParts[chunk.id];\n              if (textPart == null) {\n                throw new UIMessageStreamError({\n                  chunkType: \"text-end\",\n                  chunkId: chunk.id,\n                  message: `Received text-end for missing text part with ID \"${chunk.id}\". Ensure a \"text-start\" chunk is sent before any \"text-end\" chunks.`\n                });\n              }\n              textPart.state = \"done\";\n              textPart.providerMetadata = (_b = chunk.providerMetadata) != null ? _b : textPart.providerMetadata;\n              delete state.activeTextParts[chunk.id];\n              write();\n              break;\n            }\n            case \"reasoning-start\": {\n              const reasoningPart = {\n                type: \"reasoning\",\n                text: \"\",\n                providerMetadata: chunk.providerMetadata,\n                state: \"streaming\"\n              };\n              state.activeReasoningParts[chunk.id] = reasoningPart;\n              state.message.parts.push(reasoningPart);\n              write();\n              break;\n            }\n            case \"reasoning-delta\": {\n              const reasoningPart = state.activeReasoningParts[chunk.id];\n              if (reasoningPart == null) {\n                throw new UIMessageStreamError({\n                  chunkType: \"reasoning-delta\",\n                  chunkId: chunk.id,\n                  message: `Received reasoning-delta for missing reasoning part with ID \"${chunk.id}\". Ensure a \"reasoning-start\" chunk is sent before any \"reasoning-delta\" chunks.`\n                });\n              }\n              reasoningPart.text += chunk.delta;\n              reasoningPart.providerMetadata = (_c = chunk.providerMetadata) != null ? _c : reasoningPart.providerMetadata;\n              write();\n              break;\n            }\n            case \"reasoning-end\": {\n              const reasoningPart = state.activeReasoningParts[chunk.id];\n              if (reasoningPart == null) {\n                throw new UIMessageStreamError({\n                  chunkType: \"reasoning-end\",\n                  chunkId: chunk.id,\n                  message: `Received reasoning-end for missing reasoning part with ID \"${chunk.id}\". Ensure a \"reasoning-start\" chunk is sent before any \"reasoning-end\" chunks.`\n                });\n              }\n              reasoningPart.providerMetadata = (_d = chunk.providerMetadata) != null ? _d : reasoningPart.providerMetadata;\n              reasoningPart.state = \"done\";\n              delete state.activeReasoningParts[chunk.id];\n              write();\n              break;\n            }\n            case \"file\": {\n              state.message.parts.push({\n                type: \"file\",\n                mediaType: chunk.mediaType,\n                url: chunk.url\n              });\n              write();\n              break;\n            }\n            case \"source-url\": {\n              state.message.parts.push({\n                type: \"source-url\",\n                sourceId: chunk.sourceId,\n                url: chunk.url,\n                title: chunk.title,\n                providerMetadata: chunk.providerMetadata\n              });\n              write();\n              break;\n            }\n            case \"source-document\": {\n              state.message.parts.push({\n                type: \"source-document\",\n                sourceId: chunk.sourceId,\n                mediaType: chunk.mediaType,\n                title: chunk.title,\n                filename: chunk.filename,\n                providerMetadata: chunk.providerMetadata\n              });\n              write();\n              break;\n            }\n            case \"tool-input-start\": {\n              const toolInvocations = state.message.parts.filter(isStaticToolUIPart);\n              state.partialToolCalls[chunk.toolCallId] = {\n                text: \"\",\n                toolName: chunk.toolName,\n                index: toolInvocations.length,\n                dynamic: chunk.dynamic,\n                title: chunk.title\n              };\n              if (chunk.dynamic) {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"input-streaming\",\n                  input: void 0,\n                  providerExecuted: chunk.providerExecuted,\n                  title: chunk.title,\n                  providerMetadata: chunk.providerMetadata\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"input-streaming\",\n                  input: void 0,\n                  providerExecuted: chunk.providerExecuted,\n                  title: chunk.title,\n                  providerMetadata: chunk.providerMetadata\n                });\n              }\n              write();\n              break;\n            }\n            case \"tool-input-delta\": {\n              const partialToolCall = state.partialToolCalls[chunk.toolCallId];\n              if (partialToolCall == null) {\n                throw new UIMessageStreamError({\n                  chunkType: \"tool-input-delta\",\n                  chunkId: chunk.toolCallId,\n                  message: `Received tool-input-delta for missing tool call with ID \"${chunk.toolCallId}\". Ensure a \"tool-input-start\" chunk is sent before any \"tool-input-delta\" chunks.`\n                });\n              }\n              partialToolCall.text += chunk.inputTextDelta;\n              const { value: partialArgs } = await parsePartialJson(\n                partialToolCall.text\n              );\n              if (partialToolCall.dynamic) {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: partialToolCall.toolName,\n                  state: \"input-streaming\",\n                  input: partialArgs,\n                  title: partialToolCall.title\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: partialToolCall.toolName,\n                  state: \"input-streaming\",\n                  input: partialArgs,\n                  title: partialToolCall.title\n                });\n              }\n              write();\n              break;\n            }\n            case \"tool-input-available\": {\n              if (chunk.dynamic) {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"input-available\",\n                  input: chunk.input,\n                  providerExecuted: chunk.providerExecuted,\n                  providerMetadata: chunk.providerMetadata,\n                  title: chunk.title\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"input-available\",\n                  input: chunk.input,\n                  providerExecuted: chunk.providerExecuted,\n                  providerMetadata: chunk.providerMetadata,\n                  title: chunk.title\n                });\n              }\n              write();\n              if (onToolCall && !chunk.providerExecuted) {\n                await onToolCall({\n                  toolCall: chunk\n                });\n              }\n              break;\n            }\n            case \"tool-input-error\": {\n              if (chunk.dynamic) {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"output-error\",\n                  input: chunk.input,\n                  errorText: chunk.errorText,\n                  providerExecuted: chunk.providerExecuted,\n                  providerMetadata: chunk.providerMetadata\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"output-error\",\n                  input: void 0,\n                  rawInput: chunk.input,\n                  errorText: chunk.errorText,\n                  providerExecuted: chunk.providerExecuted,\n                  providerMetadata: chunk.providerMetadata\n                });\n              }\n              write();\n              break;\n            }\n            case \"tool-approval-request\": {\n              const toolInvocation = getToolInvocation(chunk.toolCallId);\n              toolInvocation.state = \"approval-requested\";\n              toolInvocation.approval = { id: chunk.approvalId };\n              write();\n              break;\n            }\n            case \"tool-output-denied\": {\n              const toolInvocation = getToolInvocation(chunk.toolCallId);\n              toolInvocation.state = \"output-denied\";\n              write();\n              break;\n            }\n            case \"tool-output-available\": {\n              const toolInvocation = getToolInvocation(chunk.toolCallId);\n              if (toolInvocation.type === \"dynamic-tool\") {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: toolInvocation.toolName,\n                  state: \"output-available\",\n                  input: toolInvocation.input,\n                  output: chunk.output,\n                  preliminary: chunk.preliminary,\n                  providerExecuted: chunk.providerExecuted,\n                  title: toolInvocation.title\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: getStaticToolName(toolInvocation),\n                  state: \"output-available\",\n                  input: toolInvocation.input,\n                  output: chunk.output,\n                  providerExecuted: chunk.providerExecuted,\n                  preliminary: chunk.preliminary,\n                  title: toolInvocation.title\n                });\n              }\n              write();\n              break;\n            }\n            case \"tool-output-error\": {\n              const toolInvocation = getToolInvocation(chunk.toolCallId);\n              if (toolInvocation.type === \"dynamic-tool\") {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: toolInvocation.toolName,\n                  state: \"output-error\",\n                  input: toolInvocation.input,\n                  errorText: chunk.errorText,\n                  providerExecuted: chunk.providerExecuted,\n                  title: toolInvocation.title\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: getStaticToolName(toolInvocation),\n                  state: \"output-error\",\n                  input: toolInvocation.input,\n                  rawInput: toolInvocation.rawInput,\n                  errorText: chunk.errorText,\n                  providerExecuted: chunk.providerExecuted,\n                  title: toolInvocation.title\n                });\n              }\n              write();\n              break;\n            }\n            case \"start-step\": {\n              state.message.parts.push({ type: \"step-start\" });\n              break;\n            }\n            case \"finish-step\": {\n              state.activeTextParts = {};\n              state.activeReasoningParts = {};\n              break;\n            }\n            case \"start\": {\n              if (chunk.messageId != null) {\n                state.message.id = chunk.messageId;\n              }\n              await updateMessageMetadata(chunk.messageMetadata);\n              if (chunk.messageId != null || chunk.messageMetadata != null) {\n                write();\n              }\n              break;\n            }\n            case \"finish\": {\n              if (chunk.finishReason != null) {\n                state.finishReason = chunk.finishReason;\n              }\n              await updateMessageMetadata(chunk.messageMetadata);\n              if (chunk.messageMetadata != null) {\n                write();\n              }\n              break;\n            }\n            case \"message-metadata\": {\n              await updateMessageMetadata(chunk.messageMetadata);\n              if (chunk.messageMetadata != null) {\n                write();\n              }\n              break;\n            }\n            case \"error\": {\n              onError == null ? void 0 : onError(new Error(chunk.errorText));\n              break;\n            }\n            default: {\n              if (isDataUIMessageChunk(chunk)) {\n                if ((dataPartSchemas == null ? void 0 : dataPartSchemas[chunk.type]) != null) {\n                  const partIdx = state.message.parts.findIndex(\n                    (p) => \"id\" in p && \"data\" in p && p.id === chunk.id && p.type === chunk.type\n                  );\n                  const actualPartIdx = partIdx >= 0 ? partIdx : state.message.parts.length;\n                  await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n                    value: chunk.data,\n                    schema: dataPartSchemas[chunk.type],\n                    context: {\n                      field: `message.parts[${actualPartIdx}].data`,\n                      entityName: chunk.type,\n                      entityId: chunk.id\n                    }\n                  });\n                }\n                const dataChunk = chunk;\n                if (dataChunk.transient) {\n                  onData == null ? void 0 : onData(dataChunk);\n                  break;\n                }\n                const existingUIPart = dataChunk.id != null ? state.message.parts.find(\n                  (chunkArg) => dataChunk.type === chunkArg.type && dataChunk.id === chunkArg.id\n                ) : void 0;\n                if (existingUIPart != null) {\n                  existingUIPart.data = dataChunk.data;\n                } else {\n                  state.message.parts.push(dataChunk);\n                }\n                onData == null ? void 0 : onData(dataChunk);\n                write();\n              }\n            }\n          }\n          controller.enqueue(chunk);\n        });\n      }\n    })\n  );\n}\n\n// src/ui-message-stream/handle-ui-message-stream-finish.ts\nfunction handleUIMessageStreamFinish({\n  messageId,\n  originalMessages = [],\n  onStepFinish,\n  onFinish,\n  onError,\n  stream\n}) {\n  let lastMessage = originalMessages == null ? void 0 : originalMessages[originalMessages.length - 1];\n  if ((lastMessage == null ? void 0 : lastMessage.role) !== \"assistant\") {\n    lastMessage = void 0;\n  } else {\n    messageId = lastMessage.id;\n  }\n  let isAborted = false;\n  const idInjectedStream = stream.pipeThrough(\n    new TransformStream({\n      transform(chunk, controller) {\n        if (chunk.type === \"start\") {\n          const startChunk = chunk;\n          if (startChunk.messageId == null && messageId != null) {\n            startChunk.messageId = messageId;\n          }\n        }\n        if (chunk.type === \"abort\") {\n          isAborted = true;\n        }\n        controller.enqueue(chunk);\n      }\n    })\n  );\n  if (onFinish == null && onStepFinish == null) {\n    return idInjectedStream;\n  }\n  const state = createStreamingUIMessageState({\n    lastMessage: lastMessage ? structuredClone(lastMessage) : void 0,\n    messageId: messageId != null ? messageId : \"\"\n    // will be overridden by the stream\n  });\n  const runUpdateMessageJob = async (job) => {\n    await job({ state, write: () => {\n    } });\n  };\n  let finishCalled = false;\n  const callOnFinish = async () => {\n    if (finishCalled || !onFinish) {\n      return;\n    }\n    finishCalled = true;\n    const isContinuation = state.message.id === (lastMessage == null ? void 0 : lastMessage.id);\n    await onFinish({\n      isAborted,\n      isContinuation,\n      responseMessage: state.message,\n      messages: [\n        ...isContinuation ? originalMessages.slice(0, -1) : originalMessages,\n        state.message\n      ],\n      finishReason: state.finishReason\n    });\n  };\n  const callOnStepFinish = async () => {\n    if (!onStepFinish) {\n      return;\n    }\n    const isContinuation = state.message.id === (lastMessage == null ? void 0 : lastMessage.id);\n    try {\n      await onStepFinish({\n        isContinuation,\n        responseMessage: structuredClone(state.message),\n        messages: [\n          ...isContinuation ? originalMessages.slice(0, -1) : originalMessages,\n          structuredClone(state.message)\n        ]\n      });\n    } catch (error) {\n      onError(error);\n    }\n  };\n  return processUIMessageStream({\n    stream: idInjectedStream,\n    runUpdateMessageJob,\n    onError\n  }).pipeThrough(\n    new TransformStream({\n      async transform(chunk, controller) {\n        if (chunk.type === \"finish-step\") {\n          await callOnStepFinish();\n        }\n        controller.enqueue(chunk);\n      },\n      // @ts-expect-error cancel is still new and missing from types https://developer.mozilla.org/en-US/docs/Web/API/TransformStream#browser_compatibility\n      async cancel() {\n        await callOnFinish();\n      },\n      async flush() {\n        await callOnFinish();\n      }\n    })\n  );\n}\n\n// src/ui-message-stream/pipe-ui-message-stream-to-response.ts\nfunction pipeUIMessageStreamToResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  stream,\n  consumeSseStream\n}) {\n  let sseStream = stream.pipeThrough(new JsonToSseTransformStream());\n  if (consumeSseStream) {\n    const [stream1, stream2] = sseStream.tee();\n    sseStream = stream1;\n    consumeSseStream({ stream: stream2 });\n  }\n  writeToServerResponse({\n    response,\n    status,\n    statusText,\n    headers: Object.fromEntries(\n      prepareHeaders(headers, UI_MESSAGE_STREAM_HEADERS).entries()\n    ),\n    stream: sseStream.pipeThrough(new TextEncoderStream())\n  });\n}\n\n// src/util/async-iterable-stream.ts\nfunction createAsyncIterableStream(source) {\n  const stream = source.pipeThrough(new TransformStream());\n  stream[Symbol.asyncIterator] = function() {\n    const reader = this.getReader();\n    let finished = false;\n    async function cleanup(cancelStream) {\n      var _a21;\n      if (finished)\n        return;\n      finished = true;\n      try {\n        if (cancelStream) {\n          await ((_a21 = reader.cancel) == null ? void 0 : _a21.call(reader));\n        }\n      } finally {\n        try {\n          reader.releaseLock();\n        } catch (e) {\n        }\n      }\n    }\n    return {\n      /**\n       * Reads the next chunk from the stream.\n       * @returns A promise resolving to the next IteratorResult.\n       */\n      async next() {\n        if (finished) {\n          return { done: true, value: void 0 };\n        }\n        const { done, value } = await reader.read();\n        if (done) {\n          await cleanup(true);\n          return { done: true, value: void 0 };\n        }\n        return { done: false, value };\n      },\n      /**\n       * May be called on early exit (e.g., break from for-await) or after completion.\n       * Ensures the stream is cancelled and resources are released.\n       * @returns A promise resolving to a completed IteratorResult.\n       */\n      async return() {\n        await cleanup(true);\n        return { done: true, value: void 0 };\n      },\n      /**\n       * Called on early exit with error.\n       * Ensures the stream is cancelled and resources are released, then rethrows the error.\n       * @param err The error to throw.\n       * @returns A promise that rejects with the provided error.\n       */\n      async throw(err) {\n        await cleanup(true);\n        throw err;\n      }\n    };\n  };\n  return stream;\n}\n\n// src/util/consume-stream.ts\nasync function consumeStream({\n  stream,\n  onError\n}) {\n  const reader = stream.getReader();\n  try {\n    while (true) {\n      const { done } = await reader.read();\n      if (done)\n        break;\n    }\n  } catch (error) {\n    onError == null ? void 0 : onError(error);\n  } finally {\n    reader.releaseLock();\n  }\n}\n\n// src/util/create-resolvable-promise.ts\nfunction createResolvablePromise() {\n  let resolve3;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve3 = res;\n    reject = rej;\n  });\n  return {\n    promise,\n    resolve: resolve3,\n    reject\n  };\n}\n\n// src/util/create-stitchable-stream.ts\nfunction createStitchableStream() {\n  let innerStreamReaders = [];\n  let controller = null;\n  let isClosed = false;\n  let waitForNewStream = createResolvablePromise();\n  const terminate = () => {\n    isClosed = true;\n    waitForNewStream.resolve();\n    innerStreamReaders.forEach((reader) => reader.cancel());\n    innerStreamReaders = [];\n    controller == null ? void 0 : controller.close();\n  };\n  const processPull = async () => {\n    if (isClosed && innerStreamReaders.length === 0) {\n      controller == null ? void 0 : controller.close();\n      return;\n    }\n    if (innerStreamReaders.length === 0) {\n      waitForNewStream = createResolvablePromise();\n      await waitForNewStream.promise;\n      return processPull();\n    }\n    try {\n      const { value, done } = await innerStreamReaders[0].read();\n      if (done) {\n        innerStreamReaders.shift();\n        if (innerStreamReaders.length === 0 && isClosed) {\n          controller == null ? void 0 : controller.close();\n        } else {\n          await processPull();\n        }\n      } else {\n        controller == null ? void 0 : controller.enqueue(value);\n      }\n    } catch (error) {\n      controller == null ? void 0 : controller.error(error);\n      innerStreamReaders.shift();\n      terminate();\n    }\n  };\n  return {\n    stream: new ReadableStream({\n      start(controllerParam) {\n        controller = controllerParam;\n      },\n      pull: processPull,\n      async cancel() {\n        for (const reader of innerStreamReaders) {\n          await reader.cancel();\n        }\n        innerStreamReaders = [];\n        isClosed = true;\n      }\n    }),\n    addStream: (innerStream) => {\n      if (isClosed) {\n        throw new Error(\"Cannot add inner stream: outer stream is closed\");\n      }\n      innerStreamReaders.push(innerStream.getReader());\n      waitForNewStream.resolve();\n    },\n    /**\n     * Gracefully close the outer stream. This will let the inner streams\n     * finish processing and then close the outer stream.\n     */\n    close: () => {\n      isClosed = true;\n      waitForNewStream.resolve();\n      if (innerStreamReaders.length === 0) {\n        controller == null ? void 0 : controller.close();\n      }\n    },\n    /**\n     * Immediately close the outer stream. This will cancel all inner streams\n     * and close the outer stream.\n     */\n    terminate\n  };\n}\n\n// src/generate-text/run-tools-transformation.ts\n\nfunction runToolsTransformation({\n  tools,\n  generatorStream,\n  tracer,\n  telemetry,\n  system,\n  messages,\n  abortSignal,\n  repairToolCall,\n  experimental_context,\n  generateId: generateId2,\n  stepNumber,\n  model,\n  onToolCallStart,\n  onToolCallFinish\n}) {\n  let toolResultsStreamController = null;\n  const toolResultsStream = new ReadableStream({\n    start(controller) {\n      toolResultsStreamController = controller;\n    }\n  });\n  const outstandingToolResults = /* @__PURE__ */ new Set();\n  const toolInputs = /* @__PURE__ */ new Map();\n  const toolCallsByToolCallId = /* @__PURE__ */ new Map();\n  let canClose = false;\n  let finishChunk = void 0;\n  function attemptClose() {\n    if (canClose && outstandingToolResults.size === 0) {\n      if (finishChunk != null) {\n        toolResultsStreamController.enqueue(finishChunk);\n      }\n      toolResultsStreamController.close();\n    }\n  }\n  const forwardStream = new TransformStream({\n    async transform(chunk, controller) {\n      const chunkType = chunk.type;\n      switch (chunkType) {\n        case \"stream-start\":\n        case \"text-start\":\n        case \"text-delta\":\n        case \"text-end\":\n        case \"reasoning-start\":\n        case \"reasoning-delta\":\n        case \"reasoning-end\":\n        case \"tool-input-start\":\n        case \"tool-input-delta\":\n        case \"tool-input-end\":\n        case \"source\":\n        case \"response-metadata\":\n        case \"error\":\n        case \"raw\": {\n          controller.enqueue(chunk);\n          break;\n        }\n        case \"file\": {\n          controller.enqueue({\n            type: \"file\",\n            file: new DefaultGeneratedFileWithType({\n              data: chunk.data,\n              mediaType: chunk.mediaType\n            })\n          });\n          break;\n        }\n        case \"finish\": {\n          finishChunk = {\n            type: \"finish\",\n            finishReason: chunk.finishReason.unified,\n            rawFinishReason: chunk.finishReason.raw,\n            usage: asLanguageModelUsage(chunk.usage),\n            providerMetadata: chunk.providerMetadata\n          };\n          break;\n        }\n        case \"tool-approval-request\": {\n          const toolCall = toolCallsByToolCallId.get(chunk.toolCallId);\n          if (toolCall == null) {\n            toolResultsStreamController.enqueue({\n              type: \"error\",\n              error: new ToolCallNotFoundForApprovalError({\n                toolCallId: chunk.toolCallId,\n                approvalId: chunk.approvalId\n              })\n            });\n            break;\n          }\n          controller.enqueue({\n            type: \"tool-approval-request\",\n            approvalId: chunk.approvalId,\n            toolCall\n          });\n          break;\n        }\n        case \"tool-call\": {\n          try {\n            const toolCall = await parseToolCall({\n              toolCall: chunk,\n              tools,\n              repairToolCall,\n              system,\n              messages\n            });\n            toolCallsByToolCallId.set(toolCall.toolCallId, toolCall);\n            controller.enqueue(toolCall);\n            if (toolCall.invalid) {\n              toolResultsStreamController.enqueue({\n                type: \"tool-error\",\n                toolCallId: toolCall.toolCallId,\n                toolName: toolCall.toolName,\n                input: toolCall.input,\n                error: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getErrorMessage)(toolCall.error),\n                dynamic: true,\n                title: toolCall.title\n              });\n              break;\n            }\n            const tool2 = tools == null ? void 0 : tools[toolCall.toolName];\n            if (tool2 == null) {\n              break;\n            }\n            if (tool2.onInputAvailable != null) {\n              await tool2.onInputAvailable({\n                input: toolCall.input,\n                toolCallId: toolCall.toolCallId,\n                messages,\n                abortSignal,\n                experimental_context\n              });\n            }\n            if (await isApprovalNeeded({\n              tool: tool2,\n              toolCall,\n              messages,\n              experimental_context\n            })) {\n              toolResultsStreamController.enqueue({\n                type: \"tool-approval-request\",\n                approvalId: generateId2(),\n                toolCall\n              });\n              break;\n            }\n            toolInputs.set(toolCall.toolCallId, toolCall.input);\n            if (tool2.execute != null && toolCall.providerExecuted !== true) {\n              const toolExecutionId = generateId2();\n              outstandingToolResults.add(toolExecutionId);\n              executeToolCall({\n                toolCall,\n                tools,\n                tracer,\n                telemetry,\n                messages,\n                abortSignal,\n                experimental_context,\n                stepNumber,\n                model,\n                onToolCallStart,\n                onToolCallFinish,\n                onPreliminaryToolResult: (result) => {\n                  toolResultsStreamController.enqueue(result);\n                }\n              }).then((result) => {\n                toolResultsStreamController.enqueue(result);\n              }).catch((error) => {\n                toolResultsStreamController.enqueue({\n                  type: \"error\",\n                  error\n                });\n              }).finally(() => {\n                outstandingToolResults.delete(toolExecutionId);\n                attemptClose();\n              });\n            }\n          } catch (error) {\n            toolResultsStreamController.enqueue({ type: \"error\", error });\n          }\n          break;\n        }\n        case \"tool-result\": {\n          const toolName = chunk.toolName;\n          if (chunk.isError) {\n            toolResultsStreamController.enqueue({\n              type: \"tool-error\",\n              toolCallId: chunk.toolCallId,\n              toolName,\n              input: toolInputs.get(chunk.toolCallId),\n              providerExecuted: true,\n              error: chunk.result,\n              dynamic: chunk.dynamic\n            });\n          } else {\n            controller.enqueue({\n              type: \"tool-result\",\n              toolCallId: chunk.toolCallId,\n              toolName,\n              input: toolInputs.get(chunk.toolCallId),\n              output: chunk.result,\n              providerExecuted: true,\n              dynamic: chunk.dynamic\n            });\n          }\n          break;\n        }\n        default: {\n          const _exhaustiveCheck = chunkType;\n          throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n    flush() {\n      canClose = true;\n      attemptClose();\n    }\n  });\n  return new ReadableStream({\n    async start(controller) {\n      return Promise.all([\n        generatorStream.pipeThrough(forwardStream).pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n            }\n          })\n        ),\n        toolResultsStream.pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n              controller.close();\n            }\n          })\n        )\n      ]);\n    }\n  });\n}\n\n// src/generate-text/stream-text.ts\nvar originalGenerateId2 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n  prefix: \"aitxt\",\n  size: 24\n});\nfunction streamText({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  timeout,\n  headers,\n  stopWhen = stepCountIs(1),\n  experimental_output,\n  output = experimental_output,\n  experimental_telemetry: telemetry,\n  prepareStep,\n  providerOptions,\n  experimental_activeTools,\n  activeTools = experimental_activeTools,\n  experimental_repairToolCall: repairToolCall,\n  experimental_transform: transform,\n  experimental_download: download2,\n  includeRawChunks = false,\n  onChunk,\n  onError = ({ error }) => {\n    console.error(error);\n  },\n  onFinish,\n  onAbort,\n  onStepFinish,\n  experimental_onStart: onStart,\n  experimental_onStepStart: onStepStart,\n  experimental_onToolCallStart: onToolCallStart,\n  experimental_onToolCallFinish: onToolCallFinish,\n  experimental_context,\n  experimental_include: include,\n  _internal: { now: now2 = now, generateId: generateId2 = originalGenerateId2 } = {},\n  ...settings\n}) {\n  const totalTimeoutMs = getTotalTimeoutMs(timeout);\n  const stepTimeoutMs = getStepTimeoutMs(timeout);\n  const chunkTimeoutMs = getChunkTimeoutMs(timeout);\n  const stepAbortController = stepTimeoutMs != null ? new AbortController() : void 0;\n  const chunkAbortController = chunkTimeoutMs != null ? new AbortController() : void 0;\n  return new DefaultStreamTextResult({\n    model: resolveLanguageModel(model),\n    telemetry,\n    headers,\n    settings,\n    maxRetries,\n    abortSignal: mergeAbortSignals(\n      abortSignal,\n      totalTimeoutMs != null ? AbortSignal.timeout(totalTimeoutMs) : void 0,\n      stepAbortController == null ? void 0 : stepAbortController.signal,\n      chunkAbortController == null ? void 0 : chunkAbortController.signal\n    ),\n    stepTimeoutMs,\n    stepAbortController,\n    chunkTimeoutMs,\n    chunkAbortController,\n    system,\n    prompt,\n    messages,\n    tools,\n    toolChoice,\n    transforms: asArray(transform),\n    activeTools,\n    repairToolCall,\n    stopConditions: asArray(stopWhen),\n    output,\n    providerOptions,\n    prepareStep,\n    includeRawChunks,\n    timeout,\n    stopWhen,\n    originalAbortSignal: abortSignal,\n    onChunk,\n    onError,\n    onFinish,\n    onAbort,\n    onStepFinish,\n    onStart,\n    onStepStart,\n    onToolCallStart,\n    onToolCallFinish,\n    now: now2,\n    generateId: generateId2,\n    experimental_context,\n    download: download2,\n    include\n  });\n}\nfunction createOutputTransformStream(output) {\n  let firstTextChunkId = void 0;\n  let text2 = \"\";\n  let textChunk = \"\";\n  let textProviderMetadata = void 0;\n  let lastPublishedJson = \"\";\n  function publishTextChunk({\n    controller,\n    partialOutput = void 0\n  }) {\n    controller.enqueue({\n      part: {\n        type: \"text-delta\",\n        id: firstTextChunkId,\n        text: textChunk,\n        providerMetadata: textProviderMetadata\n      },\n      partialOutput\n    });\n    textChunk = \"\";\n  }\n  return new TransformStream({\n    async transform(chunk, controller) {\n      var _a21;\n      if (chunk.type === \"finish-step\" && textChunk.length > 0) {\n        publishTextChunk({ controller });\n      }\n      if (chunk.type !== \"text-delta\" && chunk.type !== \"text-start\" && chunk.type !== \"text-end\") {\n        controller.enqueue({ part: chunk, partialOutput: void 0 });\n        return;\n      }\n      if (firstTextChunkId == null) {\n        firstTextChunkId = chunk.id;\n      } else if (chunk.id !== firstTextChunkId) {\n        controller.enqueue({ part: chunk, partialOutput: void 0 });\n        return;\n      }\n      if (chunk.type === \"text-start\") {\n        controller.enqueue({ part: chunk, partialOutput: void 0 });\n        return;\n      }\n      if (chunk.type === \"text-end\") {\n        if (textChunk.length > 0) {\n          publishTextChunk({ controller });\n        }\n        controller.enqueue({ part: chunk, partialOutput: void 0 });\n        return;\n      }\n      text2 += chunk.text;\n      textChunk += chunk.text;\n      textProviderMetadata = (_a21 = chunk.providerMetadata) != null ? _a21 : textProviderMetadata;\n      const result = await output.parsePartialOutput({ text: text2 });\n      if (result !== void 0) {\n        const currentJson = JSON.stringify(result.partial);\n        if (currentJson !== lastPublishedJson) {\n          publishTextChunk({ controller, partialOutput: result.partial });\n          lastPublishedJson = currentJson;\n        }\n      }\n    }\n  });\n}\nvar DefaultStreamTextResult = class {\n  constructor({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    stepTimeoutMs,\n    stepAbortController,\n    chunkTimeoutMs,\n    chunkAbortController,\n    system,\n    prompt,\n    messages,\n    tools,\n    toolChoice,\n    transforms,\n    activeTools,\n    repairToolCall,\n    stopConditions,\n    output,\n    providerOptions,\n    prepareStep,\n    includeRawChunks,\n    now: now2,\n    generateId: generateId2,\n    timeout,\n    stopWhen,\n    originalAbortSignal,\n    onChunk,\n    onError,\n    onFinish,\n    onAbort,\n    onStepFinish,\n    onStart,\n    onStepStart,\n    onToolCallStart,\n    onToolCallFinish,\n    experimental_context,\n    download: download2,\n    include\n  }) {\n    this._totalUsage = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n    this._finishReason = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n    this._rawFinishReason = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n    this._steps = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n    this.outputSpecification = output;\n    this.includeRawChunks = includeRawChunks;\n    this.tools = tools;\n    let stepFinish;\n    let recordedContent = [];\n    const recordedResponseMessages = [];\n    let recordedFinishReason = void 0;\n    let recordedRawFinishReason = void 0;\n    let recordedTotalUsage = void 0;\n    let recordedRequest = {};\n    let recordedWarnings = [];\n    const recordedSteps = [];\n    const pendingDeferredToolCalls = /* @__PURE__ */ new Map();\n    let rootSpan;\n    let activeTextContent = {};\n    let activeReasoningContent = {};\n    const eventProcessor = new TransformStream({\n      async transform(chunk, controller) {\n        var _a21, _b, _c, _d;\n        controller.enqueue(chunk);\n        const { part } = chunk;\n        if (part.type === \"text-delta\" || part.type === \"reasoning-delta\" || part.type === \"source\" || part.type === \"tool-call\" || part.type === \"tool-result\" || part.type === \"tool-input-start\" || part.type === \"tool-input-delta\" || part.type === \"raw\") {\n          await (onChunk == null ? void 0 : onChunk({ chunk: part }));\n        }\n        if (part.type === \"error\") {\n          await onError({ error: wrapGatewayError(part.error) });\n        }\n        if (part.type === \"text-start\") {\n          activeTextContent[part.id] = {\n            type: \"text\",\n            text: \"\",\n            providerMetadata: part.providerMetadata\n          };\n          recordedContent.push(activeTextContent[part.id]);\n        }\n        if (part.type === \"text-delta\") {\n          const activeText = activeTextContent[part.id];\n          if (activeText == null) {\n            controller.enqueue({\n              part: {\n                type: \"error\",\n                error: `text part ${part.id} not found`\n              },\n              partialOutput: void 0\n            });\n            return;\n          }\n          activeText.text += part.text;\n          activeText.providerMetadata = (_a21 = part.providerMetadata) != null ? _a21 : activeText.providerMetadata;\n        }\n        if (part.type === \"text-end\") {\n          const activeText = activeTextContent[part.id];\n          if (activeText == null) {\n            controller.enqueue({\n              part: {\n                type: \"error\",\n                error: `text part ${part.id} not found`\n              },\n              partialOutput: void 0\n            });\n            return;\n          }\n          activeText.providerMetadata = (_b = part.providerMetadata) != null ? _b : activeText.providerMetadata;\n          delete activeTextContent[part.id];\n        }\n        if (part.type === \"reasoning-start\") {\n          activeReasoningContent[part.id] = {\n            type: \"reasoning\",\n            text: \"\",\n            providerMetadata: part.providerMetadata\n          };\n          recordedContent.push(activeReasoningContent[part.id]);\n        }\n        if (part.type === \"reasoning-delta\") {\n          const activeReasoning = activeReasoningContent[part.id];\n          if (activeReasoning == null) {\n            controller.enqueue({\n              part: {\n                type: \"error\",\n                error: `reasoning part ${part.id} not found`\n              },\n              partialOutput: void 0\n            });\n            return;\n          }\n          activeReasoning.text += part.text;\n          activeReasoning.providerMetadata = (_c = part.providerMetadata) != null ? _c : activeReasoning.providerMetadata;\n        }\n        if (part.type === \"reasoning-end\") {\n          const activeReasoning = activeReasoningContent[part.id];\n          if (activeReasoning == null) {\n            controller.enqueue({\n              part: {\n                type: \"error\",\n                error: `reasoning part ${part.id} not found`\n              },\n              partialOutput: void 0\n            });\n            return;\n          }\n          activeReasoning.providerMetadata = (_d = part.providerMetadata) != null ? _d : activeReasoning.providerMetadata;\n          delete activeReasoningContent[part.id];\n        }\n        if (part.type === \"file\") {\n          recordedContent.push({ type: \"file\", file: part.file });\n        }\n        if (part.type === \"source\") {\n          recordedContent.push(part);\n        }\n        if (part.type === \"tool-call\") {\n          recordedContent.push(part);\n        }\n        if (part.type === \"tool-result\" && !part.preliminary) {\n          recordedContent.push(part);\n        }\n        if (part.type === \"tool-approval-request\") {\n          recordedContent.push(part);\n        }\n        if (part.type === \"tool-error\") {\n          recordedContent.push(part);\n        }\n        if (part.type === \"start-step\") {\n          recordedContent = [];\n          activeReasoningContent = {};\n          activeTextContent = {};\n          recordedRequest = part.request;\n          recordedWarnings = part.warnings;\n        }\n        if (part.type === \"finish-step\") {\n          const stepMessages = await toResponseMessages({\n            content: recordedContent,\n            tools\n          });\n          const currentStepResult = new DefaultStepResult({\n            stepNumber: recordedSteps.length,\n            model: modelInfo,\n            ...callbackTelemetryProps,\n            experimental_context,\n            content: recordedContent,\n            finishReason: part.finishReason,\n            rawFinishReason: part.rawFinishReason,\n            usage: part.usage,\n            warnings: recordedWarnings,\n            request: recordedRequest,\n            response: {\n              ...part.response,\n              messages: [...recordedResponseMessages, ...stepMessages]\n            },\n            providerMetadata: part.providerMetadata\n          });\n          await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));\n          logWarnings({\n            warnings: recordedWarnings,\n            provider: modelInfo.provider,\n            model: modelInfo.modelId\n          });\n          recordedSteps.push(currentStepResult);\n          recordedResponseMessages.push(...stepMessages);\n          stepFinish.resolve();\n        }\n        if (part.type === \"finish\") {\n          recordedTotalUsage = part.totalUsage;\n          recordedFinishReason = part.finishReason;\n          recordedRawFinishReason = part.rawFinishReason;\n        }\n      },\n      async flush(controller) {\n        try {\n          if (recordedSteps.length === 0) {\n            const error = (abortSignal == null ? void 0 : abortSignal.aborted) ? abortSignal.reason : new NoOutputGeneratedError({\n              message: \"No output generated. Check the stream for errors.\"\n            });\n            self._finishReason.reject(error);\n            self._rawFinishReason.reject(error);\n            self._totalUsage.reject(error);\n            self._steps.reject(error);\n            return;\n          }\n          const finishReason = recordedFinishReason != null ? recordedFinishReason : \"other\";\n          const totalUsage = recordedTotalUsage != null ? recordedTotalUsage : createNullLanguageModelUsage();\n          self._finishReason.resolve(finishReason);\n          self._rawFinishReason.resolve(recordedRawFinishReason);\n          self._totalUsage.resolve(totalUsage);\n          self._steps.resolve(recordedSteps);\n          const finalStep = recordedSteps[recordedSteps.length - 1];\n          await (onFinish == null ? void 0 : onFinish({\n            stepNumber: finalStep.stepNumber,\n            model: finalStep.model,\n            functionId: finalStep.functionId,\n            metadata: finalStep.metadata,\n            experimental_context: finalStep.experimental_context,\n            finishReason: finalStep.finishReason,\n            rawFinishReason: finalStep.rawFinishReason,\n            totalUsage,\n            usage: finalStep.usage,\n            content: finalStep.content,\n            text: finalStep.text,\n            reasoningText: finalStep.reasoningText,\n            reasoning: finalStep.reasoning,\n            files: finalStep.files,\n            sources: finalStep.sources,\n            toolCalls: finalStep.toolCalls,\n            staticToolCalls: finalStep.staticToolCalls,\n            dynamicToolCalls: finalStep.dynamicToolCalls,\n            toolResults: finalStep.toolResults,\n            staticToolResults: finalStep.staticToolResults,\n            dynamicToolResults: finalStep.dynamicToolResults,\n            request: finalStep.request,\n            response: finalStep.response,\n            warnings: finalStep.warnings,\n            providerMetadata: finalStep.providerMetadata,\n            steps: recordedSteps\n          }));\n          rootSpan.setAttributes(\n            await selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                \"ai.response.finishReason\": finishReason,\n                \"ai.response.text\": { output: () => finalStep.text },\n                \"ai.response.reasoning\": {\n                  output: () => finalStep.reasoningText\n                },\n                \"ai.response.toolCalls\": {\n                  output: () => {\n                    var _a21;\n                    return ((_a21 = finalStep.toolCalls) == null ? void 0 : _a21.length) ? JSON.stringify(finalStep.toolCalls) : void 0;\n                  }\n                },\n                \"ai.response.providerMetadata\": JSON.stringify(\n                  finalStep.providerMetadata\n                ),\n                \"ai.usage.inputTokens\": totalUsage.inputTokens,\n                \"ai.usage.outputTokens\": totalUsage.outputTokens,\n                \"ai.usage.totalTokens\": totalUsage.totalTokens,\n                \"ai.usage.reasoningTokens\": totalUsage.reasoningTokens,\n                \"ai.usage.cachedInputTokens\": totalUsage.cachedInputTokens\n              }\n            })\n          );\n        } catch (error) {\n          controller.error(error);\n        } finally {\n          rootSpan.end();\n        }\n      }\n    });\n    const stitchableStream = createStitchableStream();\n    this.addStream = stitchableStream.addStream;\n    this.closeStream = stitchableStream.close;\n    const reader = stitchableStream.stream.getReader();\n    let stream = new ReadableStream({\n      async start(controller) {\n        controller.enqueue({ type: \"start\" });\n      },\n      async pull(controller) {\n        function abort() {\n          onAbort == null ? void 0 : onAbort({ steps: recordedSteps });\n          controller.enqueue({\n            type: \"abort\",\n            // The `reason` is usually of type DOMException, but it can also be of any type,\n            // so we use getErrorMessage for serialization because it is already designed to accept values of the unknown type.\n            // See: https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/reason\n            ...(abortSignal == null ? void 0 : abortSignal.reason) !== void 0 ? { reason: (0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(abortSignal.reason) } : {}\n          });\n          controller.close();\n        }\n        try {\n          const { done, value } = await reader.read();\n          if (done) {\n            controller.close();\n            return;\n          }\n          if (abortSignal == null ? void 0 : abortSignal.aborted) {\n            abort();\n            return;\n          }\n          controller.enqueue(value);\n        } catch (error) {\n          if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.isAbortError)(error) && (abortSignal == null ? void 0 : abortSignal.aborted)) {\n            abort();\n          } else {\n            controller.error(error);\n          }\n        }\n      },\n      cancel(reason) {\n        return stitchableStream.stream.cancel(reason);\n      }\n    });\n    for (const transform of transforms) {\n      stream = stream.pipeThrough(\n        transform({\n          tools,\n          stopStream() {\n            stitchableStream.terminate();\n          }\n        })\n      );\n    }\n    this.baseStream = stream.pipeThrough(createOutputTransformStream(output != null ? output : text())).pipeThrough(eventProcessor);\n    const { maxRetries, retry } = prepareRetries({\n      maxRetries: maxRetriesArg,\n      abortSignal\n    });\n    const tracer = getTracer(telemetry);\n    const callSettings = prepareCallSettings(settings);\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n      model,\n      telemetry,\n      headers,\n      settings: { ...callSettings, maxRetries }\n    });\n    const self = this;\n    const modelInfo = { provider: model.provider, modelId: model.modelId };\n    const callbackTelemetryProps = {\n      functionId: telemetry == null ? void 0 : telemetry.functionId,\n      metadata: telemetry == null ? void 0 : telemetry.metadata\n    };\n    recordSpan({\n      name: \"ai.streamText\",\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({ operationId: \"ai.streamText\", telemetry }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          \"ai.prompt\": {\n            input: () => JSON.stringify({ system, prompt, messages })\n          }\n        }\n      }),\n      tracer,\n      endWhenDone: false,\n      fn: async (rootSpanArg) => {\n        rootSpan = rootSpanArg;\n        const initialPrompt = await standardizePrompt({\n          system,\n          prompt,\n          messages\n        });\n        try {\n          await (onStart == null ? void 0 : onStart({\n            model: modelInfo,\n            system,\n            prompt,\n            messages,\n            tools,\n            toolChoice,\n            activeTools,\n            maxOutputTokens: callSettings.maxOutputTokens,\n            temperature: callSettings.temperature,\n            topP: callSettings.topP,\n            topK: callSettings.topK,\n            presencePenalty: callSettings.presencePenalty,\n            frequencyPenalty: callSettings.frequencyPenalty,\n            stopSequences: callSettings.stopSequences,\n            seed: callSettings.seed,\n            maxRetries,\n            timeout,\n            headers,\n            providerOptions,\n            stopWhen,\n            output,\n            abortSignal: originalAbortSignal,\n            include,\n            ...callbackTelemetryProps,\n            experimental_context\n          }));\n        } catch (_ignored) {\n        }\n        const initialMessages = initialPrompt.messages;\n        const initialResponseMessages = [];\n        const { approvedToolApprovals, deniedToolApprovals } = collectToolApprovals({ messages: initialMessages });\n        if (deniedToolApprovals.length > 0 || approvedToolApprovals.length > 0) {\n          const providerExecutedToolApprovals = [\n            ...approvedToolApprovals,\n            ...deniedToolApprovals\n          ].filter((toolApproval) => toolApproval.toolCall.providerExecuted);\n          const localApprovedToolApprovals = approvedToolApprovals.filter(\n            (toolApproval) => !toolApproval.toolCall.providerExecuted\n          );\n          const localDeniedToolApprovals = deniedToolApprovals.filter(\n            (toolApproval) => !toolApproval.toolCall.providerExecuted\n          );\n          const deniedProviderExecutedToolApprovals = deniedToolApprovals.filter(\n            (toolApproval) => toolApproval.toolCall.providerExecuted\n          );\n          let toolExecutionStepStreamController;\n          const toolExecutionStepStream = new ReadableStream({\n            start(controller) {\n              toolExecutionStepStreamController = controller;\n            }\n          });\n          self.addStream(toolExecutionStepStream);\n          try {\n            for (const toolApproval of [\n              ...localDeniedToolApprovals,\n              ...deniedProviderExecutedToolApprovals\n            ]) {\n              toolExecutionStepStreamController == null ? void 0 : toolExecutionStepStreamController.enqueue({\n                type: \"tool-output-denied\",\n                toolCallId: toolApproval.toolCall.toolCallId,\n                toolName: toolApproval.toolCall.toolName\n              });\n            }\n            const toolOutputs = [];\n            await Promise.all(\n              localApprovedToolApprovals.map(async (toolApproval) => {\n                const result = await executeToolCall({\n                  toolCall: toolApproval.toolCall,\n                  tools,\n                  tracer,\n                  telemetry,\n                  messages: initialMessages,\n                  abortSignal,\n                  experimental_context,\n                  stepNumber: recordedSteps.length,\n                  model: modelInfo,\n                  onToolCallStart,\n                  onToolCallFinish,\n                  onPreliminaryToolResult: (result2) => {\n                    toolExecutionStepStreamController == null ? void 0 : toolExecutionStepStreamController.enqueue(result2);\n                  }\n                });\n                if (result != null) {\n                  toolExecutionStepStreamController == null ? void 0 : toolExecutionStepStreamController.enqueue(result);\n                  toolOutputs.push(result);\n                }\n              })\n            );\n            if (providerExecutedToolApprovals.length > 0) {\n              initialResponseMessages.push({\n                role: \"tool\",\n                content: providerExecutedToolApprovals.map(\n                  (toolApproval) => ({\n                    type: \"tool-approval-response\",\n                    approvalId: toolApproval.approvalResponse.approvalId,\n                    approved: toolApproval.approvalResponse.approved,\n                    reason: toolApproval.approvalResponse.reason,\n                    providerExecuted: true\n                  })\n                )\n              });\n            }\n            if (toolOutputs.length > 0 || localDeniedToolApprovals.length > 0) {\n              const localToolContent = [];\n              for (const output2 of toolOutputs) {\n                localToolContent.push({\n                  type: \"tool-result\",\n                  toolCallId: output2.toolCallId,\n                  toolName: output2.toolName,\n                  output: await createToolModelOutput({\n                    toolCallId: output2.toolCallId,\n                    input: output2.input,\n                    tool: tools == null ? void 0 : tools[output2.toolName],\n                    output: output2.type === \"tool-result\" ? output2.output : output2.error,\n                    errorMode: output2.type === \"tool-error\" ? \"json\" : \"none\"\n                  })\n                });\n              }\n              for (const toolApproval of localDeniedToolApprovals) {\n                localToolContent.push({\n                  type: \"tool-result\",\n                  toolCallId: toolApproval.toolCall.toolCallId,\n                  toolName: toolApproval.toolCall.toolName,\n                  output: {\n                    type: \"execution-denied\",\n                    reason: toolApproval.approvalResponse.reason\n                  }\n                });\n              }\n              initialResponseMessages.push({\n                role: \"tool\",\n                content: localToolContent\n              });\n            }\n          } finally {\n            toolExecutionStepStreamController == null ? void 0 : toolExecutionStepStreamController.close();\n          }\n        }\n        recordedResponseMessages.push(...initialResponseMessages);\n        async function streamStep({\n          currentStep,\n          responseMessages,\n          usage\n        }) {\n          var _a21, _b, _c, _d, _e, _f, _g, _h, _i;\n          const includeRawChunks2 = self.includeRawChunks;\n          const stepTimeoutId = stepTimeoutMs != null ? setTimeout(() => stepAbortController.abort(), stepTimeoutMs) : void 0;\n          let chunkTimeoutId = void 0;\n          function resetChunkTimeout() {\n            if (chunkTimeoutMs != null) {\n              if (chunkTimeoutId != null) {\n                clearTimeout(chunkTimeoutId);\n              }\n              chunkTimeoutId = setTimeout(\n                () => chunkAbortController.abort(),\n                chunkTimeoutMs\n              );\n            }\n          }\n          function clearChunkTimeout() {\n            if (chunkTimeoutId != null) {\n              clearTimeout(chunkTimeoutId);\n              chunkTimeoutId = void 0;\n            }\n          }\n          function clearStepTimeout() {\n            if (stepTimeoutId != null) {\n              clearTimeout(stepTimeoutId);\n            }\n          }\n          try {\n            stepFinish = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n            const stepInputMessages = [...initialMessages, ...responseMessages];\n            const prepareStepResult = await (prepareStep == null ? void 0 : prepareStep({\n              model,\n              steps: recordedSteps,\n              stepNumber: recordedSteps.length,\n              messages: stepInputMessages,\n              experimental_context\n            }));\n            const stepModel = resolveLanguageModel(\n              (_a21 = prepareStepResult == null ? void 0 : prepareStepResult.model) != null ? _a21 : model\n            );\n            const stepModelInfo = {\n              provider: stepModel.provider,\n              modelId: stepModel.modelId\n            };\n            const promptMessages = await convertToLanguageModelPrompt({\n              prompt: {\n                system: (_b = prepareStepResult == null ? void 0 : prepareStepResult.system) != null ? _b : initialPrompt.system,\n                messages: (_c = prepareStepResult == null ? void 0 : prepareStepResult.messages) != null ? _c : stepInputMessages\n              },\n              supportedUrls: await stepModel.supportedUrls,\n              download: download2\n            });\n            const stepActiveTools = (_d = prepareStepResult == null ? void 0 : prepareStepResult.activeTools) != null ? _d : activeTools;\n            const { toolChoice: stepToolChoice, tools: stepTools } = await prepareToolsAndToolChoice({\n              tools,\n              toolChoice: (_e = prepareStepResult == null ? void 0 : prepareStepResult.toolChoice) != null ? _e : toolChoice,\n              activeTools: stepActiveTools\n            });\n            experimental_context = (_f = prepareStepResult == null ? void 0 : prepareStepResult.experimental_context) != null ? _f : experimental_context;\n            const stepMessages = (_g = prepareStepResult == null ? void 0 : prepareStepResult.messages) != null ? _g : stepInputMessages;\n            const stepSystem = (_h = prepareStepResult == null ? void 0 : prepareStepResult.system) != null ? _h : initialPrompt.system;\n            const stepProviderOptions = mergeObjects(\n              providerOptions,\n              prepareStepResult == null ? void 0 : prepareStepResult.providerOptions\n            );\n            try {\n              await (onStepStart == null ? void 0 : onStepStart({\n                stepNumber: recordedSteps.length,\n                model: stepModelInfo,\n                system: stepSystem,\n                messages: stepMessages,\n                tools,\n                toolChoice: stepToolChoice,\n                activeTools: stepActiveTools,\n                steps: [...recordedSteps],\n                providerOptions: stepProviderOptions,\n                timeout,\n                headers,\n                stopWhen,\n                output,\n                abortSignal: originalAbortSignal,\n                include,\n                ...callbackTelemetryProps,\n                experimental_context\n              }));\n            } catch (_ignored) {\n            }\n            const {\n              result: { stream: stream2, response, request },\n              doStreamSpan,\n              startTimestampMs\n            } = await retry(\n              () => recordSpan({\n                name: \"ai.streamText.doStream\",\n                attributes: selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    ...assembleOperationName({\n                      operationId: \"ai.streamText.doStream\",\n                      telemetry\n                    }),\n                    ...baseTelemetryAttributes,\n                    // model:\n                    \"ai.model.provider\": stepModel.provider,\n                    \"ai.model.id\": stepModel.modelId,\n                    // prompt:\n                    \"ai.prompt.messages\": {\n                      input: () => stringifyForTelemetry(promptMessages)\n                    },\n                    \"ai.prompt.tools\": {\n                      // convert the language model level tools:\n                      input: () => stepTools == null ? void 0 : stepTools.map((tool2) => JSON.stringify(tool2))\n                    },\n                    \"ai.prompt.toolChoice\": {\n                      input: () => stepToolChoice != null ? JSON.stringify(stepToolChoice) : void 0\n                    },\n                    // standardized gen-ai llm span attributes:\n                    \"gen_ai.system\": stepModel.provider,\n                    \"gen_ai.request.model\": stepModel.modelId,\n                    \"gen_ai.request.frequency_penalty\": callSettings.frequencyPenalty,\n                    \"gen_ai.request.max_tokens\": callSettings.maxOutputTokens,\n                    \"gen_ai.request.presence_penalty\": callSettings.presencePenalty,\n                    \"gen_ai.request.stop_sequences\": callSettings.stopSequences,\n                    \"gen_ai.request.temperature\": callSettings.temperature,\n                    \"gen_ai.request.top_k\": callSettings.topK,\n                    \"gen_ai.request.top_p\": callSettings.topP\n                  }\n                }),\n                tracer,\n                endWhenDone: false,\n                fn: async (doStreamSpan2) => ({\n                  startTimestampMs: now2(),\n                  // get before the call\n                  doStreamSpan: doStreamSpan2,\n                  result: await stepModel.doStream({\n                    ...callSettings,\n                    tools: stepTools,\n                    toolChoice: stepToolChoice,\n                    responseFormat: await (output == null ? void 0 : output.responseFormat),\n                    prompt: promptMessages,\n                    providerOptions: stepProviderOptions,\n                    abortSignal,\n                    headers,\n                    includeRawChunks: includeRawChunks2\n                  })\n                })\n              })\n            );\n            const streamWithToolResults = runToolsTransformation({\n              tools,\n              generatorStream: stream2,\n              tracer,\n              telemetry,\n              system,\n              messages: stepInputMessages,\n              repairToolCall,\n              abortSignal,\n              experimental_context,\n              generateId: generateId2,\n              stepNumber: recordedSteps.length,\n              model: stepModelInfo,\n              onToolCallStart,\n              onToolCallFinish\n            });\n            const stepRequest = ((_i = include == null ? void 0 : include.requestBody) != null ? _i : true) ? request != null ? request : {} : { ...request, body: void 0 };\n            const stepToolCalls = [];\n            const stepToolOutputs = [];\n            let warnings;\n            const activeToolCallToolNames = {};\n            let stepFinishReason = \"other\";\n            let stepRawFinishReason = void 0;\n            let stepUsage = createNullLanguageModelUsage();\n            let stepProviderMetadata;\n            let stepFirstChunk = true;\n            let stepResponse = {\n              id: generateId2(),\n              timestamp: /* @__PURE__ */ new Date(),\n              modelId: modelInfo.modelId\n            };\n            let activeText = \"\";\n            self.addStream(\n              streamWithToolResults.pipeThrough(\n                new TransformStream({\n                  async transform(chunk, controller) {\n                    var _a22, _b2, _c2, _d2, _e2;\n                    resetChunkTimeout();\n                    if (chunk.type === \"stream-start\") {\n                      warnings = chunk.warnings;\n                      return;\n                    }\n                    if (stepFirstChunk) {\n                      const msToFirstChunk = now2() - startTimestampMs;\n                      stepFirstChunk = false;\n                      doStreamSpan.addEvent(\"ai.stream.firstChunk\", {\n                        \"ai.response.msToFirstChunk\": msToFirstChunk\n                      });\n                      doStreamSpan.setAttributes({\n                        \"ai.response.msToFirstChunk\": msToFirstChunk\n                      });\n                      controller.enqueue({\n                        type: \"start-step\",\n                        request: stepRequest,\n                        warnings: warnings != null ? warnings : []\n                      });\n                    }\n                    const chunkType = chunk.type;\n                    switch (chunkType) {\n                      case \"tool-approval-request\":\n                      case \"text-start\":\n                      case \"text-end\": {\n                        controller.enqueue(chunk);\n                        break;\n                      }\n                      case \"text-delta\": {\n                        if (chunk.delta.length > 0) {\n                          controller.enqueue({\n                            type: \"text-delta\",\n                            id: chunk.id,\n                            text: chunk.delta,\n                            providerMetadata: chunk.providerMetadata\n                          });\n                          activeText += chunk.delta;\n                        }\n                        break;\n                      }\n                      case \"reasoning-start\":\n                      case \"reasoning-end\": {\n                        controller.enqueue(chunk);\n                        break;\n                      }\n                      case \"reasoning-delta\": {\n                        controller.enqueue({\n                          type: \"reasoning-delta\",\n                          id: chunk.id,\n                          text: chunk.delta,\n                          providerMetadata: chunk.providerMetadata\n                        });\n                        break;\n                      }\n                      case \"tool-call\": {\n                        controller.enqueue(chunk);\n                        stepToolCalls.push(chunk);\n                        break;\n                      }\n                      case \"tool-result\": {\n                        controller.enqueue(chunk);\n                        if (!chunk.preliminary) {\n                          stepToolOutputs.push(chunk);\n                        }\n                        break;\n                      }\n                      case \"tool-error\": {\n                        controller.enqueue(chunk);\n                        stepToolOutputs.push(chunk);\n                        break;\n                      }\n                      case \"response-metadata\": {\n                        stepResponse = {\n                          id: (_a22 = chunk.id) != null ? _a22 : stepResponse.id,\n                          timestamp: (_b2 = chunk.timestamp) != null ? _b2 : stepResponse.timestamp,\n                          modelId: (_c2 = chunk.modelId) != null ? _c2 : stepResponse.modelId\n                        };\n                        break;\n                      }\n                      case \"finish\": {\n                        stepUsage = chunk.usage;\n                        stepFinishReason = chunk.finishReason;\n                        stepRawFinishReason = chunk.rawFinishReason;\n                        stepProviderMetadata = chunk.providerMetadata;\n                        const msToFinish = now2() - startTimestampMs;\n                        doStreamSpan.addEvent(\"ai.stream.finish\");\n                        doStreamSpan.setAttributes({\n                          \"ai.response.msToFinish\": msToFinish,\n                          \"ai.response.avgOutputTokensPerSecond\": 1e3 * ((_d2 = stepUsage.outputTokens) != null ? _d2 : 0) / msToFinish\n                        });\n                        break;\n                      }\n                      case \"file\": {\n                        controller.enqueue(chunk);\n                        break;\n                      }\n                      case \"source\": {\n                        controller.enqueue(chunk);\n                        break;\n                      }\n                      case \"tool-input-start\": {\n                        activeToolCallToolNames[chunk.id] = chunk.toolName;\n                        const tool2 = tools == null ? void 0 : tools[chunk.toolName];\n                        if ((tool2 == null ? void 0 : tool2.onInputStart) != null) {\n                          await tool2.onInputStart({\n                            toolCallId: chunk.id,\n                            messages: stepInputMessages,\n                            abortSignal,\n                            experimental_context\n                          });\n                        }\n                        controller.enqueue({\n                          ...chunk,\n                          dynamic: (_e2 = chunk.dynamic) != null ? _e2 : (tool2 == null ? void 0 : tool2.type) === \"dynamic\",\n                          title: tool2 == null ? void 0 : tool2.title\n                        });\n                        break;\n                      }\n                      case \"tool-input-end\": {\n                        delete activeToolCallToolNames[chunk.id];\n                        controller.enqueue(chunk);\n                        break;\n                      }\n                      case \"tool-input-delta\": {\n                        const toolName = activeToolCallToolNames[chunk.id];\n                        const tool2 = tools == null ? void 0 : tools[toolName];\n                        if ((tool2 == null ? void 0 : tool2.onInputDelta) != null) {\n                          await tool2.onInputDelta({\n                            inputTextDelta: chunk.delta,\n                            toolCallId: chunk.id,\n                            messages: stepInputMessages,\n                            abortSignal,\n                            experimental_context\n                          });\n                        }\n                        controller.enqueue(chunk);\n                        break;\n                      }\n                      case \"error\": {\n                        controller.enqueue(chunk);\n                        stepFinishReason = \"error\";\n                        break;\n                      }\n                      case \"raw\": {\n                        if (includeRawChunks2) {\n                          controller.enqueue(chunk);\n                        }\n                        break;\n                      }\n                      default: {\n                        const exhaustiveCheck = chunkType;\n                        throw new Error(\n                          `Unknown chunk type: ${exhaustiveCheck}`\n                        );\n                      }\n                    }\n                  },\n                  // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n                  async flush(controller) {\n                    const stepToolCallsJson = stepToolCalls.length > 0 ? JSON.stringify(stepToolCalls) : void 0;\n                    try {\n                      doStreamSpan.setAttributes(\n                        await selectTelemetryAttributes({\n                          telemetry,\n                          attributes: {\n                            \"ai.response.finishReason\": stepFinishReason,\n                            \"ai.response.text\": {\n                              output: () => activeText\n                            },\n                            \"ai.response.reasoning\": {\n                              output: () => {\n                                const reasoningParts = recordedContent.filter(\n                                  (c) => c.type === \"reasoning\"\n                                );\n                                return reasoningParts.length > 0 ? reasoningParts.map((r) => r.text).join(\"\\n\") : void 0;\n                              }\n                            },\n                            \"ai.response.toolCalls\": {\n                              output: () => stepToolCallsJson\n                            },\n                            \"ai.response.id\": stepResponse.id,\n                            \"ai.response.model\": stepResponse.modelId,\n                            \"ai.response.timestamp\": stepResponse.timestamp.toISOString(),\n                            \"ai.response.providerMetadata\": JSON.stringify(stepProviderMetadata),\n                            \"ai.usage.inputTokens\": stepUsage.inputTokens,\n                            \"ai.usage.outputTokens\": stepUsage.outputTokens,\n                            \"ai.usage.totalTokens\": stepUsage.totalTokens,\n                            \"ai.usage.reasoningTokens\": stepUsage.reasoningTokens,\n                            \"ai.usage.cachedInputTokens\": stepUsage.cachedInputTokens,\n                            // standardized gen-ai llm span attributes:\n                            \"gen_ai.response.finish_reasons\": [\n                              stepFinishReason\n                            ],\n                            \"gen_ai.response.id\": stepResponse.id,\n                            \"gen_ai.response.model\": stepResponse.modelId,\n                            \"gen_ai.usage.input_tokens\": stepUsage.inputTokens,\n                            \"gen_ai.usage.output_tokens\": stepUsage.outputTokens\n                          }\n                        })\n                      );\n                    } catch (error) {\n                    } finally {\n                      doStreamSpan.end();\n                    }\n                    controller.enqueue({\n                      type: \"finish-step\",\n                      finishReason: stepFinishReason,\n                      rawFinishReason: stepRawFinishReason,\n                      usage: stepUsage,\n                      providerMetadata: stepProviderMetadata,\n                      response: {\n                        ...stepResponse,\n                        headers: response == null ? void 0 : response.headers\n                      }\n                    });\n                    const combinedUsage = addLanguageModelUsage(\n                      usage,\n                      stepUsage\n                    );\n                    await stepFinish.promise;\n                    const clientToolCalls = stepToolCalls.filter(\n                      (toolCall) => toolCall.providerExecuted !== true\n                    );\n                    const clientToolOutputs = stepToolOutputs.filter(\n                      (toolOutput) => toolOutput.providerExecuted !== true\n                    );\n                    for (const toolCall of stepToolCalls) {\n                      if (toolCall.providerExecuted !== true)\n                        continue;\n                      const tool2 = tools == null ? void 0 : tools[toolCall.toolName];\n                      if ((tool2 == null ? void 0 : tool2.type) === \"provider\" && tool2.supportsDeferredResults) {\n                        const hasResultInStep = stepToolOutputs.some(\n                          (output2) => (output2.type === \"tool-result\" || output2.type === \"tool-error\") && output2.toolCallId === toolCall.toolCallId\n                        );\n                        if (!hasResultInStep) {\n                          pendingDeferredToolCalls.set(toolCall.toolCallId, {\n                            toolName: toolCall.toolName\n                          });\n                        }\n                      }\n                    }\n                    for (const output2 of stepToolOutputs) {\n                      if (output2.type === \"tool-result\" || output2.type === \"tool-error\") {\n                        pendingDeferredToolCalls.delete(output2.toolCallId);\n                      }\n                    }\n                    clearStepTimeout();\n                    clearChunkTimeout();\n                    if (\n                      // Continue if:\n                      // 1. There are client tool calls that have all been executed, OR\n                      // 2. There are pending deferred results from provider-executed tools\n                      (clientToolCalls.length > 0 && clientToolOutputs.length === clientToolCalls.length || pendingDeferredToolCalls.size > 0) && // continue until a stop condition is met:\n                      !await isStopConditionMet({\n                        stopConditions,\n                        steps: recordedSteps\n                      })\n                    ) {\n                      responseMessages.push(\n                        ...await toResponseMessages({\n                          content: (\n                            // use transformed content to create the messages for the next step:\n                            recordedSteps[recordedSteps.length - 1].content\n                          ),\n                          tools\n                        })\n                      );\n                      try {\n                        await streamStep({\n                          currentStep: currentStep + 1,\n                          responseMessages,\n                          usage: combinedUsage\n                        });\n                      } catch (error) {\n                        controller.enqueue({\n                          type: \"error\",\n                          error\n                        });\n                        self.closeStream();\n                      }\n                    } else {\n                      controller.enqueue({\n                        type: \"finish\",\n                        finishReason: stepFinishReason,\n                        rawFinishReason: stepRawFinishReason,\n                        totalUsage: combinedUsage\n                      });\n                      self.closeStream();\n                    }\n                  }\n                })\n              )\n            );\n          } finally {\n            clearStepTimeout();\n            clearChunkTimeout();\n          }\n        }\n        await streamStep({\n          currentStep: 0,\n          responseMessages: initialResponseMessages,\n          usage: createNullLanguageModelUsage()\n        });\n      }\n    }).catch((error) => {\n      self.addStream(\n        new ReadableStream({\n          start(controller) {\n            controller.enqueue({ type: \"error\", error });\n            controller.close();\n          }\n        })\n      );\n      self.closeStream();\n    });\n  }\n  get steps() {\n    this.consumeStream();\n    return this._steps.promise;\n  }\n  get finalStep() {\n    return this.steps.then((steps) => steps[steps.length - 1]);\n  }\n  get content() {\n    return this.finalStep.then((step) => step.content);\n  }\n  get warnings() {\n    return this.finalStep.then((step) => step.warnings);\n  }\n  get providerMetadata() {\n    return this.finalStep.then((step) => step.providerMetadata);\n  }\n  get text() {\n    return this.finalStep.then((step) => step.text);\n  }\n  get reasoningText() {\n    return this.finalStep.then((step) => step.reasoningText);\n  }\n  get reasoning() {\n    return this.finalStep.then((step) => step.reasoning);\n  }\n  get sources() {\n    return this.finalStep.then((step) => step.sources);\n  }\n  get files() {\n    return this.finalStep.then((step) => step.files);\n  }\n  get toolCalls() {\n    return this.finalStep.then((step) => step.toolCalls);\n  }\n  get staticToolCalls() {\n    return this.finalStep.then((step) => step.staticToolCalls);\n  }\n  get dynamicToolCalls() {\n    return this.finalStep.then((step) => step.dynamicToolCalls);\n  }\n  get toolResults() {\n    return this.finalStep.then((step) => step.toolResults);\n  }\n  get staticToolResults() {\n    return this.finalStep.then((step) => step.staticToolResults);\n  }\n  get dynamicToolResults() {\n    return this.finalStep.then((step) => step.dynamicToolResults);\n  }\n  get usage() {\n    return this.finalStep.then((step) => step.usage);\n  }\n  get request() {\n    return this.finalStep.then((step) => step.request);\n  }\n  get response() {\n    return this.finalStep.then((step) => step.response);\n  }\n  get totalUsage() {\n    this.consumeStream();\n    return this._totalUsage.promise;\n  }\n  get finishReason() {\n    this.consumeStream();\n    return this._finishReason.promise;\n  }\n  get rawFinishReason() {\n    this.consumeStream();\n    return this._rawFinishReason.promise;\n  }\n  /**\n   * Split out a new stream from the original stream.\n   * The original stream is replaced to allow for further splitting,\n   * since we do not know how many times the stream will be split.\n   *\n   * Note: this leads to buffering the stream content on the server.\n   * However, the LLM results are expected to be small enough to not cause issues.\n   */\n  teeStream() {\n    const [stream1, stream2] = this.baseStream.tee();\n    this.baseStream = stream2;\n    return stream1;\n  }\n  get textStream() {\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream({\n          transform({ part }, controller) {\n            if (part.type === \"text-delta\") {\n              controller.enqueue(part.text);\n            }\n          }\n        })\n      )\n    );\n  }\n  get fullStream() {\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream({\n          transform({ part }, controller) {\n            controller.enqueue(part);\n          }\n        })\n      )\n    );\n  }\n  async consumeStream(options) {\n    var _a21;\n    try {\n      await consumeStream({\n        stream: this.fullStream,\n        onError: options == null ? void 0 : options.onError\n      });\n    } catch (error) {\n      (_a21 = options == null ? void 0 : options.onError) == null ? void 0 : _a21.call(options, error);\n    }\n  }\n  get experimental_partialOutputStream() {\n    return this.partialOutputStream;\n  }\n  get partialOutputStream() {\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream({\n          transform({ partialOutput }, controller) {\n            if (partialOutput != null) {\n              controller.enqueue(partialOutput);\n            }\n          }\n        })\n      )\n    );\n  }\n  get elementStream() {\n    var _a21, _b, _c;\n    const transform = (_a21 = this.outputSpecification) == null ? void 0 : _a21.createElementStreamTransform();\n    if (transform == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n        functionality: `element streams in ${(_c = (_b = this.outputSpecification) == null ? void 0 : _b.name) != null ? _c : \"text\"} mode`\n      });\n    }\n    return createAsyncIterableStream(this.teeStream().pipeThrough(transform));\n  }\n  get output() {\n    return this.finalStep.then((step) => {\n      var _a21;\n      const output = (_a21 = this.outputSpecification) != null ? _a21 : text();\n      return output.parseCompleteOutput(\n        { text: step.text },\n        {\n          response: step.response,\n          usage: step.usage,\n          finishReason: step.finishReason\n        }\n      );\n    });\n  }\n  toUIMessageStream({\n    originalMessages,\n    generateMessageId,\n    onFinish,\n    messageMetadata,\n    sendReasoning = true,\n    sendSources = false,\n    sendStart = true,\n    sendFinish = true,\n    onError = _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage\n  } = {}) {\n    const responseMessageId = generateMessageId != null ? getResponseUIMessageId({\n      originalMessages,\n      responseMessageId: generateMessageId\n    }) : void 0;\n    const isDynamic = (part) => {\n      var _a21;\n      const tool2 = (_a21 = this.tools) == null ? void 0 : _a21[part.toolName];\n      if (tool2 == null) {\n        return part.dynamic;\n      }\n      return (tool2 == null ? void 0 : tool2.type) === \"dynamic\" ? true : void 0;\n    };\n    const baseStream = this.fullStream.pipeThrough(\n      new TransformStream({\n        transform: async (part, controller) => {\n          const messageMetadataValue = messageMetadata == null ? void 0 : messageMetadata({ part });\n          const partType = part.type;\n          switch (partType) {\n            case \"text-start\": {\n              controller.enqueue({\n                type: \"text-start\",\n                id: part.id,\n                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n              });\n              break;\n            }\n            case \"text-delta\": {\n              controller.enqueue({\n                type: \"text-delta\",\n                id: part.id,\n                delta: part.text,\n                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n              });\n              break;\n            }\n            case \"text-end\": {\n              controller.enqueue({\n                type: \"text-end\",\n                id: part.id,\n                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n              });\n              break;\n            }\n            case \"reasoning-start\": {\n              controller.enqueue({\n                type: \"reasoning-start\",\n                id: part.id,\n                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n              });\n              break;\n            }\n            case \"reasoning-delta\": {\n              if (sendReasoning) {\n                controller.enqueue({\n                  type: \"reasoning-delta\",\n                  id: part.id,\n                  delta: part.text,\n                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n                });\n              }\n              break;\n            }\n            case \"reasoning-end\": {\n              controller.enqueue({\n                type: \"reasoning-end\",\n                id: part.id,\n                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n              });\n              break;\n            }\n            case \"file\": {\n              controller.enqueue({\n                type: \"file\",\n                mediaType: part.file.mediaType,\n                url: `data:${part.file.mediaType};base64,${part.file.base64}`\n              });\n              break;\n            }\n            case \"source\": {\n              if (sendSources && part.sourceType === \"url\") {\n                controller.enqueue({\n                  type: \"source-url\",\n                  sourceId: part.id,\n                  url: part.url,\n                  title: part.title,\n                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n                });\n              }\n              if (sendSources && part.sourceType === \"document\") {\n                controller.enqueue({\n                  type: \"source-document\",\n                  sourceId: part.id,\n                  mediaType: part.mediaType,\n                  title: part.title,\n                  filename: part.filename,\n                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n                });\n              }\n              break;\n            }\n            case \"tool-input-start\": {\n              const dynamic = isDynamic(part);\n              controller.enqueue({\n                type: \"tool-input-start\",\n                toolCallId: part.id,\n                toolName: part.toolName,\n                ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},\n                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {},\n                ...dynamic != null ? { dynamic } : {},\n                ...part.title != null ? { title: part.title } : {}\n              });\n              break;\n            }\n            case \"tool-input-delta\": {\n              controller.enqueue({\n                type: \"tool-input-delta\",\n                toolCallId: part.id,\n                inputTextDelta: part.delta\n              });\n              break;\n            }\n            case \"tool-call\": {\n              const dynamic = isDynamic(part);\n              if (part.invalid) {\n                controller.enqueue({\n                  type: \"tool-input-error\",\n                  toolCallId: part.toolCallId,\n                  toolName: part.toolName,\n                  input: part.input,\n                  ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},\n                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {},\n                  ...dynamic != null ? { dynamic } : {},\n                  errorText: onError(part.error),\n                  ...part.title != null ? { title: part.title } : {}\n                });\n              } else {\n                controller.enqueue({\n                  type: \"tool-input-available\",\n                  toolCallId: part.toolCallId,\n                  toolName: part.toolName,\n                  input: part.input,\n                  ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},\n                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {},\n                  ...dynamic != null ? { dynamic } : {},\n                  ...part.title != null ? { title: part.title } : {}\n                });\n              }\n              break;\n            }\n            case \"tool-approval-request\": {\n              controller.enqueue({\n                type: \"tool-approval-request\",\n                approvalId: part.approvalId,\n                toolCallId: part.toolCall.toolCallId\n              });\n              break;\n            }\n            case \"tool-result\": {\n              const dynamic = isDynamic(part);\n              controller.enqueue({\n                type: \"tool-output-available\",\n                toolCallId: part.toolCallId,\n                output: part.output,\n                ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},\n                ...part.preliminary != null ? { preliminary: part.preliminary } : {},\n                ...dynamic != null ? { dynamic } : {}\n              });\n              break;\n            }\n            case \"tool-error\": {\n              const dynamic = isDynamic(part);\n              controller.enqueue({\n                type: \"tool-output-error\",\n                toolCallId: part.toolCallId,\n                errorText: onError(part.error),\n                ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},\n                ...dynamic != null ? { dynamic } : {}\n              });\n              break;\n            }\n            case \"tool-output-denied\": {\n              controller.enqueue({\n                type: \"tool-output-denied\",\n                toolCallId: part.toolCallId\n              });\n              break;\n            }\n            case \"error\": {\n              controller.enqueue({\n                type: \"error\",\n                errorText: onError(part.error)\n              });\n              break;\n            }\n            case \"start-step\": {\n              controller.enqueue({ type: \"start-step\" });\n              break;\n            }\n            case \"finish-step\": {\n              controller.enqueue({ type: \"finish-step\" });\n              break;\n            }\n            case \"start\": {\n              if (sendStart) {\n                controller.enqueue({\n                  type: \"start\",\n                  ...messageMetadataValue != null ? { messageMetadata: messageMetadataValue } : {},\n                  ...responseMessageId != null ? { messageId: responseMessageId } : {}\n                });\n              }\n              break;\n            }\n            case \"finish\": {\n              if (sendFinish) {\n                controller.enqueue({\n                  type: \"finish\",\n                  finishReason: part.finishReason,\n                  ...messageMetadataValue != null ? { messageMetadata: messageMetadataValue } : {}\n                });\n              }\n              break;\n            }\n            case \"abort\": {\n              controller.enqueue(part);\n              break;\n            }\n            case \"tool-input-end\": {\n              break;\n            }\n            case \"raw\": {\n              break;\n            }\n            default: {\n              const exhaustiveCheck = partType;\n              throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n            }\n          }\n          if (messageMetadataValue != null && partType !== \"start\" && partType !== \"finish\") {\n            controller.enqueue({\n              type: \"message-metadata\",\n              messageMetadata: messageMetadataValue\n            });\n          }\n        }\n      })\n    );\n    return createAsyncIterableStream(\n      handleUIMessageStreamFinish({\n        stream: baseStream,\n        messageId: responseMessageId != null ? responseMessageId : generateMessageId == null ? void 0 : generateMessageId(),\n        originalMessages,\n        onFinish,\n        onError\n      })\n    );\n  }\n  pipeUIMessageStreamToResponse(response, {\n    originalMessages,\n    generateMessageId,\n    onFinish,\n    messageMetadata,\n    sendReasoning,\n    sendSources,\n    sendFinish,\n    sendStart,\n    onError,\n    ...init\n  } = {}) {\n    pipeUIMessageStreamToResponse({\n      response,\n      stream: this.toUIMessageStream({\n        originalMessages,\n        generateMessageId,\n        onFinish,\n        messageMetadata,\n        sendReasoning,\n        sendSources,\n        sendFinish,\n        sendStart,\n        onError\n      }),\n      ...init\n    });\n  }\n  pipeTextStreamToResponse(response, init) {\n    pipeTextStreamToResponse({\n      response,\n      textStream: this.textStream,\n      ...init\n    });\n  }\n  toUIMessageStreamResponse({\n    originalMessages,\n    generateMessageId,\n    onFinish,\n    messageMetadata,\n    sendReasoning,\n    sendSources,\n    sendFinish,\n    sendStart,\n    onError,\n    ...init\n  } = {}) {\n    return createUIMessageStreamResponse({\n      stream: this.toUIMessageStream({\n        originalMessages,\n        generateMessageId,\n        onFinish,\n        messageMetadata,\n        sendReasoning,\n        sendSources,\n        sendFinish,\n        sendStart,\n        onError\n      }),\n      ...init\n    });\n  }\n  toTextStreamResponse(init) {\n    return createTextStreamResponse({\n      textStream: this.textStream,\n      ...init\n    });\n  }\n};\n\n// src/agent/tool-loop-agent.ts\nvar ToolLoopAgent = class {\n  constructor(settings) {\n    this.version = \"agent-v1\";\n    this.settings = settings;\n  }\n  /**\n   * The id of the agent.\n   */\n  get id() {\n    return this.settings.id;\n  }\n  /**\n   * The tools that the agent can use.\n   */\n  get tools() {\n    return this.settings.tools;\n  }\n  async prepareCall(options) {\n    var _a21, _b, _c, _d;\n    const {\n      experimental_onStart: _settingsOnStart,\n      experimental_onStepStart: _settingsOnStepStart,\n      experimental_onToolCallStart: _settingsOnToolCallStart,\n      experimental_onToolCallFinish: _settingsOnToolCallFinish,\n      onStepFinish: _settingsOnStepFinish,\n      onFinish: _settingsOnFinish,\n      ...settingsWithoutCallbacks\n    } = this.settings;\n    const baseCallArgs = {\n      ...settingsWithoutCallbacks,\n      stopWhen: (_a21 = this.settings.stopWhen) != null ? _a21 : stepCountIs(20),\n      ...options\n    };\n    const preparedCallArgs = (_d = await ((_c = (_b = this.settings).prepareCall) == null ? void 0 : _c.call(\n      _b,\n      baseCallArgs\n    ))) != null ? _d : baseCallArgs;\n    const { instructions, messages, prompt, ...callArgs } = preparedCallArgs;\n    return {\n      ...callArgs,\n      // restore prompt types\n      ...{ system: instructions, messages, prompt }\n    };\n  }\n  mergeCallbacks(settingsCallback, methodCallback) {\n    if (methodCallback && settingsCallback) {\n      return async (event) => {\n        await settingsCallback(event);\n        await methodCallback(event);\n      };\n    }\n    return methodCallback != null ? methodCallback : settingsCallback;\n  }\n  /**\n   * Generates an output from the agent (non-streaming).\n   */\n  async generate({\n    abortSignal,\n    timeout,\n    experimental_onStart,\n    experimental_onStepStart,\n    experimental_onToolCallStart,\n    experimental_onToolCallFinish,\n    onStepFinish,\n    onFinish,\n    ...options\n  }) {\n    return generateText({\n      ...await this.prepareCall(options),\n      abortSignal,\n      timeout,\n      experimental_onStart: this.mergeCallbacks(\n        this.settings.experimental_onStart,\n        experimental_onStart\n      ),\n      experimental_onStepStart: this.mergeCallbacks(\n        this.settings.experimental_onStepStart,\n        experimental_onStepStart\n      ),\n      experimental_onToolCallStart: this.mergeCallbacks(\n        this.settings.experimental_onToolCallStart,\n        experimental_onToolCallStart\n      ),\n      experimental_onToolCallFinish: this.mergeCallbacks(\n        this.settings.experimental_onToolCallFinish,\n        experimental_onToolCallFinish\n      ),\n      onStepFinish: this.mergeCallbacks(\n        this.settings.onStepFinish,\n        onStepFinish\n      ),\n      onFinish: this.mergeCallbacks(this.settings.onFinish, onFinish)\n    });\n  }\n  /**\n   * Streams an output from the agent (streaming).\n   */\n  async stream({\n    abortSignal,\n    timeout,\n    experimental_transform,\n    experimental_onStart,\n    experimental_onStepStart,\n    experimental_onToolCallStart,\n    experimental_onToolCallFinish,\n    onStepFinish,\n    onFinish,\n    ...options\n  }) {\n    return streamText({\n      ...await this.prepareCall(options),\n      abortSignal,\n      timeout,\n      experimental_transform,\n      experimental_onStart: this.mergeCallbacks(\n        this.settings.experimental_onStart,\n        experimental_onStart\n      ),\n      experimental_onStepStart: this.mergeCallbacks(\n        this.settings.experimental_onStepStart,\n        experimental_onStepStart\n      ),\n      experimental_onToolCallStart: this.mergeCallbacks(\n        this.settings.experimental_onToolCallStart,\n        experimental_onToolCallStart\n      ),\n      experimental_onToolCallFinish: this.mergeCallbacks(\n        this.settings.experimental_onToolCallFinish,\n        experimental_onToolCallFinish\n      ),\n      onStepFinish: this.mergeCallbacks(\n        this.settings.onStepFinish,\n        onStepFinish\n      ),\n      onFinish: this.mergeCallbacks(this.settings.onFinish, onFinish)\n    });\n  }\n};\n\n// src/ui-message-stream/create-ui-message-stream.ts\n\nfunction createUIMessageStream({\n  execute,\n  onError = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getErrorMessage,\n  originalMessages,\n  onStepFinish,\n  onFinish,\n  generateId: generateId2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.generateId\n}) {\n  let controller;\n  const ongoingStreamPromises = [];\n  const stream = new ReadableStream({\n    start(controllerArg) {\n      controller = controllerArg;\n    }\n  });\n  function safeEnqueue(data) {\n    try {\n      controller.enqueue(data);\n    } catch (error) {\n    }\n  }\n  try {\n    const result = execute({\n      writer: {\n        write(part) {\n          safeEnqueue(part);\n        },\n        merge(streamArg) {\n          ongoingStreamPromises.push(\n            (async () => {\n              const reader = streamArg.getReader();\n              while (true) {\n                const { done, value } = await reader.read();\n                if (done)\n                  break;\n                safeEnqueue(value);\n              }\n            })().catch((error) => {\n              safeEnqueue({\n                type: \"error\",\n                errorText: onError(error)\n              });\n            })\n          );\n        },\n        onError\n      }\n    });\n    if (result) {\n      ongoingStreamPromises.push(\n        result.catch((error) => {\n          safeEnqueue({\n            type: \"error\",\n            errorText: onError(error)\n          });\n        })\n      );\n    }\n  } catch (error) {\n    safeEnqueue({\n      type: \"error\",\n      errorText: onError(error)\n    });\n  }\n  const waitForStreams = new Promise(async (resolve3) => {\n    while (ongoingStreamPromises.length > 0) {\n      await ongoingStreamPromises.shift();\n    }\n    resolve3();\n  });\n  waitForStreams.finally(() => {\n    try {\n      controller.close();\n    } catch (error) {\n    }\n  });\n  return handleUIMessageStreamFinish({\n    stream,\n    messageId: generateId2(),\n    originalMessages,\n    onStepFinish,\n    onFinish,\n    onError\n  });\n}\n\n// src/ui-message-stream/read-ui-message-stream.ts\nfunction readUIMessageStream({\n  message,\n  stream,\n  onError,\n  terminateOnError = false\n}) {\n  var _a21;\n  let controller;\n  let hasErrored = false;\n  const outputStream = new ReadableStream({\n    start(controllerParam) {\n      controller = controllerParam;\n    }\n  });\n  const state = createStreamingUIMessageState({\n    messageId: (_a21 = message == null ? void 0 : message.id) != null ? _a21 : \"\",\n    lastMessage: message\n  });\n  const handleError = (error) => {\n    onError == null ? void 0 : onError(error);\n    if (!hasErrored && terminateOnError) {\n      hasErrored = true;\n      controller == null ? void 0 : controller.error(error);\n    }\n  };\n  consumeStream({\n    stream: processUIMessageStream({\n      stream,\n      runUpdateMessageJob(job) {\n        return job({\n          state,\n          write: () => {\n            controller == null ? void 0 : controller.enqueue(structuredClone(state.message));\n          }\n        });\n      },\n      onError: handleError\n    }),\n    onError: handleError\n  }).finally(() => {\n    if (!hasErrored) {\n      controller == null ? void 0 : controller.close();\n    }\n  });\n  return createAsyncIterableStream(outputStream);\n}\n\n// src/ui/convert-to-model-messages.ts\n\nasync function convertToModelMessages(messages, options) {\n  const modelMessages = [];\n  if (options == null ? void 0 : options.ignoreIncompleteToolCalls) {\n    messages = messages.map((message) => ({\n      ...message,\n      parts: message.parts.filter(\n        (part) => !isToolUIPart(part) || part.state !== \"input-streaming\" && part.state !== \"input-available\"\n      )\n    }));\n  }\n  for (const message of messages) {\n    switch (message.role) {\n      case \"system\": {\n        const textParts = message.parts.filter(\n          (part) => part.type === \"text\"\n        );\n        const providerMetadata = textParts.reduce((acc, part) => {\n          if (part.providerMetadata != null) {\n            return { ...acc, ...part.providerMetadata };\n          }\n          return acc;\n        }, {});\n        modelMessages.push({\n          role: \"system\",\n          content: textParts.map((part) => part.text).join(\"\"),\n          ...Object.keys(providerMetadata).length > 0 ? { providerOptions: providerMetadata } : {}\n        });\n        break;\n      }\n      case \"user\": {\n        modelMessages.push({\n          role: \"user\",\n          content: message.parts.map((part) => {\n            var _a21;\n            if (isTextUIPart(part)) {\n              return {\n                type: \"text\",\n                text: part.text,\n                ...part.providerMetadata != null ? { providerOptions: part.providerMetadata } : {}\n              };\n            }\n            if (isFileUIPart(part)) {\n              return {\n                type: \"file\",\n                mediaType: part.mediaType,\n                filename: part.filename,\n                data: part.url,\n                ...part.providerMetadata != null ? { providerOptions: part.providerMetadata } : {}\n              };\n            }\n            if (isDataUIPart(part)) {\n              return (_a21 = options == null ? void 0 : options.convertDataPart) == null ? void 0 : _a21.call(\n                options,\n                part\n              );\n            }\n          }).filter(_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.isNonNullable)\n        });\n        break;\n      }\n      case \"assistant\": {\n        if (message.parts != null) {\n          let block = [];\n          async function processBlock() {\n            var _a21, _b, _c, _d, _e, _f;\n            if (block.length === 0) {\n              return;\n            }\n            const content = [];\n            for (const part of block) {\n              if (isTextUIPart(part)) {\n                content.push({\n                  type: \"text\",\n                  text: part.text,\n                  ...part.providerMetadata != null ? { providerOptions: part.providerMetadata } : {}\n                });\n              } else if (isFileUIPart(part)) {\n                content.push({\n                  type: \"file\",\n                  mediaType: part.mediaType,\n                  filename: part.filename,\n                  data: part.url\n                });\n              } else if (isReasoningUIPart(part)) {\n                content.push({\n                  type: \"reasoning\",\n                  text: part.text,\n                  providerOptions: part.providerMetadata\n                });\n              } else if (isToolUIPart(part)) {\n                const toolName = getToolName(part);\n                if (part.state !== \"input-streaming\") {\n                  content.push({\n                    type: \"tool-call\",\n                    toolCallId: part.toolCallId,\n                    toolName,\n                    input: part.state === \"output-error\" ? (_a21 = part.input) != null ? _a21 : \"rawInput\" in part ? part.rawInput : void 0 : part.input,\n                    providerExecuted: part.providerExecuted,\n                    ...part.callProviderMetadata != null ? { providerOptions: part.callProviderMetadata } : {}\n                  });\n                  if (part.approval != null) {\n                    content.push({\n                      type: \"tool-approval-request\",\n                      approvalId: part.approval.id,\n                      toolCallId: part.toolCallId\n                    });\n                  }\n                  if (part.providerExecuted === true && part.state !== \"approval-responded\" && (part.state === \"output-available\" || part.state === \"output-error\")) {\n                    content.push({\n                      type: \"tool-result\",\n                      toolCallId: part.toolCallId,\n                      toolName,\n                      output: await createToolModelOutput({\n                        toolCallId: part.toolCallId,\n                        input: part.input,\n                        output: part.state === \"output-error\" ? part.errorText : part.output,\n                        tool: (_b = options == null ? void 0 : options.tools) == null ? void 0 : _b[toolName],\n                        errorMode: part.state === \"output-error\" ? \"json\" : \"none\"\n                      }),\n                      ...part.callProviderMetadata != null ? { providerOptions: part.callProviderMetadata } : {}\n                    });\n                  }\n                }\n              } else if (isDataUIPart(part)) {\n                const dataPart = (_c = options == null ? void 0 : options.convertDataPart) == null ? void 0 : _c.call(\n                  options,\n                  part\n                );\n                if (dataPart != null) {\n                  content.push(dataPart);\n                }\n              } else {\n                const _exhaustiveCheck = part;\n                throw new Error(`Unsupported part: ${_exhaustiveCheck}`);\n              }\n            }\n            modelMessages.push({\n              role: \"assistant\",\n              content\n            });\n            const toolParts = block.filter(\n              (part) => {\n                var _a22;\n                return isToolUIPart(part) && (part.providerExecuted !== true || ((_a22 = part.approval) == null ? void 0 : _a22.approved) != null);\n              }\n            );\n            if (toolParts.length > 0) {\n              {\n                const content2 = [];\n                for (const toolPart of toolParts) {\n                  if (((_d = toolPart.approval) == null ? void 0 : _d.approved) != null) {\n                    content2.push({\n                      type: \"tool-approval-response\",\n                      approvalId: toolPart.approval.id,\n                      approved: toolPart.approval.approved,\n                      reason: toolPart.approval.reason,\n                      providerExecuted: toolPart.providerExecuted\n                    });\n                  }\n                  if (toolPart.providerExecuted === true) {\n                    continue;\n                  }\n                  switch (toolPart.state) {\n                    case \"output-denied\": {\n                      content2.push({\n                        type: \"tool-result\",\n                        toolCallId: toolPart.toolCallId,\n                        toolName: getToolName(toolPart),\n                        output: {\n                          type: \"error-text\",\n                          value: (_e = toolPart.approval.reason) != null ? _e : \"Tool execution denied.\"\n                        },\n                        ...toolPart.callProviderMetadata != null ? { providerOptions: toolPart.callProviderMetadata } : {}\n                      });\n                      break;\n                    }\n                    case \"output-error\":\n                    case \"output-available\": {\n                      const toolName = getToolName(toolPart);\n                      content2.push({\n                        type: \"tool-result\",\n                        toolCallId: toolPart.toolCallId,\n                        toolName,\n                        output: await createToolModelOutput({\n                          toolCallId: toolPart.toolCallId,\n                          input: toolPart.input,\n                          output: toolPart.state === \"output-error\" ? toolPart.errorText : toolPart.output,\n                          tool: (_f = options == null ? void 0 : options.tools) == null ? void 0 : _f[toolName],\n                          errorMode: toolPart.state === \"output-error\" ? \"text\" : \"none\"\n                        }),\n                        ...toolPart.callProviderMetadata != null ? { providerOptions: toolPart.callProviderMetadata } : {}\n                      });\n                      break;\n                    }\n                  }\n                }\n                if (content2.length > 0) {\n                  modelMessages.push({\n                    role: \"tool\",\n                    content: content2\n                  });\n                }\n              }\n            }\n            block = [];\n          }\n          for (const part of message.parts) {\n            if (isTextUIPart(part) || isReasoningUIPart(part) || isFileUIPart(part) || isToolUIPart(part) || isDataUIPart(part)) {\n              block.push(part);\n            } else if (part.type === \"step-start\") {\n              await processBlock();\n            }\n          }\n          await processBlock();\n          break;\n        }\n        break;\n      }\n      default: {\n        const _exhaustiveCheck = message.role;\n        throw new MessageConversionError({\n          originalMessage: message,\n          message: `Unsupported role: ${_exhaustiveCheck}`\n        });\n      }\n    }\n  }\n  return modelMessages;\n}\n\n// src/ui/validate-ui-messages.ts\n\n\n\nvar uiMessagesSchema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.lazySchema)(\n  () => (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.zodSchema)(\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n        id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        role: zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"enum\"]([\"system\", \"user\", \"assistant\"]),\n        metadata: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown().optional(),\n        parts: zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(\n          zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"text\"),\n              text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"enum\"]([\"streaming\", \"done\"]).optional(),\n              providerMetadata: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"reasoning\"),\n              text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"enum\"]([\"streaming\", \"done\"]).optional(),\n              providerMetadata: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"source-url\"),\n              sourceId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n              providerMetadata: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"source-document\"),\n              sourceId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              filename: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n              providerMetadata: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"file\"),\n              mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              filename: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n              url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              providerMetadata: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"step-start\")\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().startsWith(\"data-\"),\n              id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n              data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"dynamic-tool\"),\n              toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"input-streaming\"),\n              input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown().optional(),\n              providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n              errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n              approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"dynamic-tool\"),\n              toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"input-available\"),\n              input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n              providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n              output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n              errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"dynamic-tool\"),\n              toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"approval-requested\"),\n              input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n              providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n              output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n              errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n                reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional()\n              })\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"dynamic-tool\"),\n              toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"approval-responded\"),\n              input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n              providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n              output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n              errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean(),\n                reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional()\n              })\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"dynamic-tool\"),\n              toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"output-available\"),\n              input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n              providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n              output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n              errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              preliminary: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n              approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(true),\n                reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional()\n              }).optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"dynamic-tool\"),\n              toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"output-error\"),\n              input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n              rawInput: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown().optional(),\n              providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n              output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n              errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(true),\n                reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional()\n              }).optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"dynamic-tool\"),\n              toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"output-denied\"),\n              input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n              providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n              output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n              errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(false),\n                reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional()\n              })\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().startsWith(\"tool-\"),\n              toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"input-streaming\"),\n              providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown().optional(),\n              output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n              errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n              approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().startsWith(\"tool-\"),\n              toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"input-available\"),\n              providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n              input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n              output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n              errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().startsWith(\"tool-\"),\n              toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"approval-requested\"),\n              input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n              providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n              output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n              errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n                reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional()\n              })\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().startsWith(\"tool-\"),\n              toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"approval-responded\"),\n              input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n              providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n              output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n              errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean(),\n                reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional()\n              })\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().startsWith(\"tool-\"),\n              toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"output-available\"),\n              providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n              input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n              output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n              errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              preliminary: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n              approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(true),\n                reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional()\n              }).optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().startsWith(\"tool-\"),\n              toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"output-error\"),\n              providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n              input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n              rawInput: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown().optional(),\n              output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n              errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(true),\n                reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional()\n              }).optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().startsWith(\"tool-\"),\n              toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"output-denied\"),\n              providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n              input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n              output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n              errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(false),\n                reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional()\n              })\n            })\n          ])\n        ).nonempty(\"Message must contain at least one part\")\n      })\n    ).nonempty(\"Messages array must not be empty\")\n  )\n);\nasync function safeValidateUIMessages({\n  messages,\n  metadataSchema,\n  dataSchemas,\n  tools\n}) {\n  try {\n    if (messages == null) {\n      return {\n        success: false,\n        error: new InvalidArgumentError({\n          parameter: \"messages\",\n          value: messages,\n          message: \"messages parameter must be provided\"\n        })\n      };\n    }\n    const validatedMessages = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n      value: messages,\n      schema: uiMessagesSchema\n    });\n    if (metadataSchema) {\n      for (const [msgIdx, message] of validatedMessages.entries()) {\n        await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n          value: message.metadata,\n          schema: metadataSchema,\n          context: {\n            field: `messages[${msgIdx}].metadata`,\n            entityId: message.id\n          }\n        });\n      }\n    }\n    if (dataSchemas || tools) {\n      for (const [msgIdx, message] of validatedMessages.entries()) {\n        for (const [partIdx, part] of message.parts.entries()) {\n          if (dataSchemas && part.type.startsWith(\"data-\")) {\n            const dataPart = part;\n            const dataName = dataPart.type.slice(5);\n            const dataSchema = dataSchemas[dataName];\n            if (!dataSchema) {\n              return {\n                success: false,\n                error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                  value: dataPart.data,\n                  cause: `No data schema found for data part ${dataName}`,\n                  context: {\n                    field: `messages[${msgIdx}].parts[${partIdx}].data`,\n                    entityName: dataName,\n                    entityId: dataPart.id\n                  }\n                })\n              };\n            }\n            await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n              value: dataPart.data,\n              schema: dataSchema,\n              context: {\n                field: `messages[${msgIdx}].parts[${partIdx}].data`,\n                entityName: dataName,\n                entityId: dataPart.id\n              }\n            });\n          }\n          if (tools && part.type.startsWith(\"tool-\")) {\n            const toolPart = part;\n            const toolName = toolPart.type.slice(5);\n            const tool2 = tools[toolName];\n            if (!tool2) {\n              return {\n                success: false,\n                error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                  value: toolPart.input,\n                  cause: `No tool schema found for tool part ${toolName}`,\n                  context: {\n                    field: `messages[${msgIdx}].parts[${partIdx}].input`,\n                    entityName: toolName,\n                    entityId: toolPart.toolCallId\n                  }\n                })\n              };\n            }\n            if (toolPart.state === \"input-available\" || toolPart.state === \"output-available\" || toolPart.state === \"output-error\" && toolPart.input !== void 0) {\n              await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n                value: toolPart.input,\n                schema: tool2.inputSchema,\n                context: {\n                  field: `messages[${msgIdx}].parts[${partIdx}].input`,\n                  entityName: toolName,\n                  entityId: toolPart.toolCallId\n                }\n              });\n            }\n            if (toolPart.state === \"output-available\" && tool2.outputSchema) {\n              await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n                value: toolPart.output,\n                schema: tool2.outputSchema,\n                context: {\n                  field: `messages[${msgIdx}].parts[${partIdx}].output`,\n                  entityName: toolName,\n                  entityId: toolPart.toolCallId\n                }\n              });\n            }\n          }\n        }\n      }\n    }\n    return {\n      success: true,\n      data: validatedMessages\n    };\n  } catch (error) {\n    const err = error;\n    return {\n      success: false,\n      error: err\n    };\n  }\n}\nasync function validateUIMessages({\n  messages,\n  metadataSchema,\n  dataSchemas,\n  tools\n}) {\n  const response = await safeValidateUIMessages({\n    messages,\n    metadataSchema,\n    dataSchemas,\n    tools\n  });\n  if (!response.success)\n    throw response.error;\n  return response.data;\n}\n\n// src/agent/create-agent-ui-stream.ts\nasync function createAgentUIStream({\n  agent,\n  uiMessages,\n  options,\n  abortSignal,\n  timeout,\n  experimental_transform,\n  onStepFinish,\n  ...uiMessageStreamOptions\n}) {\n  var _a21;\n  const validatedMessages = await validateUIMessages({\n    messages: uiMessages,\n    tools: agent.tools\n  });\n  const modelMessages = await convertToModelMessages(validatedMessages, {\n    tools: agent.tools\n  });\n  const result = await agent.stream({\n    prompt: modelMessages,\n    options,\n    abortSignal,\n    timeout,\n    experimental_transform,\n    onStepFinish\n  });\n  return result.toUIMessageStream({\n    ...uiMessageStreamOptions,\n    // TODO reading `originalMessages` is here for bc, always use `validatedMessages` in v7\n    originalMessages: (_a21 = uiMessageStreamOptions.originalMessages) != null ? _a21 : validatedMessages\n  });\n}\n\n// src/agent/create-agent-ui-stream-response.ts\nasync function createAgentUIStreamResponse({\n  headers,\n  status,\n  statusText,\n  consumeSseStream,\n  ...options\n}) {\n  return createUIMessageStreamResponse({\n    headers,\n    status,\n    statusText,\n    consumeSseStream,\n    stream: await createAgentUIStream(options)\n  });\n}\n\n// src/agent/pipe-agent-ui-stream-to-response.ts\nasync function pipeAgentUIStreamToResponse({\n  response,\n  headers,\n  status,\n  statusText,\n  consumeSseStream,\n  ...options\n}) {\n  pipeUIMessageStreamToResponse({\n    response,\n    headers,\n    status,\n    statusText,\n    consumeSseStream,\n    stream: await createAgentUIStream(options)\n  });\n}\n\n// src/embed/embed.ts\n\nasync function embed({\n  model: modelArg,\n  value,\n  providerOptions,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry\n}) {\n  const model = resolveEmbeddingModel(modelArg);\n  const { maxRetries, retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const headersWithUserAgent = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(\n    headers != null ? headers : {},\n    `ai/${VERSION}`\n  );\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers: headersWithUserAgent,\n    settings: { maxRetries }\n  });\n  const tracer = getTracer(telemetry);\n  return recordSpan({\n    name: \"ai.embed\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: \"ai.embed\", telemetry }),\n        ...baseTelemetryAttributes,\n        \"ai.value\": { input: () => JSON.stringify(value) }\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      const { embedding, usage, warnings, response, providerMetadata } = await retry(\n        () => (\n          // nested spans to align with the embedMany telemetry data:\n          recordSpan({\n            name: \"ai.embed.doEmbed\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.embed.doEmbed\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.values\": { input: () => [JSON.stringify(value)] }\n              }\n            }),\n            tracer,\n            fn: async (doEmbedSpan) => {\n              var _a21;\n              const modelResponse = await model.doEmbed({\n                values: [value],\n                abortSignal,\n                headers: headersWithUserAgent,\n                providerOptions\n              });\n              const embedding2 = modelResponse.embeddings[0];\n              const usage2 = (_a21 = modelResponse.usage) != null ? _a21 : { tokens: NaN };\n              doEmbedSpan.setAttributes(\n                await selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.embeddings\": {\n                      output: () => modelResponse.embeddings.map(\n                        (embedding3) => JSON.stringify(embedding3)\n                      )\n                    },\n                    \"ai.usage.tokens\": usage2.tokens\n                  }\n                })\n              );\n              return {\n                embedding: embedding2,\n                usage: usage2,\n                warnings: modelResponse.warnings,\n                providerMetadata: modelResponse.providerMetadata,\n                response: modelResponse.response\n              };\n            }\n          })\n        )\n      );\n      span.setAttributes(\n        await selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.embedding\": { output: () => JSON.stringify(embedding) },\n            \"ai.usage.tokens\": usage.tokens\n          }\n        })\n      );\n      logWarnings({ warnings, provider: model.provider, model: model.modelId });\n      return new DefaultEmbedResult({\n        value,\n        embedding,\n        usage,\n        warnings,\n        providerMetadata,\n        response\n      });\n    }\n  });\n}\nvar DefaultEmbedResult = class {\n  constructor(options) {\n    this.value = options.value;\n    this.embedding = options.embedding;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.providerMetadata = options.providerMetadata;\n    this.response = options.response;\n  }\n};\n\n// src/embed/embed-many.ts\n\n\n// src/util/split-array.ts\nfunction splitArray(array2, chunkSize) {\n  if (chunkSize <= 0) {\n    throw new Error(\"chunkSize must be greater than 0\");\n  }\n  const result = [];\n  for (let i = 0; i < array2.length; i += chunkSize) {\n    result.push(array2.slice(i, i + chunkSize));\n  }\n  return result;\n}\n\n// src/embed/embed-many.ts\nasync function embedMany({\n  model: modelArg,\n  values,\n  maxParallelCalls = Infinity,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  providerOptions,\n  experimental_telemetry: telemetry\n}) {\n  const model = resolveEmbeddingModel(modelArg);\n  const { maxRetries, retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const headersWithUserAgent = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(\n    headers != null ? headers : {},\n    `ai/${VERSION}`\n  );\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers: headersWithUserAgent,\n    settings: { maxRetries }\n  });\n  const tracer = getTracer(telemetry);\n  return recordSpan({\n    name: \"ai.embedMany\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: \"ai.embedMany\", telemetry }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        \"ai.values\": {\n          input: () => values.map((value) => JSON.stringify(value))\n        }\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      var _a21;\n      const [maxEmbeddingsPerCall, supportsParallelCalls] = await Promise.all([\n        model.maxEmbeddingsPerCall,\n        model.supportsParallelCalls\n      ]);\n      if (maxEmbeddingsPerCall == null || maxEmbeddingsPerCall === Infinity) {\n        const { embeddings: embeddings2, usage, warnings: warnings2, response, providerMetadata: providerMetadata2 } = await retry(() => {\n          return recordSpan({\n            name: \"ai.embedMany.doEmbed\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.embedMany.doEmbed\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.values\": {\n                  input: () => values.map((value) => JSON.stringify(value))\n                }\n              }\n            }),\n            tracer,\n            fn: async (doEmbedSpan) => {\n              var _a22;\n              const modelResponse = await model.doEmbed({\n                values,\n                abortSignal,\n                headers: headersWithUserAgent,\n                providerOptions\n              });\n              const embeddings3 = modelResponse.embeddings;\n              const usage2 = (_a22 = modelResponse.usage) != null ? _a22 : { tokens: NaN };\n              doEmbedSpan.setAttributes(\n                await selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.embeddings\": {\n                      output: () => embeddings3.map(\n                        (embedding) => JSON.stringify(embedding)\n                      )\n                    },\n                    \"ai.usage.tokens\": usage2.tokens\n                  }\n                })\n              );\n              return {\n                embeddings: embeddings3,\n                usage: usage2,\n                warnings: modelResponse.warnings,\n                providerMetadata: modelResponse.providerMetadata,\n                response: modelResponse.response\n              };\n            }\n          });\n        });\n        span.setAttributes(\n          await selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              \"ai.embeddings\": {\n                output: () => embeddings2.map((embedding) => JSON.stringify(embedding))\n              },\n              \"ai.usage.tokens\": usage.tokens\n            }\n          })\n        );\n        logWarnings({\n          warnings: warnings2,\n          provider: model.provider,\n          model: model.modelId\n        });\n        return new DefaultEmbedManyResult({\n          values,\n          embeddings: embeddings2,\n          usage,\n          warnings: warnings2,\n          providerMetadata: providerMetadata2,\n          responses: [response]\n        });\n      }\n      const valueChunks = splitArray(values, maxEmbeddingsPerCall);\n      const embeddings = [];\n      const warnings = [];\n      const responses = [];\n      let tokens = 0;\n      let providerMetadata;\n      const parallelChunks = splitArray(\n        valueChunks,\n        supportsParallelCalls ? maxParallelCalls : 1\n      );\n      for (const parallelChunk of parallelChunks) {\n        const results = await Promise.all(\n          parallelChunk.map((chunk) => {\n            return retry(() => {\n              return recordSpan({\n                name: \"ai.embedMany.doEmbed\",\n                attributes: selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    ...assembleOperationName({\n                      operationId: \"ai.embedMany.doEmbed\",\n                      telemetry\n                    }),\n                    ...baseTelemetryAttributes,\n                    // specific settings that only make sense on the outer level:\n                    \"ai.values\": {\n                      input: () => chunk.map((value) => JSON.stringify(value))\n                    }\n                  }\n                }),\n                tracer,\n                fn: async (doEmbedSpan) => {\n                  var _a22;\n                  const modelResponse = await model.doEmbed({\n                    values: chunk,\n                    abortSignal,\n                    headers: headersWithUserAgent,\n                    providerOptions\n                  });\n                  const embeddings2 = modelResponse.embeddings;\n                  const usage = (_a22 = modelResponse.usage) != null ? _a22 : { tokens: NaN };\n                  doEmbedSpan.setAttributes(\n                    await selectTelemetryAttributes({\n                      telemetry,\n                      attributes: {\n                        \"ai.embeddings\": {\n                          output: () => embeddings2.map(\n                            (embedding) => JSON.stringify(embedding)\n                          )\n                        },\n                        \"ai.usage.tokens\": usage.tokens\n                      }\n                    })\n                  );\n                  return {\n                    embeddings: embeddings2,\n                    usage,\n                    warnings: modelResponse.warnings,\n                    providerMetadata: modelResponse.providerMetadata,\n                    response: modelResponse.response\n                  };\n                }\n              });\n            });\n          })\n        );\n        for (const result of results) {\n          embeddings.push(...result.embeddings);\n          warnings.push(...result.warnings);\n          responses.push(result.response);\n          tokens += result.usage.tokens;\n          if (result.providerMetadata) {\n            if (!providerMetadata) {\n              providerMetadata = { ...result.providerMetadata };\n            } else {\n              for (const [providerName, metadata] of Object.entries(\n                result.providerMetadata\n              )) {\n                providerMetadata[providerName] = {\n                  ...(_a21 = providerMetadata[providerName]) != null ? _a21 : {},\n                  ...metadata\n                };\n              }\n            }\n          }\n        }\n      }\n      span.setAttributes(\n        await selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.embeddings\": {\n              output: () => embeddings.map((embedding) => JSON.stringify(embedding))\n            },\n            \"ai.usage.tokens\": tokens\n          }\n        })\n      );\n      logWarnings({\n        warnings,\n        provider: model.provider,\n        model: model.modelId\n      });\n      return new DefaultEmbedManyResult({\n        values,\n        embeddings,\n        usage: { tokens },\n        warnings,\n        providerMetadata,\n        responses\n      });\n    }\n  });\n}\nvar DefaultEmbedManyResult = class {\n  constructor(options) {\n    this.values = options.values;\n    this.embeddings = options.embeddings;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.providerMetadata = options.providerMetadata;\n    this.responses = options.responses;\n  }\n};\n\n// src/generate-image/generate-image.ts\n\nasync function generateImage({\n  model: modelArg,\n  prompt: promptArg,\n  n = 1,\n  maxImagesPerCall,\n  size,\n  aspectRatio,\n  seed,\n  providerOptions,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers\n}) {\n  var _a21, _b;\n  const model = resolveImageModel(modelArg);\n  const headersWithUserAgent = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(\n    headers != null ? headers : {},\n    `ai/${VERSION}`\n  );\n  const { retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const maxImagesPerCallWithDefault = (_a21 = maxImagesPerCall != null ? maxImagesPerCall : await invokeModelMaxImagesPerCall(model)) != null ? _a21 : 1;\n  const callCount = Math.ceil(n / maxImagesPerCallWithDefault);\n  const callImageCounts = Array.from({ length: callCount }, (_, i) => {\n    if (i < callCount - 1) {\n      return maxImagesPerCallWithDefault;\n    }\n    const remainder = n % maxImagesPerCallWithDefault;\n    return remainder === 0 ? maxImagesPerCallWithDefault : remainder;\n  });\n  const results = await Promise.all(\n    callImageCounts.map(\n      async (callImageCount) => retry(() => {\n        const { prompt, files, mask } = normalizePrompt(promptArg);\n        return model.doGenerate({\n          prompt,\n          files,\n          mask,\n          n: callImageCount,\n          abortSignal,\n          headers: headersWithUserAgent,\n          size,\n          aspectRatio,\n          seed,\n          providerOptions: providerOptions != null ? providerOptions : {}\n        });\n      })\n    )\n  );\n  const images = [];\n  const warnings = [];\n  const responses = [];\n  const providerMetadata = {};\n  let totalUsage = {\n    inputTokens: void 0,\n    outputTokens: void 0,\n    totalTokens: void 0\n  };\n  for (const result of results) {\n    images.push(\n      ...result.images.map(\n        (image) => {\n          var _a22;\n          return new DefaultGeneratedFile({\n            data: image,\n            mediaType: (_a22 = detectMediaType({\n              data: image,\n              signatures: imageMediaTypeSignatures\n            })) != null ? _a22 : \"image/png\"\n          });\n        }\n      )\n    );\n    warnings.push(...result.warnings);\n    if (result.usage != null) {\n      totalUsage = addImageModelUsage(totalUsage, result.usage);\n    }\n    if (result.providerMetadata) {\n      for (const [providerName, metadata] of Object.entries(result.providerMetadata)) {\n        if (providerName === \"gateway\") {\n          const currentEntry = providerMetadata[providerName];\n          if (currentEntry != null && typeof currentEntry === \"object\") {\n            providerMetadata[providerName] = {\n              ...currentEntry,\n              ...metadata\n            };\n          } else {\n            providerMetadata[providerName] = metadata;\n          }\n          const imagesValue = providerMetadata[providerName].images;\n          if (Array.isArray(imagesValue) && imagesValue.length === 0) {\n            delete providerMetadata[providerName].images;\n          }\n        } else {\n          (_b = providerMetadata[providerName]) != null ? _b : providerMetadata[providerName] = { images: [] };\n          providerMetadata[providerName].images.push(\n            ...result.providerMetadata[providerName].images\n          );\n        }\n      }\n    }\n    responses.push(result.response);\n  }\n  logWarnings({ warnings, provider: model.provider, model: model.modelId });\n  if (!images.length) {\n    throw new NoImageGeneratedError({ responses });\n  }\n  return new DefaultGenerateImageResult({\n    images,\n    warnings,\n    responses,\n    providerMetadata,\n    usage: totalUsage\n  });\n}\nvar DefaultGenerateImageResult = class {\n  constructor(options) {\n    this.images = options.images;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = options.providerMetadata;\n    this.usage = options.usage;\n  }\n  get image() {\n    return this.images[0];\n  }\n};\nasync function invokeModelMaxImagesPerCall(model) {\n  const isFunction = model.maxImagesPerCall instanceof Function;\n  if (!isFunction) {\n    return model.maxImagesPerCall;\n  }\n  return model.maxImagesPerCall({\n    modelId: model.modelId\n  });\n}\nfunction normalizePrompt(prompt) {\n  if (typeof prompt === \"string\") {\n    return { prompt, files: void 0, mask: void 0 };\n  }\n  return {\n    prompt: prompt.text,\n    files: prompt.images.map(toImageModelV3File),\n    mask: prompt.mask ? toImageModelV3File(prompt.mask) : void 0\n  };\n}\nfunction toImageModelV3File(dataContent) {\n  if (typeof dataContent === \"string\" && dataContent.startsWith(\"http\")) {\n    return {\n      type: \"url\",\n      url: dataContent\n    };\n  }\n  if (typeof dataContent === \"string\" && dataContent.startsWith(\"data:\")) {\n    const { mediaType: dataUrlMediaType, base64Content } = splitDataUrl(dataContent);\n    if (base64Content != null) {\n      const uint8Data2 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(base64Content);\n      return {\n        type: \"file\",\n        data: uint8Data2,\n        mediaType: dataUrlMediaType || detectMediaType({\n          data: uint8Data2,\n          signatures: imageMediaTypeSignatures\n        }) || \"image/png\"\n      };\n    }\n  }\n  const uint8Data = convertDataContentToUint8Array(dataContent);\n  return {\n    type: \"file\",\n    data: uint8Data,\n    mediaType: detectMediaType({\n      data: uint8Data,\n      signatures: imageMediaTypeSignatures\n    }) || \"image/png\"\n  };\n}\n\n// src/generate-image/index.ts\nvar experimental_generateImage = generateImage;\n\n// src/generate-object/generate-object.ts\n\n\n// src/generate-object/output-strategy.ts\n\n\nvar noSchemaOutputStrategy = {\n  type: \"no-schema\",\n  jsonSchema: async () => void 0,\n  async validatePartialResult({ value, textDelta }) {\n    return { success: true, value: { partial: value, textDelta } };\n  },\n  async validateFinalResult(value, context2) {\n    return value === void 0 ? {\n      success: false,\n      error: new NoObjectGeneratedError({\n        message: \"No object generated: response did not match schema.\",\n        text: context2.text,\n        response: context2.response,\n        usage: context2.usage,\n        finishReason: context2.finishReason\n      })\n    } : { success: true, value };\n  },\n  createElementStream() {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n      functionality: \"element streams in no-schema mode\"\n    });\n  }\n};\nvar objectOutputStrategy = (schema) => ({\n  type: \"object\",\n  jsonSchema: async () => await schema.jsonSchema,\n  async validatePartialResult({ value, textDelta }) {\n    return {\n      success: true,\n      value: {\n        // Note: currently no validation of partial results:\n        partial: value,\n        textDelta\n      }\n    };\n  },\n  async validateFinalResult(value) {\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({ value, schema });\n  },\n  createElementStream() {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n      functionality: \"element streams in object mode\"\n    });\n  }\n});\nvar arrayOutputStrategy = (schema) => {\n  return {\n    type: \"array\",\n    // wrap in object that contains array of elements, since most LLMs will not\n    // be able to generate an array directly:\n    // possible future optimization: use arrays directly when model supports grammar-guided generation\n    jsonSchema: async () => {\n      const { $schema, ...itemSchema } = await schema.jsonSchema;\n      return {\n        $schema: \"http://json-schema.org/draft-07/schema#\",\n        type: \"object\",\n        properties: {\n          elements: { type: \"array\", items: itemSchema }\n        },\n        required: [\"elements\"],\n        additionalProperties: false\n      };\n    },\n    async validatePartialResult({\n      value,\n      latestObject,\n      isFirstDelta,\n      isFinalDelta\n    }) {\n      var _a21;\n      if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || !(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONArray)(value.elements)) {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: \"value must be an object that contains an array of elements\"\n          })\n        };\n      }\n      const inputArray = value.elements;\n      const resultArray = [];\n      for (let i = 0; i < inputArray.length; i++) {\n        const element = inputArray[i];\n        const result = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({ value: element, schema });\n        if (i === inputArray.length - 1 && !isFinalDelta) {\n          continue;\n        }\n        if (!result.success) {\n          return result;\n        }\n        resultArray.push(result.value);\n      }\n      const publishedElementCount = (_a21 = latestObject == null ? void 0 : latestObject.length) != null ? _a21 : 0;\n      let textDelta = \"\";\n      if (isFirstDelta) {\n        textDelta += \"[\";\n      }\n      if (publishedElementCount > 0) {\n        textDelta += \",\";\n      }\n      textDelta += resultArray.slice(publishedElementCount).map((element) => JSON.stringify(element)).join(\",\");\n      if (isFinalDelta) {\n        textDelta += \"]\";\n      }\n      return {\n        success: true,\n        value: {\n          partial: resultArray,\n          textDelta\n        }\n      };\n    },\n    async validateFinalResult(value) {\n      if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || !(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONArray)(value.elements)) {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: \"value must be an object that contains an array of elements\"\n          })\n        };\n      }\n      const inputArray = value.elements;\n      for (const element of inputArray) {\n        const result = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({ value: element, schema });\n        if (!result.success) {\n          return result;\n        }\n      }\n      return { success: true, value: inputArray };\n    },\n    createElementStream(originalStream) {\n      let publishedElements = 0;\n      return createAsyncIterableStream(\n        originalStream.pipeThrough(\n          new TransformStream({\n            transform(chunk, controller) {\n              switch (chunk.type) {\n                case \"object\": {\n                  const array2 = chunk.object;\n                  for (; publishedElements < array2.length; publishedElements++) {\n                    controller.enqueue(array2[publishedElements]);\n                  }\n                  break;\n                }\n                case \"text-delta\":\n                case \"finish\":\n                case \"error\":\n                  break;\n                default: {\n                  const _exhaustiveCheck = chunk;\n                  throw new Error(\n                    `Unsupported chunk type: ${_exhaustiveCheck}`\n                  );\n                }\n              }\n            }\n          })\n        )\n      );\n    }\n  };\n};\nvar enumOutputStrategy = (enumValues) => {\n  return {\n    type: \"enum\",\n    // wrap in object that contains result, since most LLMs will not\n    // be able to generate an enum value directly:\n    // possible future optimization: use enums directly when model supports top-level enums\n    jsonSchema: async () => ({\n      $schema: \"http://json-schema.org/draft-07/schema#\",\n      type: \"object\",\n      properties: {\n        result: { type: \"string\", enum: enumValues }\n      },\n      required: [\"result\"],\n      additionalProperties: false\n    }),\n    async validateFinalResult(value) {\n      if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || typeof value.result !== \"string\") {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: 'value must be an object that contains a string in the \"result\" property.'\n          })\n        };\n      }\n      const result = value.result;\n      return enumValues.includes(result) ? { success: true, value: result } : {\n        success: false,\n        error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n          value,\n          cause: \"value must be a string in the enum\"\n        })\n      };\n    },\n    async validatePartialResult({ value, textDelta }) {\n      if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || typeof value.result !== \"string\") {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: 'value must be an object that contains a string in the \"result\" property.'\n          })\n        };\n      }\n      const result = value.result;\n      const possibleEnumValues = enumValues.filter(\n        (enumValue) => enumValue.startsWith(result)\n      );\n      if (value.result.length === 0 || possibleEnumValues.length === 0) {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: \"value must be a string in the enum\"\n          })\n        };\n      }\n      return {\n        success: true,\n        value: {\n          partial: possibleEnumValues.length > 1 ? result : possibleEnumValues[0],\n          textDelta\n        }\n      };\n    },\n    createElementStream() {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n        functionality: \"element streams in enum mode\"\n      });\n    }\n  };\n};\nfunction getOutputStrategy({\n  output,\n  schema,\n  enumValues\n}) {\n  switch (output) {\n    case \"object\":\n      return objectOutputStrategy((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(schema));\n    case \"array\":\n      return arrayOutputStrategy((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(schema));\n    case \"enum\":\n      return enumOutputStrategy(enumValues);\n    case \"no-schema\":\n      return noSchemaOutputStrategy;\n    default: {\n      const _exhaustiveCheck = output;\n      throw new Error(`Unsupported output: ${_exhaustiveCheck}`);\n    }\n  }\n}\n\n// src/generate-object/parse-and-validate-object-result.ts\n\n\nasync function parseAndValidateObjectResult(result, outputStrategy, context2) {\n  const parseResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: result });\n  if (!parseResult.success) {\n    throw new NoObjectGeneratedError({\n      message: \"No object generated: could not parse the response.\",\n      cause: parseResult.error,\n      text: result,\n      response: context2.response,\n      usage: context2.usage,\n      finishReason: context2.finishReason\n    });\n  }\n  const validationResult = await outputStrategy.validateFinalResult(\n    parseResult.value,\n    {\n      text: result,\n      response: context2.response,\n      usage: context2.usage\n    }\n  );\n  if (!validationResult.success) {\n    throw new NoObjectGeneratedError({\n      message: \"No object generated: response did not match schema.\",\n      cause: validationResult.error,\n      text: result,\n      response: context2.response,\n      usage: context2.usage,\n      finishReason: context2.finishReason\n    });\n  }\n  return validationResult.value;\n}\nasync function parseAndValidateObjectResultWithRepair(result, outputStrategy, repairText, context2) {\n  try {\n    return await parseAndValidateObjectResult(result, outputStrategy, context2);\n  } catch (error) {\n    if (repairText != null && NoObjectGeneratedError.isInstance(error) && (_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError.isInstance(error.cause) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError.isInstance(error.cause))) {\n      const repairedText = await repairText({\n        text: result,\n        error: error.cause\n      });\n      if (repairedText === null) {\n        throw error;\n      }\n      return await parseAndValidateObjectResult(\n        repairedText,\n        outputStrategy,\n        context2\n      );\n    }\n    throw error;\n  }\n}\n\n// src/generate-object/validate-object-generation-input.ts\nfunction validateObjectGenerationInput({\n  output,\n  schema,\n  schemaName,\n  schemaDescription,\n  enumValues\n}) {\n  if (output != null && output !== \"object\" && output !== \"array\" && output !== \"enum\" && output !== \"no-schema\") {\n    throw new InvalidArgumentError({\n      parameter: \"output\",\n      value: output,\n      message: \"Invalid output type.\"\n    });\n  }\n  if (output === \"no-schema\") {\n    if (schema != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Schema is not supported for no-schema output.\"\n      });\n    }\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaDescription\",\n        value: schemaDescription,\n        message: \"Schema description is not supported for no-schema output.\"\n      });\n    }\n    if (schemaName != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaName\",\n        value: schemaName,\n        message: \"Schema name is not supported for no-schema output.\"\n      });\n    }\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are not supported for no-schema output.\"\n      });\n    }\n  }\n  if (output === \"object\") {\n    if (schema == null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Schema is required for object output.\"\n      });\n    }\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are not supported for object output.\"\n      });\n    }\n  }\n  if (output === \"array\") {\n    if (schema == null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Element schema is required for array output.\"\n      });\n    }\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are not supported for array output.\"\n      });\n    }\n  }\n  if (output === \"enum\") {\n    if (schema != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Schema is not supported for enum output.\"\n      });\n    }\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaDescription\",\n        value: schemaDescription,\n        message: \"Schema description is not supported for enum output.\"\n      });\n    }\n    if (schemaName != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaName\",\n        value: schemaName,\n        message: \"Schema name is not supported for enum output.\"\n      });\n    }\n    if (enumValues == null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are required for enum output.\"\n      });\n    }\n    for (const value of enumValues) {\n      if (typeof value !== \"string\") {\n        throw new InvalidArgumentError({\n          parameter: \"enumValues\",\n          value,\n          message: \"Enum values must be strings.\"\n        });\n      }\n    }\n  }\n}\n\n// src/generate-object/generate-object.ts\nvar originalGenerateId3 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({ prefix: \"aiobj\", size: 24 });\nasync function generateObject(options) {\n  const {\n    model: modelArg,\n    output = \"object\",\n    system,\n    prompt,\n    messages,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    headers,\n    experimental_repairText: repairText,\n    experimental_telemetry: telemetry,\n    experimental_download: download2,\n    providerOptions,\n    _internal: {\n      generateId: generateId2 = originalGenerateId3,\n      currentDate = () => /* @__PURE__ */ new Date()\n    } = {},\n    ...settings\n  } = options;\n  const model = resolveLanguageModel(modelArg);\n  const enumValues = \"enum\" in options ? options.enum : void 0;\n  const {\n    schema: inputSchema,\n    schemaDescription,\n    schemaName\n  } = \"schema\" in options ? options : {};\n  validateObjectGenerationInput({\n    output,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription,\n    enumValues\n  });\n  const { maxRetries, retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const outputStrategy = getOutputStrategy({\n    output,\n    schema: inputSchema,\n    enumValues\n  });\n  const callSettings = prepareCallSettings(settings);\n  const headersWithUserAgent = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(\n    headers != null ? headers : {},\n    `ai/${VERSION}`\n  );\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers: headersWithUserAgent,\n    settings: { ...callSettings, maxRetries }\n  });\n  const tracer = getTracer(telemetry);\n  const jsonSchema2 = await outputStrategy.jsonSchema();\n  try {\n    return await recordSpan({\n      name: \"ai.generateObject\",\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({\n            operationId: \"ai.generateObject\",\n            telemetry\n          }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          \"ai.prompt\": {\n            input: () => JSON.stringify({ system, prompt, messages })\n          },\n          \"ai.schema\": jsonSchema2 != null ? { input: () => JSON.stringify(jsonSchema2) } : void 0,\n          \"ai.schema.name\": schemaName,\n          \"ai.schema.description\": schemaDescription,\n          \"ai.settings.output\": outputStrategy.type\n        }\n      }),\n      tracer,\n      fn: async (span) => {\n        var _a21;\n        let result;\n        let finishReason;\n        let usage;\n        let warnings;\n        let response;\n        let request;\n        let resultProviderMetadata;\n        let reasoning;\n        const standardizedPrompt = await standardizePrompt({\n          system,\n          prompt,\n          messages\n        });\n        const promptMessages = await convertToLanguageModelPrompt({\n          prompt: standardizedPrompt,\n          supportedUrls: await model.supportedUrls,\n          download: download2\n        });\n        const generateResult = await retry(\n          () => recordSpan({\n            name: \"ai.generateObject.doGenerate\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.generateObject.doGenerate\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                \"ai.prompt.messages\": {\n                  input: () => stringifyForTelemetry(promptMessages)\n                },\n                // standardized gen-ai llm span attributes:\n                \"gen_ai.system\": model.provider,\n                \"gen_ai.request.model\": model.modelId,\n                \"gen_ai.request.frequency_penalty\": callSettings.frequencyPenalty,\n                \"gen_ai.request.max_tokens\": callSettings.maxOutputTokens,\n                \"gen_ai.request.presence_penalty\": callSettings.presencePenalty,\n                \"gen_ai.request.temperature\": callSettings.temperature,\n                \"gen_ai.request.top_k\": callSettings.topK,\n                \"gen_ai.request.top_p\": callSettings.topP\n              }\n            }),\n            tracer,\n            fn: async (span2) => {\n              var _a22, _b, _c, _d, _e, _f, _g, _h;\n              const result2 = await model.doGenerate({\n                responseFormat: {\n                  type: \"json\",\n                  schema: jsonSchema2,\n                  name: schemaName,\n                  description: schemaDescription\n                },\n                ...prepareCallSettings(settings),\n                prompt: promptMessages,\n                providerOptions,\n                abortSignal,\n                headers: headersWithUserAgent\n              });\n              const responseData = {\n                id: (_b = (_a22 = result2.response) == null ? void 0 : _a22.id) != null ? _b : generateId2(),\n                timestamp: (_d = (_c = result2.response) == null ? void 0 : _c.timestamp) != null ? _d : currentDate(),\n                modelId: (_f = (_e = result2.response) == null ? void 0 : _e.modelId) != null ? _f : model.modelId,\n                headers: (_g = result2.response) == null ? void 0 : _g.headers,\n                body: (_h = result2.response) == null ? void 0 : _h.body\n              };\n              const text2 = extractTextContent(result2.content);\n              const reasoning2 = extractReasoningContent(result2.content);\n              if (text2 === void 0) {\n                throw new NoObjectGeneratedError({\n                  message: \"No object generated: the model did not return a response.\",\n                  response: responseData,\n                  usage: asLanguageModelUsage(result2.usage),\n                  finishReason: result2.finishReason.unified\n                });\n              }\n              span2.setAttributes(\n                await selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.response.finishReason\": result2.finishReason.unified,\n                    \"ai.response.object\": { output: () => text2 },\n                    \"ai.response.id\": responseData.id,\n                    \"ai.response.model\": responseData.modelId,\n                    \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                    \"ai.response.providerMetadata\": JSON.stringify(\n                      result2.providerMetadata\n                    ),\n                    // TODO rename telemetry attributes to inputTokens and outputTokens\n                    \"ai.usage.promptTokens\": result2.usage.inputTokens.total,\n                    \"ai.usage.completionTokens\": result2.usage.outputTokens.total,\n                    // standardized gen-ai llm span attributes:\n                    \"gen_ai.response.finish_reasons\": [\n                      result2.finishReason.unified\n                    ],\n                    \"gen_ai.response.id\": responseData.id,\n                    \"gen_ai.response.model\": responseData.modelId,\n                    \"gen_ai.usage.input_tokens\": result2.usage.inputTokens.total,\n                    \"gen_ai.usage.output_tokens\": result2.usage.outputTokens.total\n                  }\n                })\n              );\n              return {\n                ...result2,\n                objectText: text2,\n                reasoning: reasoning2,\n                responseData\n              };\n            }\n          })\n        );\n        result = generateResult.objectText;\n        finishReason = generateResult.finishReason.unified;\n        usage = asLanguageModelUsage(generateResult.usage);\n        warnings = generateResult.warnings;\n        resultProviderMetadata = generateResult.providerMetadata;\n        request = (_a21 = generateResult.request) != null ? _a21 : {};\n        response = generateResult.responseData;\n        reasoning = generateResult.reasoning;\n        logWarnings({\n          warnings,\n          provider: model.provider,\n          model: model.modelId\n        });\n        const object2 = await parseAndValidateObjectResultWithRepair(\n          result,\n          outputStrategy,\n          repairText,\n          {\n            response,\n            usage,\n            finishReason\n          }\n        );\n        span.setAttributes(\n          await selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              \"ai.response.finishReason\": finishReason,\n              \"ai.response.object\": {\n                output: () => JSON.stringify(object2)\n              },\n              \"ai.response.providerMetadata\": JSON.stringify(\n                resultProviderMetadata\n              ),\n              // TODO rename telemetry attributes to inputTokens and outputTokens\n              \"ai.usage.promptTokens\": usage.inputTokens,\n              \"ai.usage.completionTokens\": usage.outputTokens\n            }\n          })\n        );\n        return new DefaultGenerateObjectResult({\n          object: object2,\n          reasoning,\n          finishReason,\n          usage,\n          warnings,\n          request,\n          response,\n          providerMetadata: resultProviderMetadata\n        });\n      }\n    });\n  } catch (error) {\n    throw wrapGatewayError(error);\n  }\n}\nvar DefaultGenerateObjectResult = class {\n  constructor(options) {\n    this.object = options.object;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.providerMetadata = options.providerMetadata;\n    this.response = options.response;\n    this.request = options.request;\n    this.reasoning = options.reasoning;\n  }\n  toJsonResponse(init) {\n    var _a21;\n    return new Response(JSON.stringify(this.object), {\n      status: (_a21 = init == null ? void 0 : init.status) != null ? _a21 : 200,\n      headers: prepareHeaders(init == null ? void 0 : init.headers, {\n        \"content-type\": \"application/json; charset=utf-8\"\n      })\n    });\n  }\n};\n\n// src/generate-object/stream-object.ts\n\n\n// src/util/cosine-similarity.ts\nfunction cosineSimilarity(vector1, vector2) {\n  if (vector1.length !== vector2.length) {\n    throw new InvalidArgumentError({\n      parameter: \"vector1,vector2\",\n      value: { vector1Length: vector1.length, vector2Length: vector2.length },\n      message: `Vectors must have the same length`\n    });\n  }\n  const n = vector1.length;\n  if (n === 0) {\n    return 0;\n  }\n  let magnitudeSquared1 = 0;\n  let magnitudeSquared2 = 0;\n  let dotProduct = 0;\n  for (let i = 0; i < n; i++) {\n    const value1 = vector1[i];\n    const value2 = vector2[i];\n    magnitudeSquared1 += value1 * value1;\n    magnitudeSquared2 += value2 * value2;\n    dotProduct += value1 * value2;\n  }\n  return magnitudeSquared1 === 0 || magnitudeSquared2 === 0 ? 0 : dotProduct / (Math.sqrt(magnitudeSquared1) * Math.sqrt(magnitudeSquared2));\n}\n\n// src/util/download/create-download.ts\nfunction createDownload(options) {\n  return ({ url, abortSignal }) => download({ url, maxBytes: options == null ? void 0 : options.maxBytes, abortSignal });\n}\n\n// src/util/data-url.ts\nfunction getTextFromDataUrl(dataUrl) {\n  const [header, base64Content] = dataUrl.split(\",\");\n  const mediaType = header.split(\";\")[0].split(\":\")[1];\n  if (mediaType == null || base64Content == null) {\n    throw new Error(\"Invalid data URL format\");\n  }\n  try {\n    return window.atob(base64Content);\n  } catch (error) {\n    throw new Error(`Error decoding data URL`);\n  }\n}\n\n// src/util/is-deep-equal-data.ts\nfunction isDeepEqualData(obj1, obj2) {\n  if (obj1 === obj2)\n    return true;\n  if (obj1 == null || obj2 == null)\n    return false;\n  if (typeof obj1 !== \"object\" && typeof obj2 !== \"object\")\n    return obj1 === obj2;\n  if (obj1.constructor !== obj2.constructor)\n    return false;\n  if (obj1 instanceof Date && obj2 instanceof Date) {\n    return obj1.getTime() === obj2.getTime();\n  }\n  if (Array.isArray(obj1)) {\n    if (obj1.length !== obj2.length)\n      return false;\n    for (let i = 0; i < obj1.length; i++) {\n      if (!isDeepEqualData(obj1[i], obj2[i]))\n        return false;\n    }\n    return true;\n  }\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n  if (keys1.length !== keys2.length)\n    return false;\n  for (const key of keys1) {\n    if (!keys2.includes(key))\n      return false;\n    if (!isDeepEqualData(obj1[key], obj2[key]))\n      return false;\n  }\n  return true;\n}\n\n// src/util/serial-job-executor.ts\nvar SerialJobExecutor = class {\n  constructor() {\n    this.queue = [];\n    this.isProcessing = false;\n  }\n  async processQueue() {\n    if (this.isProcessing) {\n      return;\n    }\n    this.isProcessing = true;\n    while (this.queue.length > 0) {\n      await this.queue[0]();\n      this.queue.shift();\n    }\n    this.isProcessing = false;\n  }\n  async run(job) {\n    return new Promise((resolve3, reject) => {\n      this.queue.push(async () => {\n        try {\n          await job();\n          resolve3();\n        } catch (error) {\n          reject(error);\n        }\n      });\n      void this.processQueue();\n    });\n  }\n};\n\n// src/util/simulate-readable-stream.ts\n\nfunction simulateReadableStream({\n  chunks,\n  initialDelayInMs = 0,\n  chunkDelayInMs = 0,\n  _internal\n}) {\n  var _a21;\n  const delay2 = (_a21 = _internal == null ? void 0 : _internal.delay) != null ? _a21 : _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.delay;\n  let index = 0;\n  return new ReadableStream({\n    async pull(controller) {\n      if (index < chunks.length) {\n        await delay2(index === 0 ? initialDelayInMs : chunkDelayInMs);\n        controller.enqueue(chunks[index++]);\n      } else {\n        controller.close();\n      }\n    }\n  });\n}\n\n// src/generate-object/stream-object.ts\nvar originalGenerateId4 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({ prefix: \"aiobj\", size: 24 });\nfunction streamObject(options) {\n  const {\n    model,\n    output = \"object\",\n    system,\n    prompt,\n    messages,\n    maxRetries,\n    abortSignal,\n    headers,\n    experimental_repairText: repairText,\n    experimental_telemetry: telemetry,\n    experimental_download: download2,\n    providerOptions,\n    onError = ({ error }) => {\n      console.error(error);\n    },\n    onFinish,\n    _internal: {\n      generateId: generateId2 = originalGenerateId4,\n      currentDate = () => /* @__PURE__ */ new Date(),\n      now: now2 = now\n    } = {},\n    ...settings\n  } = options;\n  const enumValues = \"enum\" in options && options.enum ? options.enum : void 0;\n  const {\n    schema: inputSchema,\n    schemaDescription,\n    schemaName\n  } = \"schema\" in options ? options : {};\n  validateObjectGenerationInput({\n    output,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription,\n    enumValues\n  });\n  const outputStrategy = getOutputStrategy({\n    output,\n    schema: inputSchema,\n    enumValues\n  });\n  return new DefaultStreamObjectResult({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries,\n    abortSignal,\n    outputStrategy,\n    system,\n    prompt,\n    messages,\n    schemaName,\n    schemaDescription,\n    providerOptions,\n    repairText,\n    onError,\n    onFinish,\n    download: download2,\n    generateId: generateId2,\n    currentDate,\n    now: now2\n  });\n}\nvar DefaultStreamObjectResult = class {\n  constructor({\n    model: modelArg,\n    headers,\n    telemetry,\n    settings,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    outputStrategy,\n    system,\n    prompt,\n    messages,\n    schemaName,\n    schemaDescription,\n    providerOptions,\n    repairText,\n    onError,\n    onFinish,\n    download: download2,\n    generateId: generateId2,\n    currentDate,\n    now: now2\n  }) {\n    this._object = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n    this._usage = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n    this._providerMetadata = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n    this._warnings = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n    this._request = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n    this._response = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n    this._finishReason = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n    const model = resolveLanguageModel(modelArg);\n    const { maxRetries, retry } = prepareRetries({\n      maxRetries: maxRetriesArg,\n      abortSignal\n    });\n    const callSettings = prepareCallSettings(settings);\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n      model,\n      telemetry,\n      headers,\n      settings: { ...callSettings, maxRetries }\n    });\n    const tracer = getTracer(telemetry);\n    const self = this;\n    const stitchableStream = createStitchableStream();\n    const eventProcessor = new TransformStream({\n      transform(chunk, controller) {\n        controller.enqueue(chunk);\n        if (chunk.type === \"error\") {\n          onError({ error: wrapGatewayError(chunk.error) });\n        }\n      }\n    });\n    this.baseStream = stitchableStream.stream.pipeThrough(eventProcessor);\n    recordSpan({\n      name: \"ai.streamObject\",\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({\n            operationId: \"ai.streamObject\",\n            telemetry\n          }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          \"ai.prompt\": {\n            input: () => JSON.stringify({ system, prompt, messages })\n          },\n          \"ai.schema\": {\n            input: async () => JSON.stringify(await outputStrategy.jsonSchema())\n          },\n          \"ai.schema.name\": schemaName,\n          \"ai.schema.description\": schemaDescription,\n          \"ai.settings.output\": outputStrategy.type\n        }\n      }),\n      tracer,\n      endWhenDone: false,\n      fn: async (rootSpan) => {\n        const standardizedPrompt = await standardizePrompt({\n          system,\n          prompt,\n          messages\n        });\n        const callOptions = {\n          responseFormat: {\n            type: \"json\",\n            schema: await outputStrategy.jsonSchema(),\n            name: schemaName,\n            description: schemaDescription\n          },\n          ...prepareCallSettings(settings),\n          prompt: await convertToLanguageModelPrompt({\n            prompt: standardizedPrompt,\n            supportedUrls: await model.supportedUrls,\n            download: download2\n          }),\n          providerOptions,\n          abortSignal,\n          headers,\n          includeRawChunks: false\n        };\n        const transformer = {\n          transform: (chunk, controller) => {\n            switch (chunk.type) {\n              case \"text-delta\":\n                controller.enqueue(chunk.delta);\n                break;\n              case \"response-metadata\":\n              case \"finish\":\n              case \"error\":\n              case \"stream-start\":\n                controller.enqueue(chunk);\n                break;\n            }\n          }\n        };\n        const {\n          result: { stream, response, request },\n          doStreamSpan,\n          startTimestampMs\n        } = await retry(\n          () => recordSpan({\n            name: \"ai.streamObject.doStream\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.streamObject.doStream\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                \"ai.prompt.messages\": {\n                  input: () => stringifyForTelemetry(callOptions.prompt)\n                },\n                // standardized gen-ai llm span attributes:\n                \"gen_ai.system\": model.provider,\n                \"gen_ai.request.model\": model.modelId,\n                \"gen_ai.request.frequency_penalty\": callSettings.frequencyPenalty,\n                \"gen_ai.request.max_tokens\": callSettings.maxOutputTokens,\n                \"gen_ai.request.presence_penalty\": callSettings.presencePenalty,\n                \"gen_ai.request.temperature\": callSettings.temperature,\n                \"gen_ai.request.top_k\": callSettings.topK,\n                \"gen_ai.request.top_p\": callSettings.topP\n              }\n            }),\n            tracer,\n            endWhenDone: false,\n            fn: async (doStreamSpan2) => ({\n              startTimestampMs: now2(),\n              doStreamSpan: doStreamSpan2,\n              result: await model.doStream(callOptions)\n            })\n          })\n        );\n        self._request.resolve(request != null ? request : {});\n        let warnings;\n        let usage = createNullLanguageModelUsage();\n        let finishReason;\n        let providerMetadata;\n        let object2;\n        let error;\n        let accumulatedText = \"\";\n        let textDelta = \"\";\n        let fullResponse = {\n          id: generateId2(),\n          timestamp: currentDate(),\n          modelId: model.modelId\n        };\n        let latestObjectJson = void 0;\n        let latestObject = void 0;\n        let isFirstChunk = true;\n        let isFirstDelta = true;\n        const transformedStream = stream.pipeThrough(new TransformStream(transformer)).pipeThrough(\n          new TransformStream({\n            async transform(chunk, controller) {\n              var _a21, _b, _c;\n              if (typeof chunk === \"object\" && chunk.type === \"stream-start\") {\n                warnings = chunk.warnings;\n                return;\n              }\n              if (isFirstChunk) {\n                const msToFirstChunk = now2() - startTimestampMs;\n                isFirstChunk = false;\n                doStreamSpan.addEvent(\"ai.stream.firstChunk\", {\n                  \"ai.stream.msToFirstChunk\": msToFirstChunk\n                });\n                doStreamSpan.setAttributes({\n                  \"ai.stream.msToFirstChunk\": msToFirstChunk\n                });\n              }\n              if (typeof chunk === \"string\") {\n                accumulatedText += chunk;\n                textDelta += chunk;\n                const { value: currentObjectJson, state: parseState } = await parsePartialJson(accumulatedText);\n                if (currentObjectJson !== void 0 && !isDeepEqualData(latestObjectJson, currentObjectJson)) {\n                  const validationResult = await outputStrategy.validatePartialResult({\n                    value: currentObjectJson,\n                    textDelta,\n                    latestObject,\n                    isFirstDelta,\n                    isFinalDelta: parseState === \"successful-parse\"\n                  });\n                  if (validationResult.success && !isDeepEqualData(\n                    latestObject,\n                    validationResult.value.partial\n                  )) {\n                    latestObjectJson = currentObjectJson;\n                    latestObject = validationResult.value.partial;\n                    controller.enqueue({\n                      type: \"object\",\n                      object: latestObject\n                    });\n                    controller.enqueue({\n                      type: \"text-delta\",\n                      textDelta: validationResult.value.textDelta\n                    });\n                    textDelta = \"\";\n                    isFirstDelta = false;\n                  }\n                }\n                return;\n              }\n              switch (chunk.type) {\n                case \"response-metadata\": {\n                  fullResponse = {\n                    id: (_a21 = chunk.id) != null ? _a21 : fullResponse.id,\n                    timestamp: (_b = chunk.timestamp) != null ? _b : fullResponse.timestamp,\n                    modelId: (_c = chunk.modelId) != null ? _c : fullResponse.modelId\n                  };\n                  break;\n                }\n                case \"finish\": {\n                  if (textDelta !== \"\") {\n                    controller.enqueue({ type: \"text-delta\", textDelta });\n                  }\n                  finishReason = chunk.finishReason.unified;\n                  usage = asLanguageModelUsage(chunk.usage);\n                  providerMetadata = chunk.providerMetadata;\n                  controller.enqueue({\n                    ...chunk,\n                    finishReason: chunk.finishReason.unified,\n                    usage,\n                    response: fullResponse\n                  });\n                  logWarnings({\n                    warnings: warnings != null ? warnings : [],\n                    provider: model.provider,\n                    model: model.modelId\n                  });\n                  self._usage.resolve(usage);\n                  self._providerMetadata.resolve(providerMetadata);\n                  self._warnings.resolve(warnings);\n                  self._response.resolve({\n                    ...fullResponse,\n                    headers: response == null ? void 0 : response.headers\n                  });\n                  self._finishReason.resolve(finishReason != null ? finishReason : \"other\");\n                  try {\n                    object2 = await parseAndValidateObjectResultWithRepair(\n                      accumulatedText,\n                      outputStrategy,\n                      repairText,\n                      {\n                        response: fullResponse,\n                        usage,\n                        finishReason\n                      }\n                    );\n                    self._object.resolve(object2);\n                  } catch (e) {\n                    error = e;\n                    self._object.reject(e);\n                  }\n                  break;\n                }\n                default: {\n                  controller.enqueue(chunk);\n                  break;\n                }\n              }\n            },\n            // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n            async flush(controller) {\n              try {\n                const finalUsage = usage != null ? usage : {\n                  promptTokens: NaN,\n                  completionTokens: NaN,\n                  totalTokens: NaN\n                };\n                doStreamSpan.setAttributes(\n                  await selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.response.finishReason\": finishReason,\n                      \"ai.response.object\": {\n                        output: () => JSON.stringify(object2)\n                      },\n                      \"ai.response.id\": fullResponse.id,\n                      \"ai.response.model\": fullResponse.modelId,\n                      \"ai.response.timestamp\": fullResponse.timestamp.toISOString(),\n                      \"ai.response.providerMetadata\": JSON.stringify(providerMetadata),\n                      \"ai.usage.inputTokens\": finalUsage.inputTokens,\n                      \"ai.usage.outputTokens\": finalUsage.outputTokens,\n                      \"ai.usage.totalTokens\": finalUsage.totalTokens,\n                      \"ai.usage.reasoningTokens\": finalUsage.reasoningTokens,\n                      \"ai.usage.cachedInputTokens\": finalUsage.cachedInputTokens,\n                      // standardized gen-ai llm span attributes:\n                      \"gen_ai.response.finish_reasons\": [finishReason],\n                      \"gen_ai.response.id\": fullResponse.id,\n                      \"gen_ai.response.model\": fullResponse.modelId,\n                      \"gen_ai.usage.input_tokens\": finalUsage.inputTokens,\n                      \"gen_ai.usage.output_tokens\": finalUsage.outputTokens\n                    }\n                  })\n                );\n                doStreamSpan.end();\n                rootSpan.setAttributes(\n                  await selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.usage.inputTokens\": finalUsage.inputTokens,\n                      \"ai.usage.outputTokens\": finalUsage.outputTokens,\n                      \"ai.usage.totalTokens\": finalUsage.totalTokens,\n                      \"ai.usage.reasoningTokens\": finalUsage.reasoningTokens,\n                      \"ai.usage.cachedInputTokens\": finalUsage.cachedInputTokens,\n                      \"ai.response.object\": {\n                        output: () => JSON.stringify(object2)\n                      },\n                      \"ai.response.providerMetadata\": JSON.stringify(providerMetadata)\n                    }\n                  })\n                );\n                await (onFinish == null ? void 0 : onFinish({\n                  usage: finalUsage,\n                  object: object2,\n                  error,\n                  response: {\n                    ...fullResponse,\n                    headers: response == null ? void 0 : response.headers\n                  },\n                  warnings,\n                  providerMetadata\n                }));\n              } catch (error2) {\n                controller.enqueue({ type: \"error\", error: error2 });\n              } finally {\n                rootSpan.end();\n              }\n            }\n          })\n        );\n        stitchableStream.addStream(transformedStream);\n      }\n    }).catch((error) => {\n      stitchableStream.addStream(\n        new ReadableStream({\n          start(controller) {\n            controller.enqueue({ type: \"error\", error });\n            controller.close();\n          }\n        })\n      );\n    }).finally(() => {\n      stitchableStream.close();\n    });\n    this.outputStrategy = outputStrategy;\n  }\n  get object() {\n    return this._object.promise;\n  }\n  get usage() {\n    return this._usage.promise;\n  }\n  get providerMetadata() {\n    return this._providerMetadata.promise;\n  }\n  get warnings() {\n    return this._warnings.promise;\n  }\n  get request() {\n    return this._request.promise;\n  }\n  get response() {\n    return this._response.promise;\n  }\n  get finishReason() {\n    return this._finishReason.promise;\n  }\n  get partialObjectStream() {\n    return createAsyncIterableStream(\n      this.baseStream.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            switch (chunk.type) {\n              case \"object\":\n                controller.enqueue(chunk.object);\n                break;\n              case \"text-delta\":\n              case \"finish\":\n              case \"error\":\n                break;\n              default: {\n                const _exhaustiveCheck = chunk;\n                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n              }\n            }\n          }\n        })\n      )\n    );\n  }\n  get elementStream() {\n    return this.outputStrategy.createElementStream(this.baseStream);\n  }\n  get textStream() {\n    return createAsyncIterableStream(\n      this.baseStream.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            switch (chunk.type) {\n              case \"text-delta\":\n                controller.enqueue(chunk.textDelta);\n                break;\n              case \"object\":\n              case \"finish\":\n              case \"error\":\n                break;\n              default: {\n                const _exhaustiveCheck = chunk;\n                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n              }\n            }\n          }\n        })\n      )\n    );\n  }\n  get fullStream() {\n    return createAsyncIterableStream(this.baseStream);\n  }\n  pipeTextStreamToResponse(response, init) {\n    pipeTextStreamToResponse({\n      response,\n      textStream: this.textStream,\n      ...init\n    });\n  }\n  toTextStreamResponse(init) {\n    return createTextStreamResponse({\n      textStream: this.textStream,\n      ...init\n    });\n  }\n};\n\n// src/generate-speech/generate-speech.ts\n\n\n// src/generate-speech/generated-audio-file.ts\nvar DefaultGeneratedAudioFile = class extends DefaultGeneratedFile {\n  constructor({\n    data,\n    mediaType\n  }) {\n    super({ data, mediaType });\n    let format = \"mp3\";\n    if (mediaType) {\n      const mediaTypeParts = mediaType.split(\"/\");\n      if (mediaTypeParts.length === 2) {\n        if (mediaType !== \"audio/mpeg\") {\n          format = mediaTypeParts[1];\n        }\n      }\n    }\n    if (!format) {\n      throw new Error(\n        \"Audio format must be provided or determinable from media type\"\n      );\n    }\n    this.format = format;\n  }\n};\n\n// src/generate-speech/generate-speech.ts\nasync function generateSpeech({\n  model,\n  text: text2,\n  voice,\n  outputFormat,\n  instructions,\n  speed,\n  language,\n  providerOptions = {},\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers\n}) {\n  var _a21;\n  const resolvedModel = resolveSpeechModel(model);\n  if (!resolvedModel) {\n    throw new Error(\"Model could not be resolved\");\n  }\n  const headersWithUserAgent = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(\n    headers != null ? headers : {},\n    `ai/${VERSION}`\n  );\n  const { retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const result = await retry(\n    () => resolvedModel.doGenerate({\n      text: text2,\n      voice,\n      outputFormat,\n      instructions,\n      speed,\n      language,\n      abortSignal,\n      headers: headersWithUserAgent,\n      providerOptions\n    })\n  );\n  if (!result.audio || result.audio.length === 0) {\n    throw new NoSpeechGeneratedError({ responses: [result.response] });\n  }\n  logWarnings({\n    warnings: result.warnings,\n    provider: resolvedModel.provider,\n    model: resolvedModel.modelId\n  });\n  return new DefaultSpeechResult({\n    audio: new DefaultGeneratedAudioFile({\n      data: result.audio,\n      mediaType: (_a21 = detectMediaType({\n        data: result.audio,\n        signatures: audioMediaTypeSignatures\n      })) != null ? _a21 : \"audio/mp3\"\n    }),\n    warnings: result.warnings,\n    responses: [result.response],\n    providerMetadata: result.providerMetadata\n  });\n}\nvar DefaultSpeechResult = class {\n  constructor(options) {\n    var _a21;\n    this.audio = options.audio;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = (_a21 = options.providerMetadata) != null ? _a21 : {};\n  }\n};\n\n// src/generate-text/prune-messages.ts\nfunction pruneMessages({\n  messages,\n  reasoning = \"none\",\n  toolCalls = [],\n  emptyMessages = \"remove\"\n}) {\n  if (reasoning === \"all\" || reasoning === \"before-last-message\") {\n    messages = messages.map((message, messageIndex) => {\n      if (message.role !== \"assistant\" || typeof message.content === \"string\" || reasoning === \"before-last-message\" && messageIndex === messages.length - 1) {\n        return message;\n      }\n      return {\n        ...message,\n        content: message.content.filter((part) => part.type !== \"reasoning\")\n      };\n    });\n  }\n  if (toolCalls === \"none\") {\n    toolCalls = [];\n  } else if (toolCalls === \"all\") {\n    toolCalls = [{ type: \"all\" }];\n  } else if (toolCalls === \"before-last-message\") {\n    toolCalls = [{ type: \"before-last-message\" }];\n  } else if (typeof toolCalls === \"string\") {\n    toolCalls = [{ type: toolCalls }];\n  }\n  for (const toolCall of toolCalls) {\n    const keepLastMessagesCount = toolCall.type === \"all\" ? void 0 : toolCall.type === \"before-last-message\" ? 1 : Number(\n      toolCall.type.slice(\"before-last-\".length).slice(0, -\"-messages\".length)\n    );\n    const keptToolCallIds = /* @__PURE__ */ new Set();\n    const keptApprovalIds = /* @__PURE__ */ new Set();\n    if (keepLastMessagesCount != null) {\n      for (const message of messages.slice(-keepLastMessagesCount)) {\n        if ((message.role === \"assistant\" || message.role === \"tool\") && typeof message.content !== \"string\") {\n          for (const part of message.content) {\n            if (part.type === \"tool-call\" || part.type === \"tool-result\") {\n              keptToolCallIds.add(part.toolCallId);\n            } else if (part.type === \"tool-approval-request\" || part.type === \"tool-approval-response\") {\n              keptApprovalIds.add(part.approvalId);\n            }\n          }\n        }\n      }\n    }\n    messages = messages.map((message, messageIndex) => {\n      if (message.role !== \"assistant\" && message.role !== \"tool\" || typeof message.content === \"string\" || keepLastMessagesCount && messageIndex >= messages.length - keepLastMessagesCount) {\n        return message;\n      }\n      const toolCallIdToToolName = {};\n      const approvalIdToToolName = {};\n      return {\n        ...message,\n        content: message.content.filter((part) => {\n          if (part.type !== \"tool-call\" && part.type !== \"tool-result\" && part.type !== \"tool-approval-request\" && part.type !== \"tool-approval-response\") {\n            return true;\n          }\n          if (part.type === \"tool-call\") {\n            toolCallIdToToolName[part.toolCallId] = part.toolName;\n          } else if (part.type === \"tool-approval-request\") {\n            approvalIdToToolName[part.approvalId] = toolCallIdToToolName[part.toolCallId];\n          }\n          if ((part.type === \"tool-call\" || part.type === \"tool-result\") && keptToolCallIds.has(part.toolCallId) || (part.type === \"tool-approval-request\" || part.type === \"tool-approval-response\") && keptApprovalIds.has(part.approvalId)) {\n            return true;\n          }\n          return toolCall.tools != null && !toolCall.tools.includes(\n            part.type === \"tool-call\" || part.type === \"tool-result\" ? part.toolName : approvalIdToToolName[part.approvalId]\n          );\n        })\n      };\n    });\n  }\n  if (emptyMessages === \"remove\") {\n    messages = messages.filter((message) => message.content.length > 0);\n  }\n  return messages;\n}\n\n// src/generate-text/smooth-stream.ts\n\n\nvar CHUNKING_REGEXPS = {\n  word: /\\S+\\s+/m,\n  line: /\\n+/m\n};\nfunction smoothStream({\n  delayInMs = 10,\n  chunking = \"word\",\n  _internal: { delay: delay2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.delay } = {}\n} = {}) {\n  let detectChunk;\n  if (chunking != null && typeof chunking === \"object\" && \"segment\" in chunking && typeof chunking.segment === \"function\") {\n    const segmenter = chunking;\n    detectChunk = (buffer) => {\n      if (buffer.length === 0)\n        return null;\n      const iterator = segmenter.segment(buffer)[Symbol.iterator]();\n      const first = iterator.next().value;\n      return (first == null ? void 0 : first.segment) || null;\n    };\n  } else if (typeof chunking === \"function\") {\n    detectChunk = (buffer) => {\n      const match = chunking(buffer);\n      if (match == null) {\n        return null;\n      }\n      if (!match.length) {\n        throw new Error(`Chunking function must return a non-empty string.`);\n      }\n      if (!buffer.startsWith(match)) {\n        throw new Error(\n          `Chunking function must return a match that is a prefix of the buffer. Received: \"${match}\" expected to start with \"${buffer}\"`\n        );\n      }\n      return match;\n    };\n  } else {\n    const chunkingRegex = typeof chunking === \"string\" ? CHUNKING_REGEXPS[chunking] : chunking instanceof RegExp ? chunking : void 0;\n    if (chunkingRegex == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError({\n        argument: \"chunking\",\n        message: `Chunking must be \"word\", \"line\", a RegExp, an Intl.Segmenter, or a ChunkDetector function. Received: ${chunking}`\n      });\n    }\n    detectChunk = (buffer) => {\n      const match = chunkingRegex.exec(buffer);\n      if (!match) {\n        return null;\n      }\n      return buffer.slice(0, match.index) + (match == null ? void 0 : match[0]);\n    };\n  }\n  return () => {\n    let buffer = \"\";\n    let id = \"\";\n    let type = void 0;\n    let providerMetadata = void 0;\n    function flushBuffer(controller) {\n      if (buffer.length > 0 && type !== void 0) {\n        controller.enqueue({\n          type,\n          text: buffer,\n          id,\n          ...providerMetadata != null ? { providerMetadata } : {}\n        });\n        buffer = \"\";\n        providerMetadata = void 0;\n      }\n    }\n    return new TransformStream({\n      async transform(chunk, controller) {\n        if (chunk.type !== \"text-delta\" && chunk.type !== \"reasoning-delta\") {\n          flushBuffer(controller);\n          controller.enqueue(chunk);\n          return;\n        }\n        if ((chunk.type !== type || chunk.id !== id) && buffer.length > 0) {\n          flushBuffer(controller);\n        }\n        buffer += chunk.text;\n        id = chunk.id;\n        type = chunk.type;\n        if (chunk.providerMetadata != null) {\n          providerMetadata = chunk.providerMetadata;\n        }\n        let match;\n        while ((match = detectChunk(buffer)) != null) {\n          controller.enqueue({ type, text: match, id });\n          buffer = buffer.slice(match.length);\n          await delay2(delayInMs);\n        }\n      }\n    });\n  };\n}\n\n// src/generate-video/generate-video.ts\n\nvar defaultDownload = createDownload();\nasync function experimental_generateVideo({\n  model: modelArg,\n  prompt: promptArg,\n  n = 1,\n  maxVideosPerCall,\n  aspectRatio,\n  resolution,\n  duration,\n  fps,\n  seed,\n  providerOptions,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  download: downloadFn = defaultDownload\n}) {\n  var _a21;\n  const model = resolveVideoModel(modelArg);\n  const headersWithUserAgent = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(\n    headers != null ? headers : {},\n    `ai/${VERSION}`\n  );\n  const { retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const { prompt, image } = normalizePrompt2(promptArg);\n  const maxVideosPerCallWithDefault = (_a21 = maxVideosPerCall != null ? maxVideosPerCall : await invokeModelMaxVideosPerCall(model)) != null ? _a21 : 1;\n  const callCount = Math.ceil(n / maxVideosPerCallWithDefault);\n  const callVideoCounts = Array.from({ length: callCount }, (_, index) => {\n    const remaining = n - index * maxVideosPerCallWithDefault;\n    return Math.min(remaining, maxVideosPerCallWithDefault);\n  });\n  const results = await Promise.all(\n    callVideoCounts.map(\n      async (callVideoCount) => retry(\n        () => model.doGenerate({\n          prompt,\n          n: callVideoCount,\n          aspectRatio,\n          resolution,\n          duration,\n          fps,\n          seed,\n          image,\n          providerOptions: providerOptions != null ? providerOptions : {},\n          headers: headersWithUserAgent,\n          abortSignal\n        })\n      )\n    )\n  );\n  const videos = [];\n  const warnings = [];\n  const responses = [];\n  const providerMetadata = {};\n  for (const result of results) {\n    for (const videoData of result.videos) {\n      switch (videoData.type) {\n        case \"url\": {\n          const { data, mediaType: downloadedMediaType } = await downloadFn({\n            url: new URL(videoData.url),\n            abortSignal\n          });\n          const isUsableMediaType = (type) => !!type && type !== \"application/octet-stream\";\n          const mediaType = isUsableMediaType(videoData.mediaType) && videoData.mediaType || isUsableMediaType(downloadedMediaType) && downloadedMediaType || detectMediaType({\n            data,\n            signatures: videoMediaTypeSignatures\n          }) || \"video/mp4\";\n          videos.push(\n            new DefaultGeneratedFile({\n              data,\n              mediaType\n            })\n          );\n          break;\n        }\n        case \"base64\": {\n          videos.push(\n            new DefaultGeneratedFile({\n              data: videoData.data,\n              mediaType: videoData.mediaType || \"video/mp4\"\n            })\n          );\n          break;\n        }\n        case \"binary\": {\n          const mediaType = videoData.mediaType || detectMediaType({\n            data: videoData.data,\n            signatures: videoMediaTypeSignatures\n          }) || \"video/mp4\";\n          videos.push(\n            new DefaultGeneratedFile({\n              data: videoData.data,\n              mediaType\n            })\n          );\n          break;\n        }\n      }\n    }\n    warnings.push(...result.warnings);\n    responses.push({\n      timestamp: result.response.timestamp,\n      modelId: result.response.modelId,\n      headers: result.response.headers,\n      providerMetadata: result.providerMetadata\n    });\n    if (result.providerMetadata != null) {\n      for (const [providerName, metadata] of Object.entries(\n        result.providerMetadata\n      )) {\n        const existingMetadata = providerMetadata[providerName];\n        if (existingMetadata != null && typeof existingMetadata === \"object\") {\n          providerMetadata[providerName] = {\n            ...existingMetadata,\n            ...metadata\n          };\n          if (\"videos\" in existingMetadata && Array.isArray(existingMetadata.videos) && \"videos\" in metadata && Array.isArray(metadata.videos)) {\n            providerMetadata[providerName].videos = [\n              ...existingMetadata.videos,\n              ...metadata.videos\n            ];\n          }\n        } else {\n          providerMetadata[providerName] = metadata;\n        }\n      }\n    }\n  }\n  if (videos.length === 0) {\n    throw new NoVideoGeneratedError({ responses });\n  }\n  if (warnings.length > 0) {\n    logWarnings({\n      warnings,\n      provider: model.provider,\n      model: model.modelId\n    });\n  }\n  return {\n    video: videos[0],\n    videos,\n    warnings,\n    responses,\n    providerMetadata\n  };\n}\nfunction normalizePrompt2(promptArg) {\n  var _a21, _b;\n  if (typeof promptArg === \"string\") {\n    return {\n      prompt: promptArg,\n      image: void 0\n    };\n  }\n  let image;\n  if (promptArg.image != null) {\n    const dataContent = promptArg.image;\n    if (typeof dataContent === \"string\") {\n      if (dataContent.startsWith(\"http://\") || dataContent.startsWith(\"https://\")) {\n        image = {\n          type: \"url\",\n          url: dataContent\n        };\n      } else if (dataContent.startsWith(\"data:\")) {\n        const { mediaType, base64Content } = splitDataUrl(dataContent);\n        image = {\n          type: \"file\",\n          mediaType: mediaType != null ? mediaType : \"image/png\",\n          data: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(base64Content != null ? base64Content : \"\")\n        };\n      } else {\n        const bytes = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(dataContent);\n        const mediaType = (_a21 = detectMediaType({\n          data: bytes,\n          signatures: imageMediaTypeSignatures\n        })) != null ? _a21 : \"image/png\";\n        image = {\n          type: \"file\",\n          mediaType,\n          data: bytes\n        };\n      }\n    } else if (dataContent instanceof Uint8Array) {\n      const mediaType = (_b = detectMediaType({\n        data: dataContent,\n        signatures: imageMediaTypeSignatures\n      })) != null ? _b : \"image/png\";\n      image = {\n        type: \"file\",\n        mediaType,\n        data: dataContent\n      };\n    }\n  }\n  return {\n    prompt: promptArg.text,\n    image\n  };\n}\nasync function invokeModelMaxVideosPerCall(model) {\n  if (typeof model.maxVideosPerCall === \"function\") {\n    return await model.maxVideosPerCall({ modelId: model.modelId });\n  }\n  return model.maxVideosPerCall;\n}\n\n// src/middleware/default-embedding-settings-middleware.ts\nfunction defaultEmbeddingSettingsMiddleware({\n  settings\n}) {\n  return {\n    specificationVersion: \"v3\",\n    transformParams: async ({ params }) => {\n      return mergeObjects(settings, params);\n    }\n  };\n}\n\n// src/middleware/default-settings-middleware.ts\nfunction defaultSettingsMiddleware({\n  settings\n}) {\n  return {\n    specificationVersion: \"v3\",\n    transformParams: async ({ params }) => {\n      return mergeObjects(settings, params);\n    }\n  };\n}\n\n// src/middleware/extract-json-middleware.ts\nfunction defaultTransform(text2) {\n  return text2.replace(/^```(?:json)?\\s*\\n?/, \"\").replace(/\\n?```\\s*$/, \"\").trim();\n}\nfunction extractJsonMiddleware(options) {\n  var _a21;\n  const transform = (_a21 = options == null ? void 0 : options.transform) != null ? _a21 : defaultTransform;\n  const hasCustomTransform = (options == null ? void 0 : options.transform) !== void 0;\n  return {\n    specificationVersion: \"v3\",\n    wrapGenerate: async ({ doGenerate }) => {\n      const { content, ...rest } = await doGenerate();\n      const transformedContent = [];\n      for (const part of content) {\n        if (part.type !== \"text\") {\n          transformedContent.push(part);\n          continue;\n        }\n        transformedContent.push({\n          ...part,\n          text: transform(part.text)\n        });\n      }\n      return { content: transformedContent, ...rest };\n    },\n    wrapStream: async ({ doStream }) => {\n      const { stream, ...rest } = await doStream();\n      const textBlocks = {};\n      const SUFFIX_BUFFER_SIZE = 12;\n      return {\n        stream: stream.pipeThrough(\n          new TransformStream({\n            transform: (chunk, controller) => {\n              if (chunk.type === \"text-start\") {\n                textBlocks[chunk.id] = {\n                  startEvent: chunk,\n                  // Custom transforms need to buffer all content\n                  phase: hasCustomTransform ? \"buffering\" : \"prefix\",\n                  buffer: \"\",\n                  prefixStripped: false\n                };\n                return;\n              }\n              if (chunk.type === \"text-delta\") {\n                const block = textBlocks[chunk.id];\n                if (!block) {\n                  controller.enqueue(chunk);\n                  return;\n                }\n                block.buffer += chunk.delta;\n                if (block.phase === \"buffering\") {\n                  return;\n                }\n                if (block.phase === \"prefix\") {\n                  if (block.buffer.length > 0 && !block.buffer.startsWith(\"`\")) {\n                    block.phase = \"streaming\";\n                    controller.enqueue(block.startEvent);\n                  } else if (block.buffer.startsWith(\"```\")) {\n                    if (block.buffer.includes(\"\\n\")) {\n                      const prefixMatch = block.buffer.match(/^```(?:json)?\\s*\\n/);\n                      if (prefixMatch) {\n                        block.buffer = block.buffer.slice(\n                          prefixMatch[0].length\n                        );\n                        block.prefixStripped = true;\n                        block.phase = \"streaming\";\n                        controller.enqueue(block.startEvent);\n                      } else {\n                        block.phase = \"streaming\";\n                        controller.enqueue(block.startEvent);\n                      }\n                    }\n                  } else if (block.buffer.length >= 3 && !block.buffer.startsWith(\"```\")) {\n                    block.phase = \"streaming\";\n                    controller.enqueue(block.startEvent);\n                  }\n                }\n                if (block.phase === \"streaming\" && block.buffer.length > SUFFIX_BUFFER_SIZE) {\n                  const toStream = block.buffer.slice(0, -SUFFIX_BUFFER_SIZE);\n                  block.buffer = block.buffer.slice(-SUFFIX_BUFFER_SIZE);\n                  controller.enqueue({\n                    type: \"text-delta\",\n                    id: chunk.id,\n                    delta: toStream\n                  });\n                }\n                return;\n              }\n              if (chunk.type === \"text-end\") {\n                const block = textBlocks[chunk.id];\n                if (block) {\n                  if (block.phase === \"prefix\" || block.phase === \"buffering\") {\n                    controller.enqueue(block.startEvent);\n                  }\n                  let remaining = block.buffer;\n                  if (block.phase === \"buffering\") {\n                    remaining = transform(remaining);\n                  } else if (block.prefixStripped) {\n                    remaining = remaining.replace(/\\n?```\\s*$/, \"\").trimEnd();\n                  } else {\n                    remaining = transform(remaining);\n                  }\n                  if (remaining.length > 0) {\n                    controller.enqueue({\n                      type: \"text-delta\",\n                      id: chunk.id,\n                      delta: remaining\n                    });\n                  }\n                  controller.enqueue(chunk);\n                  delete textBlocks[chunk.id];\n                  return;\n                }\n              }\n              controller.enqueue(chunk);\n            }\n          })\n        ),\n        ...rest\n      };\n    }\n  };\n}\n\n// src/util/get-potential-start-index.ts\nfunction getPotentialStartIndex(text2, searchedText) {\n  if (searchedText.length === 0) {\n    return null;\n  }\n  const directIndex = text2.indexOf(searchedText);\n  if (directIndex !== -1) {\n    return directIndex;\n  }\n  for (let i = text2.length - 1; i >= 0; i--) {\n    const suffix = text2.substring(i);\n    if (searchedText.startsWith(suffix)) {\n      return i;\n    }\n  }\n  return null;\n}\n\n// src/middleware/extract-reasoning-middleware.ts\nfunction extractReasoningMiddleware({\n  tagName,\n  separator = \"\\n\",\n  startWithReasoning = false\n}) {\n  const openingTag = `<${tagName}>`;\n  const closingTag = `</${tagName}>`;\n  return {\n    specificationVersion: \"v3\",\n    wrapGenerate: async ({ doGenerate }) => {\n      const { content, ...rest } = await doGenerate();\n      const transformedContent = [];\n      for (const part of content) {\n        if (part.type !== \"text\") {\n          transformedContent.push(part);\n          continue;\n        }\n        const text2 = startWithReasoning ? openingTag + part.text : part.text;\n        const regexp = new RegExp(`${openingTag}(.*?)${closingTag}`, \"gs\");\n        const matches = Array.from(text2.matchAll(regexp));\n        if (!matches.length) {\n          transformedContent.push(part);\n          continue;\n        }\n        const reasoningText = matches.map((match) => match[1]).join(separator);\n        let textWithoutReasoning = text2;\n        for (let i = matches.length - 1; i >= 0; i--) {\n          const match = matches[i];\n          const beforeMatch = textWithoutReasoning.slice(0, match.index);\n          const afterMatch = textWithoutReasoning.slice(\n            match.index + match[0].length\n          );\n          textWithoutReasoning = beforeMatch + (beforeMatch.length > 0 && afterMatch.length > 0 ? separator : \"\") + afterMatch;\n        }\n        transformedContent.push({\n          type: \"reasoning\",\n          text: reasoningText\n        });\n        transformedContent.push({\n          type: \"text\",\n          text: textWithoutReasoning\n        });\n      }\n      return { content: transformedContent, ...rest };\n    },\n    wrapStream: async ({ doStream }) => {\n      const { stream, ...rest } = await doStream();\n      const reasoningExtractions = {};\n      let delayedTextStart;\n      return {\n        stream: stream.pipeThrough(\n          new TransformStream({\n            transform: (chunk, controller) => {\n              if (chunk.type === \"text-start\") {\n                delayedTextStart = chunk;\n                return;\n              }\n              if (chunk.type === \"text-end\" && delayedTextStart) {\n                controller.enqueue(delayedTextStart);\n                delayedTextStart = void 0;\n              }\n              if (chunk.type !== \"text-delta\") {\n                controller.enqueue(chunk);\n                return;\n              }\n              if (reasoningExtractions[chunk.id] == null) {\n                reasoningExtractions[chunk.id] = {\n                  isFirstReasoning: true,\n                  isFirstText: true,\n                  afterSwitch: false,\n                  isReasoning: startWithReasoning,\n                  buffer: \"\",\n                  idCounter: 0,\n                  textId: chunk.id\n                };\n              }\n              const activeExtraction = reasoningExtractions[chunk.id];\n              activeExtraction.buffer += chunk.delta;\n              function publish(text2) {\n                if (text2.length > 0) {\n                  const prefix = activeExtraction.afterSwitch && (activeExtraction.isReasoning ? !activeExtraction.isFirstReasoning : !activeExtraction.isFirstText) ? separator : \"\";\n                  if (activeExtraction.isReasoning && (activeExtraction.afterSwitch || activeExtraction.isFirstReasoning)) {\n                    controller.enqueue({\n                      type: \"reasoning-start\",\n                      id: `reasoning-${activeExtraction.idCounter}`\n                    });\n                  }\n                  if (activeExtraction.isReasoning) {\n                    controller.enqueue({\n                      type: \"reasoning-delta\",\n                      delta: prefix + text2,\n                      id: `reasoning-${activeExtraction.idCounter}`\n                    });\n                  } else {\n                    if (delayedTextStart) {\n                      controller.enqueue(delayedTextStart);\n                      delayedTextStart = void 0;\n                    }\n                    controller.enqueue({\n                      type: \"text-delta\",\n                      delta: prefix + text2,\n                      id: activeExtraction.textId\n                    });\n                  }\n                  activeExtraction.afterSwitch = false;\n                  if (activeExtraction.isReasoning) {\n                    activeExtraction.isFirstReasoning = false;\n                  } else {\n                    activeExtraction.isFirstText = false;\n                  }\n                }\n              }\n              do {\n                const nextTag = activeExtraction.isReasoning ? closingTag : openingTag;\n                const startIndex = getPotentialStartIndex(\n                  activeExtraction.buffer,\n                  nextTag\n                );\n                if (startIndex == null) {\n                  publish(activeExtraction.buffer);\n                  activeExtraction.buffer = \"\";\n                  break;\n                }\n                publish(activeExtraction.buffer.slice(0, startIndex));\n                const foundFullMatch = startIndex + nextTag.length <= activeExtraction.buffer.length;\n                if (foundFullMatch) {\n                  activeExtraction.buffer = activeExtraction.buffer.slice(\n                    startIndex + nextTag.length\n                  );\n                  if (activeExtraction.isReasoning) {\n                    if (activeExtraction.isFirstReasoning) {\n                      controller.enqueue({\n                        type: \"reasoning-start\",\n                        id: `reasoning-${activeExtraction.idCounter}`\n                      });\n                    }\n                    controller.enqueue({\n                      type: \"reasoning-end\",\n                      id: `reasoning-${activeExtraction.idCounter++}`\n                    });\n                  }\n                  activeExtraction.isReasoning = !activeExtraction.isReasoning;\n                  activeExtraction.afterSwitch = true;\n                } else {\n                  activeExtraction.buffer = activeExtraction.buffer.slice(startIndex);\n                  break;\n                }\n              } while (true);\n            }\n          })\n        ),\n        ...rest\n      };\n    }\n  };\n}\n\n// src/middleware/simulate-streaming-middleware.ts\nfunction simulateStreamingMiddleware() {\n  return {\n    specificationVersion: \"v3\",\n    wrapStream: async ({ doGenerate }) => {\n      const result = await doGenerate();\n      let id = 0;\n      const simulatedStream = new ReadableStream({\n        start(controller) {\n          controller.enqueue({\n            type: \"stream-start\",\n            warnings: result.warnings\n          });\n          controller.enqueue({ type: \"response-metadata\", ...result.response });\n          for (const part of result.content) {\n            switch (part.type) {\n              case \"text\": {\n                if (part.text.length > 0) {\n                  controller.enqueue({ type: \"text-start\", id: String(id) });\n                  controller.enqueue({\n                    type: \"text-delta\",\n                    id: String(id),\n                    delta: part.text\n                  });\n                  controller.enqueue({ type: \"text-end\", id: String(id) });\n                  id++;\n                }\n                break;\n              }\n              case \"reasoning\": {\n                controller.enqueue({\n                  type: \"reasoning-start\",\n                  id: String(id),\n                  providerMetadata: part.providerMetadata\n                });\n                controller.enqueue({\n                  type: \"reasoning-delta\",\n                  id: String(id),\n                  delta: part.text\n                });\n                controller.enqueue({ type: \"reasoning-end\", id: String(id) });\n                id++;\n                break;\n              }\n              default: {\n                controller.enqueue(part);\n                break;\n              }\n            }\n          }\n          controller.enqueue({\n            type: \"finish\",\n            finishReason: result.finishReason,\n            usage: result.usage,\n            providerMetadata: result.providerMetadata\n          });\n          controller.close();\n        }\n      });\n      return {\n        stream: simulatedStream,\n        request: result.request,\n        response: result.response\n      };\n    }\n  };\n}\n\n// src/middleware/add-tool-input-examples-middleware.ts\nfunction defaultFormatExample(example) {\n  return JSON.stringify(example.input);\n}\nfunction addToolInputExamplesMiddleware({\n  prefix = \"Input Examples:\",\n  format = defaultFormatExample,\n  remove = true\n} = {}) {\n  return {\n    specificationVersion: \"v3\",\n    transformParams: async ({ params }) => {\n      var _a21;\n      if (!((_a21 = params.tools) == null ? void 0 : _a21.length)) {\n        return params;\n      }\n      const transformedTools = params.tools.map((tool2) => {\n        var _a22;\n        if (tool2.type !== \"function\" || !((_a22 = tool2.inputExamples) == null ? void 0 : _a22.length)) {\n          return tool2;\n        }\n        const formattedExamples = tool2.inputExamples.map((example, index) => format(example, index)).join(\"\\n\");\n        const examplesSection = `${prefix}\n${formattedExamples}`;\n        const toolDescription = tool2.description ? `${tool2.description}\n\n${examplesSection}` : examplesSection;\n        return {\n          ...tool2,\n          description: toolDescription,\n          inputExamples: remove ? void 0 : tool2.inputExamples\n        };\n      });\n      return {\n        ...params,\n        tools: transformedTools\n      };\n    }\n  };\n}\n\n// src/middleware/wrap-language-model.ts\nvar wrapLanguageModel = ({\n  model,\n  middleware: middlewareArg,\n  modelId,\n  providerId\n}) => {\n  return [...asArray(middlewareArg)].reverse().reduce((wrappedModel, middleware) => {\n    return doWrap({ model: wrappedModel, middleware, modelId, providerId });\n  }, model);\n};\nvar doWrap = ({\n  model,\n  middleware: {\n    transformParams,\n    wrapGenerate,\n    wrapStream,\n    overrideProvider,\n    overrideModelId,\n    overrideSupportedUrls\n  },\n  modelId,\n  providerId\n}) => {\n  var _a21, _b, _c;\n  async function doTransform({\n    params,\n    type\n  }) {\n    return transformParams ? await transformParams({ params, type, model }) : params;\n  }\n  return {\n    specificationVersion: \"v3\",\n    provider: (_a21 = providerId != null ? providerId : overrideProvider == null ? void 0 : overrideProvider({ model })) != null ? _a21 : model.provider,\n    modelId: (_b = modelId != null ? modelId : overrideModelId == null ? void 0 : overrideModelId({ model })) != null ? _b : model.modelId,\n    supportedUrls: (_c = overrideSupportedUrls == null ? void 0 : overrideSupportedUrls({ model })) != null ? _c : model.supportedUrls,\n    async doGenerate(params) {\n      const transformedParams = await doTransform({ params, type: \"generate\" });\n      const doGenerate = async () => model.doGenerate(transformedParams);\n      const doStream = async () => model.doStream(transformedParams);\n      return wrapGenerate ? wrapGenerate({\n        doGenerate,\n        doStream,\n        params: transformedParams,\n        model\n      }) : doGenerate();\n    },\n    async doStream(params) {\n      const transformedParams = await doTransform({ params, type: \"stream\" });\n      const doGenerate = async () => model.doGenerate(transformedParams);\n      const doStream = async () => model.doStream(transformedParams);\n      return wrapStream ? wrapStream({ doGenerate, doStream, params: transformedParams, model }) : doStream();\n    }\n  };\n};\n\n// src/middleware/wrap-embedding-model.ts\nvar wrapEmbeddingModel = ({\n  model,\n  middleware: middlewareArg,\n  modelId,\n  providerId\n}) => {\n  return [...asArray(middlewareArg)].reverse().reduce((wrappedModel, middleware) => {\n    return doWrap2({ model: wrappedModel, middleware, modelId, providerId });\n  }, model);\n};\nvar doWrap2 = ({\n  model,\n  middleware: {\n    transformParams,\n    wrapEmbed,\n    overrideProvider,\n    overrideModelId,\n    overrideMaxEmbeddingsPerCall,\n    overrideSupportsParallelCalls\n  },\n  modelId,\n  providerId\n}) => {\n  var _a21, _b, _c, _d;\n  async function doTransform({\n    params\n  }) {\n    return transformParams ? await transformParams({ params, model }) : params;\n  }\n  return {\n    specificationVersion: \"v3\",\n    provider: (_a21 = providerId != null ? providerId : overrideProvider == null ? void 0 : overrideProvider({ model })) != null ? _a21 : model.provider,\n    modelId: (_b = modelId != null ? modelId : overrideModelId == null ? void 0 : overrideModelId({ model })) != null ? _b : model.modelId,\n    maxEmbeddingsPerCall: (_c = overrideMaxEmbeddingsPerCall == null ? void 0 : overrideMaxEmbeddingsPerCall({ model })) != null ? _c : model.maxEmbeddingsPerCall,\n    supportsParallelCalls: (_d = overrideSupportsParallelCalls == null ? void 0 : overrideSupportsParallelCalls({ model })) != null ? _d : model.supportsParallelCalls,\n    async doEmbed(params) {\n      const transformedParams = await doTransform({ params });\n      const doEmbed = async () => model.doEmbed(transformedParams);\n      return wrapEmbed ? wrapEmbed({\n        doEmbed,\n        params: transformedParams,\n        model\n      }) : doEmbed();\n    }\n  };\n};\n\n// src/middleware/wrap-image-model.ts\nvar wrapImageModel = ({\n  model,\n  middleware: middlewareArg,\n  modelId,\n  providerId\n}) => {\n  return [...asArray(middlewareArg)].reverse().reduce((wrappedModel, middleware) => {\n    return doWrap3({ model: wrappedModel, middleware, modelId, providerId });\n  }, model);\n};\nvar doWrap3 = ({\n  model,\n  middleware: {\n    transformParams,\n    wrapGenerate,\n    overrideProvider,\n    overrideModelId,\n    overrideMaxImagesPerCall\n  },\n  modelId,\n  providerId\n}) => {\n  var _a21, _b, _c;\n  async function doTransform({ params }) {\n    return transformParams ? await transformParams({ params, model }) : params;\n  }\n  const maxImagesPerCallRaw = (_a21 = overrideMaxImagesPerCall == null ? void 0 : overrideMaxImagesPerCall({ model })) != null ? _a21 : model.maxImagesPerCall;\n  const maxImagesPerCall = maxImagesPerCallRaw instanceof Function ? maxImagesPerCallRaw.bind(model) : maxImagesPerCallRaw;\n  return {\n    specificationVersion: \"v3\",\n    provider: (_b = providerId != null ? providerId : overrideProvider == null ? void 0 : overrideProvider({ model })) != null ? _b : model.provider,\n    modelId: (_c = modelId != null ? modelId : overrideModelId == null ? void 0 : overrideModelId({ model })) != null ? _c : model.modelId,\n    maxImagesPerCall,\n    async doGenerate(params) {\n      const transformedParams = await doTransform({ params });\n      const doGenerate = async () => model.doGenerate(transformedParams);\n      return wrapGenerate ? wrapGenerate({\n        doGenerate,\n        params: transformedParams,\n        model\n      }) : doGenerate();\n    }\n  };\n};\n\n// src/model/as-provider-v3.ts\nfunction asProviderV3(provider) {\n  if (\"specificationVersion\" in provider && provider.specificationVersion === \"v3\") {\n    return provider;\n  }\n  const v2Provider = provider;\n  return {\n    specificationVersion: \"v3\",\n    languageModel: (modelId) => asLanguageModelV3(v2Provider.languageModel(modelId)),\n    embeddingModel: (modelId) => asEmbeddingModelV3(v2Provider.textEmbeddingModel(modelId)),\n    imageModel: (modelId) => asImageModelV3(v2Provider.imageModel(modelId)),\n    transcriptionModel: v2Provider.transcriptionModel ? (modelId) => asTranscriptionModelV3(v2Provider.transcriptionModel(modelId)) : void 0,\n    speechModel: v2Provider.speechModel ? (modelId) => asSpeechModelV3(v2Provider.speechModel(modelId)) : void 0,\n    rerankingModel: void 0\n    // v2 providers don't have reranking models\n  };\n}\n\n// src/middleware/wrap-provider.ts\nfunction wrapProvider({\n  provider,\n  languageModelMiddleware,\n  imageModelMiddleware\n}) {\n  const providerV3 = asProviderV3(provider);\n  return {\n    specificationVersion: \"v3\",\n    languageModel: (modelId) => wrapLanguageModel({\n      model: providerV3.languageModel(modelId),\n      middleware: languageModelMiddleware\n    }),\n    embeddingModel: providerV3.embeddingModel,\n    imageModel: (modelId) => {\n      let model = providerV3.imageModel(modelId);\n      if (imageModelMiddleware != null) {\n        model = wrapImageModel({ model, middleware: imageModelMiddleware });\n      }\n      return model;\n    },\n    transcriptionModel: providerV3.transcriptionModel,\n    speechModel: providerV3.speechModel,\n    rerankingModel: providerV3.rerankingModel\n  };\n}\n\n// src/registry/custom-provider.ts\n\nfunction customProvider({\n  languageModels,\n  embeddingModels,\n  imageModels,\n  transcriptionModels,\n  speechModels,\n  rerankingModels,\n  videoModels,\n  fallbackProvider: fallbackProviderArg\n}) {\n  const fallbackProvider = fallbackProviderArg ? asProviderV3(fallbackProviderArg) : void 0;\n  return {\n    specificationVersion: \"v3\",\n    languageModel(modelId) {\n      if (languageModels != null && modelId in languageModels) {\n        return languageModels[modelId];\n      }\n      if (fallbackProvider) {\n        return fallbackProvider.languageModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId, modelType: \"languageModel\" });\n    },\n    embeddingModel(modelId) {\n      if (embeddingModels != null && modelId in embeddingModels) {\n        return embeddingModels[modelId];\n      }\n      if (fallbackProvider) {\n        return fallbackProvider.embeddingModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId, modelType: \"embeddingModel\" });\n    },\n    imageModel(modelId) {\n      if (imageModels != null && modelId in imageModels) {\n        return imageModels[modelId];\n      }\n      if (fallbackProvider == null ? void 0 : fallbackProvider.imageModel) {\n        return fallbackProvider.imageModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId, modelType: \"imageModel\" });\n    },\n    transcriptionModel(modelId) {\n      if (transcriptionModels != null && modelId in transcriptionModels) {\n        return transcriptionModels[modelId];\n      }\n      if (fallbackProvider == null ? void 0 : fallbackProvider.transcriptionModel) {\n        return fallbackProvider.transcriptionModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId, modelType: \"transcriptionModel\" });\n    },\n    speechModel(modelId) {\n      if (speechModels != null && modelId in speechModels) {\n        return speechModels[modelId];\n      }\n      if (fallbackProvider == null ? void 0 : fallbackProvider.speechModel) {\n        return fallbackProvider.speechModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId, modelType: \"speechModel\" });\n    },\n    rerankingModel(modelId) {\n      if (rerankingModels != null && modelId in rerankingModels) {\n        return rerankingModels[modelId];\n      }\n      if (fallbackProvider == null ? void 0 : fallbackProvider.rerankingModel) {\n        return fallbackProvider.rerankingModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId, modelType: \"rerankingModel\" });\n    },\n    videoModel(modelId) {\n      if (videoModels != null && modelId in videoModels) {\n        return videoModels[modelId];\n      }\n      const videoModel = fallbackProvider == null ? void 0 : fallbackProvider.videoModel;\n      if (videoModel) {\n        return videoModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId, modelType: \"videoModel\" });\n    }\n  };\n}\nvar experimental_customProvider = customProvider;\n\n// src/registry/no-such-provider-error.ts\n\nvar name20 = \"AI_NoSuchProviderError\";\nvar marker20 = `vercel.ai.error.${name20}`;\nvar symbol20 = Symbol.for(marker20);\nvar _a20;\nvar NoSuchProviderError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError {\n  constructor({\n    modelId,\n    modelType,\n    providerId,\n    availableProviders,\n    message = `No such provider: ${providerId} (available providers: ${availableProviders.join()})`\n  }) {\n    super({ errorName: name20, modelId, modelType, message });\n    this[_a20] = true;\n    this.providerId = providerId;\n    this.availableProviders = availableProviders;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker20);\n  }\n};\n_a20 = symbol20;\n\n// src/registry/provider-registry.ts\n\nfunction createProviderRegistry(providers, {\n  separator = \":\",\n  languageModelMiddleware,\n  imageModelMiddleware\n} = {}) {\n  const registry = new DefaultProviderRegistry({\n    separator,\n    languageModelMiddleware,\n    imageModelMiddleware\n  });\n  for (const [id, provider] of Object.entries(providers)) {\n    registry.registerProvider({ id, provider });\n  }\n  return registry;\n}\nvar experimental_createProviderRegistry = createProviderRegistry;\nvar DefaultProviderRegistry = class {\n  constructor({\n    separator,\n    languageModelMiddleware,\n    imageModelMiddleware\n  }) {\n    this.providers = {};\n    this.separator = separator;\n    this.languageModelMiddleware = languageModelMiddleware;\n    this.imageModelMiddleware = imageModelMiddleware;\n  }\n  registerProvider({\n    id,\n    provider\n  }) {\n    this.providers[id] = provider;\n  }\n  getProvider(id, modelType) {\n    const provider = this.providers[id];\n    if (provider == null) {\n      throw new NoSuchProviderError({\n        modelId: id,\n        modelType,\n        providerId: id,\n        availableProviders: Object.keys(this.providers)\n      });\n    }\n    return provider;\n  }\n  splitId(id, modelType) {\n    const index = id.indexOf(this.separator);\n    if (index === -1) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n        modelId: id,\n        modelType,\n        message: `Invalid ${modelType} id for registry: ${id} (must be in the format \"providerId${this.separator}modelId\")`\n      });\n    }\n    return [id.slice(0, index), id.slice(index + this.separator.length)];\n  }\n  languageModel(id) {\n    var _a21, _b;\n    const [providerId, modelId] = this.splitId(id, \"languageModel\");\n    let model = (_b = (_a21 = this.getProvider(providerId, \"languageModel\")).languageModel) == null ? void 0 : _b.call(\n      _a21,\n      modelId\n    );\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId: id, modelType: \"languageModel\" });\n    }\n    if (this.languageModelMiddleware != null) {\n      model = wrapLanguageModel({\n        model,\n        middleware: this.languageModelMiddleware\n      });\n    }\n    return model;\n  }\n  embeddingModel(id) {\n    var _a21;\n    const [providerId, modelId] = this.splitId(id, \"embeddingModel\");\n    const provider = this.getProvider(providerId, \"embeddingModel\");\n    const model = (_a21 = provider.embeddingModel) == null ? void 0 : _a21.call(provider, modelId);\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n        modelId: id,\n        modelType: \"embeddingModel\"\n      });\n    }\n    return model;\n  }\n  imageModel(id) {\n    var _a21;\n    const [providerId, modelId] = this.splitId(id, \"imageModel\");\n    const provider = this.getProvider(providerId, \"imageModel\");\n    let model = (_a21 = provider.imageModel) == null ? void 0 : _a21.call(provider, modelId);\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId: id, modelType: \"imageModel\" });\n    }\n    if (this.imageModelMiddleware != null) {\n      model = wrapImageModel({\n        model,\n        middleware: this.imageModelMiddleware\n      });\n    }\n    return model;\n  }\n  transcriptionModel(id) {\n    var _a21;\n    const [providerId, modelId] = this.splitId(id, \"transcriptionModel\");\n    const provider = this.getProvider(providerId, \"transcriptionModel\");\n    const model = (_a21 = provider.transcriptionModel) == null ? void 0 : _a21.call(provider, modelId);\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n        modelId: id,\n        modelType: \"transcriptionModel\"\n      });\n    }\n    return model;\n  }\n  speechModel(id) {\n    var _a21;\n    const [providerId, modelId] = this.splitId(id, \"speechModel\");\n    const provider = this.getProvider(providerId, \"speechModel\");\n    const model = (_a21 = provider.speechModel) == null ? void 0 : _a21.call(provider, modelId);\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId: id, modelType: \"speechModel\" });\n    }\n    return model;\n  }\n  rerankingModel(id) {\n    var _a21;\n    const [providerId, modelId] = this.splitId(id, \"rerankingModel\");\n    const provider = this.getProvider(providerId, \"rerankingModel\");\n    const model = (_a21 = provider.rerankingModel) == null ? void 0 : _a21.call(provider, modelId);\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId: id, modelType: \"rerankingModel\" });\n    }\n    return model;\n  }\n};\n\n// src/rerank/rerank.ts\nasync function rerank({\n  model,\n  documents,\n  query,\n  topN,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  providerOptions,\n  experimental_telemetry: telemetry\n}) {\n  if (documents.length === 0) {\n    return new DefaultRerankResult({\n      originalDocuments: [],\n      ranking: [],\n      providerMetadata: void 0,\n      response: {\n        timestamp: /* @__PURE__ */ new Date(),\n        modelId: model.modelId\n      }\n    });\n  }\n  const { maxRetries, retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const documentsToSend = typeof documents[0] === \"string\" ? { type: \"text\", values: documents } : { type: \"object\", values: documents };\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { maxRetries }\n  });\n  const tracer = getTracer(telemetry);\n  return recordSpan({\n    name: \"ai.rerank\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: \"ai.rerank\", telemetry }),\n        ...baseTelemetryAttributes,\n        \"ai.documents\": {\n          input: () => documents.map((document) => JSON.stringify(document))\n        }\n      }\n    }),\n    tracer,\n    fn: async () => {\n      var _a21, _b;\n      const { ranking, response, providerMetadata, warnings } = await retry(\n        () => recordSpan({\n          name: \"ai.rerank.doRerank\",\n          attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              ...assembleOperationName({\n                operationId: \"ai.rerank.doRerank\",\n                telemetry\n              }),\n              ...baseTelemetryAttributes,\n              // specific settings that only make sense on the outer level:\n              \"ai.documents\": {\n                input: () => documents.map((document) => JSON.stringify(document))\n              }\n            }\n          }),\n          tracer,\n          fn: async (doRerankSpan) => {\n            const modelResponse = await model.doRerank({\n              documents: documentsToSend,\n              query,\n              topN,\n              providerOptions,\n              abortSignal,\n              headers\n            });\n            const ranking2 = modelResponse.ranking;\n            doRerankSpan.setAttributes(\n              await selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  \"ai.ranking.type\": documentsToSend.type,\n                  \"ai.ranking\": {\n                    output: () => ranking2.map((ranking3) => JSON.stringify(ranking3))\n                  }\n                }\n              })\n            );\n            return {\n              ranking: ranking2,\n              providerMetadata: modelResponse.providerMetadata,\n              response: modelResponse.response,\n              warnings: modelResponse.warnings\n            };\n          }\n        })\n      );\n      logWarnings({\n        warnings: warnings != null ? warnings : [],\n        provider: model.provider,\n        model: model.modelId\n      });\n      return new DefaultRerankResult({\n        originalDocuments: documents,\n        ranking: ranking.map((ranking2) => ({\n          originalIndex: ranking2.index,\n          score: ranking2.relevanceScore,\n          document: documents[ranking2.index]\n        })),\n        providerMetadata,\n        response: {\n          id: response == null ? void 0 : response.id,\n          timestamp: (_a21 = response == null ? void 0 : response.timestamp) != null ? _a21 : /* @__PURE__ */ new Date(),\n          modelId: (_b = response == null ? void 0 : response.modelId) != null ? _b : model.modelId,\n          headers: response == null ? void 0 : response.headers,\n          body: response == null ? void 0 : response.body\n        }\n      });\n    }\n  });\n}\nvar DefaultRerankResult = class {\n  constructor(options) {\n    this.originalDocuments = options.originalDocuments;\n    this.ranking = options.ranking;\n    this.response = options.response;\n    this.providerMetadata = options.providerMetadata;\n  }\n  get rerankedDocuments() {\n    return this.ranking.map((ranking) => ranking.document);\n  }\n};\n\n// src/transcribe/transcribe.ts\n\nvar defaultDownload2 = createDownload();\nasync function transcribe({\n  model,\n  audio,\n  providerOptions = {},\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  download: downloadFn = defaultDownload2\n}) {\n  const resolvedModel = resolveTranscriptionModel(model);\n  if (!resolvedModel) {\n    throw new Error(\"Model could not be resolved\");\n  }\n  const { retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const headersWithUserAgent = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(\n    headers != null ? headers : {},\n    `ai/${VERSION}`\n  );\n  const audioData = audio instanceof URL ? (await downloadFn({ url: audio, abortSignal })).data : convertDataContentToUint8Array(audio);\n  const result = await retry(\n    () => {\n      var _a21;\n      return resolvedModel.doGenerate({\n        audio: audioData,\n        abortSignal,\n        headers: headersWithUserAgent,\n        providerOptions,\n        mediaType: (_a21 = detectMediaType({\n          data: audioData,\n          signatures: audioMediaTypeSignatures\n        })) != null ? _a21 : \"audio/wav\"\n      });\n    }\n  );\n  logWarnings({\n    warnings: result.warnings,\n    provider: resolvedModel.provider,\n    model: resolvedModel.modelId\n  });\n  if (!result.text) {\n    throw new NoTranscriptGeneratedError({ responses: [result.response] });\n  }\n  return new DefaultTranscriptionResult({\n    text: result.text,\n    segments: result.segments,\n    language: result.language,\n    durationInSeconds: result.durationInSeconds,\n    warnings: result.warnings,\n    responses: [result.response],\n    providerMetadata: result.providerMetadata\n  });\n}\nvar DefaultTranscriptionResult = class {\n  constructor(options) {\n    var _a21;\n    this.text = options.text;\n    this.segments = options.segments;\n    this.language = options.language;\n    this.durationInSeconds = options.durationInSeconds;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = (_a21 = options.providerMetadata) != null ? _a21 : {};\n  }\n};\n\n// src/ui/call-completion-api.ts\n\n\n// src/ui/process-text-stream.ts\nasync function processTextStream({\n  stream,\n  onTextPart\n}) {\n  const reader = stream.pipeThrough(new TextDecoderStream()).getReader();\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    await onTextPart(value);\n  }\n}\n\n// src/ui/call-completion-api.ts\nvar getOriginalFetch = () => fetch;\nasync function callCompletionApi({\n  api,\n  prompt,\n  credentials,\n  headers,\n  body,\n  streamProtocol = \"data\",\n  setCompletion,\n  setLoading,\n  setError,\n  setAbortController,\n  onFinish,\n  onError,\n  fetch: fetch2 = getOriginalFetch()\n}) {\n  var _a21;\n  try {\n    setLoading(true);\n    setError(void 0);\n    const abortController = new AbortController();\n    setAbortController(abortController);\n    setCompletion(\"\");\n    const response = await fetch2(api, {\n      method: \"POST\",\n      body: JSON.stringify({\n        prompt,\n        ...body\n      }),\n      credentials,\n      headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(\n        {\n          \"Content-Type\": \"application/json\",\n          ...headers\n        },\n        `ai-sdk/${VERSION}`,\n        (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getRuntimeEnvironmentUserAgent)()\n      ),\n      signal: abortController.signal\n    }).catch((err) => {\n      throw err;\n    });\n    if (!response.ok) {\n      throw new Error(\n        (_a21 = await response.text()) != null ? _a21 : \"Failed to fetch the chat response.\"\n      );\n    }\n    if (!response.body) {\n      throw new Error(\"The response body is empty.\");\n    }\n    let result = \"\";\n    switch (streamProtocol) {\n      case \"text\": {\n        await processTextStream({\n          stream: response.body,\n          onTextPart: (chunk) => {\n            result += chunk;\n            setCompletion(result);\n          }\n        });\n        break;\n      }\n      case \"data\": {\n        await consumeStream({\n          stream: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.parseJsonEventStream)({\n            stream: response.body,\n            schema: uiMessageChunkSchema\n          }).pipeThrough(\n            new TransformStream({\n              async transform(part) {\n                if (!part.success) {\n                  throw part.error;\n                }\n                const streamPart = part.value;\n                if (streamPart.type === \"text-delta\") {\n                  result += streamPart.delta;\n                  setCompletion(result);\n                } else if (streamPart.type === \"error\") {\n                  throw new Error(streamPart.errorText);\n                }\n              }\n            })\n          ),\n          onError: (error) => {\n            throw error;\n          }\n        });\n        break;\n      }\n      default: {\n        const exhaustiveCheck = streamProtocol;\n        throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n      }\n    }\n    if (onFinish) {\n      onFinish(prompt, result);\n    }\n    setAbortController(null);\n    return result;\n  } catch (err) {\n    if (err.name === \"AbortError\") {\n      setAbortController(null);\n      return null;\n    }\n    if (err instanceof Error) {\n      if (onError) {\n        onError(err);\n      }\n    }\n    setError(err);\n  } finally {\n    setLoading(false);\n  }\n}\n\n// src/ui/chat.ts\n\n\n// src/ui/convert-file-list-to-file-ui-parts.ts\nasync function convertFileListToFileUIParts(files) {\n  if (files == null) {\n    return [];\n  }\n  if (!globalThis.FileList || !(files instanceof globalThis.FileList)) {\n    throw new Error(\"FileList is not supported in the current environment\");\n  }\n  return Promise.all(\n    Array.from(files).map(async (file) => {\n      const { name: name21, type } = file;\n      const dataUrl = await new Promise((resolve3, reject) => {\n        const reader = new FileReader();\n        reader.onload = (readerEvent) => {\n          var _a21;\n          resolve3((_a21 = readerEvent.target) == null ? void 0 : _a21.result);\n        };\n        reader.onerror = (error) => reject(error);\n        reader.readAsDataURL(file);\n      });\n      return {\n        type: \"file\",\n        mediaType: type,\n        filename: name21,\n        url: dataUrl\n      };\n    })\n  );\n}\n\n// src/ui/default-chat-transport.ts\n\n\n// src/ui/http-chat-transport.ts\n\nvar HttpChatTransport = class {\n  constructor({\n    api = \"/api/chat\",\n    credentials,\n    headers,\n    body,\n    fetch: fetch2,\n    prepareSendMessagesRequest,\n    prepareReconnectToStreamRequest\n  }) {\n    this.api = api;\n    this.credentials = credentials;\n    this.headers = headers;\n    this.body = body;\n    this.fetch = fetch2;\n    this.prepareSendMessagesRequest = prepareSendMessagesRequest;\n    this.prepareReconnectToStreamRequest = prepareReconnectToStreamRequest;\n  }\n  async sendMessages({\n    abortSignal,\n    ...options\n  }) {\n    var _a21, _b, _c, _d, _e;\n    const resolvedBody = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.body);\n    const resolvedHeaders = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.headers);\n    const resolvedCredentials = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.credentials);\n    const baseHeaders = {\n      ...(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeHeaders)(resolvedHeaders),\n      ...(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeHeaders)(options.headers)\n    };\n    const preparedRequest = await ((_a21 = this.prepareSendMessagesRequest) == null ? void 0 : _a21.call(this, {\n      api: this.api,\n      id: options.chatId,\n      messages: options.messages,\n      body: { ...resolvedBody, ...options.body },\n      headers: baseHeaders,\n      credentials: resolvedCredentials,\n      requestMetadata: options.metadata,\n      trigger: options.trigger,\n      messageId: options.messageId\n    }));\n    const api = (_b = preparedRequest == null ? void 0 : preparedRequest.api) != null ? _b : this.api;\n    const headers = (preparedRequest == null ? void 0 : preparedRequest.headers) !== void 0 ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeHeaders)(preparedRequest.headers) : baseHeaders;\n    const body = (preparedRequest == null ? void 0 : preparedRequest.body) !== void 0 ? preparedRequest.body : {\n      ...resolvedBody,\n      ...options.body,\n      id: options.chatId,\n      messages: options.messages,\n      trigger: options.trigger,\n      messageId: options.messageId\n    };\n    const credentials = (_c = preparedRequest == null ? void 0 : preparedRequest.credentials) != null ? _c : resolvedCredentials;\n    const fetch2 = (_d = this.fetch) != null ? _d : globalThis.fetch;\n    const response = await fetch2(api, {\n      method: \"POST\",\n      headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(\n        {\n          \"Content-Type\": \"application/json\",\n          ...headers\n        },\n        `ai-sdk/${VERSION}`,\n        (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getRuntimeEnvironmentUserAgent)()\n      ),\n      body: JSON.stringify(body),\n      credentials,\n      signal: abortSignal\n    });\n    if (!response.ok) {\n      throw new Error(\n        (_e = await response.text()) != null ? _e : \"Failed to fetch the chat response.\"\n      );\n    }\n    if (!response.body) {\n      throw new Error(\"The response body is empty.\");\n    }\n    return this.processResponseStream(response.body);\n  }\n  async reconnectToStream(options) {\n    var _a21, _b, _c, _d, _e;\n    const resolvedBody = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.body);\n    const resolvedHeaders = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.headers);\n    const resolvedCredentials = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.credentials);\n    const baseHeaders = {\n      ...(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeHeaders)(resolvedHeaders),\n      ...(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeHeaders)(options.headers)\n    };\n    const preparedRequest = await ((_a21 = this.prepareReconnectToStreamRequest) == null ? void 0 : _a21.call(this, {\n      api: this.api,\n      id: options.chatId,\n      body: { ...resolvedBody, ...options.body },\n      headers: baseHeaders,\n      credentials: resolvedCredentials,\n      requestMetadata: options.metadata\n    }));\n    const api = (_b = preparedRequest == null ? void 0 : preparedRequest.api) != null ? _b : `${this.api}/${options.chatId}/stream`;\n    const headers = (preparedRequest == null ? void 0 : preparedRequest.headers) !== void 0 ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeHeaders)(preparedRequest.headers) : baseHeaders;\n    const credentials = (_c = preparedRequest == null ? void 0 : preparedRequest.credentials) != null ? _c : resolvedCredentials;\n    const fetch2 = (_d = this.fetch) != null ? _d : globalThis.fetch;\n    const response = await fetch2(api, {\n      method: \"GET\",\n      headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(\n        headers,\n        `ai-sdk/${VERSION}`,\n        (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getRuntimeEnvironmentUserAgent)()\n      ),\n      credentials\n    });\n    if (response.status === 204) {\n      return null;\n    }\n    if (!response.ok) {\n      throw new Error(\n        (_e = await response.text()) != null ? _e : \"Failed to fetch the chat response.\"\n      );\n    }\n    if (!response.body) {\n      throw new Error(\"The response body is empty.\");\n    }\n    return this.processResponseStream(response.body);\n  }\n};\n\n// src/ui/default-chat-transport.ts\nvar DefaultChatTransport = class extends HttpChatTransport {\n  constructor(options = {}) {\n    super(options);\n  }\n  processResponseStream(stream) {\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.parseJsonEventStream)({\n      stream,\n      schema: uiMessageChunkSchema\n    }).pipeThrough(\n      new TransformStream({\n        async transform(chunk, controller) {\n          if (!chunk.success) {\n            throw chunk.error;\n          }\n          controller.enqueue(chunk.value);\n        }\n      })\n    );\n  }\n};\n\n// src/ui/chat.ts\nvar AbstractChat = class {\n  constructor({\n    generateId: generateId2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.generateId,\n    id = generateId2(),\n    transport = new DefaultChatTransport(),\n    messageMetadataSchema,\n    dataPartSchemas,\n    state,\n    onError,\n    onToolCall,\n    onFinish,\n    onData,\n    sendAutomaticallyWhen\n  }) {\n    this.activeResponse = void 0;\n    this.jobExecutor = new SerialJobExecutor();\n    /**\n     * Appends or replaces a user message to the chat list. This triggers the API call to fetch\n     * the assistant's response.\n     *\n     * If a messageId is provided, the message will be replaced.\n     */\n    this.sendMessage = async (message, options) => {\n      var _a21, _b, _c, _d;\n      if (message == null) {\n        await this.makeRequest({\n          trigger: \"submit-message\",\n          messageId: (_a21 = this.lastMessage) == null ? void 0 : _a21.id,\n          ...options\n        });\n        return;\n      }\n      let uiMessage;\n      if (\"text\" in message || \"files\" in message) {\n        const fileParts = Array.isArray(message.files) ? message.files : await convertFileListToFileUIParts(message.files);\n        uiMessage = {\n          parts: [\n            ...fileParts,\n            ...\"text\" in message && message.text != null ? [{ type: \"text\", text: message.text }] : []\n          ]\n        };\n      } else {\n        uiMessage = message;\n      }\n      if (message.messageId != null) {\n        const messageIndex = this.state.messages.findIndex(\n          (m) => m.id === message.messageId\n        );\n        if (messageIndex === -1) {\n          throw new Error(`message with id ${message.messageId} not found`);\n        }\n        if (this.state.messages[messageIndex].role !== \"user\") {\n          throw new Error(\n            `message with id ${message.messageId} is not a user message`\n          );\n        }\n        this.state.messages = this.state.messages.slice(0, messageIndex + 1);\n        this.state.replaceMessage(messageIndex, {\n          ...uiMessage,\n          id: message.messageId,\n          role: (_b = uiMessage.role) != null ? _b : \"user\",\n          metadata: message.metadata\n        });\n      } else {\n        this.state.pushMessage({\n          ...uiMessage,\n          id: (_c = uiMessage.id) != null ? _c : this.generateId(),\n          role: (_d = uiMessage.role) != null ? _d : \"user\",\n          metadata: message.metadata\n        });\n      }\n      await this.makeRequest({\n        trigger: \"submit-message\",\n        messageId: message.messageId,\n        ...options\n      });\n    };\n    /**\n     * Regenerate the assistant message with the provided message id.\n     * If no message id is provided, the last assistant message will be regenerated.\n     */\n    this.regenerate = async ({\n      messageId,\n      ...options\n    } = {}) => {\n      const messageIndex = messageId == null ? this.state.messages.length - 1 : this.state.messages.findIndex((message) => message.id === messageId);\n      if (messageIndex === -1) {\n        throw new Error(`message ${messageId} not found`);\n      }\n      this.state.messages = this.state.messages.slice(\n        0,\n        // if the message is a user message, we need to include it in the request:\n        this.messages[messageIndex].role === \"assistant\" ? messageIndex : messageIndex + 1\n      );\n      await this.makeRequest({\n        trigger: \"regenerate-message\",\n        messageId,\n        ...options\n      });\n    };\n    /**\n     * Attempt to resume an ongoing streaming response.\n     */\n    this.resumeStream = async (options = {}) => {\n      await this.makeRequest({ trigger: \"resume-stream\", ...options });\n    };\n    /**\n     * Clear the error state and set the status to ready if the chat is in an error state.\n     */\n    this.clearError = () => {\n      if (this.status === \"error\") {\n        this.state.error = void 0;\n        this.setStatus({ status: \"ready\" });\n      }\n    };\n    this.addToolApprovalResponse = async ({\n      id,\n      approved,\n      reason\n    }) => this.jobExecutor.run(async () => {\n      const messages = this.state.messages;\n      const lastMessage = messages[messages.length - 1];\n      const updatePart = (part) => isToolUIPart(part) && part.state === \"approval-requested\" && part.approval.id === id ? {\n        ...part,\n        state: \"approval-responded\",\n        approval: { id, approved, reason }\n      } : part;\n      this.state.replaceMessage(messages.length - 1, {\n        ...lastMessage,\n        parts: lastMessage.parts.map(updatePart)\n      });\n      if (this.activeResponse) {\n        this.activeResponse.state.message.parts = this.activeResponse.state.message.parts.map(updatePart);\n      }\n      if (this.status !== \"streaming\" && this.status !== \"submitted\" && this.sendAutomaticallyWhen) {\n        this.shouldSendAutomatically().then((shouldSend) => {\n          var _a21;\n          if (shouldSend) {\n            this.makeRequest({\n              trigger: \"submit-message\",\n              messageId: (_a21 = this.lastMessage) == null ? void 0 : _a21.id\n            });\n          }\n        });\n      }\n    });\n    this.addToolOutput = async ({\n      state = \"output-available\",\n      tool: tool2,\n      toolCallId,\n      output,\n      errorText\n    }) => this.jobExecutor.run(async () => {\n      const messages = this.state.messages;\n      const lastMessage = messages[messages.length - 1];\n      const updatePart = (part) => isToolUIPart(part) && part.toolCallId === toolCallId ? { ...part, state, output, errorText } : part;\n      this.state.replaceMessage(messages.length - 1, {\n        ...lastMessage,\n        parts: lastMessage.parts.map(updatePart)\n      });\n      if (this.activeResponse) {\n        this.activeResponse.state.message.parts = this.activeResponse.state.message.parts.map(updatePart);\n      }\n      if (this.status !== \"streaming\" && this.status !== \"submitted\" && this.sendAutomaticallyWhen) {\n        this.shouldSendAutomatically().then((shouldSend) => {\n          var _a21;\n          if (shouldSend) {\n            this.makeRequest({\n              trigger: \"submit-message\",\n              messageId: (_a21 = this.lastMessage) == null ? void 0 : _a21.id\n            });\n          }\n        });\n      }\n    });\n    /** @deprecated Use addToolOutput */\n    this.addToolResult = this.addToolOutput;\n    /**\n     * Abort the current request immediately, keep the generated tokens if any.\n     */\n    this.stop = async () => {\n      var _a21;\n      if (this.status !== \"streaming\" && this.status !== \"submitted\")\n        return;\n      if ((_a21 = this.activeResponse) == null ? void 0 : _a21.abortController) {\n        this.activeResponse.abortController.abort();\n      }\n    };\n    this.id = id;\n    this.transport = transport;\n    this.generateId = generateId2;\n    this.messageMetadataSchema = messageMetadataSchema;\n    this.dataPartSchemas = dataPartSchemas;\n    this.state = state;\n    this.onError = onError;\n    this.onToolCall = onToolCall;\n    this.onFinish = onFinish;\n    this.onData = onData;\n    this.sendAutomaticallyWhen = sendAutomaticallyWhen;\n  }\n  /**\n   * Hook status:\n   *\n   * - `submitted`: The message has been sent to the API and we're awaiting the start of the response stream.\n   * - `streaming`: The response is actively streaming in from the API, receiving chunks of data.\n   * - `ready`: The full response has been received and processed; a new user message can be submitted.\n   * - `error`: An error occurred during the API request, preventing successful completion.\n   */\n  get status() {\n    return this.state.status;\n  }\n  setStatus({\n    status,\n    error\n  }) {\n    if (this.status === status)\n      return;\n    this.state.status = status;\n    this.state.error = error;\n  }\n  get error() {\n    return this.state.error;\n  }\n  get messages() {\n    return this.state.messages;\n  }\n  get lastMessage() {\n    return this.state.messages[this.state.messages.length - 1];\n  }\n  set messages(messages) {\n    this.state.messages = messages;\n  }\n  async shouldSendAutomatically() {\n    if (!this.sendAutomaticallyWhen)\n      return false;\n    const result = this.sendAutomaticallyWhen({\n      messages: this.state.messages\n    });\n    if (result && typeof result === \"object\" && \"then\" in result) {\n      return await result;\n    }\n    return result;\n  }\n  async makeRequest({\n    trigger,\n    metadata,\n    headers,\n    body,\n    messageId\n  }) {\n    var _a21, _b, _c;\n    let resumeStream;\n    if (trigger === \"resume-stream\") {\n      try {\n        const reconnect = await this.transport.reconnectToStream({\n          chatId: this.id,\n          metadata,\n          headers,\n          body\n        });\n        if (reconnect == null) {\n          return;\n        }\n        resumeStream = reconnect;\n      } catch (err) {\n        if (this.onError && err instanceof Error) {\n          this.onError(err);\n        }\n        this.setStatus({ status: \"error\", error: err });\n        return;\n      }\n    }\n    this.setStatus({ status: \"submitted\", error: void 0 });\n    const lastMessage = this.lastMessage;\n    let isAbort = false;\n    let isDisconnect = false;\n    let isError = false;\n    try {\n      const activeResponse = {\n        state: createStreamingUIMessageState({\n          lastMessage: this.state.snapshot(lastMessage),\n          messageId: this.generateId()\n        }),\n        abortController: new AbortController()\n      };\n      activeResponse.abortController.signal.addEventListener(\"abort\", () => {\n        isAbort = true;\n      });\n      this.activeResponse = activeResponse;\n      let stream;\n      if (trigger === \"resume-stream\") {\n        stream = resumeStream;\n      } else {\n        stream = await this.transport.sendMessages({\n          chatId: this.id,\n          messages: this.state.messages,\n          abortSignal: activeResponse.abortController.signal,\n          metadata,\n          headers,\n          body,\n          trigger,\n          messageId\n        });\n      }\n      const runUpdateMessageJob = (job) => (\n        // serialize the job execution to avoid race conditions:\n        this.jobExecutor.run(\n          () => job({\n            state: activeResponse.state,\n            write: () => {\n              var _a22;\n              this.setStatus({ status: \"streaming\" });\n              const replaceLastMessage = activeResponse.state.message.id === ((_a22 = this.lastMessage) == null ? void 0 : _a22.id);\n              if (replaceLastMessage) {\n                this.state.replaceMessage(\n                  this.state.messages.length - 1,\n                  activeResponse.state.message\n                );\n              } else {\n                this.state.pushMessage(activeResponse.state.message);\n              }\n            }\n          })\n        )\n      );\n      await consumeStream({\n        stream: processUIMessageStream({\n          stream,\n          onToolCall: this.onToolCall,\n          onData: this.onData,\n          messageMetadataSchema: this.messageMetadataSchema,\n          dataPartSchemas: this.dataPartSchemas,\n          runUpdateMessageJob,\n          onError: (error) => {\n            throw error;\n          }\n        }),\n        onError: (error) => {\n          throw error;\n        }\n      });\n      this.setStatus({ status: \"ready\" });\n    } catch (err) {\n      if (isAbort || err.name === \"AbortError\") {\n        isAbort = true;\n        this.setStatus({ status: \"ready\" });\n        return null;\n      }\n      isError = true;\n      if (err instanceof TypeError && (err.message.toLowerCase().includes(\"fetch\") || err.message.toLowerCase().includes(\"network\"))) {\n        isDisconnect = true;\n      }\n      if (this.onError && err instanceof Error) {\n        this.onError(err);\n      }\n      this.setStatus({ status: \"error\", error: err });\n    } finally {\n      try {\n        (_b = this.onFinish) == null ? void 0 : _b.call(this, {\n          message: this.activeResponse.state.message,\n          messages: this.state.messages,\n          isAbort,\n          isDisconnect,\n          isError,\n          finishReason: (_a21 = this.activeResponse) == null ? void 0 : _a21.state.finishReason\n        });\n      } catch (err) {\n        console.error(err);\n      }\n      this.activeResponse = void 0;\n    }\n    if (!isError && await this.shouldSendAutomatically()) {\n      await this.makeRequest({\n        trigger: \"submit-message\",\n        messageId: (_c = this.lastMessage) == null ? void 0 : _c.id,\n        metadata,\n        headers,\n        body\n      });\n    }\n  }\n};\n\n// src/ui/direct-chat-transport.ts\nvar DirectChatTransport = class {\n  constructor({\n    agent,\n    options,\n    ...uiMessageStreamOptions\n  }) {\n    this.agent = agent;\n    this.agentOptions = options;\n    this.uiMessageStreamOptions = uiMessageStreamOptions;\n  }\n  async sendMessages({\n    messages,\n    abortSignal\n  }) {\n    const validatedMessages = await validateUIMessages({\n      messages,\n      tools: this.agent.tools\n    });\n    const modelMessages = await convertToModelMessages(validatedMessages, {\n      tools: this.agent.tools\n    });\n    const result = await this.agent.stream({\n      prompt: modelMessages,\n      abortSignal,\n      ...this.agentOptions !== void 0 ? { options: this.agentOptions } : {}\n    });\n    return result.toUIMessageStream(this.uiMessageStreamOptions);\n  }\n  /**\n   * Direct transport does not support reconnection since there is no\n   * persistent server-side stream to reconnect to.\n   *\n   * @returns Always returns `null`\n   */\n  async reconnectToStream(_options) {\n    return null;\n  }\n};\n\n// src/ui/last-assistant-message-is-complete-with-approval-responses.ts\nfunction lastAssistantMessageIsCompleteWithApprovalResponses({\n  messages\n}) {\n  const message = messages[messages.length - 1];\n  if (!message) {\n    return false;\n  }\n  if (message.role !== \"assistant\") {\n    return false;\n  }\n  const lastStepStartIndex = message.parts.reduce((lastIndex, part, index) => {\n    return part.type === \"step-start\" ? index : lastIndex;\n  }, -1);\n  const lastStepToolInvocations = message.parts.slice(lastStepStartIndex + 1).filter(isToolUIPart).filter((part) => !part.providerExecuted);\n  return (\n    // has at least one tool approval response\n    lastStepToolInvocations.filter((part) => part.state === \"approval-responded\").length > 0 && // all tool approvals must have a response\n    lastStepToolInvocations.every(\n      (part) => part.state === \"output-available\" || part.state === \"output-error\" || part.state === \"approval-responded\"\n    )\n  );\n}\n\n// src/ui/last-assistant-message-is-complete-with-tool-calls.ts\nfunction lastAssistantMessageIsCompleteWithToolCalls({\n  messages\n}) {\n  const message = messages[messages.length - 1];\n  if (!message) {\n    return false;\n  }\n  if (message.role !== \"assistant\") {\n    return false;\n  }\n  const lastStepStartIndex = message.parts.reduce((lastIndex, part, index) => {\n    return part.type === \"step-start\" ? index : lastIndex;\n  }, -1);\n  const lastStepToolInvocations = message.parts.slice(lastStepStartIndex + 1).filter(isToolUIPart).filter((part) => !part.providerExecuted);\n  return lastStepToolInvocations.length > 0 && lastStepToolInvocations.every(\n    (part) => part.state === \"output-available\" || part.state === \"output-error\"\n  );\n}\n\n// src/ui/transform-text-to-ui-message-stream.ts\nfunction transformTextToUiMessageStream({\n  stream\n}) {\n  return stream.pipeThrough(\n    new TransformStream({\n      start(controller) {\n        controller.enqueue({ type: \"start\" });\n        controller.enqueue({ type: \"start-step\" });\n        controller.enqueue({ type: \"text-start\", id: \"text-1\" });\n      },\n      async transform(part, controller) {\n        controller.enqueue({ type: \"text-delta\", id: \"text-1\", delta: part });\n      },\n      async flush(controller) {\n        controller.enqueue({ type: \"text-end\", id: \"text-1\" });\n        controller.enqueue({ type: \"finish-step\" });\n        controller.enqueue({ type: \"finish\" });\n      }\n    })\n  );\n}\n\n// src/ui/text-stream-chat-transport.ts\nvar TextStreamChatTransport = class extends HttpChatTransport {\n  constructor(options = {}) {\n    super(options);\n  }\n  processResponseStream(stream) {\n    return transformTextToUiMessageStream({\n      stream: stream.pipeThrough(new TextDecoderStream())\n    });\n  }\n};\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9yZWFjdC9ub2RlX21vZHVsZXMvYWkvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxvQ0FBb0M7QUFDcEU7O0FBRUE7QUFDcUU7QUFVckM7O0FBRWhDO0FBS2dDOztBQUVoQztBQWUwQjs7QUFFMUI7QUFDOEM7QUFDOUM7QUFDQSxnQ0FBZ0MsS0FBSztBQUNyQztBQUNBO0FBQ0EseUNBQXlDLHdEQUFVO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxpREFBaUQsVUFBVSxJQUFJLFFBQVE7QUFDdkUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdEQUFVO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUM2RDtBQUM3RDtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQSwyQ0FBMkMsd0RBQVc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3REFBVztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDNkQ7QUFDN0Q7QUFDQSxpQ0FBaUMsTUFBTTtBQUN2QztBQUNBO0FBQ0EsNkNBQTZDLHdEQUFXO0FBQ3hELGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQSx5RUFBeUUsV0FBVztBQUNwRixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdEQUFXO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUM4RTtBQUM5RTtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxvREFBTztBQUM3RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUdnQzs7QUFFaEM7QUFDbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlGQUF5QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxvREFBb0QsaUZBQXlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFDQUFxQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQ0FBcUM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsd0JBQXdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsc0VBQWM7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNpRTtBQUNpQztBQUNsRztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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UztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHlDQUF5QztBQUNwRixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qix5RUFBaUI7QUFDMUM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtDQUErQyxJQUFJO0FBQ2xFO0FBQ0E7QUFD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QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsZ0JBQWdCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOENBQThDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Z0NBQWdDO0FBQzdELDZCQUE2QixxQkFBcUI7QUFDbEQsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBZ0lFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbGVldGZsb3cvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9yZWFjdC9ub2RlX21vZHVsZXMvYWkvZGlzdC9pbmRleC5tanM/MzU4YiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUyMSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZTIxLCB7IGdldDogYWxsW25hbWUyMV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xuXG4vLyBzcmMvaW5kZXgudHNcbmltcG9ydCB7IGNyZWF0ZUdhdGV3YXksIGdhdGV3YXkgYXMgZ2F0ZXdheTIgfSBmcm9tIFwiQGFpLXNkay9nYXRld2F5XCI7XG5pbXBvcnQge1xuICBhc1NjaGVtYSBhcyBhc1NjaGVtYTUsXG4gIGNyZWF0ZUlkR2VuZXJhdG9yIGFzIGNyZWF0ZUlkR2VuZXJhdG9yNSxcbiAgZHluYW1pY1Rvb2wsXG4gIGdlbmVyYXRlSWQsXG4gIGpzb25TY2hlbWEsXG4gIHBhcnNlSnNvbkV2ZW50U3RyZWFtIGFzIHBhcnNlSnNvbkV2ZW50U3RyZWFtMyxcbiAgdG9vbCxcbiAgem9kU2NoZW1hIGFzIHpvZFNjaGVtYTNcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL2dlbmVyYXRlLXRleHQvZ2VuZXJhdGUtdGV4dC50c1xuaW1wb3J0IHtcbiAgY3JlYXRlSWRHZW5lcmF0b3IsXG4gIGdldEVycm9yTWVzc2FnZSBhcyBnZXRFcnJvck1lc3NhZ2U1LFxuICB3aXRoVXNlckFnZW50U3VmZml4IGFzIHdpdGhVc2VyQWdlbnRTdWZmaXgyXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy9lcnJvci9pbmRleC50c1xuaW1wb3J0IHtcbiAgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMjEsXG4gIEFQSUNhbGxFcnJvcixcbiAgRW1wdHlSZXNwb25zZUJvZHlFcnJvcixcbiAgSW52YWxpZFByb21wdEVycm9yLFxuICBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IsXG4gIEpTT05QYXJzZUVycm9yLFxuICBMb2FkQVBJS2V5RXJyb3IsXG4gIExvYWRTZXR0aW5nRXJyb3IsXG4gIE5vQ29udGVudEdlbmVyYXRlZEVycm9yLFxuICBOb1N1Y2hNb2RlbEVycm9yLFxuICBUb29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yLFxuICBUeXBlVmFsaWRhdGlvbkVycm9yLFxuICBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvclxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuXG4vLyBzcmMvZXJyb3IvaW52YWxpZC1hcmd1bWVudC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZSA9IFwiQUlfSW52YWxpZEFyZ3VtZW50RXJyb3JcIjtcbnZhciBtYXJrZXIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZX1gO1xudmFyIHN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyKTtcbnZhciBfYTtcbnZhciBJbnZhbGlkQXJndW1lbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwYXJhbWV0ZXIsXG4gICAgdmFsdWUsXG4gICAgbWVzc2FnZVxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZSxcbiAgICAgIG1lc3NhZ2U6IGBJbnZhbGlkIGFyZ3VtZW50IGZvciBwYXJhbWV0ZXIgJHtwYXJhbWV0ZXJ9OiAke21lc3NhZ2V9YFxuICAgIH0pO1xuICAgIHRoaXNbX2FdID0gdHJ1ZTtcbiAgICB0aGlzLnBhcmFtZXRlciA9IHBhcmFtZXRlcjtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcik7XG4gIH1cbn07XG5fYSA9IHN5bWJvbDtcblxuLy8gc3JjL2Vycm9yL2ludmFsaWQtc3RyZWFtLXBhcnQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUyID0gXCJBSV9JbnZhbGlkU3RyZWFtUGFydEVycm9yXCI7XG52YXIgbWFya2VyMiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMn1gO1xudmFyIHN5bWJvbDIgPSBTeW1ib2wuZm9yKG1hcmtlcjIpO1xudmFyIF9hMjtcbnZhciBJbnZhbGlkU3RyZWFtUGFydEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMiB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjaHVuayxcbiAgICBtZXNzYWdlXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUyLCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2EyXSA9IHRydWU7XG4gICAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IyLmhhc01hcmtlcihlcnJvciwgbWFya2VyMik7XG4gIH1cbn07XG5fYTIgPSBzeW1ib2wyO1xuXG4vLyBzcmMvZXJyb3IvaW52YWxpZC10b29sLWFwcHJvdmFsLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMyA9IFwiQUlfSW52YWxpZFRvb2xBcHByb3ZhbEVycm9yXCI7XG52YXIgbWFya2VyMyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lM31gO1xudmFyIHN5bWJvbDMgPSBTeW1ib2wuZm9yKG1hcmtlcjMpO1xudmFyIF9hMztcbnZhciBJbnZhbGlkVG9vbEFwcHJvdmFsRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IzIHtcbiAgY29uc3RydWN0b3IoeyBhcHByb3ZhbElkIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBuYW1lMyxcbiAgICAgIG1lc3NhZ2U6IGBUb29sIGFwcHJvdmFsIHJlc3BvbnNlIHJlZmVyZW5jZXMgdW5rbm93biBhcHByb3ZhbElkOiBcIiR7YXBwcm92YWxJZH1cIi4gTm8gbWF0Y2hpbmcgdG9vbC1hcHByb3ZhbC1yZXF1ZXN0IGZvdW5kIGluIG1lc3NhZ2UgaGlzdG9yeS5gXG4gICAgfSk7XG4gICAgdGhpc1tfYTNdID0gdHJ1ZTtcbiAgICB0aGlzLmFwcHJvdmFsSWQgPSBhcHByb3ZhbElkO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IzLmhhc01hcmtlcihlcnJvciwgbWFya2VyMyk7XG4gIH1cbn07XG5fYTMgPSBzeW1ib2wzO1xuXG4vLyBzcmMvZXJyb3IvaW52YWxpZC10b29sLWlucHV0LWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I0LCBnZXRFcnJvck1lc3NhZ2UgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU0ID0gXCJBSV9JbnZhbGlkVG9vbElucHV0RXJyb3JcIjtcbnZhciBtYXJrZXI0ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU0fWA7XG52YXIgc3ltYm9sNCA9IFN5bWJvbC5mb3IobWFya2VyNCk7XG52YXIgX2E0O1xudmFyIEludmFsaWRUb29sSW5wdXRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjQge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdG9vbElucHV0LFxuICAgIHRvb2xOYW1lLFxuICAgIGNhdXNlLFxuICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dCBmb3IgdG9vbCAke3Rvb2xOYW1lfTogJHtnZXRFcnJvck1lc3NhZ2UoY2F1c2UpfWBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTQsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2E0XSA9IHRydWU7XG4gICAgdGhpcy50b29sSW5wdXQgPSB0b29sSW5wdXQ7XG4gICAgdGhpcy50b29sTmFtZSA9IHRvb2xOYW1lO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3I0Lmhhc01hcmtlcihlcnJvciwgbWFya2VyNCk7XG4gIH1cbn07XG5fYTQgPSBzeW1ib2w0O1xuXG4vLyBzcmMvZXJyb3IvdG9vbC1jYWxsLW5vdC1mb3VuZC1mb3ItYXBwcm92YWwtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjUgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU1ID0gXCJBSV9Ub29sQ2FsbE5vdEZvdW5kRm9yQXBwcm92YWxFcnJvclwiO1xudmFyIG1hcmtlcjUgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTV9YDtcbnZhciBzeW1ib2w1ID0gU3ltYm9sLmZvcihtYXJrZXI1KTtcbnZhciBfYTU7XG52YXIgVG9vbENhbGxOb3RGb3VuZEZvckFwcHJvdmFsRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I1IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHRvb2xDYWxsSWQsXG4gICAgYXBwcm92YWxJZFxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogbmFtZTUsXG4gICAgICBtZXNzYWdlOiBgVG9vbCBjYWxsIFwiJHt0b29sQ2FsbElkfVwiIG5vdCBmb3VuZCBmb3IgYXBwcm92YWwgcmVxdWVzdCBcIiR7YXBwcm92YWxJZH1cIi5gXG4gICAgfSk7XG4gICAgdGhpc1tfYTVdID0gdHJ1ZTtcbiAgICB0aGlzLnRvb2xDYWxsSWQgPSB0b29sQ2FsbElkO1xuICAgIHRoaXMuYXBwcm92YWxJZCA9IGFwcHJvdmFsSWQ7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjUuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI1KTtcbiAgfVxufTtcbl9hNSA9IHN5bWJvbDU7XG5cbi8vIHNyYy9lcnJvci9taXNzaW5nLXRvb2wtcmVzdWx0LWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I2IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lNiA9IFwiQUlfTWlzc2luZ1Rvb2xSZXN1bHRzRXJyb3JcIjtcbnZhciBtYXJrZXI2ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU2fWA7XG52YXIgc3ltYm9sNiA9IFN5bWJvbC5mb3IobWFya2VyNik7XG52YXIgX2E2O1xudmFyIE1pc3NpbmdUb29sUmVzdWx0c0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yNiB7XG4gIGNvbnN0cnVjdG9yKHsgdG9vbENhbGxJZHMgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IG5hbWU2LFxuICAgICAgbWVzc2FnZTogYFRvb2wgcmVzdWx0JHt0b29sQ2FsbElkcy5sZW5ndGggPiAxID8gXCJzIGFyZVwiIDogXCIgaXNcIn0gbWlzc2luZyBmb3IgdG9vbCBjYWxsJHt0b29sQ2FsbElkcy5sZW5ndGggPiAxID8gXCJzXCIgOiBcIlwifSAke3Rvb2xDYWxsSWRzLmpvaW4oXG4gICAgICAgIFwiLCBcIlxuICAgICAgKX0uYFxuICAgIH0pO1xuICAgIHRoaXNbX2E2XSA9IHRydWU7XG4gICAgdGhpcy50b29sQ2FsbElkcyA9IHRvb2xDYWxsSWRzO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3I2Lmhhc01hcmtlcihlcnJvciwgbWFya2VyNik7XG4gIH1cbn07XG5fYTYgPSBzeW1ib2w2O1xuXG4vLyBzcmMvZXJyb3Ivbm8taW1hZ2UtZ2VuZXJhdGVkLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I3IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lNyA9IFwiQUlfTm9JbWFnZUdlbmVyYXRlZEVycm9yXCI7XG52YXIgbWFya2VyNyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lN31gO1xudmFyIHN5bWJvbDcgPSBTeW1ib2wuZm9yKG1hcmtlcjcpO1xudmFyIF9hNztcbnZhciBOb0ltYWdlR2VuZXJhdGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I3IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UgPSBcIk5vIGltYWdlIGdlbmVyYXRlZC5cIixcbiAgICBjYXVzZSxcbiAgICByZXNwb25zZXNcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTcsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2E3XSA9IHRydWU7XG4gICAgdGhpcy5yZXNwb25zZXMgPSByZXNwb25zZXM7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjcuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI3KTtcbiAgfVxufTtcbl9hNyA9IHN5bWJvbDc7XG5cbi8vIHNyYy9lcnJvci9uby1vYmplY3QtZ2VuZXJhdGVkLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I4IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lOCA9IFwiQUlfTm9PYmplY3RHZW5lcmF0ZWRFcnJvclwiO1xudmFyIG1hcmtlcjggPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTh9YDtcbnZhciBzeW1ib2w4ID0gU3ltYm9sLmZvcihtYXJrZXI4KTtcbnZhciBfYTg7XG52YXIgTm9PYmplY3RHZW5lcmF0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjgge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSA9IFwiTm8gb2JqZWN0IGdlbmVyYXRlZC5cIixcbiAgICBjYXVzZSxcbiAgICB0ZXh0OiB0ZXh0MixcbiAgICByZXNwb25zZSxcbiAgICB1c2FnZSxcbiAgICBmaW5pc2hSZWFzb25cbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTgsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2E4XSA9IHRydWU7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDI7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIHRoaXMudXNhZ2UgPSB1c2FnZTtcbiAgICB0aGlzLmZpbmlzaFJlYXNvbiA9IGZpbmlzaFJlYXNvbjtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yOC5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjgpO1xuICB9XG59O1xuX2E4ID0gc3ltYm9sODtcblxuLy8gc3JjL2Vycm9yL25vLW91dHB1dC1nZW5lcmF0ZWQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjkgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU5ID0gXCJBSV9Ob091dHB1dEdlbmVyYXRlZEVycm9yXCI7XG52YXIgbWFya2VyOSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lOX1gO1xudmFyIHN5bWJvbDkgPSBTeW1ib2wuZm9yKG1hcmtlcjkpO1xudmFyIF9hOTtcbnZhciBOb091dHB1dEdlbmVyYXRlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yOSB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSA9IFwiTm8gb3V0cHV0IGdlbmVyYXRlZC5cIixcbiAgICBjYXVzZVxuICB9ID0ge30pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU5LCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hOV0gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3I5Lmhhc01hcmtlcihlcnJvciwgbWFya2VyOSk7XG4gIH1cbn07XG5fYTkgPSBzeW1ib2w5O1xuXG4vLyBzcmMvZXJyb3Ivbm8tc3BlZWNoLWdlbmVyYXRlZC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTAgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUxMCA9IFwiQUlfTm9TcGVlY2hHZW5lcmF0ZWRFcnJvclwiO1xudmFyIG1hcmtlcjEwID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxMH1gO1xudmFyIHN5bWJvbDEwID0gU3ltYm9sLmZvcihtYXJrZXIxMCk7XG52YXIgX2ExMDtcbnZhciBOb1NwZWVjaEdlbmVyYXRlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMTAge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogbmFtZTEwLFxuICAgICAgbWVzc2FnZTogXCJObyBzcGVlY2ggYXVkaW8gZ2VuZXJhdGVkLlwiXG4gICAgfSk7XG4gICAgdGhpc1tfYTEwXSA9IHRydWU7XG4gICAgdGhpcy5yZXNwb25zZXMgPSBvcHRpb25zLnJlc3BvbnNlcztcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMTAuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMCk7XG4gIH1cbn07XG5fYTEwID0gc3ltYm9sMTA7XG5cbi8vIHNyYy9lcnJvci9uby10cmFuc2NyaXB0LWdlbmVyYXRlZC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTEgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUxMSA9IFwiQUlfTm9UcmFuc2NyaXB0R2VuZXJhdGVkRXJyb3JcIjtcbnZhciBtYXJrZXIxMSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTF9YDtcbnZhciBzeW1ib2wxMSA9IFN5bWJvbC5mb3IobWFya2VyMTEpO1xudmFyIF9hMTE7XG52YXIgTm9UcmFuc2NyaXB0R2VuZXJhdGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IxMSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBuYW1lMTEsXG4gICAgICBtZXNzYWdlOiBcIk5vIHRyYW5zY3JpcHQgZ2VuZXJhdGVkLlwiXG4gICAgfSk7XG4gICAgdGhpc1tfYTExXSA9IHRydWU7XG4gICAgdGhpcy5yZXNwb25zZXMgPSBvcHRpb25zLnJlc3BvbnNlcztcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMTEuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMSk7XG4gIH1cbn07XG5fYTExID0gc3ltYm9sMTE7XG5cbi8vIHNyYy9lcnJvci9uby12aWRlby1nZW5lcmF0ZWQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjEyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMTIgPSBcIkFJX05vVmlkZW9HZW5lcmF0ZWRFcnJvclwiO1xudmFyIG1hcmtlcjEyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxMn1gO1xudmFyIHN5bWJvbDEyID0gU3ltYm9sLmZvcihtYXJrZXIxMik7XG52YXIgX2ExMjtcbnZhciBOb1ZpZGVvR2VuZXJhdGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IxMiB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlID0gXCJObyB2aWRlbyBnZW5lcmF0ZWQuXCIsXG4gICAgY2F1c2UsXG4gICAgcmVzcG9uc2VzXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUxMiwgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTEyXSA9IHRydWU7XG4gICAgdGhpcy5yZXNwb25zZXMgPSByZXNwb25zZXM7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjEyLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTIpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc05vVmlkZW9HZW5lcmF0ZWRFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWUxMiAmJiB0eXBlb2YgZXJyb3IucmVzcG9uc2VzICE9PSBcInVuZGVmaW5lZFwiID8gdHJ1ZSA6IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICBjYXVzZTogdGhpcy5jYXVzZSxcbiAgICAgIHJlc3BvbnNlczogdGhpcy5yZXNwb25zZXNcbiAgICB9O1xuICB9XG59O1xuX2ExMiA9IHN5bWJvbDEyO1xuXG4vLyBzcmMvZXJyb3Ivbm8tc3VjaC10b29sLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxMyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTEzID0gXCJBSV9Ob1N1Y2hUb29sRXJyb3JcIjtcbnZhciBtYXJrZXIxMyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTN9YDtcbnZhciBzeW1ib2wxMyA9IFN5bWJvbC5mb3IobWFya2VyMTMpO1xudmFyIF9hMTM7XG52YXIgTm9TdWNoVG9vbEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMTMge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdG9vbE5hbWUsXG4gICAgYXZhaWxhYmxlVG9vbHMgPSB2b2lkIDAsXG4gICAgbWVzc2FnZSA9IGBNb2RlbCB0cmllZCB0byBjYWxsIHVuYXZhaWxhYmxlIHRvb2wgJyR7dG9vbE5hbWV9Jy4gJHthdmFpbGFibGVUb29scyA9PT0gdm9pZCAwID8gXCJObyB0b29scyBhcmUgYXZhaWxhYmxlLlwiIDogYEF2YWlsYWJsZSB0b29sczogJHthdmFpbGFibGVUb29scy5qb2luKFwiLCBcIil9LmB9YFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMTMsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTEzXSA9IHRydWU7XG4gICAgdGhpcy50b29sTmFtZSA9IHRvb2xOYW1lO1xuICAgIHRoaXMuYXZhaWxhYmxlVG9vbHMgPSBhdmFpbGFibGVUb29scztcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMTMuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMyk7XG4gIH1cbn07XG5fYTEzID0gc3ltYm9sMTM7XG5cbi8vIHNyYy9lcnJvci90b29sLWNhbGwtcmVwYWlyLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxNCwgZ2V0RXJyb3JNZXNzYWdlIGFzIGdldEVycm9yTWVzc2FnZTIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUxNCA9IFwiQUlfVG9vbENhbGxSZXBhaXJFcnJvclwiO1xudmFyIG1hcmtlcjE0ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxNH1gO1xudmFyIHN5bWJvbDE0ID0gU3ltYm9sLmZvcihtYXJrZXIxNCk7XG52YXIgX2ExNDtcbnZhciBUb29sQ2FsbFJlcGFpckVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMTQge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY2F1c2UsXG4gICAgb3JpZ2luYWxFcnJvcixcbiAgICBtZXNzYWdlID0gYEVycm9yIHJlcGFpcmluZyB0b29sIGNhbGw6ICR7Z2V0RXJyb3JNZXNzYWdlMihjYXVzZSl9YFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMTQsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2ExNF0gPSB0cnVlO1xuICAgIHRoaXMub3JpZ2luYWxFcnJvciA9IG9yaWdpbmFsRXJyb3I7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjE0Lmhhc01hcmtlcihlcnJvciwgbWFya2VyMTQpO1xuICB9XG59O1xuX2ExNCA9IHN5bWJvbDE0O1xuXG4vLyBzcmMvZXJyb3IvdW5zdXBwb3J0ZWQtbW9kZWwtdmVyc2lvbi1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTUgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIFVuc3VwcG9ydGVkTW9kZWxWZXJzaW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IxNSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkFJX1Vuc3VwcG9ydGVkTW9kZWxWZXJzaW9uRXJyb3JcIixcbiAgICAgIG1lc3NhZ2U6IGBVbnN1cHBvcnRlZCBtb2RlbCB2ZXJzaW9uICR7b3B0aW9ucy52ZXJzaW9ufSBmb3IgcHJvdmlkZXIgXCIke29wdGlvbnMucHJvdmlkZXJ9XCIgYW5kIG1vZGVsIFwiJHtvcHRpb25zLm1vZGVsSWR9XCIuIEFJIFNESyA1IG9ubHkgc3VwcG9ydHMgbW9kZWxzIHRoYXQgaW1wbGVtZW50IHNwZWNpZmljYXRpb24gdmVyc2lvbiBcInYyXCIuYFxuICAgIH0pO1xuICAgIHRoaXMudmVyc2lvbiA9IG9wdGlvbnMudmVyc2lvbjtcbiAgICB0aGlzLnByb3ZpZGVyID0gb3B0aW9ucy5wcm92aWRlcjtcbiAgICB0aGlzLm1vZGVsSWQgPSBvcHRpb25zLm1vZGVsSWQ7XG4gIH1cbn07XG5cbi8vIHNyYy9lcnJvci91aS1tZXNzYWdlLXN0cmVhbS1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTYgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUxNSA9IFwiQUlfVUlNZXNzYWdlU3RyZWFtRXJyb3JcIjtcbnZhciBtYXJrZXIxNSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTV9YDtcbnZhciBzeW1ib2wxNSA9IFN5bWJvbC5mb3IobWFya2VyMTUpO1xudmFyIF9hMTU7XG52YXIgVUlNZXNzYWdlU3RyZWFtRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IxNiB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjaHVua1R5cGUsXG4gICAgY2h1bmtJZCxcbiAgICBtZXNzYWdlXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUxNSwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hMTVdID0gdHJ1ZTtcbiAgICB0aGlzLmNodW5rVHlwZSA9IGNodW5rVHlwZTtcbiAgICB0aGlzLmNodW5rSWQgPSBjaHVua0lkO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IxNi5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjE1KTtcbiAgfVxufTtcbl9hMTUgPSBzeW1ib2wxNTtcblxuLy8gc3JjL3Byb21wdC9pbnZhbGlkLWRhdGEtY29udGVudC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTcgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUxNiA9IFwiQUlfSW52YWxpZERhdGFDb250ZW50RXJyb3JcIjtcbnZhciBtYXJrZXIxNiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTZ9YDtcbnZhciBzeW1ib2wxNiA9IFN5bWJvbC5mb3IobWFya2VyMTYpO1xudmFyIF9hMTY7XG52YXIgSW52YWxpZERhdGFDb250ZW50RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IxNyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb250ZW50LFxuICAgIGNhdXNlLFxuICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBkYXRhIGNvbnRlbnQuIEV4cGVjdGVkIGEgYmFzZTY0IHN0cmluZywgVWludDhBcnJheSwgQXJyYXlCdWZmZXIsIG9yIEJ1ZmZlciwgYnV0IGdvdCAke3R5cGVvZiBjb250ZW50fS5gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUxNiwgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTE2XSA9IHRydWU7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMTcuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxNik7XG4gIH1cbn07XG5fYTE2ID0gc3ltYm9sMTY7XG5cbi8vIHNyYy9wcm9tcHQvaW52YWxpZC1tZXNzYWdlLXJvbGUtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjE4IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMTcgPSBcIkFJX0ludmFsaWRNZXNzYWdlUm9sZUVycm9yXCI7XG52YXIgbWFya2VyMTcgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTE3fWA7XG52YXIgc3ltYm9sMTcgPSBTeW1ib2wuZm9yKG1hcmtlcjE3KTtcbnZhciBfYTE3O1xudmFyIEludmFsaWRNZXNzYWdlUm9sZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMTgge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcm9sZSxcbiAgICBtZXNzYWdlID0gYEludmFsaWQgbWVzc2FnZSByb2xlOiAnJHtyb2xlfScuIE11c3QgYmUgb25lIG9mOiBcInN5c3RlbVwiLCBcInVzZXJcIiwgXCJhc3Npc3RhbnRcIiwgXCJ0b29sXCIuYFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMTcsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTE3XSA9IHRydWU7XG4gICAgdGhpcy5yb2xlID0gcm9sZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMTguaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxNyk7XG4gIH1cbn07XG5fYTE3ID0gc3ltYm9sMTc7XG5cbi8vIHNyYy9wcm9tcHQvbWVzc2FnZS1jb252ZXJzaW9uLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxOSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTE4ID0gXCJBSV9NZXNzYWdlQ29udmVyc2lvbkVycm9yXCI7XG52YXIgbWFya2VyMTggPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTE4fWA7XG52YXIgc3ltYm9sMTggPSBTeW1ib2wuZm9yKG1hcmtlcjE4KTtcbnZhciBfYTE4O1xudmFyIE1lc3NhZ2VDb252ZXJzaW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IxOSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBvcmlnaW5hbE1lc3NhZ2UsXG4gICAgbWVzc2FnZVxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMTgsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTE4XSA9IHRydWU7XG4gICAgdGhpcy5vcmlnaW5hbE1lc3NhZ2UgPSBvcmlnaW5hbE1lc3NhZ2U7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjE5Lmhhc01hcmtlcihlcnJvciwgbWFya2VyMTgpO1xuICB9XG59O1xuX2ExOCA9IHN5bWJvbDE4O1xuXG4vLyBzcmMvZXJyb3IvaW5kZXgudHNcbmltcG9ydCB7IERvd25sb2FkRXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdXRpbC9yZXRyeS1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMjAgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUxOSA9IFwiQUlfUmV0cnlFcnJvclwiO1xudmFyIG1hcmtlcjE5ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxOX1gO1xudmFyIHN5bWJvbDE5ID0gU3ltYm9sLmZvcihtYXJrZXIxOSk7XG52YXIgX2ExOTtcbnZhciBSZXRyeUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMjAge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSxcbiAgICByZWFzb24sXG4gICAgZXJyb3JzXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUxOSwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hMTldID0gdHJ1ZTtcbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB0aGlzLmxhc3RFcnJvciA9IGVycm9yc1tlcnJvcnMubGVuZ3RoIC0gMV07XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjIwLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTkpO1xuICB9XG59O1xuX2ExOSA9IHN5bWJvbDE5O1xuXG4vLyBzcmMvbG9nZ2VyL2xvZy13YXJuaW5ncy50c1xuZnVuY3Rpb24gZm9ybWF0V2FybmluZyh7XG4gIHdhcm5pbmcsXG4gIHByb3ZpZGVyLFxuICBtb2RlbFxufSkge1xuICBjb25zdCBwcmVmaXggPSBgQUkgU0RLIFdhcm5pbmcgKCR7cHJvdmlkZXJ9IC8gJHttb2RlbH0pOmA7XG4gIHN3aXRjaCAod2FybmluZy50eXBlKSB7XG4gICAgY2FzZSBcInVuc3VwcG9ydGVkXCI6IHtcbiAgICAgIGxldCBtZXNzYWdlID0gYCR7cHJlZml4fSBUaGUgZmVhdHVyZSBcIiR7d2FybmluZy5mZWF0dXJlfVwiIGlzIG5vdCBzdXBwb3J0ZWQuYDtcbiAgICAgIGlmICh3YXJuaW5nLmRldGFpbHMpIHtcbiAgICAgICAgbWVzc2FnZSArPSBgICR7d2FybmluZy5kZXRhaWxzfWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgY2FzZSBcImNvbXBhdGliaWxpdHlcIjoge1xuICAgICAgbGV0IG1lc3NhZ2UgPSBgJHtwcmVmaXh9IFRoZSBmZWF0dXJlIFwiJHt3YXJuaW5nLmZlYXR1cmV9XCIgaXMgdXNlZCBpbiBhIGNvbXBhdGliaWxpdHkgbW9kZS5gO1xuICAgICAgaWYgKHdhcm5pbmcuZGV0YWlscykge1xuICAgICAgICBtZXNzYWdlICs9IGAgJHt3YXJuaW5nLmRldGFpbHN9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBjYXNlIFwib3RoZXJcIjoge1xuICAgICAgcmV0dXJuIGAke3ByZWZpeH0gJHt3YXJuaW5nLm1lc3NhZ2V9YDtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgcmV0dXJuIGAke3ByZWZpeH0gJHtKU09OLnN0cmluZ2lmeSh3YXJuaW5nLCBudWxsLCAyKX1gO1xuICAgIH1cbiAgfVxufVxudmFyIEZJUlNUX1dBUk5JTkdfSU5GT19NRVNTQUdFID0gXCJBSSBTREsgV2FybmluZyBTeXN0ZW06IFRvIHR1cm4gb2ZmIHdhcm5pbmcgbG9nZ2luZywgc2V0IHRoZSBBSV9TREtfTE9HX1dBUk5JTkdTIGdsb2JhbCB0byBmYWxzZS5cIjtcbnZhciBoYXNMb2dnZWRCZWZvcmUgPSBmYWxzZTtcbnZhciBsb2dXYXJuaW5ncyA9IChvcHRpb25zKSA9PiB7XG4gIGlmIChvcHRpb25zLndhcm5pbmdzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBsb2dnZXIgPSBnbG9iYWxUaGlzLkFJX1NES19MT0dfV0FSTklOR1M7XG4gIGlmIChsb2dnZXIgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2YgbG9nZ2VyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBsb2dnZXIob3B0aW9ucyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghaGFzTG9nZ2VkQmVmb3JlKSB7XG4gICAgaGFzTG9nZ2VkQmVmb3JlID0gdHJ1ZTtcbiAgICBjb25zb2xlLmluZm8oRklSU1RfV0FSTklOR19JTkZPX01FU1NBR0UpO1xuICB9XG4gIGZvciAoY29uc3Qgd2FybmluZyBvZiBvcHRpb25zLndhcm5pbmdzKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgZm9ybWF0V2FybmluZyh7XG4gICAgICAgIHdhcm5pbmcsXG4gICAgICAgIHByb3ZpZGVyOiBvcHRpb25zLnByb3ZpZGVyLFxuICAgICAgICBtb2RlbDogb3B0aW9ucy5tb2RlbFxuICAgICAgfSlcbiAgICApO1xuICB9XG59O1xuXG4vLyBzcmMvbW9kZWwvcmVzb2x2ZS1tb2RlbC50c1xuaW1wb3J0IHsgZ2F0ZXdheSB9IGZyb20gXCJAYWktc2RrL2dhdGV3YXlcIjtcblxuLy8gc3JjL3V0aWwvbG9nLXYyLWNvbXBhdGliaWxpdHktd2FybmluZy50c1xuZnVuY3Rpb24gbG9nVjJDb21wYXRpYmlsaXR5V2FybmluZyh7XG4gIHByb3ZpZGVyLFxuICBtb2RlbElkXG59KSB7XG4gIGxvZ1dhcm5pbmdzKHtcbiAgICB3YXJuaW5nczogW1xuICAgICAge1xuICAgICAgICB0eXBlOiBcImNvbXBhdGliaWxpdHlcIixcbiAgICAgICAgZmVhdHVyZTogXCJzcGVjaWZpY2F0aW9uVmVyc2lvblwiLFxuICAgICAgICBkZXRhaWxzOiBgVXNpbmcgdjIgc3BlY2lmaWNhdGlvbiBjb21wYXRpYmlsaXR5IG1vZGUuIFNvbWUgZmVhdHVyZXMgbWF5IG5vdCBiZSBhdmFpbGFibGUuYFxuICAgICAgfVxuICAgIF0sXG4gICAgcHJvdmlkZXIsXG4gICAgbW9kZWw6IG1vZGVsSWRcbiAgfSk7XG59XG5cbi8vIHNyYy9tb2RlbC9hcy1lbWJlZGRpbmctbW9kZWwtdjMudHNcbmZ1bmN0aW9uIGFzRW1iZWRkaW5nTW9kZWxWMyhtb2RlbCkge1xuICBpZiAobW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24gPT09IFwidjNcIikge1xuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuICBsb2dWMkNvbXBhdGliaWxpdHlXYXJuaW5nKHtcbiAgICBwcm92aWRlcjogbW9kZWwucHJvdmlkZXIsXG4gICAgbW9kZWxJZDogbW9kZWwubW9kZWxJZFxuICB9KTtcbiAgcmV0dXJuIG5ldyBQcm94eShtb2RlbCwge1xuICAgIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgIGlmIChwcm9wID09PSBcInNwZWNpZmljYXRpb25WZXJzaW9uXCIpXG4gICAgICAgIHJldHVybiBcInYzXCI7XG4gICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9tb2RlbC9hcy1pbWFnZS1tb2RlbC12My50c1xuZnVuY3Rpb24gYXNJbWFnZU1vZGVsVjMobW9kZWwpIHtcbiAgaWYgKG1vZGVsLnNwZWNpZmljYXRpb25WZXJzaW9uID09PSBcInYzXCIpIHtcbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cbiAgbG9nVjJDb21wYXRpYmlsaXR5V2FybmluZyh7XG4gICAgcHJvdmlkZXI6IG1vZGVsLnByb3ZpZGVyLFxuICAgIG1vZGVsSWQ6IG1vZGVsLm1vZGVsSWRcbiAgfSk7XG4gIHJldHVybiBuZXcgUHJveHkobW9kZWwsIHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wKSB7XG4gICAgICBpZiAocHJvcCA9PT0gXCJzcGVjaWZpY2F0aW9uVmVyc2lvblwiKVxuICAgICAgICByZXR1cm4gXCJ2M1wiO1xuICAgICAgcmV0dXJuIHRhcmdldFtwcm9wXTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvbW9kZWwvYXMtbGFuZ3VhZ2UtbW9kZWwtdjMudHNcbmZ1bmN0aW9uIGFzTGFuZ3VhZ2VNb2RlbFYzKG1vZGVsKSB7XG4gIGlmIChtb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbiA9PT0gXCJ2M1wiKSB7XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIGxvZ1YyQ29tcGF0aWJpbGl0eVdhcm5pbmcoe1xuICAgIHByb3ZpZGVyOiBtb2RlbC5wcm92aWRlcixcbiAgICBtb2RlbElkOiBtb2RlbC5tb2RlbElkXG4gIH0pO1xuICByZXR1cm4gbmV3IFByb3h5KG1vZGVsLCB7XG4gICAgZ2V0KHRhcmdldCwgcHJvcCkge1xuICAgICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgIGNhc2UgXCJzcGVjaWZpY2F0aW9uVmVyc2lvblwiOlxuICAgICAgICAgIHJldHVybiBcInYzXCI7XG4gICAgICAgIGNhc2UgXCJkb0dlbmVyYXRlXCI6XG4gICAgICAgICAgcmV0dXJuIGFzeW5jICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0YXJnZXQuZG9HZW5lcmF0ZSguLi5hcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBjb252ZXJ0VjJGaW5pc2hSZWFzb25Ub1YzKHJlc3VsdC5maW5pc2hSZWFzb24pLFxuICAgICAgICAgICAgICB1c2FnZTogY29udmVydFYyVXNhZ2VUb1YzKHJlc3VsdC51c2FnZSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcImRvU3RyZWFtXCI6XG4gICAgICAgICAgcmV0dXJuIGFzeW5jICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0YXJnZXQuZG9TdHJlYW0oLi4uYXJncyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgICAgIHN0cmVhbTogY29udmVydFYyU3RyZWFtVG9WMyhyZXN1bHQuc3RyZWFtKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRWMlN0cmVhbVRvVjMoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2goXG4gICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcImZpbmlzaFwiOlxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgLi4uY2h1bmssXG4gICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogY29udmVydFYyRmluaXNoUmVhc29uVG9WMyhjaHVuay5maW5pc2hSZWFzb24pLFxuICAgICAgICAgICAgICB1c2FnZTogY29udmVydFYyVXNhZ2VUb1YzKGNodW5rLnVzYWdlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRWMkZpbmlzaFJlYXNvblRvVjMoZmluaXNoUmVhc29uKSB7XG4gIHJldHVybiB7XG4gICAgdW5pZmllZDogZmluaXNoUmVhc29uID09PSBcInVua25vd25cIiA/IFwib3RoZXJcIiA6IGZpbmlzaFJlYXNvbixcbiAgICByYXc6IHZvaWQgMFxuICB9O1xufVxuZnVuY3Rpb24gY29udmVydFYyVXNhZ2VUb1YzKHVzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgaW5wdXRUb2tlbnM6IHtcbiAgICAgIHRvdGFsOiB1c2FnZS5pbnB1dFRva2VucyxcbiAgICAgIG5vQ2FjaGU6IHZvaWQgMCxcbiAgICAgIGNhY2hlUmVhZDogdXNhZ2UuY2FjaGVkSW5wdXRUb2tlbnMsXG4gICAgICBjYWNoZVdyaXRlOiB2b2lkIDBcbiAgICB9LFxuICAgIG91dHB1dFRva2Vuczoge1xuICAgICAgdG90YWw6IHVzYWdlLm91dHB1dFRva2VucyxcbiAgICAgIHRleHQ6IHZvaWQgMCxcbiAgICAgIHJlYXNvbmluZzogdXNhZ2UucmVhc29uaW5nVG9rZW5zXG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbW9kZWwvYXMtc3BlZWNoLW1vZGVsLXYzLnRzXG5mdW5jdGlvbiBhc1NwZWVjaE1vZGVsVjMobW9kZWwpIHtcbiAgaWYgKG1vZGVsLnNwZWNpZmljYXRpb25WZXJzaW9uID09PSBcInYzXCIpIHtcbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cbiAgbG9nVjJDb21wYXRpYmlsaXR5V2FybmluZyh7XG4gICAgcHJvdmlkZXI6IG1vZGVsLnByb3ZpZGVyLFxuICAgIG1vZGVsSWQ6IG1vZGVsLm1vZGVsSWRcbiAgfSk7XG4gIHJldHVybiBuZXcgUHJveHkobW9kZWwsIHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wKSB7XG4gICAgICBpZiAocHJvcCA9PT0gXCJzcGVjaWZpY2F0aW9uVmVyc2lvblwiKVxuICAgICAgICByZXR1cm4gXCJ2M1wiO1xuICAgICAgcmV0dXJuIHRhcmdldFtwcm9wXTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvbW9kZWwvYXMtdHJhbnNjcmlwdGlvbi1tb2RlbC12My50c1xuZnVuY3Rpb24gYXNUcmFuc2NyaXB0aW9uTW9kZWxWMyhtb2RlbCkge1xuICBpZiAobW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24gPT09IFwidjNcIikge1xuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuICBsb2dWMkNvbXBhdGliaWxpdHlXYXJuaW5nKHtcbiAgICBwcm92aWRlcjogbW9kZWwucHJvdmlkZXIsXG4gICAgbW9kZWxJZDogbW9kZWwubW9kZWxJZFxuICB9KTtcbiAgcmV0dXJuIG5ldyBQcm94eShtb2RlbCwge1xuICAgIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgIGlmIChwcm9wID09PSBcInNwZWNpZmljYXRpb25WZXJzaW9uXCIpXG4gICAgICAgIHJldHVybiBcInYzXCI7XG4gICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9tb2RlbC9yZXNvbHZlLW1vZGVsLnRzXG5mdW5jdGlvbiByZXNvbHZlTGFuZ3VhZ2VNb2RlbChtb2RlbCkge1xuICBpZiAodHlwZW9mIG1vZGVsICE9PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKG1vZGVsLnNwZWNpZmljYXRpb25WZXJzaW9uICE9PSBcInYzXCIgJiYgbW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24gIT09IFwidjJcIikge1xuICAgICAgY29uc3QgdW5zdXBwb3J0ZWRNb2RlbCA9IG1vZGVsO1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkTW9kZWxWZXJzaW9uRXJyb3Ioe1xuICAgICAgICB2ZXJzaW9uOiB1bnN1cHBvcnRlZE1vZGVsLnNwZWNpZmljYXRpb25WZXJzaW9uLFxuICAgICAgICBwcm92aWRlcjogdW5zdXBwb3J0ZWRNb2RlbC5wcm92aWRlcixcbiAgICAgICAgbW9kZWxJZDogdW5zdXBwb3J0ZWRNb2RlbC5tb2RlbElkXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFzTGFuZ3VhZ2VNb2RlbFYzKG1vZGVsKTtcbiAgfVxuICByZXR1cm4gZ2V0R2xvYmFsUHJvdmlkZXIoKS5sYW5ndWFnZU1vZGVsKG1vZGVsKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVFbWJlZGRpbmdNb2RlbChtb2RlbCkge1xuICBpZiAodHlwZW9mIG1vZGVsICE9PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKG1vZGVsLnNwZWNpZmljYXRpb25WZXJzaW9uICE9PSBcInYzXCIgJiYgbW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24gIT09IFwidjJcIikge1xuICAgICAgY29uc3QgdW5zdXBwb3J0ZWRNb2RlbCA9IG1vZGVsO1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkTW9kZWxWZXJzaW9uRXJyb3Ioe1xuICAgICAgICB2ZXJzaW9uOiB1bnN1cHBvcnRlZE1vZGVsLnNwZWNpZmljYXRpb25WZXJzaW9uLFxuICAgICAgICBwcm92aWRlcjogdW5zdXBwb3J0ZWRNb2RlbC5wcm92aWRlcixcbiAgICAgICAgbW9kZWxJZDogdW5zdXBwb3J0ZWRNb2RlbC5tb2RlbElkXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFzRW1iZWRkaW5nTW9kZWxWMyhtb2RlbCk7XG4gIH1cbiAgcmV0dXJuIGdldEdsb2JhbFByb3ZpZGVyKCkuZW1iZWRkaW5nTW9kZWwobW9kZWwpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zY3JpcHRpb25Nb2RlbChtb2RlbCkge1xuICB2YXIgX2EyMSwgX2I7XG4gIGlmICh0eXBlb2YgbW9kZWwgIT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAobW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24gIT09IFwidjNcIiAmJiBtb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbiAhPT0gXCJ2MlwiKSB7XG4gICAgICBjb25zdCB1bnN1cHBvcnRlZE1vZGVsID0gbW9kZWw7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRNb2RlbFZlcnNpb25FcnJvcih7XG4gICAgICAgIHZlcnNpb246IHVuc3VwcG9ydGVkTW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24sXG4gICAgICAgIHByb3ZpZGVyOiB1bnN1cHBvcnRlZE1vZGVsLnByb3ZpZGVyLFxuICAgICAgICBtb2RlbElkOiB1bnN1cHBvcnRlZE1vZGVsLm1vZGVsSWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXNUcmFuc2NyaXB0aW9uTW9kZWxWMyhtb2RlbCk7XG4gIH1cbiAgcmV0dXJuIChfYiA9IChfYTIxID0gZ2V0R2xvYmFsUHJvdmlkZXIoKSkudHJhbnNjcmlwdGlvbk1vZGVsKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTIxLCBtb2RlbCk7XG59XG5mdW5jdGlvbiByZXNvbHZlU3BlZWNoTW9kZWwobW9kZWwpIHtcbiAgdmFyIF9hMjEsIF9iO1xuICBpZiAodHlwZW9mIG1vZGVsICE9PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKG1vZGVsLnNwZWNpZmljYXRpb25WZXJzaW9uICE9PSBcInYzXCIgJiYgbW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24gIT09IFwidjJcIikge1xuICAgICAgY29uc3QgdW5zdXBwb3J0ZWRNb2RlbCA9IG1vZGVsO1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkTW9kZWxWZXJzaW9uRXJyb3Ioe1xuICAgICAgICB2ZXJzaW9uOiB1bnN1cHBvcnRlZE1vZGVsLnNwZWNpZmljYXRpb25WZXJzaW9uLFxuICAgICAgICBwcm92aWRlcjogdW5zdXBwb3J0ZWRNb2RlbC5wcm92aWRlcixcbiAgICAgICAgbW9kZWxJZDogdW5zdXBwb3J0ZWRNb2RlbC5tb2RlbElkXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFzU3BlZWNoTW9kZWxWMyhtb2RlbCk7XG4gIH1cbiAgcmV0dXJuIChfYiA9IChfYTIxID0gZ2V0R2xvYmFsUHJvdmlkZXIoKSkuc3BlZWNoTW9kZWwpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMjEsIG1vZGVsKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVJbWFnZU1vZGVsKG1vZGVsKSB7XG4gIGlmICh0eXBlb2YgbW9kZWwgIT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAobW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24gIT09IFwidjNcIiAmJiBtb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbiAhPT0gXCJ2MlwiKSB7XG4gICAgICBjb25zdCB1bnN1cHBvcnRlZE1vZGVsID0gbW9kZWw7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRNb2RlbFZlcnNpb25FcnJvcih7XG4gICAgICAgIHZlcnNpb246IHVuc3VwcG9ydGVkTW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24sXG4gICAgICAgIHByb3ZpZGVyOiB1bnN1cHBvcnRlZE1vZGVsLnByb3ZpZGVyLFxuICAgICAgICBtb2RlbElkOiB1bnN1cHBvcnRlZE1vZGVsLm1vZGVsSWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXNJbWFnZU1vZGVsVjMobW9kZWwpO1xuICB9XG4gIHJldHVybiBnZXRHbG9iYWxQcm92aWRlcigpLmltYWdlTW9kZWwobW9kZWwpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVZpZGVvTW9kZWwobW9kZWwpIHtcbiAgaWYgKHR5cGVvZiBtb2RlbCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0R2xvYmFsUHJvdmlkZXIoKTtcbiAgICBjb25zdCB2aWRlb01vZGVsID0gcHJvdmlkZXIudmlkZW9Nb2RlbDtcbiAgICBpZiAoIXZpZGVvTW9kZWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1RoZSBkZWZhdWx0IHByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgdmlkZW8gbW9kZWxzLiBQbGVhc2UgdXNlIGEgRXhwZXJpbWVudGFsX1ZpZGVvTW9kZWxWMyBvYmplY3QgZnJvbSBhIHByb3ZpZGVyIChlLmcuLCB2ZXJ0ZXgudmlkZW8oXCJtb2RlbC1pZFwiKSkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHZpZGVvTW9kZWwobW9kZWwpO1xuICB9XG4gIGlmIChtb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbiAhPT0gXCJ2M1wiKSB7XG4gICAgY29uc3QgdW5zdXBwb3J0ZWRNb2RlbCA9IG1vZGVsO1xuICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE1vZGVsVmVyc2lvbkVycm9yKHtcbiAgICAgIHZlcnNpb246IHVuc3VwcG9ydGVkTW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24sXG4gICAgICBwcm92aWRlcjogdW5zdXBwb3J0ZWRNb2RlbC5wcm92aWRlcixcbiAgICAgIG1vZGVsSWQ6IHVuc3VwcG9ydGVkTW9kZWwubW9kZWxJZFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBtb2RlbDtcbn1cbmZ1bmN0aW9uIGdldEdsb2JhbFByb3ZpZGVyKCkge1xuICB2YXIgX2EyMTtcbiAgcmV0dXJuIChfYTIxID0gZ2xvYmFsVGhpcy5BSV9TREtfREVGQVVMVF9QUk9WSURFUikgIT0gbnVsbCA/IF9hMjEgOiBnYXRld2F5O1xufVxuXG4vLyBzcmMvcHJvbXB0L2NhbGwtc2V0dGluZ3MudHNcbmZ1bmN0aW9uIGdldFRvdGFsVGltZW91dE1zKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQgPT0gbnVsbCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKHR5cGVvZiB0aW1lb3V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIHRpbWVvdXQ7XG4gIH1cbiAgcmV0dXJuIHRpbWVvdXQudG90YWxNcztcbn1cbmZ1bmN0aW9uIGdldFN0ZXBUaW1lb3V0TXModGltZW91dCkge1xuICBpZiAodGltZW91dCA9PSBudWxsIHx8IHR5cGVvZiB0aW1lb3V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gdGltZW91dC5zdGVwTXM7XG59XG5mdW5jdGlvbiBnZXRDaHVua1RpbWVvdXRNcyh0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0ID09IG51bGwgfHwgdHlwZW9mIHRpbWVvdXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiB0aW1lb3V0LmNodW5rTXM7XG59XG5cbi8vIHNyYy9wcm9tcHQvY29udmVydC10by1sYW5ndWFnZS1tb2RlbC1wcm9tcHQudHNcbmltcG9ydCB7XG4gIGlzVXJsU3VwcG9ydGVkXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy91dGlsL2RldGVjdC1tZWRpYS10eXBlLnRzXG5pbXBvcnQgeyBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbnZhciBpbWFnZU1lZGlhVHlwZVNpZ25hdHVyZXMgPSBbXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiaW1hZ2UvZ2lmXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFs3MSwgNzMsIDcwXVxuICAgIC8vIEdJRlxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL3BuZ1wiLFxuICAgIGJ5dGVzUHJlZml4OiBbMTM3LCA4MCwgNzgsIDcxXVxuICAgIC8vIFBOR1xuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL2pwZWdcIixcbiAgICBieXRlc1ByZWZpeDogWzI1NSwgMjE2XVxuICAgIC8vIEpQRUdcbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJpbWFnZS93ZWJwXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFtcbiAgICAgIDgyLFxuICAgICAgNzMsXG4gICAgICA3MCxcbiAgICAgIDcwLFxuICAgICAgLy8gXCJSSUZGXCJcbiAgICAgIG51bGwsXG4gICAgICBudWxsLFxuICAgICAgbnVsbCxcbiAgICAgIG51bGwsXG4gICAgICAvLyBmaWxlIHNpemUgKHZhcmlhYmxlKVxuICAgICAgODcsXG4gICAgICA2OSxcbiAgICAgIDY2LFxuICAgICAgODBcbiAgICAgIC8vIFwiV0VCUFwiXG4gICAgXVxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL2JtcFwiLFxuICAgIGJ5dGVzUHJlZml4OiBbNjYsIDc3XVxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL3RpZmZcIixcbiAgICBieXRlc1ByZWZpeDogWzczLCA3MywgNDIsIDBdXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiaW1hZ2UvdGlmZlwiLFxuICAgIGJ5dGVzUHJlZml4OiBbNzcsIDc3LCAwLCA0Ml1cbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJpbWFnZS9hdmlmXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFtcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDMyLFxuICAgICAgMTAyLFxuICAgICAgMTE2LFxuICAgICAgMTIxLFxuICAgICAgMTEyLFxuICAgICAgOTcsXG4gICAgICAxMTgsXG4gICAgICAxMDUsXG4gICAgICAxMDJcbiAgICBdXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiaW1hZ2UvaGVpY1wiLFxuICAgIGJ5dGVzUHJlZml4OiBbXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAzMixcbiAgICAgIDEwMixcbiAgICAgIDExNixcbiAgICAgIDEyMSxcbiAgICAgIDExMixcbiAgICAgIDEwNCxcbiAgICAgIDEwMSxcbiAgICAgIDEwNSxcbiAgICAgIDk5XG4gICAgXVxuICB9XG5dO1xudmFyIGF1ZGlvTWVkaWFUeXBlU2lnbmF0dXJlcyA9IFtcbiAge1xuICAgIG1lZGlhVHlwZTogXCJhdWRpby9tcGVnXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFsyNTUsIDI1MV1cbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJhdWRpby9tcGVnXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFsyNTUsIDI1MF1cbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJhdWRpby9tcGVnXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFsyNTUsIDI0M11cbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJhdWRpby9tcGVnXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFsyNTUsIDI0Ml1cbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJhdWRpby9tcGVnXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFsyNTUsIDIyN11cbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJhdWRpby9tcGVnXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFsyNTUsIDIyNl1cbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJhdWRpby93YXZcIixcbiAgICBieXRlc1ByZWZpeDogW1xuICAgICAgODIsXG4gICAgICAvLyBSXG4gICAgICA3MyxcbiAgICAgIC8vIElcbiAgICAgIDcwLFxuICAgICAgLy8gRlxuICAgICAgNzAsXG4gICAgICAvLyBGXG4gICAgICBudWxsLFxuICAgICAgbnVsbCxcbiAgICAgIG51bGwsXG4gICAgICBudWxsLFxuICAgICAgODcsXG4gICAgICAvLyBXXG4gICAgICA2NSxcbiAgICAgIC8vIEFcbiAgICAgIDg2LFxuICAgICAgLy8gVlxuICAgICAgNjlcbiAgICAgIC8vIEVcbiAgICBdXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiYXVkaW8vb2dnXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFs3OSwgMTAzLCAxMDMsIDgzXVxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL2ZsYWNcIixcbiAgICBieXRlc1ByZWZpeDogWzEwMiwgNzYsIDk3LCA2N11cbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJhdWRpby9hYWNcIixcbiAgICBieXRlc1ByZWZpeDogWzY0LCAyMSwgMCwgMF1cbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJhdWRpby9tcDRcIixcbiAgICBieXRlc1ByZWZpeDogWzEwMiwgMTE2LCAxMjEsIDExMl1cbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJhdWRpby93ZWJtXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFsyNiwgNjksIDIyMywgMTYzXVxuICB9XG5dO1xudmFyIHZpZGVvTWVkaWFUeXBlU2lnbmF0dXJlcyA9IFtcbiAge1xuICAgIG1lZGlhVHlwZTogXCJ2aWRlby9tcDRcIixcbiAgICBieXRlc1ByZWZpeDogW1xuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgbnVsbCxcbiAgICAgIDEwMixcbiAgICAgIDExNixcbiAgICAgIDEyMSxcbiAgICAgIDExMlxuICAgICAgLy8gZnR5cFxuICAgIF1cbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJ2aWRlby93ZWJtXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFsyNiwgNjksIDIyMywgMTYzXVxuICAgIC8vIEVCTUxcbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJ2aWRlby9xdWlja3RpbWVcIixcbiAgICBieXRlc1ByZWZpeDogW1xuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMjAsXG4gICAgICAxMDIsXG4gICAgICAxMTYsXG4gICAgICAxMjEsXG4gICAgICAxMTIsXG4gICAgICAxMTMsXG4gICAgICAxMTZcbiAgICAgIC8vIGZ0eXBxdFxuICAgIF1cbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJ2aWRlby94LW1zdmlkZW9cIixcbiAgICBieXRlc1ByZWZpeDogWzgyLCA3MywgNzAsIDcwXVxuICAgIC8vIFJJRkYgKEFWSSlcbiAgfVxuXTtcbnZhciBzdHJpcElEMyA9IChkYXRhKSA9PiB7XG4gIGNvbnN0IGJ5dGVzID0gdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgPyBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5KGRhdGEpIDogZGF0YTtcbiAgY29uc3QgaWQzU2l6ZSA9IChieXRlc1s2XSAmIDEyNykgPDwgMjEgfCAoYnl0ZXNbN10gJiAxMjcpIDw8IDE0IHwgKGJ5dGVzWzhdICYgMTI3KSA8PCA3IHwgYnl0ZXNbOV0gJiAxMjc7XG4gIHJldHVybiBieXRlcy5zbGljZShpZDNTaXplICsgMTApO1xufTtcbmZ1bmN0aW9uIHN0cmlwSUQzVGFnc0lmUHJlc2VudChkYXRhKSB7XG4gIGNvbnN0IGhhc0lkMyA9IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICYmIGRhdGEuc3RhcnRzV2l0aChcIlNVUXpcIikgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgJiYgZGF0YS5sZW5ndGggPiAxMCAmJiBkYXRhWzBdID09PSA3MyAmJiAvLyAnSSdcbiAgZGF0YVsxXSA9PT0gNjggJiYgLy8gJ0QnXG4gIGRhdGFbMl0gPT09IDUxO1xuICByZXR1cm4gaGFzSWQzID8gc3RyaXBJRDMoZGF0YSkgOiBkYXRhO1xufVxuZnVuY3Rpb24gZGV0ZWN0TWVkaWFUeXBlKHtcbiAgZGF0YSxcbiAgc2lnbmF0dXJlc1xufSkge1xuICBjb25zdCBwcm9jZXNzZWREYXRhID0gc3RyaXBJRDNUYWdzSWZQcmVzZW50KGRhdGEpO1xuICBjb25zdCBieXRlcyA9IHR5cGVvZiBwcm9jZXNzZWREYXRhID09PSBcInN0cmluZ1wiID8gY29udmVydEJhc2U2NFRvVWludDhBcnJheShcbiAgICBwcm9jZXNzZWREYXRhLnN1YnN0cmluZygwLCBNYXRoLm1pbihwcm9jZXNzZWREYXRhLmxlbmd0aCwgMjQpKVxuICApIDogcHJvY2Vzc2VkRGF0YTtcbiAgZm9yIChjb25zdCBzaWduYXR1cmUgb2Ygc2lnbmF0dXJlcykge1xuICAgIGlmIChieXRlcy5sZW5ndGggPj0gc2lnbmF0dXJlLmJ5dGVzUHJlZml4Lmxlbmd0aCAmJiBzaWduYXR1cmUuYnl0ZXNQcmVmaXguZXZlcnkoXG4gICAgICAoYnl0ZSwgaW5kZXgpID0+IGJ5dGUgPT09IG51bGwgfHwgYnl0ZXNbaW5kZXhdID09PSBieXRlXG4gICAgKSkge1xuICAgICAgcmV0dXJuIHNpZ25hdHVyZS5tZWRpYVR5cGU7XG4gICAgfVxuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5cbi8vIHNyYy91dGlsL2Rvd25sb2FkL2Rvd25sb2FkLnRzXG5pbXBvcnQge1xuICBEb3dubG9hZEVycm9yIGFzIERvd25sb2FkRXJyb3IyLFxuICByZWFkUmVzcG9uc2VXaXRoU2l6ZUxpbWl0LFxuICBERUZBVUxUX01BWF9ET1dOTE9BRF9TSVpFXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQge1xuICB3aXRoVXNlckFnZW50U3VmZml4LFxuICBnZXRSdW50aW1lRW52aXJvbm1lbnRVc2VyQWdlbnRcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL3ZlcnNpb24udHNcbnZhciBWRVJTSU9OID0gdHJ1ZSA/IFwiNi4wLjk3XCIgOiBcIjAuMC4wLXRlc3RcIjtcblxuLy8gc3JjL3V0aWwvZG93bmxvYWQvZG93bmxvYWQudHNcbnZhciBkb3dubG9hZCA9IGFzeW5jICh7XG4gIHVybCxcbiAgbWF4Qnl0ZXMsXG4gIGFib3J0U2lnbmFsXG59KSA9PiB7XG4gIHZhciBfYTIxO1xuICBjb25zdCB1cmxUZXh0ID0gdXJsLnRvU3RyaW5nKCk7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmxUZXh0LCB7XG4gICAgICBoZWFkZXJzOiB3aXRoVXNlckFnZW50U3VmZml4KFxuICAgICAgICB7fSxcbiAgICAgICAgYGFpLXNkay8ke1ZFUlNJT059YCxcbiAgICAgICAgZ2V0UnVudGltZUVudmlyb25tZW50VXNlckFnZW50KClcbiAgICAgICksXG4gICAgICBzaWduYWw6IGFib3J0U2lnbmFsXG4gICAgfSk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IERvd25sb2FkRXJyb3IyKHtcbiAgICAgICAgdXJsOiB1cmxUZXh0LFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVhZFJlc3BvbnNlV2l0aFNpemVMaW1pdCh7XG4gICAgICByZXNwb25zZSxcbiAgICAgIHVybDogdXJsVGV4dCxcbiAgICAgIG1heEJ5dGVzOiBtYXhCeXRlcyAhPSBudWxsID8gbWF4Qnl0ZXMgOiBERUZBVUxUX01BWF9ET1dOTE9BRF9TSVpFXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGEsXG4gICAgICBtZWRpYVR5cGU6IChfYTIxID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikpICE9IG51bGwgPyBfYTIxIDogdm9pZCAwXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoRG93bmxvYWRFcnJvcjIuaXNJbnN0YW5jZShlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRG93bmxvYWRFcnJvcjIoeyB1cmw6IHVybFRleHQsIGNhdXNlOiBlcnJvciB9KTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWwvZG93bmxvYWQvZG93bmxvYWQtZnVuY3Rpb24udHNcbnZhciBjcmVhdGVEZWZhdWx0RG93bmxvYWRGdW5jdGlvbiA9IChkb3dubG9hZDIgPSBkb3dubG9hZCkgPT4gKHJlcXVlc3RlZERvd25sb2FkcykgPT4gUHJvbWlzZS5hbGwoXG4gIHJlcXVlc3RlZERvd25sb2Fkcy5tYXAoXG4gICAgYXN5bmMgKHJlcXVlc3RlZERvd25sb2FkKSA9PiByZXF1ZXN0ZWREb3dubG9hZC5pc1VybFN1cHBvcnRlZEJ5TW9kZWwgPyBudWxsIDogZG93bmxvYWQyKHJlcXVlc3RlZERvd25sb2FkKVxuICApXG4pO1xuXG4vLyBzcmMvcHJvbXB0L2RhdGEtY29udGVudC50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHtcbiAgY29udmVydEJhc2U2NFRvVWludDhBcnJheSBhcyBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5MixcbiAgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NFxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuaW1wb3J0IHsgeiB9IGZyb20gXCJ6b2QvdjRcIjtcblxuLy8gc3JjL3Byb21wdC9zcGxpdC1kYXRhLXVybC50c1xuZnVuY3Rpb24gc3BsaXREYXRhVXJsKGRhdGFVcmwpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBbaGVhZGVyLCBiYXNlNjRDb250ZW50XSA9IGRhdGFVcmwuc3BsaXQoXCIsXCIpO1xuICAgIHJldHVybiB7XG4gICAgICBtZWRpYVR5cGU6IGhlYWRlci5zcGxpdChcIjtcIilbMF0uc3BsaXQoXCI6XCIpWzFdLFxuICAgICAgYmFzZTY0Q29udGVudFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1lZGlhVHlwZTogdm9pZCAwLFxuICAgICAgYmFzZTY0Q29udGVudDogdm9pZCAwXG4gICAgfTtcbiAgfVxufVxuXG4vLyBzcmMvcHJvbXB0L2RhdGEtY29udGVudC50c1xudmFyIGRhdGFDb250ZW50U2NoZW1hID0gei51bmlvbihbXG4gIHouc3RyaW5nKCksXG4gIHouaW5zdGFuY2VvZihVaW50OEFycmF5KSxcbiAgei5pbnN0YW5jZW9mKEFycmF5QnVmZmVyKSxcbiAgei5jdXN0b20oXG4gICAgLy8gQnVmZmVyIG1pZ2h0IG5vdCBiZSBhdmFpbGFibGUgaW4gc29tZSBlbnZpcm9ubWVudHMgc3VjaCBhcyBDbG91ZEZsYXJlOlxuICAgICh2YWx1ZSkgPT4ge1xuICAgICAgdmFyIF9hMjEsIF9iO1xuICAgICAgcmV0dXJuIChfYiA9IChfYTIxID0gZ2xvYmFsVGhpcy5CdWZmZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYTIxLmlzQnVmZmVyKHZhbHVlKSkgIT0gbnVsbCA/IF9iIDogZmFsc2U7XG4gICAgfSxcbiAgICB7IG1lc3NhZ2U6IFwiTXVzdCBiZSBhIEJ1ZmZlclwiIH1cbiAgKVxuXSk7XG5mdW5jdGlvbiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsVjNEYXRhQ29udGVudChjb250ZW50KSB7XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiB7IGRhdGE6IGNvbnRlbnQsIG1lZGlhVHlwZTogdm9pZCAwIH07XG4gIH1cbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiB7IGRhdGE6IG5ldyBVaW50OEFycmF5KGNvbnRlbnQpLCBtZWRpYVR5cGU6IHZvaWQgMCB9O1xuICB9XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRyeSB7XG4gICAgICBjb250ZW50ID0gbmV3IFVSTChjb250ZW50KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgIH1cbiAgfVxuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIFVSTCAmJiBjb250ZW50LnByb3RvY29sID09PSBcImRhdGE6XCIpIHtcbiAgICBjb25zdCB7IG1lZGlhVHlwZTogZGF0YVVybE1lZGlhVHlwZSwgYmFzZTY0Q29udGVudCB9ID0gc3BsaXREYXRhVXJsKFxuICAgICAgY29udGVudC50b1N0cmluZygpXG4gICAgKTtcbiAgICBpZiAoZGF0YVVybE1lZGlhVHlwZSA9PSBudWxsIHx8IGJhc2U2NENvbnRlbnQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEFJU0RLRXJyb3IyMih7XG4gICAgICAgIG5hbWU6IFwiSW52YWxpZERhdGFDb250ZW50RXJyb3JcIixcbiAgICAgICAgbWVzc2FnZTogYEludmFsaWQgZGF0YSBVUkwgZm9ybWF0IGluIGNvbnRlbnQgJHtjb250ZW50LnRvU3RyaW5nKCl9YFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7IGRhdGE6IGJhc2U2NENvbnRlbnQsIG1lZGlhVHlwZTogZGF0YVVybE1lZGlhVHlwZSB9O1xuICB9XG4gIHJldHVybiB7IGRhdGE6IGNvbnRlbnQsIG1lZGlhVHlwZTogdm9pZCAwIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0RGF0YUNvbnRlbnRUb0Jhc2U2NFN0cmluZyhjb250ZW50KSB7XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NChuZXcgVWludDhBcnJheShjb250ZW50KSk7XG4gIH1cbiAgcmV0dXJuIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQoY29udGVudCk7XG59XG5mdW5jdGlvbiBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoY29udGVudCkge1xuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkyKGNvbnRlbnQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZERhdGFDb250ZW50RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBcIkludmFsaWQgZGF0YSBjb250ZW50LiBDb250ZW50IHN0cmluZyBpcyBub3QgYSBiYXNlNjQtZW5jb2RlZCBtZWRpYS5cIixcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgY2F1c2U6IGVycm9yXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShjb250ZW50KTtcbiAgfVxuICB0aHJvdyBuZXcgSW52YWxpZERhdGFDb250ZW50RXJyb3IoeyBjb250ZW50IH0pO1xufVxuXG4vLyBzcmMvdXRpbC9hcy1hcnJheS50c1xuZnVuY3Rpb24gYXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCA/IFtdIDogQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG59XG5cbi8vIHNyYy9wcm9tcHQvY29udmVydC10by1sYW5ndWFnZS1tb2RlbC1wcm9tcHQudHNcbmFzeW5jIGZ1bmN0aW9uIGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICBwcm9tcHQsXG4gIHN1cHBvcnRlZFVybHMsXG4gIGRvd25sb2FkOiBkb3dubG9hZDIgPSBjcmVhdGVEZWZhdWx0RG93bmxvYWRGdW5jdGlvbigpXG59KSB7XG4gIGNvbnN0IGRvd25sb2FkZWRBc3NldHMgPSBhd2FpdCBkb3dubG9hZEFzc2V0cyhcbiAgICBwcm9tcHQubWVzc2FnZXMsXG4gICAgZG93bmxvYWQyLFxuICAgIHN1cHBvcnRlZFVybHNcbiAgKTtcbiAgY29uc3QgYXBwcm92YWxJZFRvVG9vbENhbGxJZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZvciAoY29uc3QgbWVzc2FnZSBvZiBwcm9tcHQubWVzc2FnZXMpIHtcbiAgICBpZiAobWVzc2FnZS5yb2xlID09PSBcImFzc2lzdGFudFwiICYmIEFycmF5LmlzQXJyYXkobWVzc2FnZS5jb250ZW50KSkge1xuICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIG1lc3NhZ2UuY29udGVudCkge1xuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRvb2wtYXBwcm92YWwtcmVxdWVzdFwiICYmIFwiYXBwcm92YWxJZFwiIGluIHBhcnQgJiYgXCJ0b29sQ2FsbElkXCIgaW4gcGFydCkge1xuICAgICAgICAgIGFwcHJvdmFsSWRUb1Rvb2xDYWxsSWQuc2V0KFxuICAgICAgICAgICAgcGFydC5hcHByb3ZhbElkLFxuICAgICAgICAgICAgcGFydC50b29sQ2FsbElkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBhcHByb3ZlZFRvb2xDYWxsSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCBtZXNzYWdlIG9mIHByb21wdC5tZXNzYWdlcykge1xuICAgIGlmIChtZXNzYWdlLnJvbGUgPT09IFwidG9vbFwiKSB7XG4gICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgbWVzc2FnZS5jb250ZW50KSB7XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidG9vbC1hcHByb3ZhbC1yZXNwb25zZVwiKSB7XG4gICAgICAgICAgY29uc3QgdG9vbENhbGxJZCA9IGFwcHJvdmFsSWRUb1Rvb2xDYWxsSWQuZ2V0KHBhcnQuYXBwcm92YWxJZCk7XG4gICAgICAgICAgaWYgKHRvb2xDYWxsSWQpIHtcbiAgICAgICAgICAgIGFwcHJvdmVkVG9vbENhbGxJZHMuYWRkKHRvb2xDYWxsSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBtZXNzYWdlcyA9IFtcbiAgICAuLi5wcm9tcHQuc3lzdGVtICE9IG51bGwgPyB0eXBlb2YgcHJvbXB0LnN5c3RlbSA9PT0gXCJzdHJpbmdcIiA/IFt7IHJvbGU6IFwic3lzdGVtXCIsIGNvbnRlbnQ6IHByb21wdC5zeXN0ZW0gfV0gOiBhc0FycmF5KHByb21wdC5zeXN0ZW0pLm1hcCgobWVzc2FnZSkgPT4gKHtcbiAgICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQsXG4gICAgICBwcm92aWRlck9wdGlvbnM6IG1lc3NhZ2UucHJvdmlkZXJPcHRpb25zXG4gICAgfSkpIDogW10sXG4gICAgLi4ucHJvbXB0Lm1lc3NhZ2VzLm1hcChcbiAgICAgIChtZXNzYWdlKSA9PiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsTWVzc2FnZSh7IG1lc3NhZ2UsIGRvd25sb2FkZWRBc3NldHMgfSlcbiAgICApXG4gIF07XG4gIGNvbnN0IGNvbWJpbmVkTWVzc2FnZXMgPSBbXTtcbiAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzKSB7XG4gICAgaWYgKG1lc3NhZ2Uucm9sZSAhPT0gXCJ0b29sXCIpIHtcbiAgICAgIGNvbWJpbmVkTWVzc2FnZXMucHVzaChtZXNzYWdlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBsYXN0Q29tYmluZWRNZXNzYWdlID0gY29tYmluZWRNZXNzYWdlcy5hdCgtMSk7XG4gICAgaWYgKChsYXN0Q29tYmluZWRNZXNzYWdlID09IG51bGwgPyB2b2lkIDAgOiBsYXN0Q29tYmluZWRNZXNzYWdlLnJvbGUpID09PSBcInRvb2xcIikge1xuICAgICAgbGFzdENvbWJpbmVkTWVzc2FnZS5jb250ZW50LnB1c2goLi4ubWVzc2FnZS5jb250ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tYmluZWRNZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuICBjb25zdCB0b29sQ2FsbElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGZvciAoY29uc3QgbWVzc2FnZSBvZiBjb21iaW5lZE1lc3NhZ2VzKSB7XG4gICAgc3dpdGNoIChtZXNzYWdlLnJvbGUpIHtcbiAgICAgIGNhc2UgXCJhc3Npc3RhbnRcIjoge1xuICAgICAgICBmb3IgKGNvbnN0IGNvbnRlbnQgb2YgbWVzc2FnZS5jb250ZW50KSB7XG4gICAgICAgICAgaWYgKGNvbnRlbnQudHlwZSA9PT0gXCJ0b29sLWNhbGxcIiAmJiAhY29udGVudC5wcm92aWRlckV4ZWN1dGVkKSB7XG4gICAgICAgICAgICB0b29sQ2FsbElkcy5hZGQoY29udGVudC50b29sQ2FsbElkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwidG9vbFwiOiB7XG4gICAgICAgIGZvciAoY29uc3QgY29udGVudCBvZiBtZXNzYWdlLmNvbnRlbnQpIHtcbiAgICAgICAgICBpZiAoY29udGVudC50eXBlID09PSBcInRvb2wtcmVzdWx0XCIpIHtcbiAgICAgICAgICAgIHRvb2xDYWxsSWRzLmRlbGV0ZShjb250ZW50LnRvb2xDYWxsSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ1c2VyXCI6XG4gICAgICBjYXNlIFwic3lzdGVtXCI6XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgYXBwcm92ZWRUb29sQ2FsbElkcykge1xuICAgICAgICAgIHRvb2xDYWxsSWRzLmRlbGV0ZShpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvb2xDYWxsSWRzLnNpemUgPiAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE1pc3NpbmdUb29sUmVzdWx0c0Vycm9yKHtcbiAgICAgICAgICAgIHRvb2xDYWxsSWRzOiBBcnJheS5mcm9tKHRvb2xDYWxsSWRzKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGlkIG9mIGFwcHJvdmVkVG9vbENhbGxJZHMpIHtcbiAgICB0b29sQ2FsbElkcy5kZWxldGUoaWQpO1xuICB9XG4gIGlmICh0b29sQ2FsbElkcy5zaXplID4gMCkge1xuICAgIHRocm93IG5ldyBNaXNzaW5nVG9vbFJlc3VsdHNFcnJvcih7IHRvb2xDYWxsSWRzOiBBcnJheS5mcm9tKHRvb2xDYWxsSWRzKSB9KTtcbiAgfVxuICByZXR1cm4gY29tYmluZWRNZXNzYWdlcy5maWx0ZXIoXG4gICAgLy8gRmlsdGVyIG91dCBlbXB0eSB0b29sIG1lc3NhZ2VzIChlLmcuIGlmIHRoZXkgb25seSBjb250YWluZWRcbiAgICAvLyB0b29sLWFwcHJvdmFsLXJlc3BvbnNlIHBhcnRzIHRoYXQgd2VyZSByZW1vdmVkKS5cbiAgICAvLyBUaGlzIHByZXZlbnRzIHNlbmRpbmcgaW52YWxpZCBlbXB0eSBtZXNzYWdlcyB0byB0aGUgcHJvdmlkZXIuXG4gICAgLy8gTm90ZTogcHJvdmlkZXItZXhlY3V0ZWQgdG9vbC1hcHByb3ZhbC1yZXNwb25zZSBwYXJ0cyBhcmUgcHJlc2VydmVkLlxuICAgIChtZXNzYWdlKSA9PiBtZXNzYWdlLnJvbGUgIT09IFwidG9vbFwiIHx8IG1lc3NhZ2UuY29udGVudC5sZW5ndGggPiAwXG4gICk7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsTWVzc2FnZSh7XG4gIG1lc3NhZ2UsXG4gIGRvd25sb2FkZWRBc3NldHNcbn0pIHtcbiAgY29uc3Qgcm9sZSA9IG1lc3NhZ2Uucm9sZTtcbiAgc3dpdGNoIChyb2xlKSB7XG4gICAgY2FzZSBcInN5c3RlbVwiOiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiBcInN5c3RlbVwiLFxuICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQsXG4gICAgICAgIHByb3ZpZGVyT3B0aW9uczogbWVzc2FnZS5wcm92aWRlck9wdGlvbnNcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJ1c2VyXCI6IHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgY29udGVudDogW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IG1lc3NhZ2UuY29udGVudCB9XSxcbiAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IG1lc3NhZ2UucHJvdmlkZXJPcHRpb25zXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50Lm1hcCgocGFydCkgPT4gY29udmVydFBhcnRUb0xhbmd1YWdlTW9kZWxQYXJ0KHBhcnQsIGRvd25sb2FkZWRBc3NldHMpKS5maWx0ZXIoKHBhcnQpID0+IHBhcnQudHlwZSAhPT0gXCJ0ZXh0XCIgfHwgcGFydC50ZXh0ICE9PSBcIlwiKSxcbiAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBtZXNzYWdlLnByb3ZpZGVyT3B0aW9uc1xuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcImFzc2lzdGFudFwiOiB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgY29udGVudDogW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IG1lc3NhZ2UuY29udGVudCB9XSxcbiAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IG1lc3NhZ2UucHJvdmlkZXJPcHRpb25zXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQuZmlsdGVyKFxuICAgICAgICAgIC8vIHJlbW92ZSBlbXB0eSB0ZXh0IHBhcnRzIChubyB0ZXh0LCBhbmQgbm8gcHJvdmlkZXIgb3B0aW9ucyk6XG4gICAgICAgICAgKHBhcnQpID0+IHBhcnQudHlwZSAhPT0gXCJ0ZXh0XCIgfHwgcGFydC50ZXh0ICE9PSBcIlwiIHx8IHBhcnQucHJvdmlkZXJPcHRpb25zICE9IG51bGxcbiAgICAgICAgKS5maWx0ZXIoXG4gICAgICAgICAgKHBhcnQpID0+IHBhcnQudHlwZSAhPT0gXCJ0b29sLWFwcHJvdmFsLXJlcXVlc3RcIlxuICAgICAgICApLm1hcCgocGFydCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHByb3ZpZGVyT3B0aW9ucyA9IHBhcnQucHJvdmlkZXJPcHRpb25zO1xuICAgICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZmlsZVwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgbWVkaWFUeXBlIH0gPSBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsVjNEYXRhQ29udGVudChcbiAgICAgICAgICAgICAgICBwYXJ0LmRhdGFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBwYXJ0LmZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIG1lZGlhVHlwZTogbWVkaWFUeXBlICE9IG51bGwgPyBtZWRpYVR5cGUgOiBwYXJ0Lm1lZGlhVHlwZSxcbiAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJyZWFzb25pbmdcIjoge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nXCIsXG4gICAgICAgICAgICAgICAgdGV4dDogcGFydC50ZXh0LFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRleHRcIjoge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgIHRleHQ6IHBhcnQudGV4dCxcbiAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGxcIjoge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1jYWxsXCIsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIGlucHV0OiBwYXJ0LmlucHV0LFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHBhcnQucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLXJlc3VsdFwiOiB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IG1hcFRvb2xSZXN1bHRPdXRwdXQocGFydC5vdXRwdXQpLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIHByb3ZpZGVyT3B0aW9uczogbWVzc2FnZS5wcm92aWRlck9wdGlvbnNcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJ0b29sXCI6IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6IFwidG9vbFwiLFxuICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQuZmlsdGVyKFxuICAgICAgICAgIC8vIE9ubHkgaW5jbHVkZSB0b29sLWFwcHJvdmFsLXJlc3BvbnNlIGZvciBwcm92aWRlci1leGVjdXRlZCB0b29sc1xuICAgICAgICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgIT09IFwidG9vbC1hcHByb3ZhbC1yZXNwb25zZVwiIHx8IHBhcnQucHJvdmlkZXJFeGVjdXRlZFxuICAgICAgICApLm1hcCgocGFydCkgPT4ge1xuICAgICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1yZXN1bHRcIjoge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBtYXBUb29sUmVzdWx0T3V0cHV0KHBhcnQub3V0cHV0KSxcbiAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHBhcnQucHJvdmlkZXJPcHRpb25zXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1hcHByb3ZhbC1yZXNwb25zZVwiOiB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWFwcHJvdmFsLXJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgYXBwcm92YWxJZDogcGFydC5hcHByb3ZhbElkLFxuICAgICAgICAgICAgICAgIGFwcHJvdmVkOiBwYXJ0LmFwcHJvdmVkLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogcGFydC5yZWFzb25cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBwcm92aWRlck9wdGlvbnM6IG1lc3NhZ2UucHJvdmlkZXJPcHRpb25zXG4gICAgICB9O1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gcm9sZTtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvcih7IHJvbGU6IF9leGhhdXN0aXZlQ2hlY2sgfSk7XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiBkb3dubG9hZEFzc2V0cyhtZXNzYWdlcywgZG93bmxvYWQyLCBzdXBwb3J0ZWRVcmxzKSB7XG4gIGNvbnN0IHBsYW5uZWREb3dubG9hZHMgPSBtZXNzYWdlcy5maWx0ZXIoKG1lc3NhZ2UpID0+IG1lc3NhZ2Uucm9sZSA9PT0gXCJ1c2VyXCIpLm1hcCgobWVzc2FnZSkgPT4gbWVzc2FnZS5jb250ZW50KS5maWx0ZXIoXG4gICAgKGNvbnRlbnQpID0+IEFycmF5LmlzQXJyYXkoY29udGVudClcbiAgKS5mbGF0KCkuZmlsdGVyKFxuICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwiaW1hZ2VcIiB8fCBwYXJ0LnR5cGUgPT09IFwiZmlsZVwiXG4gICkubWFwKChwYXJ0KSA9PiB7XG4gICAgdmFyIF9hMjE7XG4gICAgY29uc3QgbWVkaWFUeXBlID0gKF9hMjEgPSBwYXJ0Lm1lZGlhVHlwZSkgIT0gbnVsbCA/IF9hMjEgOiBwYXJ0LnR5cGUgPT09IFwiaW1hZ2VcIiA/IFwiaW1hZ2UvKlwiIDogdm9pZCAwO1xuICAgIGxldCBkYXRhID0gcGFydC50eXBlID09PSBcImltYWdlXCIgPyBwYXJ0LmltYWdlIDogcGFydC5kYXRhO1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IG5ldyBVUkwoZGF0YSk7XG4gICAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG1lZGlhVHlwZSwgZGF0YSB9O1xuICB9KS5maWx0ZXIoXG4gICAgKHBhcnQpID0+IHBhcnQuZGF0YSBpbnN0YW5jZW9mIFVSTFxuICApLm1hcCgocGFydCkgPT4gKHtcbiAgICB1cmw6IHBhcnQuZGF0YSxcbiAgICBpc1VybFN1cHBvcnRlZEJ5TW9kZWw6IHBhcnQubWVkaWFUeXBlICE9IG51bGwgJiYgaXNVcmxTdXBwb3J0ZWQoe1xuICAgICAgdXJsOiBwYXJ0LmRhdGEudG9TdHJpbmcoKSxcbiAgICAgIG1lZGlhVHlwZTogcGFydC5tZWRpYVR5cGUsXG4gICAgICBzdXBwb3J0ZWRVcmxzXG4gICAgfSlcbiAgfSkpO1xuICBjb25zdCBkb3dubG9hZGVkRmlsZXMgPSBhd2FpdCBkb3dubG9hZDIocGxhbm5lZERvd25sb2Fkcyk7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgZG93bmxvYWRlZEZpbGVzLm1hcChcbiAgICAgIChmaWxlLCBpbmRleCkgPT4gZmlsZSA9PSBudWxsID8gbnVsbCA6IFtcbiAgICAgICAgcGxhbm5lZERvd25sb2Fkc1tpbmRleF0udXJsLnRvU3RyaW5nKCksXG4gICAgICAgIHsgZGF0YTogZmlsZS5kYXRhLCBtZWRpYVR5cGU6IGZpbGUubWVkaWFUeXBlIH1cbiAgICAgIF1cbiAgICApLmZpbHRlcigoZmlsZSkgPT4gZmlsZSAhPSBudWxsKVxuICApO1xufVxuZnVuY3Rpb24gY29udmVydFBhcnRUb0xhbmd1YWdlTW9kZWxQYXJ0KHBhcnQsIGRvd25sb2FkZWRBc3NldHMpIHtcbiAgdmFyIF9hMjE7XG4gIGlmIChwYXJ0LnR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgdGV4dDogcGFydC50ZXh0LFxuICAgICAgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyT3B0aW9uc1xuICAgIH07XG4gIH1cbiAgbGV0IG9yaWdpbmFsRGF0YTtcbiAgY29uc3QgdHlwZSA9IHBhcnQudHlwZTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcImltYWdlXCI6XG4gICAgICBvcmlnaW5hbERhdGEgPSBwYXJ0LmltYWdlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImZpbGVcIjpcbiAgICAgIG9yaWdpbmFsRGF0YSA9IHBhcnQuZGF0YTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHBhcnQgdHlwZTogJHt0eXBlfWApO1xuICB9XG4gIGNvbnN0IHsgZGF0YTogY29udmVydGVkRGF0YSwgbWVkaWFUeXBlOiBjb252ZXJ0ZWRNZWRpYVR5cGUgfSA9IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxWM0RhdGFDb250ZW50KG9yaWdpbmFsRGF0YSk7XG4gIGxldCBtZWRpYVR5cGUgPSBjb252ZXJ0ZWRNZWRpYVR5cGUgIT0gbnVsbCA/IGNvbnZlcnRlZE1lZGlhVHlwZSA6IHBhcnQubWVkaWFUeXBlO1xuICBsZXQgZGF0YSA9IGNvbnZlcnRlZERhdGE7XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgY29uc3QgZG93bmxvYWRlZEZpbGUgPSBkb3dubG9hZGVkQXNzZXRzW2RhdGEudG9TdHJpbmcoKV07XG4gICAgaWYgKGRvd25sb2FkZWRGaWxlKSB7XG4gICAgICBkYXRhID0gZG93bmxvYWRlZEZpbGUuZGF0YTtcbiAgICAgIG1lZGlhVHlwZSAhPSBudWxsID8gbWVkaWFUeXBlIDogbWVkaWFUeXBlID0gZG93bmxvYWRlZEZpbGUubWVkaWFUeXBlO1xuICAgIH1cbiAgfVxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFwiaW1hZ2VcIjoge1xuICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG1lZGlhVHlwZSA9IChfYTIxID0gZGV0ZWN0TWVkaWFUeXBlKHsgZGF0YSwgc2lnbmF0dXJlczogaW1hZ2VNZWRpYVR5cGVTaWduYXR1cmVzIH0pKSAhPSBudWxsID8gX2EyMSA6IG1lZGlhVHlwZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICBtZWRpYVR5cGU6IG1lZGlhVHlwZSAhPSBudWxsID8gbWVkaWFUeXBlIDogXCJpbWFnZS8qXCIsXG4gICAgICAgIC8vIGFueSBpbWFnZVxuICAgICAgICBmaWxlbmFtZTogdm9pZCAwLFxuICAgICAgICBkYXRhLFxuICAgICAgICBwcm92aWRlck9wdGlvbnM6IHBhcnQucHJvdmlkZXJPcHRpb25zXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwiZmlsZVwiOiB7XG4gICAgICBpZiAobWVkaWFUeXBlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZWRpYSB0eXBlIGlzIG1pc3NpbmcgZm9yIGZpbGUgcGFydGApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgIG1lZGlhVHlwZSxcbiAgICAgICAgZmlsZW5hbWU6IHBhcnQuZmlsZW5hbWUsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck9wdGlvbnNcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXBUb29sUmVzdWx0T3V0cHV0KG91dHB1dCkge1xuICBpZiAob3V0cHV0LnR5cGUgIT09IFwiY29udGVudFwiKSB7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiY29udGVudFwiLFxuICAgIHZhbHVlOiBvdXRwdXQudmFsdWUubWFwKChpdGVtKSA9PiB7XG4gICAgICBpZiAoaXRlbS50eXBlICE9PSBcIm1lZGlhXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG4gICAgICBpZiAoaXRlbS5tZWRpYVR5cGUuc3RhcnRzV2l0aChcImltYWdlL1wiKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiaW1hZ2UtZGF0YVwiLFxuICAgICAgICAgIGRhdGE6IGl0ZW0uZGF0YSxcbiAgICAgICAgICBtZWRpYVR5cGU6IGl0ZW0ubWVkaWFUeXBlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImZpbGUtZGF0YVwiLFxuICAgICAgICBkYXRhOiBpdGVtLmRhdGEsXG4gICAgICAgIG1lZGlhVHlwZTogaXRlbS5tZWRpYVR5cGVcbiAgICAgIH07XG4gICAgfSlcbiAgfTtcbn1cblxuLy8gc3JjL3Byb21wdC9jcmVhdGUtdG9vbC1tb2RlbC1vdXRwdXQudHNcbmltcG9ydCB7IGdldEVycm9yTWVzc2FnZSBhcyBnZXRFcnJvck1lc3NhZ2UzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVRvb2xNb2RlbE91dHB1dCh7XG4gIHRvb2xDYWxsSWQsXG4gIGlucHV0LFxuICBvdXRwdXQsXG4gIHRvb2w6IHRvb2wyLFxuICBlcnJvck1vZGVcbn0pIHtcbiAgaWYgKGVycm9yTW9kZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yLXRleHRcIiwgdmFsdWU6IGdldEVycm9yTWVzc2FnZTMob3V0cHV0KSB9O1xuICB9IGVsc2UgaWYgKGVycm9yTW9kZSA9PT0gXCJqc29uXCIpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yLWpzb25cIiwgdmFsdWU6IHRvSlNPTlZhbHVlKG91dHB1dCkgfTtcbiAgfVxuICBpZiAodG9vbDIgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2wyLnRvTW9kZWxPdXRwdXQpIHtcbiAgICByZXR1cm4gYXdhaXQgdG9vbDIudG9Nb2RlbE91dHB1dCh7IHRvb2xDYWxsSWQsIGlucHV0LCBvdXRwdXQgfSk7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBvdXRwdXQgPT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogb3V0cHV0IH0gOiB7IHR5cGU6IFwianNvblwiLCB2YWx1ZTogdG9KU09OVmFsdWUob3V0cHV0KSB9O1xufVxuZnVuY3Rpb24gdG9KU09OVmFsdWUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyBudWxsIDogdmFsdWU7XG59XG5cbi8vIHNyYy9wcm9tcHQvcHJlcGFyZS1jYWxsLXNldHRpbmdzLnRzXG5mdW5jdGlvbiBwcmVwYXJlQ2FsbFNldHRpbmdzKHtcbiAgbWF4T3V0cHV0VG9rZW5zLFxuICB0ZW1wZXJhdHVyZSxcbiAgdG9wUCxcbiAgdG9wSyxcbiAgcHJlc2VuY2VQZW5hbHR5LFxuICBmcmVxdWVuY3lQZW5hbHR5LFxuICBzZWVkLFxuICBzdG9wU2VxdWVuY2VzXG59KSB7XG4gIGlmIChtYXhPdXRwdXRUb2tlbnMgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhPdXRwdXRUb2tlbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwibWF4T3V0cHV0VG9rZW5zXCIsXG4gICAgICAgIHZhbHVlOiBtYXhPdXRwdXRUb2tlbnMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4T3V0cHV0VG9rZW5zIG11c3QgYmUgYW4gaW50ZWdlclwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG1heE91dHB1dFRva2VucyA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhPdXRwdXRUb2tlbnNcIixcbiAgICAgICAgdmFsdWU6IG1heE91dHB1dFRva2VucyxcbiAgICAgICAgbWVzc2FnZTogXCJtYXhPdXRwdXRUb2tlbnMgbXVzdCBiZSA+PSAxXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAodGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdGVtcGVyYXR1cmUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJ0ZW1wZXJhdHVyZVwiLFxuICAgICAgICB2YWx1ZTogdGVtcGVyYXR1cmUsXG4gICAgICAgIG1lc3NhZ2U6IFwidGVtcGVyYXR1cmUgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHRvcFAgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdG9wUCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInRvcFBcIixcbiAgICAgICAgdmFsdWU6IHRvcFAsXG4gICAgICAgIG1lc3NhZ2U6IFwidG9wUCBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAodG9wSyAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB0b3BLICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwidG9wS1wiLFxuICAgICAgICB2YWx1ZTogdG9wSyxcbiAgICAgICAgbWVzc2FnZTogXCJ0b3BLIG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChwcmVzZW5jZVBlbmFsdHkgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgcHJlc2VuY2VQZW5hbHR5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwicHJlc2VuY2VQZW5hbHR5XCIsXG4gICAgICAgIHZhbHVlOiBwcmVzZW5jZVBlbmFsdHksXG4gICAgICAgIG1lc3NhZ2U6IFwicHJlc2VuY2VQZW5hbHR5IG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChmcmVxdWVuY3lQZW5hbHR5ICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIGZyZXF1ZW5jeVBlbmFsdHkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJmcmVxdWVuY3lQZW5hbHR5XCIsXG4gICAgICAgIHZhbHVlOiBmcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICBtZXNzYWdlOiBcImZyZXF1ZW5jeVBlbmFsdHkgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHNlZWQgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihzZWVkKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNlZWRcIixcbiAgICAgICAgdmFsdWU6IHNlZWQsXG4gICAgICAgIG1lc3NhZ2U6IFwic2VlZCBtdXN0IGJlIGFuIGludGVnZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbWF4T3V0cHV0VG9rZW5zLFxuICAgIHRlbXBlcmF0dXJlLFxuICAgIHRvcFAsXG4gICAgdG9wSyxcbiAgICBwcmVzZW5jZVBlbmFsdHksXG4gICAgZnJlcXVlbmN5UGVuYWx0eSxcbiAgICBzdG9wU2VxdWVuY2VzLFxuICAgIHNlZWRcbiAgfTtcbn1cblxuLy8gc3JjL3Byb21wdC9wcmVwYXJlLXRvb2xzLWFuZC10b29sLWNob2ljZS50c1xuaW1wb3J0IHsgYXNTY2hlbWEgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdXRpbC9pcy1ub24tZW1wdHktb2JqZWN0LnRzXG5mdW5jdGlvbiBpc05vbkVtcHR5T2JqZWN0KG9iamVjdDIpIHtcbiAgcmV0dXJuIG9iamVjdDIgIT0gbnVsbCAmJiBPYmplY3Qua2V5cyhvYmplY3QyKS5sZW5ndGggPiAwO1xufVxuXG4vLyBzcmMvcHJvbXB0L3ByZXBhcmUtdG9vbHMtYW5kLXRvb2wtY2hvaWNlLnRzXG5hc3luYyBmdW5jdGlvbiBwcmVwYXJlVG9vbHNBbmRUb29sQ2hvaWNlKHtcbiAgdG9vbHMsXG4gIHRvb2xDaG9pY2UsXG4gIGFjdGl2ZVRvb2xzXG59KSB7XG4gIGlmICghaXNOb25FbXB0eU9iamVjdCh0b29scykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9vbHM6IHZvaWQgMCxcbiAgICAgIHRvb2xDaG9pY2U6IHZvaWQgMFxuICAgIH07XG4gIH1cbiAgY29uc3QgZmlsdGVyZWRUb29scyA9IGFjdGl2ZVRvb2xzICE9IG51bGwgPyBPYmplY3QuZW50cmllcyh0b29scykuZmlsdGVyKFxuICAgIChbbmFtZTIxXSkgPT4gYWN0aXZlVG9vbHMuaW5jbHVkZXMobmFtZTIxKVxuICApIDogT2JqZWN0LmVudHJpZXModG9vbHMpO1xuICBjb25zdCBsYW5ndWFnZU1vZGVsVG9vbHMgPSBbXTtcbiAgZm9yIChjb25zdCBbbmFtZTIxLCB0b29sMl0gb2YgZmlsdGVyZWRUb29scykge1xuICAgIGNvbnN0IHRvb2xUeXBlID0gdG9vbDIudHlwZTtcbiAgICBzd2l0Y2ggKHRvb2xUeXBlKSB7XG4gICAgICBjYXNlIHZvaWQgMDpcbiAgICAgIGNhc2UgXCJkeW5hbWljXCI6XG4gICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgbGFuZ3VhZ2VNb2RlbFRvb2xzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICBuYW1lOiBuYW1lMjEsXG4gICAgICAgICAgZGVzY3JpcHRpb246IHRvb2wyLmRlc2NyaXB0aW9uLFxuICAgICAgICAgIGlucHV0U2NoZW1hOiBhd2FpdCBhc1NjaGVtYSh0b29sMi5pbnB1dFNjaGVtYSkuanNvblNjaGVtYSxcbiAgICAgICAgICAuLi50b29sMi5pbnB1dEV4YW1wbGVzICE9IG51bGwgPyB7IGlucHV0RXhhbXBsZXM6IHRvb2wyLmlucHV0RXhhbXBsZXMgfSA6IHt9LFxuICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogdG9vbDIucHJvdmlkZXJPcHRpb25zLFxuICAgICAgICAgIC4uLnRvb2wyLnN0cmljdCAhPSBudWxsID8geyBzdHJpY3Q6IHRvb2wyLnN0cmljdCB9IDoge31cbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInByb3ZpZGVyXCI6XG4gICAgICAgIGxhbmd1YWdlTW9kZWxUb29scy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcInByb3ZpZGVyXCIsXG4gICAgICAgICAgbmFtZTogbmFtZTIxLFxuICAgICAgICAgIGlkOiB0b29sMi5pZCxcbiAgICAgICAgICBhcmdzOiB0b29sMi5hcmdzXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gdG9vbFR5cGU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgdG9vbCB0eXBlOiAke2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b29sczogbGFuZ3VhZ2VNb2RlbFRvb2xzLFxuICAgIHRvb2xDaG9pY2U6IHRvb2xDaG9pY2UgPT0gbnVsbCA/IHsgdHlwZTogXCJhdXRvXCIgfSA6IHR5cGVvZiB0b29sQ2hvaWNlID09PSBcInN0cmluZ1wiID8geyB0eXBlOiB0b29sQ2hvaWNlIH0gOiB7IHR5cGU6IFwidG9vbFwiLCB0b29sTmFtZTogdG9vbENob2ljZS50b29sTmFtZSB9XG4gIH07XG59XG5cbi8vIHNyYy9wcm9tcHQvc3RhbmRhcmRpemUtcHJvbXB0LnRzXG5pbXBvcnQgeyBJbnZhbGlkUHJvbXB0RXJyb3IgYXMgSW52YWxpZFByb21wdEVycm9yMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQge1xuICBzYWZlVmFsaWRhdGVUeXBlc1xufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuaW1wb3J0IHsgeiBhcyB6NiB9IGZyb20gXCJ6b2QvdjRcIjtcblxuLy8gc3JjL3Byb21wdC9tZXNzYWdlLnRzXG5pbXBvcnQgeyB6IGFzIHo1IH0gZnJvbSBcInpvZC92NFwiO1xuXG4vLyBzcmMvdHlwZXMvcHJvdmlkZXItbWV0YWRhdGEudHNcbmltcG9ydCB7IHogYXMgejMgfSBmcm9tIFwiem9kL3Y0XCI7XG5cbi8vIHNyYy90eXBlcy9qc29uLXZhbHVlLnRzXG5pbXBvcnQgeyB6IGFzIHoyIH0gZnJvbSBcInpvZC92NFwiO1xudmFyIGpzb25WYWx1ZVNjaGVtYSA9IHoyLmxhenkoXG4gICgpID0+IHoyLnVuaW9uKFtcbiAgICB6Mi5udWxsKCksXG4gICAgejIuc3RyaW5nKCksXG4gICAgejIubnVtYmVyKCksXG4gICAgejIuYm9vbGVhbigpLFxuICAgIHoyLnJlY29yZCh6Mi5zdHJpbmcoKSwganNvblZhbHVlU2NoZW1hLm9wdGlvbmFsKCkpLFxuICAgIHoyLmFycmF5KGpzb25WYWx1ZVNjaGVtYSlcbiAgXSlcbik7XG5cbi8vIHNyYy90eXBlcy9wcm92aWRlci1tZXRhZGF0YS50c1xudmFyIHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEgPSB6My5yZWNvcmQoXG4gIHozLnN0cmluZygpLFxuICB6My5yZWNvcmQoejMuc3RyaW5nKCksIGpzb25WYWx1ZVNjaGVtYS5vcHRpb25hbCgpKVxuKTtcblxuLy8gc3JjL3Byb21wdC9jb250ZW50LXBhcnQudHNcbmltcG9ydCB7IHogYXMgejQgfSBmcm9tIFwiem9kL3Y0XCI7XG52YXIgdGV4dFBhcnRTY2hlbWEgPSB6NC5vYmplY3Qoe1xuICB0eXBlOiB6NC5saXRlcmFsKFwidGV4dFwiKSxcbiAgdGV4dDogejQuc3RyaW5nKCksXG4gIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciBpbWFnZVBhcnRTY2hlbWEgPSB6NC5vYmplY3Qoe1xuICB0eXBlOiB6NC5saXRlcmFsKFwiaW1hZ2VcIiksXG4gIGltYWdlOiB6NC51bmlvbihbZGF0YUNvbnRlbnRTY2hlbWEsIHo0Lmluc3RhbmNlb2YoVVJMKV0pLFxuICBtZWRpYVR5cGU6IHo0LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciBmaWxlUGFydFNjaGVtYSA9IHo0Lm9iamVjdCh7XG4gIHR5cGU6IHo0LmxpdGVyYWwoXCJmaWxlXCIpLFxuICBkYXRhOiB6NC51bmlvbihbZGF0YUNvbnRlbnRTY2hlbWEsIHo0Lmluc3RhbmNlb2YoVVJMKV0pLFxuICBmaWxlbmFtZTogejQuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgbWVkaWFUeXBlOiB6NC5zdHJpbmcoKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIHJlYXNvbmluZ1BhcnRTY2hlbWEgPSB6NC5vYmplY3Qoe1xuICB0eXBlOiB6NC5saXRlcmFsKFwicmVhc29uaW5nXCIpLFxuICB0ZXh0OiB6NC5zdHJpbmcoKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIHRvb2xDYWxsUGFydFNjaGVtYSA9IHo0Lm9iamVjdCh7XG4gIHR5cGU6IHo0LmxpdGVyYWwoXCJ0b29sLWNhbGxcIiksXG4gIHRvb2xDYWxsSWQ6IHo0LnN0cmluZygpLFxuICB0b29sTmFtZTogejQuc3RyaW5nKCksXG4gIGlucHV0OiB6NC51bmtub3duKCksXG4gIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICBwcm92aWRlckV4ZWN1dGVkOiB6NC5ib29sZWFuKCkub3B0aW9uYWwoKVxufSk7XG52YXIgb3V0cHV0U2NoZW1hID0gejQuZGlzY3JpbWluYXRlZFVuaW9uKFxuICBcInR5cGVcIixcbiAgW1xuICAgIHo0Lm9iamVjdCh7XG4gICAgICB0eXBlOiB6NC5saXRlcmFsKFwidGV4dFwiKSxcbiAgICAgIHZhbHVlOiB6NC5zdHJpbmcoKSxcbiAgICAgIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgfSksXG4gICAgejQub2JqZWN0KHtcbiAgICAgIHR5cGU6IHo0LmxpdGVyYWwoXCJqc29uXCIpLFxuICAgICAgdmFsdWU6IGpzb25WYWx1ZVNjaGVtYSxcbiAgICAgIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgfSksXG4gICAgejQub2JqZWN0KHtcbiAgICAgIHR5cGU6IHo0LmxpdGVyYWwoXCJleGVjdXRpb24tZGVuaWVkXCIpLFxuICAgICAgcmVhc29uOiB6NC5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgICAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICB9KSxcbiAgICB6NC5vYmplY3Qoe1xuICAgICAgdHlwZTogejQubGl0ZXJhbChcImVycm9yLXRleHRcIiksXG4gICAgICB2YWx1ZTogejQuc3RyaW5nKCksXG4gICAgICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgIH0pLFxuICAgIHo0Lm9iamVjdCh7XG4gICAgICB0eXBlOiB6NC5saXRlcmFsKFwiZXJyb3ItanNvblwiKSxcbiAgICAgIHZhbHVlOiBqc29uVmFsdWVTY2hlbWEsXG4gICAgICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgIH0pLFxuICAgIHo0Lm9iamVjdCh7XG4gICAgICB0eXBlOiB6NC5saXRlcmFsKFwiY29udGVudFwiKSxcbiAgICAgIHZhbHVlOiB6NC5hcnJheShcbiAgICAgICAgejQudW5pb24oW1xuICAgICAgICAgIHo0Lm9iamVjdCh7XG4gICAgICAgICAgICB0eXBlOiB6NC5saXRlcmFsKFwidGV4dFwiKSxcbiAgICAgICAgICAgIHRleHQ6IHo0LnN0cmluZygpLFxuICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB6NC5vYmplY3Qoe1xuICAgICAgICAgICAgdHlwZTogejQubGl0ZXJhbChcIm1lZGlhXCIpLFxuICAgICAgICAgICAgZGF0YTogejQuc3RyaW5nKCksXG4gICAgICAgICAgICBtZWRpYVR5cGU6IHo0LnN0cmluZygpXG4gICAgICAgICAgfSksXG4gICAgICAgICAgejQub2JqZWN0KHtcbiAgICAgICAgICAgIHR5cGU6IHo0LmxpdGVyYWwoXCJmaWxlLWRhdGFcIiksXG4gICAgICAgICAgICBkYXRhOiB6NC5zdHJpbmcoKSxcbiAgICAgICAgICAgIG1lZGlhVHlwZTogejQuc3RyaW5nKCksXG4gICAgICAgICAgICBmaWxlbmFtZTogejQuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgICAgICAgfSksXG4gICAgICAgICAgejQub2JqZWN0KHtcbiAgICAgICAgICAgIHR5cGU6IHo0LmxpdGVyYWwoXCJmaWxlLXVybFwiKSxcbiAgICAgICAgICAgIHVybDogejQuc3RyaW5nKCksXG4gICAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHo0Lm9iamVjdCh7XG4gICAgICAgICAgICB0eXBlOiB6NC5saXRlcmFsKFwiZmlsZS1pZFwiKSxcbiAgICAgICAgICAgIGZpbGVJZDogejQudW5pb24oW3o0LnN0cmluZygpLCB6NC5yZWNvcmQoejQuc3RyaW5nKCksIHo0LnN0cmluZygpKV0pLFxuICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB6NC5vYmplY3Qoe1xuICAgICAgICAgICAgdHlwZTogejQubGl0ZXJhbChcImltYWdlLWRhdGFcIiksXG4gICAgICAgICAgICBkYXRhOiB6NC5zdHJpbmcoKSxcbiAgICAgICAgICAgIG1lZGlhVHlwZTogejQuc3RyaW5nKCksXG4gICAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHo0Lm9iamVjdCh7XG4gICAgICAgICAgICB0eXBlOiB6NC5saXRlcmFsKFwiaW1hZ2UtdXJsXCIpLFxuICAgICAgICAgICAgdXJsOiB6NC5zdHJpbmcoKSxcbiAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgICAgICAgfSksXG4gICAgICAgICAgejQub2JqZWN0KHtcbiAgICAgICAgICAgIHR5cGU6IHo0LmxpdGVyYWwoXCJpbWFnZS1maWxlLWlkXCIpLFxuICAgICAgICAgICAgZmlsZUlkOiB6NC51bmlvbihbejQuc3RyaW5nKCksIHo0LnJlY29yZCh6NC5zdHJpbmcoKSwgejQuc3RyaW5nKCkpXSksXG4gICAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHo0Lm9iamVjdCh7XG4gICAgICAgICAgICB0eXBlOiB6NC5saXRlcmFsKFwiY3VzdG9tXCIpLFxuICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgICAgICB9KVxuICAgICAgICBdKVxuICAgICAgKVxuICAgIH0pXG4gIF1cbik7XG52YXIgdG9vbFJlc3VsdFBhcnRTY2hlbWEgPSB6NC5vYmplY3Qoe1xuICB0eXBlOiB6NC5saXRlcmFsKFwidG9vbC1yZXN1bHRcIiksXG4gIHRvb2xDYWxsSWQ6IHo0LnN0cmluZygpLFxuICB0b29sTmFtZTogejQuc3RyaW5nKCksXG4gIG91dHB1dDogb3V0cHV0U2NoZW1hLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgdG9vbEFwcHJvdmFsUmVxdWVzdFNjaGVtYSA9IHo0Lm9iamVjdCh7XG4gIHR5cGU6IHo0LmxpdGVyYWwoXCJ0b29sLWFwcHJvdmFsLXJlcXVlc3RcIiksXG4gIGFwcHJvdmFsSWQ6IHo0LnN0cmluZygpLFxuICB0b29sQ2FsbElkOiB6NC5zdHJpbmcoKVxufSk7XG52YXIgdG9vbEFwcHJvdmFsUmVzcG9uc2VTY2hlbWEgPSB6NC5vYmplY3Qoe1xuICB0eXBlOiB6NC5saXRlcmFsKFwidG9vbC1hcHByb3ZhbC1yZXNwb25zZVwiKSxcbiAgYXBwcm92YWxJZDogejQuc3RyaW5nKCksXG4gIGFwcHJvdmVkOiB6NC5ib29sZWFuKCksXG4gIHJlYXNvbjogejQuc3RyaW5nKCkub3B0aW9uYWwoKVxufSk7XG5cbi8vIHNyYy9wcm9tcHQvbWVzc2FnZS50c1xudmFyIHN5c3RlbU1vZGVsTWVzc2FnZVNjaGVtYSA9IHo1Lm9iamVjdChcbiAge1xuICAgIHJvbGU6IHo1LmxpdGVyYWwoXCJzeXN0ZW1cIiksXG4gICAgY29udGVudDogejUuc3RyaW5nKCksXG4gICAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgfVxuKTtcbnZhciB1c2VyTW9kZWxNZXNzYWdlU2NoZW1hID0gejUub2JqZWN0KHtcbiAgcm9sZTogejUubGl0ZXJhbChcInVzZXJcIiksXG4gIGNvbnRlbnQ6IHo1LnVuaW9uKFtcbiAgICB6NS5zdHJpbmcoKSxcbiAgICB6NS5hcnJheSh6NS51bmlvbihbdGV4dFBhcnRTY2hlbWEsIGltYWdlUGFydFNjaGVtYSwgZmlsZVBhcnRTY2hlbWFdKSlcbiAgXSksXG4gIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciBhc3Npc3RhbnRNb2RlbE1lc3NhZ2VTY2hlbWEgPSB6NS5vYmplY3Qoe1xuICByb2xlOiB6NS5saXRlcmFsKFwiYXNzaXN0YW50XCIpLFxuICBjb250ZW50OiB6NS51bmlvbihbXG4gICAgejUuc3RyaW5nKCksXG4gICAgejUuYXJyYXkoXG4gICAgICB6NS51bmlvbihbXG4gICAgICAgIHRleHRQYXJ0U2NoZW1hLFxuICAgICAgICBmaWxlUGFydFNjaGVtYSxcbiAgICAgICAgcmVhc29uaW5nUGFydFNjaGVtYSxcbiAgICAgICAgdG9vbENhbGxQYXJ0U2NoZW1hLFxuICAgICAgICB0b29sUmVzdWx0UGFydFNjaGVtYSxcbiAgICAgICAgdG9vbEFwcHJvdmFsUmVxdWVzdFNjaGVtYVxuICAgICAgXSlcbiAgICApXG4gIF0pLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgdG9vbE1vZGVsTWVzc2FnZVNjaGVtYSA9IHo1Lm9iamVjdCh7XG4gIHJvbGU6IHo1LmxpdGVyYWwoXCJ0b29sXCIpLFxuICBjb250ZW50OiB6NS5hcnJheSh6NS51bmlvbihbdG9vbFJlc3VsdFBhcnRTY2hlbWEsIHRvb2xBcHByb3ZhbFJlc3BvbnNlU2NoZW1hXSkpLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgbW9kZWxNZXNzYWdlU2NoZW1hID0gejUudW5pb24oW1xuICBzeXN0ZW1Nb2RlbE1lc3NhZ2VTY2hlbWEsXG4gIHVzZXJNb2RlbE1lc3NhZ2VTY2hlbWEsXG4gIGFzc2lzdGFudE1vZGVsTWVzc2FnZVNjaGVtYSxcbiAgdG9vbE1vZGVsTWVzc2FnZVNjaGVtYVxuXSk7XG5cbi8vIHNyYy9wcm9tcHQvc3RhbmRhcmRpemUtcHJvbXB0LnRzXG5hc3luYyBmdW5jdGlvbiBzdGFuZGFyZGl6ZVByb21wdChwcm9tcHQpIHtcbiAgaWYgKHByb21wdC5wcm9tcHQgPT0gbnVsbCAmJiBwcm9tcHQubWVzc2FnZXMgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3IyKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwicHJvbXB0IG9yIG1lc3NhZ2VzIG11c3QgYmUgZGVmaW5lZFwiXG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb21wdC5wcm9tcHQgIT0gbnVsbCAmJiBwcm9tcHQubWVzc2FnZXMgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3IyKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwicHJvbXB0IGFuZCBtZXNzYWdlcyBjYW5ub3QgYmUgZGVmaW5lZCBhdCB0aGUgc2FtZSB0aW1lXCJcbiAgICB9KTtcbiAgfVxuICBpZiAocHJvbXB0LnN5c3RlbSAhPSBudWxsICYmIHR5cGVvZiBwcm9tcHQuc3lzdGVtICE9PSBcInN0cmluZ1wiICYmICFhc0FycmF5KHByb21wdC5zeXN0ZW0pLmV2ZXJ5KFxuICAgIChtZXNzYWdlKSA9PiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJvYmplY3RcIiAmJiBtZXNzYWdlICE9PSBudWxsICYmIFwicm9sZVwiIGluIG1lc3NhZ2UgJiYgbWVzc2FnZS5yb2xlID09PSBcInN5c3RlbVwiXG4gICkpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yMih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiBcInN5c3RlbSBtdXN0IGJlIGEgc3RyaW5nLCBTeXN0ZW1Nb2RlbE1lc3NhZ2UsIG9yIGFycmF5IG9mIFN5c3RlbU1vZGVsTWVzc2FnZVwiXG4gICAgfSk7XG4gIH1cbiAgbGV0IG1lc3NhZ2VzO1xuICBpZiAocHJvbXB0LnByb21wdCAhPSBudWxsICYmIHR5cGVvZiBwcm9tcHQucHJvbXB0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgbWVzc2FnZXMgPSBbeyByb2xlOiBcInVzZXJcIiwgY29udGVudDogcHJvbXB0LnByb21wdCB9XTtcbiAgfSBlbHNlIGlmIChwcm9tcHQucHJvbXB0ICE9IG51bGwgJiYgQXJyYXkuaXNBcnJheShwcm9tcHQucHJvbXB0KSkge1xuICAgIG1lc3NhZ2VzID0gcHJvbXB0LnByb21wdDtcbiAgfSBlbHNlIGlmIChwcm9tcHQubWVzc2FnZXMgIT0gbnVsbCkge1xuICAgIG1lc3NhZ2VzID0gcHJvbXB0Lm1lc3NhZ2VzO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3IyKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwicHJvbXB0IG9yIG1lc3NhZ2VzIG11c3QgYmUgZGVmaW5lZFwiXG4gICAgfSk7XG4gIH1cbiAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3IyKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwibWVzc2FnZXMgbXVzdCBub3QgYmUgZW1wdHlcIlxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSBhd2FpdCBzYWZlVmFsaWRhdGVUeXBlcyh7XG4gICAgdmFsdWU6IG1lc3NhZ2VzLFxuICAgIHNjaGVtYTogejYuYXJyYXkobW9kZWxNZXNzYWdlU2NoZW1hKVxuICB9KTtcbiAgaWYgKCF2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yMih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiBcIlRoZSBtZXNzYWdlcyBkbyBub3QgbWF0Y2ggdGhlIE1vZGVsTWVzc2FnZVtdIHNjaGVtYS5cIixcbiAgICAgIGNhdXNlOiB2YWxpZGF0aW9uUmVzdWx0LmVycm9yXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlcyxcbiAgICBzeXN0ZW06IHByb21wdC5zeXN0ZW1cbiAgfTtcbn1cblxuLy8gc3JjL3Byb21wdC93cmFwLWdhdGV3YXktZXJyb3IudHNcbmltcG9ydCB7IEdhdGV3YXlBdXRoZW50aWNhdGlvbkVycm9yIH0gZnJvbSBcIkBhaS1zZGsvZ2F0ZXdheVwiO1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMjMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuZnVuY3Rpb24gd3JhcEdhdGV3YXlFcnJvcihlcnJvcikge1xuICBpZiAoIUdhdGV3YXlBdXRoZW50aWNhdGlvbkVycm9yLmlzSW5zdGFuY2UoZXJyb3IpKVxuICAgIHJldHVybiBlcnJvcjtcbiAgY29uc3QgaXNQcm9kdWN0aW9uRW52ID0gKHByb2Nlc3MgPT0gbnVsbCA/IHZvaWQgMCA6IHByb2Nlc3MuZW52Lk5PREVfRU5WKSA9PT0gXCJwcm9kdWN0aW9uXCI7XG4gIGNvbnN0IG1vcmVJbmZvVVJMID0gXCJodHRwczovL2FpLXNkay5kZXYvdW5hdXRoZW50aWNhdGVkLWFpLWdhdGV3YXlcIjtcbiAgaWYgKGlzUHJvZHVjdGlvbkVudikge1xuICAgIHJldHVybiBuZXcgQUlTREtFcnJvcjIzKHtcbiAgICAgIG5hbWU6IFwiR2F0ZXdheUVycm9yXCIsXG4gICAgICBtZXNzYWdlOiBgVW5hdXRoZW50aWNhdGVkLiBDb25maWd1cmUgQUlfR0FURVdBWV9BUElfS0VZIG9yIHVzZSBhIHByb3ZpZGVyIG1vZHVsZS4gTGVhcm4gbW9yZTogJHttb3JlSW5mb1VSTH1gXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgbmV3IEVycm9yKGBcXHgxQlsxbVxceDFCWzMxbVVuYXV0aGVudGljYXRlZCByZXF1ZXN0IHRvIEFJIEdhdGV3YXkuXFx4MUJbMG1cblxuVG8gYXV0aGVudGljYXRlLCBzZXQgdGhlIFxceDFCWzMzbUFJX0dBVEVXQVlfQVBJX0tFWVxceDFCWzBtIGVudmlyb25tZW50IHZhcmlhYmxlIHdpdGggeW91ciBBUEkga2V5LlxuXG5BbHRlcm5hdGl2ZWx5LCB5b3UgY2FuIHVzZSBhIHByb3ZpZGVyIG1vZHVsZSBpbnN0ZWFkIG9mIHRoZSBBSSBHYXRld2F5LlxuXG5MZWFybiBtb3JlOiBcXHgxQlszNG0ke21vcmVJbmZvVVJMfVxceDFCWzBtXG5cbmApLFxuICAgIHsgbmFtZTogXCJHYXRld2F5QXV0aGVudGljYXRpb25FcnJvclwiIH1cbiAgKTtcbn1cblxuLy8gc3JjL3RlbGVtZXRyeS9hc3NlbWJsZS1vcGVyYXRpb24tbmFtZS50c1xuZnVuY3Rpb24gYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgb3BlcmF0aW9uSWQsXG4gIHRlbGVtZXRyeVxufSkge1xuICByZXR1cm4ge1xuICAgIC8vIHN0YW5kYXJkaXplZCBvcGVyYXRpb24gYW5kIHJlc291cmNlIG5hbWU6XG4gICAgXCJvcGVyYXRpb24ubmFtZVwiOiBgJHtvcGVyYXRpb25JZH0keyh0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5mdW5jdGlvbklkKSAhPSBudWxsID8gYCAke3RlbGVtZXRyeS5mdW5jdGlvbklkfWAgOiBcIlwifWAsXG4gICAgXCJyZXNvdXJjZS5uYW1lXCI6IHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LmZ1bmN0aW9uSWQsXG4gICAgLy8gZGV0YWlsZWQsIEFJIFNESyBzcGVjaWZpYyBkYXRhOlxuICAgIFwiYWkub3BlcmF0aW9uSWRcIjogb3BlcmF0aW9uSWQsXG4gICAgXCJhaS50ZWxlbWV0cnkuZnVuY3Rpb25JZFwiOiB0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5mdW5jdGlvbklkXG4gIH07XG59XG5cbi8vIHNyYy90ZWxlbWV0cnkvZ2V0LWJhc2UtdGVsZW1ldHJ5LWF0dHJpYnV0ZXMudHNcbmZ1bmN0aW9uIGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgbW9kZWwsXG4gIHNldHRpbmdzLFxuICB0ZWxlbWV0cnksXG4gIGhlYWRlcnNcbn0pIHtcbiAgdmFyIF9hMjE7XG4gIHJldHVybiB7XG4gICAgXCJhaS5tb2RlbC5wcm92aWRlclwiOiBtb2RlbC5wcm92aWRlcixcbiAgICBcImFpLm1vZGVsLmlkXCI6IG1vZGVsLm1vZGVsSWQsXG4gICAgLy8gc2V0dGluZ3M6XG4gICAgLi4uT2JqZWN0LmVudHJpZXMoc2V0dGluZ3MpLnJlZHVjZSgoYXR0cmlidXRlcywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAoa2V5ID09PSBcInRpbWVvdXRcIikge1xuICAgICAgICBjb25zdCB0b3RhbFRpbWVvdXRNcyA9IGdldFRvdGFsVGltZW91dE1zKFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgICk7XG4gICAgICAgIGlmICh0b3RhbFRpbWVvdXRNcyAhPSBudWxsKSB7XG4gICAgICAgICAgYXR0cmlidXRlc1tgYWkuc2V0dGluZ3MuJHtrZXl9YF0gPSB0b3RhbFRpbWVvdXRNcztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cmlidXRlc1tgYWkuc2V0dGluZ3MuJHtrZXl9YF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgIH0sIHt9KSxcbiAgICAvLyBhZGQgbWV0YWRhdGEgYXMgYXR0cmlidXRlczpcbiAgICAuLi5PYmplY3QuZW50cmllcygoX2EyMSA9IHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5Lm1ldGFkYXRhKSAhPSBudWxsID8gX2EyMSA6IHt9KS5yZWR1Y2UoXG4gICAgICAoYXR0cmlidXRlcywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGF0dHJpYnV0ZXNbYGFpLnRlbGVtZXRyeS5tZXRhZGF0YS4ke2tleX1gXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICAgIH0sXG4gICAgICB7fVxuICAgICksXG4gICAgLy8gcmVxdWVzdCBoZWFkZXJzXG4gICAgLi4uT2JqZWN0LmVudHJpZXMoaGVhZGVycyAhPSBudWxsID8gaGVhZGVycyA6IHt9KS5yZWR1Y2UoKGF0dHJpYnV0ZXMsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgYXR0cmlidXRlc1tgYWkucmVxdWVzdC5oZWFkZXJzLiR7a2V5fWBdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICB9LCB7fSlcbiAgfTtcbn1cblxuLy8gc3JjL3RlbGVtZXRyeS9nZXQtdHJhY2VyLnRzXG5pbXBvcnQgeyB0cmFjZSB9IGZyb20gXCJAb3BlbnRlbGVtZXRyeS9hcGlcIjtcblxuLy8gc3JjL3RlbGVtZXRyeS9ub29wLXRyYWNlci50c1xudmFyIG5vb3BUcmFjZXIgPSB7XG4gIHN0YXJ0U3BhbigpIHtcbiAgICByZXR1cm4gbm9vcFNwYW47XG4gIH0sXG4gIHN0YXJ0QWN0aXZlU3BhbihuYW1lMjEsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBpZiAodHlwZW9mIGFyZzEgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGFyZzEobm9vcFNwYW4pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZzIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGFyZzIobm9vcFNwYW4pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZzMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGFyZzMobm9vcFNwYW4pO1xuICAgIH1cbiAgfVxufTtcbnZhciBub29wU3BhbiA9IHtcbiAgc3BhbkNvbnRleHQoKSB7XG4gICAgcmV0dXJuIG5vb3BTcGFuQ29udGV4dDtcbiAgfSxcbiAgc2V0QXR0cmlidXRlKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzZXRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhZGRFdmVudCgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkTGluaygpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkTGlua3MoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHNldFN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgdXBkYXRlTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZW5kKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBpc1JlY29yZGluZygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIHJlY29yZEV4Y2VwdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbnZhciBub29wU3BhbkNvbnRleHQgPSB7XG4gIHRyYWNlSWQ6IFwiXCIsXG4gIHNwYW5JZDogXCJcIixcbiAgdHJhY2VGbGFnczogMFxufTtcblxuLy8gc3JjL3RlbGVtZXRyeS9nZXQtdHJhY2VyLnRzXG5mdW5jdGlvbiBnZXRUcmFjZXIoe1xuICBpc0VuYWJsZWQgPSBmYWxzZSxcbiAgdHJhY2VyXG59ID0ge30pIHtcbiAgaWYgKCFpc0VuYWJsZWQpIHtcbiAgICByZXR1cm4gbm9vcFRyYWNlcjtcbiAgfVxuICBpZiAodHJhY2VyKSB7XG4gICAgcmV0dXJuIHRyYWNlcjtcbiAgfVxuICByZXR1cm4gdHJhY2UuZ2V0VHJhY2VyKFwiYWlcIik7XG59XG5cbi8vIHNyYy90ZWxlbWV0cnkvcmVjb3JkLXNwYW4udHNcbmltcG9ydCB7XG4gIFNwYW5TdGF0dXNDb2RlLFxuICBjb250ZXh0XG59IGZyb20gXCJAb3BlbnRlbGVtZXRyeS9hcGlcIjtcbmFzeW5jIGZ1bmN0aW9uIHJlY29yZFNwYW4oe1xuICBuYW1lOiBuYW1lMjEsXG4gIHRyYWNlcixcbiAgYXR0cmlidXRlcyxcbiAgZm4sXG4gIGVuZFdoZW5Eb25lID0gdHJ1ZVxufSkge1xuICByZXR1cm4gdHJhY2VyLnN0YXJ0QWN0aXZlU3BhbihcbiAgICBuYW1lMjEsXG4gICAgeyBhdHRyaWJ1dGVzOiBhd2FpdCBhdHRyaWJ1dGVzIH0sXG4gICAgYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgIGNvbnN0IGN0eCA9IGNvbnRleHQuYWN0aXZlKCk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb250ZXh0LndpdGgoY3R4LCAoKSA9PiBmbihzcGFuKSk7XG4gICAgICAgIGlmIChlbmRXaGVuRG9uZSkge1xuICAgICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVjb3JkRXJyb3JPblNwYW4oc3BhbiwgZXJyb3IpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gcmVjb3JkRXJyb3JPblNwYW4oc3BhbiwgZXJyb3IpIHtcbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICBzcGFuLnJlY29yZEV4Y2VwdGlvbih7XG4gICAgICBuYW1lOiBlcnJvci5uYW1lLFxuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgIHN0YWNrOiBlcnJvci5zdGFja1xuICAgIH0pO1xuICAgIHNwYW4uc2V0U3RhdHVzKHtcbiAgICAgIGNvZGU6IFNwYW5TdGF0dXNDb2RlLkVSUk9SLFxuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHNwYW4uc2V0U3RhdHVzKHsgY29kZTogU3BhblN0YXR1c0NvZGUuRVJST1IgfSk7XG4gIH1cbn1cblxuLy8gc3JjL3RlbGVtZXRyeS9zZWxlY3QtdGVsZW1ldHJ5LWF0dHJpYnV0ZXMudHNcbmFzeW5jIGZ1bmN0aW9uIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICB0ZWxlbWV0cnksXG4gIGF0dHJpYnV0ZXNcbn0pIHtcbiAgaWYgKCh0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5pc0VuYWJsZWQpICE9PSB0cnVlKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGNvbnN0IHJlc3VsdEF0dHJpYnV0ZXMgPSB7fTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgXCJpbnB1dFwiIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5pbnB1dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBpZiAoKHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LnJlY29yZElucHV0cykgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsdWUuaW5wdXQoKTtcbiAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICByZXN1bHRBdHRyaWJ1dGVzW2tleV0gPSByZXN1bHQ7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBcIm91dHB1dFwiIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5vdXRwdXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgaWYgKCh0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5yZWNvcmRPdXRwdXRzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWx1ZS5vdXRwdXQoKTtcbiAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICByZXN1bHRBdHRyaWJ1dGVzW2tleV0gPSByZXN1bHQ7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmVzdWx0QXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdEF0dHJpYnV0ZXM7XG59XG5cbi8vIHNyYy90ZWxlbWV0cnkvc3RyaW5naWZ5LWZvci10ZWxlbWV0cnkudHNcbmZ1bmN0aW9uIHN0cmluZ2lmeUZvclRlbGVtZXRyeShwcm9tcHQpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFxuICAgIHByb21wdC5tYXAoKG1lc3NhZ2UpID0+ICh7XG4gICAgICAuLi5tZXNzYWdlLFxuICAgICAgY29udGVudDogdHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gXCJzdHJpbmdcIiA/IG1lc3NhZ2UuY29udGVudCA6IG1lc3NhZ2UuY29udGVudC5tYXAoXG4gICAgICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwiZmlsZVwiID8ge1xuICAgICAgICAgIC4uLnBhcnQsXG4gICAgICAgICAgZGF0YTogcGFydC5kYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSA/IGNvbnZlcnREYXRhQ29udGVudFRvQmFzZTY0U3RyaW5nKHBhcnQuZGF0YSkgOiBwYXJ0LmRhdGFcbiAgICAgICAgfSA6IHBhcnRcbiAgICAgIClcbiAgICB9KSlcbiAgKTtcbn1cblxuLy8gc3JjL3R5cGVzL3VzYWdlLnRzXG5mdW5jdGlvbiBhc0xhbmd1YWdlTW9kZWxVc2FnZSh1c2FnZSkge1xuICByZXR1cm4ge1xuICAgIGlucHV0VG9rZW5zOiB1c2FnZS5pbnB1dFRva2Vucy50b3RhbCxcbiAgICBpbnB1dFRva2VuRGV0YWlsczoge1xuICAgICAgbm9DYWNoZVRva2VuczogdXNhZ2UuaW5wdXRUb2tlbnMubm9DYWNoZSxcbiAgICAgIGNhY2hlUmVhZFRva2VuczogdXNhZ2UuaW5wdXRUb2tlbnMuY2FjaGVSZWFkLFxuICAgICAgY2FjaGVXcml0ZVRva2VuczogdXNhZ2UuaW5wdXRUb2tlbnMuY2FjaGVXcml0ZVxuICAgIH0sXG4gICAgb3V0cHV0VG9rZW5zOiB1c2FnZS5vdXRwdXRUb2tlbnMudG90YWwsXG4gICAgb3V0cHV0VG9rZW5EZXRhaWxzOiB7XG4gICAgICB0ZXh0VG9rZW5zOiB1c2FnZS5vdXRwdXRUb2tlbnMudGV4dCxcbiAgICAgIHJlYXNvbmluZ1Rva2VuczogdXNhZ2Uub3V0cHV0VG9rZW5zLnJlYXNvbmluZ1xuICAgIH0sXG4gICAgdG90YWxUb2tlbnM6IGFkZFRva2VuQ291bnRzKFxuICAgICAgdXNhZ2UuaW5wdXRUb2tlbnMudG90YWwsXG4gICAgICB1c2FnZS5vdXRwdXRUb2tlbnMudG90YWxcbiAgICApLFxuICAgIHJhdzogdXNhZ2UucmF3LFxuICAgIHJlYXNvbmluZ1Rva2VuczogdXNhZ2Uub3V0cHV0VG9rZW5zLnJlYXNvbmluZyxcbiAgICBjYWNoZWRJbnB1dFRva2VuczogdXNhZ2UuaW5wdXRUb2tlbnMuY2FjaGVSZWFkXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVOdWxsTGFuZ3VhZ2VNb2RlbFVzYWdlKCkge1xuICByZXR1cm4ge1xuICAgIGlucHV0VG9rZW5zOiB2b2lkIDAsXG4gICAgaW5wdXRUb2tlbkRldGFpbHM6IHtcbiAgICAgIG5vQ2FjaGVUb2tlbnM6IHZvaWQgMCxcbiAgICAgIGNhY2hlUmVhZFRva2Vuczogdm9pZCAwLFxuICAgICAgY2FjaGVXcml0ZVRva2Vuczogdm9pZCAwXG4gICAgfSxcbiAgICBvdXRwdXRUb2tlbnM6IHZvaWQgMCxcbiAgICBvdXRwdXRUb2tlbkRldGFpbHM6IHtcbiAgICAgIHRleHRUb2tlbnM6IHZvaWQgMCxcbiAgICAgIHJlYXNvbmluZ1Rva2Vuczogdm9pZCAwXG4gICAgfSxcbiAgICB0b3RhbFRva2Vuczogdm9pZCAwLFxuICAgIHJhdzogdm9pZCAwXG4gIH07XG59XG5mdW5jdGlvbiBhZGRMYW5ndWFnZU1vZGVsVXNhZ2UodXNhZ2UxLCB1c2FnZTIpIHtcbiAgdmFyIF9hMjEsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaSwgX2o7XG4gIHJldHVybiB7XG4gICAgaW5wdXRUb2tlbnM6IGFkZFRva2VuQ291bnRzKHVzYWdlMS5pbnB1dFRva2VucywgdXNhZ2UyLmlucHV0VG9rZW5zKSxcbiAgICBpbnB1dFRva2VuRGV0YWlsczoge1xuICAgICAgbm9DYWNoZVRva2VuczogYWRkVG9rZW5Db3VudHMoXG4gICAgICAgIChfYTIxID0gdXNhZ2UxLmlucHV0VG9rZW5EZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2EyMS5ub0NhY2hlVG9rZW5zLFxuICAgICAgICAoX2IgPSB1c2FnZTIuaW5wdXRUb2tlbkRldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5ub0NhY2hlVG9rZW5zXG4gICAgICApLFxuICAgICAgY2FjaGVSZWFkVG9rZW5zOiBhZGRUb2tlbkNvdW50cyhcbiAgICAgICAgKF9jID0gdXNhZ2UxLmlucHV0VG9rZW5EZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2MuY2FjaGVSZWFkVG9rZW5zLFxuICAgICAgICAoX2QgPSB1c2FnZTIuaW5wdXRUb2tlbkRldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBfZC5jYWNoZVJlYWRUb2tlbnNcbiAgICAgICksXG4gICAgICBjYWNoZVdyaXRlVG9rZW5zOiBhZGRUb2tlbkNvdW50cyhcbiAgICAgICAgKF9lID0gdXNhZ2UxLmlucHV0VG9rZW5EZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2UuY2FjaGVXcml0ZVRva2VucyxcbiAgICAgICAgKF9mID0gdXNhZ2UyLmlucHV0VG9rZW5EZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2YuY2FjaGVXcml0ZVRva2Vuc1xuICAgICAgKVxuICAgIH0sXG4gICAgb3V0cHV0VG9rZW5zOiBhZGRUb2tlbkNvdW50cyh1c2FnZTEub3V0cHV0VG9rZW5zLCB1c2FnZTIub3V0cHV0VG9rZW5zKSxcbiAgICBvdXRwdXRUb2tlbkRldGFpbHM6IHtcbiAgICAgIHRleHRUb2tlbnM6IGFkZFRva2VuQ291bnRzKFxuICAgICAgICAoX2cgPSB1c2FnZTEub3V0cHV0VG9rZW5EZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2cudGV4dFRva2VucyxcbiAgICAgICAgKF9oID0gdXNhZ2UyLm91dHB1dFRva2VuRGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9oLnRleHRUb2tlbnNcbiAgICAgICksXG4gICAgICByZWFzb25pbmdUb2tlbnM6IGFkZFRva2VuQ291bnRzKFxuICAgICAgICAoX2kgPSB1c2FnZTEub3V0cHV0VG9rZW5EZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2kucmVhc29uaW5nVG9rZW5zLFxuICAgICAgICAoX2ogPSB1c2FnZTIub3V0cHV0VG9rZW5EZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2oucmVhc29uaW5nVG9rZW5zXG4gICAgICApXG4gICAgfSxcbiAgICB0b3RhbFRva2VuczogYWRkVG9rZW5Db3VudHModXNhZ2UxLnRvdGFsVG9rZW5zLCB1c2FnZTIudG90YWxUb2tlbnMpLFxuICAgIHJlYXNvbmluZ1Rva2VuczogYWRkVG9rZW5Db3VudHMoXG4gICAgICB1c2FnZTEucmVhc29uaW5nVG9rZW5zLFxuICAgICAgdXNhZ2UyLnJlYXNvbmluZ1Rva2Vuc1xuICAgICksXG4gICAgY2FjaGVkSW5wdXRUb2tlbnM6IGFkZFRva2VuQ291bnRzKFxuICAgICAgdXNhZ2UxLmNhY2hlZElucHV0VG9rZW5zLFxuICAgICAgdXNhZ2UyLmNhY2hlZElucHV0VG9rZW5zXG4gICAgKVxuICB9O1xufVxuZnVuY3Rpb24gYWRkVG9rZW5Db3VudHModG9rZW5Db3VudDEsIHRva2VuQ291bnQyKSB7XG4gIHJldHVybiB0b2tlbkNvdW50MSA9PSBudWxsICYmIHRva2VuQ291bnQyID09IG51bGwgPyB2b2lkIDAgOiAodG9rZW5Db3VudDEgIT0gbnVsbCA/IHRva2VuQ291bnQxIDogMCkgKyAodG9rZW5Db3VudDIgIT0gbnVsbCA/IHRva2VuQ291bnQyIDogMCk7XG59XG5mdW5jdGlvbiBhZGRJbWFnZU1vZGVsVXNhZ2UodXNhZ2UxLCB1c2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBpbnB1dFRva2VuczogYWRkVG9rZW5Db3VudHModXNhZ2UxLmlucHV0VG9rZW5zLCB1c2FnZTIuaW5wdXRUb2tlbnMpLFxuICAgIG91dHB1dFRva2VuczogYWRkVG9rZW5Db3VudHModXNhZ2UxLm91dHB1dFRva2VucywgdXNhZ2UyLm91dHB1dFRva2VucyksXG4gICAgdG90YWxUb2tlbnM6IGFkZFRva2VuQ291bnRzKHVzYWdlMS50b3RhbFRva2VucywgdXNhZ2UyLnRvdGFsVG9rZW5zKVxuICB9O1xufVxuXG4vLyBzcmMvdXRpbC9tZXJnZS1vYmplY3RzLnRzXG5mdW5jdGlvbiBtZXJnZU9iamVjdHMoYmFzZSwgb3ZlcnJpZGVzKSB7XG4gIGlmIChiYXNlID09PSB2b2lkIDAgJiYgb3ZlcnJpZGVzID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmIChiYXNlID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gb3ZlcnJpZGVzO1xuICB9XG4gIGlmIChvdmVycmlkZXMgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IHsgLi4uYmFzZSB9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBvdmVycmlkZXMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG92ZXJyaWRlcywga2V5KSkge1xuICAgICAgY29uc3Qgb3ZlcnJpZGVzVmFsdWUgPSBvdmVycmlkZXNba2V5XTtcbiAgICAgIGlmIChvdmVycmlkZXNWYWx1ZSA9PT0gdm9pZCAwKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGtleSBpbiBiYXNlID8gYmFzZVtrZXldIDogdm9pZCAwO1xuICAgICAgY29uc3QgaXNTb3VyY2VPYmplY3QgPSBvdmVycmlkZXNWYWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2Ygb3ZlcnJpZGVzVmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkob3ZlcnJpZGVzVmFsdWUpICYmICEob3ZlcnJpZGVzVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSAmJiAhKG92ZXJyaWRlc1ZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKTtcbiAgICAgIGNvbnN0IGlzVGFyZ2V0T2JqZWN0ID0gYmFzZVZhbHVlICE9PSBudWxsICYmIGJhc2VWYWx1ZSAhPT0gdm9pZCAwICYmIHR5cGVvZiBiYXNlVmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoYmFzZVZhbHVlKSAmJiAhKGJhc2VWYWx1ZSBpbnN0YW5jZW9mIERhdGUpICYmICEoYmFzZVZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKTtcbiAgICAgIGlmIChpc1NvdXJjZU9iamVjdCAmJiBpc1RhcmdldE9iamVjdCkge1xuICAgICAgICByZXN1bHRba2V5XSA9IG1lcmdlT2JqZWN0cyhcbiAgICAgICAgICBiYXNlVmFsdWUsXG4gICAgICAgICAgb3ZlcnJpZGVzVmFsdWVcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gb3ZlcnJpZGVzVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHNyYy91dGlsL3JldHJ5LXdpdGgtZXhwb25lbnRpYWwtYmFja29mZi50c1xuaW1wb3J0IHsgQVBJQ2FsbEVycm9yIGFzIEFQSUNhbGxFcnJvcjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHsgZGVsYXksIGdldEVycm9yTWVzc2FnZSBhcyBnZXRFcnJvck1lc3NhZ2U0LCBpc0Fib3J0RXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuZnVuY3Rpb24gZ2V0UmV0cnlEZWxheUluTXMoe1xuICBlcnJvcixcbiAgZXhwb25lbnRpYWxCYWNrb2ZmRGVsYXlcbn0pIHtcbiAgY29uc3QgaGVhZGVycyA9IGVycm9yLnJlc3BvbnNlSGVhZGVycztcbiAgaWYgKCFoZWFkZXJzKVxuICAgIHJldHVybiBleHBvbmVudGlhbEJhY2tvZmZEZWxheTtcbiAgbGV0IG1zO1xuICBjb25zdCByZXRyeUFmdGVyTXMgPSBoZWFkZXJzW1wicmV0cnktYWZ0ZXItbXNcIl07XG4gIGlmIChyZXRyeUFmdGVyTXMpIHtcbiAgICBjb25zdCB0aW1lb3V0TXMgPSBwYXJzZUZsb2F0KHJldHJ5QWZ0ZXJNcyk7XG4gICAgaWYgKCFOdW1iZXIuaXNOYU4odGltZW91dE1zKSkge1xuICAgICAgbXMgPSB0aW1lb3V0TXM7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJldHJ5QWZ0ZXIgPSBoZWFkZXJzW1wicmV0cnktYWZ0ZXJcIl07XG4gIGlmIChyZXRyeUFmdGVyICYmIG1zID09PSB2b2lkIDApIHtcbiAgICBjb25zdCB0aW1lb3V0U2Vjb25kcyA9IHBhcnNlRmxvYXQocmV0cnlBZnRlcik7XG4gICAgaWYgKCFOdW1iZXIuaXNOYU4odGltZW91dFNlY29uZHMpKSB7XG4gICAgICBtcyA9IHRpbWVvdXRTZWNvbmRzICogMWUzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtcyA9IERhdGUucGFyc2UocmV0cnlBZnRlcikgLSBEYXRlLm5vdygpO1xuICAgIH1cbiAgfVxuICBpZiAobXMgIT0gbnVsbCAmJiAhTnVtYmVyLmlzTmFOKG1zKSAmJiAwIDw9IG1zICYmIChtcyA8IDYwICogMWUzIHx8IG1zIDwgZXhwb25lbnRpYWxCYWNrb2ZmRGVsYXkpKSB7XG4gICAgcmV0dXJuIG1zO1xuICB9XG4gIHJldHVybiBleHBvbmVudGlhbEJhY2tvZmZEZWxheTtcbn1cbnZhciByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmZSZXNwZWN0aW5nUmV0cnlIZWFkZXJzID0gKHtcbiAgbWF4UmV0cmllcyA9IDIsXG4gIGluaXRpYWxEZWxheUluTXMgPSAyZTMsXG4gIGJhY2tvZmZGYWN0b3IgPSAyLFxuICBhYm9ydFNpZ25hbFxufSA9IHt9KSA9PiBhc3luYyAoZikgPT4gX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZihmLCB7XG4gIG1heFJldHJpZXMsXG4gIGRlbGF5SW5NczogaW5pdGlhbERlbGF5SW5NcyxcbiAgYmFja29mZkZhY3RvcixcbiAgYWJvcnRTaWduYWxcbn0pO1xuYXN5bmMgZnVuY3Rpb24gX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZihmLCB7XG4gIG1heFJldHJpZXMsXG4gIGRlbGF5SW5NcyxcbiAgYmFja29mZkZhY3RvcixcbiAgYWJvcnRTaWduYWxcbn0sIGVycm9ycyA9IFtdKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGYoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoaXNBYm9ydEVycm9yKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmIChtYXhSZXRyaWVzID09PSAwKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZ2V0RXJyb3JNZXNzYWdlNChlcnJvcik7XG4gICAgY29uc3QgbmV3RXJyb3JzID0gWy4uLmVycm9ycywgZXJyb3JdO1xuICAgIGNvbnN0IHRyeU51bWJlciA9IG5ld0Vycm9ycy5sZW5ndGg7XG4gICAgaWYgKHRyeU51bWJlciA+IG1heFJldHJpZXMpIHtcbiAgICAgIHRocm93IG5ldyBSZXRyeUVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogYEZhaWxlZCBhZnRlciAke3RyeU51bWJlcn0gYXR0ZW1wdHMuIExhc3QgZXJyb3I6ICR7ZXJyb3JNZXNzYWdlfWAsXG4gICAgICAgIHJlYXNvbjogXCJtYXhSZXRyaWVzRXhjZWVkZWRcIixcbiAgICAgICAgZXJyb3JzOiBuZXdFcnJvcnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBBUElDYWxsRXJyb3IyLmlzSW5zdGFuY2UoZXJyb3IpICYmIGVycm9yLmlzUmV0cnlhYmxlID09PSB0cnVlICYmIHRyeU51bWJlciA8PSBtYXhSZXRyaWVzKSB7XG4gICAgICBhd2FpdCBkZWxheShcbiAgICAgICAgZ2V0UmV0cnlEZWxheUluTXMoe1xuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIGV4cG9uZW50aWFsQmFja29mZkRlbGF5OiBkZWxheUluTXNcbiAgICAgICAgfSksXG4gICAgICAgIHsgYWJvcnRTaWduYWwgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKFxuICAgICAgICBmLFxuICAgICAgICB7XG4gICAgICAgICAgbWF4UmV0cmllcyxcbiAgICAgICAgICBkZWxheUluTXM6IGJhY2tvZmZGYWN0b3IgKiBkZWxheUluTXMsXG4gICAgICAgICAgYmFja29mZkZhY3RvcixcbiAgICAgICAgICBhYm9ydFNpZ25hbFxuICAgICAgICB9LFxuICAgICAgICBuZXdFcnJvcnNcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0cnlOdW1iZXIgPT09IDEpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUmV0cnlFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgRmFpbGVkIGFmdGVyICR7dHJ5TnVtYmVyfSBhdHRlbXB0cyB3aXRoIG5vbi1yZXRyeWFibGUgZXJyb3I6ICcke2Vycm9yTWVzc2FnZX0nYCxcbiAgICAgIHJlYXNvbjogXCJlcnJvck5vdFJldHJ5YWJsZVwiLFxuICAgICAgZXJyb3JzOiBuZXdFcnJvcnNcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbC9wcmVwYXJlLXJldHJpZXMudHNcbmZ1bmN0aW9uIHByZXBhcmVSZXRyaWVzKHtcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWxcbn0pIHtcbiAgaWYgKG1heFJldHJpZXMgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhSZXRyaWVzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heFJldHJpZXNcIixcbiAgICAgICAgdmFsdWU6IG1heFJldHJpZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4UmV0cmllcyBtdXN0IGJlIGFuIGludGVnZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChtYXhSZXRyaWVzIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heFJldHJpZXNcIixcbiAgICAgICAgdmFsdWU6IG1heFJldHJpZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4UmV0cmllcyBtdXN0IGJlID49IDBcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG1heFJldHJpZXNSZXN1bHQgPSBtYXhSZXRyaWVzICE9IG51bGwgPyBtYXhSZXRyaWVzIDogMjtcbiAgcmV0dXJuIHtcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzUmVzdWx0LFxuICAgIHJldHJ5OiByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmZSZXNwZWN0aW5nUmV0cnlIZWFkZXJzKHtcbiAgICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNSZXN1bHQsXG4gICAgICBhYm9ydFNpZ25hbFxuICAgIH0pXG4gIH07XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L2NvbGxlY3QtdG9vbC1hcHByb3ZhbHMudHNcbmZ1bmN0aW9uIGNvbGxlY3RUb29sQXBwcm92YWxzKHtcbiAgbWVzc2FnZXNcbn0pIHtcbiAgY29uc3QgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlcy5hdCgtMSk7XG4gIGlmICgobGFzdE1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RNZXNzYWdlLnJvbGUpICE9IFwidG9vbFwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFwcHJvdmVkVG9vbEFwcHJvdmFsczogW10sXG4gICAgICBkZW5pZWRUb29sQXBwcm92YWxzOiBbXVxuICAgIH07XG4gIH1cbiAgY29uc3QgdG9vbENhbGxzQnlUb29sQ2FsbElkID0ge307XG4gIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcykge1xuICAgIGlmIChtZXNzYWdlLnJvbGUgPT09IFwiYXNzaXN0YW50XCIgJiYgdHlwZW9mIG1lc3NhZ2UuY29udGVudCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgY29udGVudCA9IG1lc3NhZ2UuY29udGVudDtcbiAgICAgIGZvciAoY29uc3QgcGFydCBvZiBjb250ZW50KSB7XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidG9vbC1jYWxsXCIpIHtcbiAgICAgICAgICB0b29sQ2FsbHNCeVRvb2xDYWxsSWRbcGFydC50b29sQ2FsbElkXSA9IHBhcnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgdG9vbEFwcHJvdmFsUmVxdWVzdHNCeUFwcHJvdmFsSWQgPSB7fTtcbiAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzKSB7XG4gICAgaWYgKG1lc3NhZ2Uucm9sZSA9PT0gXCJhc3Npc3RhbnRcIiAmJiB0eXBlb2YgbWVzc2FnZS5jb250ZW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gbWVzc2FnZS5jb250ZW50O1xuICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0b29sLWFwcHJvdmFsLXJlcXVlc3RcIikge1xuICAgICAgICAgIHRvb2xBcHByb3ZhbFJlcXVlc3RzQnlBcHByb3ZhbElkW3BhcnQuYXBwcm92YWxJZF0gPSBwYXJ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHRvb2xSZXN1bHRzID0ge307XG4gIGZvciAoY29uc3QgcGFydCBvZiBsYXN0TWVzc2FnZS5jb250ZW50KSB7XG4gICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0b29sLXJlc3VsdFwiKSB7XG4gICAgICB0b29sUmVzdWx0c1twYXJ0LnRvb2xDYWxsSWRdID0gcGFydDtcbiAgICB9XG4gIH1cbiAgY29uc3QgYXBwcm92ZWRUb29sQXBwcm92YWxzID0gW107XG4gIGNvbnN0IGRlbmllZFRvb2xBcHByb3ZhbHMgPSBbXTtcbiAgY29uc3QgYXBwcm92YWxSZXNwb25zZXMgPSBsYXN0TWVzc2FnZS5jb250ZW50LmZpbHRlcihcbiAgICAocGFydCkgPT4gcGFydC50eXBlID09PSBcInRvb2wtYXBwcm92YWwtcmVzcG9uc2VcIlxuICApO1xuICBmb3IgKGNvbnN0IGFwcHJvdmFsUmVzcG9uc2Ugb2YgYXBwcm92YWxSZXNwb25zZXMpIHtcbiAgICBjb25zdCBhcHByb3ZhbFJlcXVlc3QgPSB0b29sQXBwcm92YWxSZXF1ZXN0c0J5QXBwcm92YWxJZFthcHByb3ZhbFJlc3BvbnNlLmFwcHJvdmFsSWRdO1xuICAgIGlmIChhcHByb3ZhbFJlcXVlc3QgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUb29sQXBwcm92YWxFcnJvcih7XG4gICAgICAgIGFwcHJvdmFsSWQ6IGFwcHJvdmFsUmVzcG9uc2UuYXBwcm92YWxJZFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0b29sUmVzdWx0c1thcHByb3ZhbFJlcXVlc3QudG9vbENhbGxJZF0gIT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHRvb2xDYWxsID0gdG9vbENhbGxzQnlUb29sQ2FsbElkW2FwcHJvdmFsUmVxdWVzdC50b29sQ2FsbElkXTtcbiAgICBpZiAodG9vbENhbGwgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFRvb2xDYWxsTm90Rm91bmRGb3JBcHByb3ZhbEVycm9yKHtcbiAgICAgICAgdG9vbENhbGxJZDogYXBwcm92YWxSZXF1ZXN0LnRvb2xDYWxsSWQsXG4gICAgICAgIGFwcHJvdmFsSWQ6IGFwcHJvdmFsUmVxdWVzdC5hcHByb3ZhbElkXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgYXBwcm92YWwgPSB7XG4gICAgICBhcHByb3ZhbFJlcXVlc3QsXG4gICAgICBhcHByb3ZhbFJlc3BvbnNlLFxuICAgICAgdG9vbENhbGxcbiAgICB9O1xuICAgIGlmIChhcHByb3ZhbFJlc3BvbnNlLmFwcHJvdmVkKSB7XG4gICAgICBhcHByb3ZlZFRvb2xBcHByb3ZhbHMucHVzaChhcHByb3ZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbmllZFRvb2xBcHByb3ZhbHMucHVzaChhcHByb3ZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IGFwcHJvdmVkVG9vbEFwcHJvdmFscywgZGVuaWVkVG9vbEFwcHJvdmFscyB9O1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9leGVjdXRlLXRvb2wtY2FsbC50c1xuaW1wb3J0IHsgZXhlY3V0ZVRvb2wgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdXRpbC9ub3cudHNcbmZ1bmN0aW9uIG5vdygpIHtcbiAgdmFyIF9hMjEsIF9iO1xuICByZXR1cm4gKF9iID0gKF9hMjEgPSBnbG9iYWxUaGlzID09IG51bGwgPyB2b2lkIDAgOiBnbG9iYWxUaGlzLnBlcmZvcm1hbmNlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyMS5ub3coKSkgIT0gbnVsbCA/IF9iIDogRGF0ZS5ub3coKTtcbn1cblxuLy8gc3JjL2dlbmVyYXRlLXRleHQvZXhlY3V0ZS10b29sLWNhbGwudHNcbmFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVUb29sQ2FsbCh7XG4gIHRvb2xDYWxsLFxuICB0b29scyxcbiAgdHJhY2VyLFxuICB0ZWxlbWV0cnksXG4gIG1lc3NhZ2VzLFxuICBhYm9ydFNpZ25hbCxcbiAgZXhwZXJpbWVudGFsX2NvbnRleHQsXG4gIHN0ZXBOdW1iZXIsXG4gIG1vZGVsLFxuICBvblByZWxpbWluYXJ5VG9vbFJlc3VsdCxcbiAgb25Ub29sQ2FsbFN0YXJ0LFxuICBvblRvb2xDYWxsRmluaXNoXG59KSB7XG4gIGNvbnN0IHsgdG9vbE5hbWUsIHRvb2xDYWxsSWQsIGlucHV0IH0gPSB0b29sQ2FsbDtcbiAgY29uc3QgdG9vbDIgPSB0b29scyA9PSBudWxsID8gdm9pZCAwIDogdG9vbHNbdG9vbE5hbWVdO1xuICBpZiAoKHRvb2wyID09IG51bGwgPyB2b2lkIDAgOiB0b29sMi5leGVjdXRlKSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCBiYXNlQ2FsbGJhY2tFdmVudCA9IHtcbiAgICBzdGVwTnVtYmVyLFxuICAgIG1vZGVsLFxuICAgIHRvb2xDYWxsLFxuICAgIG1lc3NhZ2VzLFxuICAgIGFib3J0U2lnbmFsLFxuICAgIGZ1bmN0aW9uSWQ6IHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LmZ1bmN0aW9uSWQsXG4gICAgbWV0YWRhdGE6IHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5Lm1ldGFkYXRhLFxuICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0XG4gIH07XG4gIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICBuYW1lOiBcImFpLnRvb2xDYWxsXCIsXG4gICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkudG9vbENhbGxcIixcbiAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgfSksXG4gICAgICAgIFwiYWkudG9vbENhbGwubmFtZVwiOiB0b29sTmFtZSxcbiAgICAgICAgXCJhaS50b29sQ2FsbC5pZFwiOiB0b29sQ2FsbElkLFxuICAgICAgICBcImFpLnRvb2xDYWxsLmFyZ3NcIjoge1xuICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoaW5wdXQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICBsZXQgb3V0cHV0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgKG9uVG9vbENhbGxTdGFydCA9PSBudWxsID8gdm9pZCAwIDogb25Ub29sQ2FsbFN0YXJ0KGJhc2VDYWxsYmFja0V2ZW50KSk7XG4gICAgICB9IGNhdGNoIChfaWdub3JlZCkge1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gbm93KCk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBleGVjdXRlVG9vbCh7XG4gICAgICAgICAgZXhlY3V0ZTogdG9vbDIuZXhlY3V0ZS5iaW5kKHRvb2wyKSxcbiAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICB0b29sQ2FsbElkLFxuICAgICAgICAgICAgbWVzc2FnZXMsXG4gICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBwYXJ0IG9mIHN0cmVhbSkge1xuICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwicHJlbGltaW5hcnlcIikge1xuICAgICAgICAgICAgb25QcmVsaW1pbmFyeVRvb2xSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uUHJlbGltaW5hcnlUb29sUmVzdWx0KHtcbiAgICAgICAgICAgICAgLi4udG9vbENhbGwsXG4gICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgb3V0cHV0OiBwYXJ0Lm91dHB1dCxcbiAgICAgICAgICAgICAgcHJlbGltaW5hcnk6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBwYXJ0Lm91dHB1dDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uTXMyID0gbm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgKG9uVG9vbENhbGxGaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uVG9vbENhbGxGaW5pc2goe1xuICAgICAgICAgICAgLi4uYmFzZUNhbGxiYWNrRXZlbnQsXG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgZHVyYXRpb25NczogZHVyYXRpb25NczJcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gY2F0Y2ggKF9pZ25vcmVkKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmVjb3JkRXJyb3JPblNwYW4oc3BhbiwgZXJyb3IpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwidG9vbC1lcnJvclwiLFxuICAgICAgICAgIHRvb2xDYWxsSWQsXG4gICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgZHluYW1pYzogdG9vbDIudHlwZSA9PT0gXCJkeW5hbWljXCIsXG4gICAgICAgICAgLi4udG9vbENhbGwucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck1ldGFkYXRhOiB0b29sQ2FsbC5wcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgZHVyYXRpb25NcyA9IG5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgKG9uVG9vbENhbGxGaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uVG9vbENhbGxGaW5pc2goe1xuICAgICAgICAgIC4uLmJhc2VDYWxsYmFja0V2ZW50LFxuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgIGR1cmF0aW9uTXNcbiAgICAgICAgfSkpO1xuICAgICAgfSBjYXRjaCAoX2lnbm9yZWQpIHtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICBhd2FpdCBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5yZXN1bHRcIjoge1xuICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob3V0cHV0KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgdG9vbENhbGxJZCxcbiAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBvdXRwdXQsXG4gICAgICAgIGR5bmFtaWM6IHRvb2wyLnR5cGUgPT09IFwiZHluYW1pY1wiLFxuICAgICAgICAuLi50b29sQ2FsbC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyTWV0YWRhdGE6IHRvb2xDYWxsLnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L2V4dHJhY3QtcmVhc29uaW5nLWNvbnRlbnQudHNcbmZ1bmN0aW9uIGV4dHJhY3RSZWFzb25pbmdDb250ZW50KGNvbnRlbnQpIHtcbiAgY29uc3QgcGFydHMgPSBjb250ZW50LmZpbHRlcihcbiAgICAoY29udGVudDIpID0+IGNvbnRlbnQyLnR5cGUgPT09IFwicmVhc29uaW5nXCJcbiAgKTtcbiAgcmV0dXJuIHBhcnRzLmxlbmd0aCA9PT0gMCA/IHZvaWQgMCA6IHBhcnRzLm1hcCgoY29udGVudDIpID0+IGNvbnRlbnQyLnRleHQpLmpvaW4oXCJcXG5cIik7XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L2V4dHJhY3QtdGV4dC1jb250ZW50LnRzXG5mdW5jdGlvbiBleHRyYWN0VGV4dENvbnRlbnQoY29udGVudCkge1xuICBjb25zdCBwYXJ0cyA9IGNvbnRlbnQuZmlsdGVyKFxuICAgIChjb250ZW50MikgPT4gY29udGVudDIudHlwZSA9PT0gXCJ0ZXh0XCJcbiAgKTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIHBhcnRzLm1hcCgoY29udGVudDIpID0+IGNvbnRlbnQyLnRleHQpLmpvaW4oXCJcIik7XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L2dlbmVyYXRlZC1maWxlLnRzXG5pbXBvcnQge1xuICBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5IGFzIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkzLFxuICBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0IGFzIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQyXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG52YXIgRGVmYXVsdEdlbmVyYXRlZEZpbGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkYXRhLFxuICAgIG1lZGlhVHlwZVxuICB9KSB7XG4gICAgY29uc3QgaXNVaW50OEFycmF5ID0gZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gICAgdGhpcy5iYXNlNjREYXRhID0gaXNVaW50OEFycmF5ID8gdm9pZCAwIDogZGF0YTtcbiAgICB0aGlzLnVpbnQ4QXJyYXlEYXRhID0gaXNVaW50OEFycmF5ID8gZGF0YSA6IHZvaWQgMDtcbiAgICB0aGlzLm1lZGlhVHlwZSA9IG1lZGlhVHlwZTtcbiAgfVxuICAvLyBsYXp5IGNvbnZlcnNpb24gd2l0aCBjYWNoaW5nIHRvIGF2b2lkIHVubmVjZXNzYXJ5IGNvbnZlcnNpb24gb3ZlcmhlYWQ6XG4gIGdldCBiYXNlNjQoKSB7XG4gICAgaWYgKHRoaXMuYmFzZTY0RGF0YSA9PSBudWxsKSB7XG4gICAgICB0aGlzLmJhc2U2NERhdGEgPSBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0Mih0aGlzLnVpbnQ4QXJyYXlEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYmFzZTY0RGF0YTtcbiAgfVxuICAvLyBsYXp5IGNvbnZlcnNpb24gd2l0aCBjYWNoaW5nIHRvIGF2b2lkIHVubmVjZXNzYXJ5IGNvbnZlcnNpb24gb3ZlcmhlYWQ6XG4gIGdldCB1aW50OEFycmF5KCkge1xuICAgIGlmICh0aGlzLnVpbnQ4QXJyYXlEYXRhID09IG51bGwpIHtcbiAgICAgIHRoaXMudWludDhBcnJheURhdGEgPSBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5Myh0aGlzLmJhc2U2NERhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy51aW50OEFycmF5RGF0YTtcbiAgfVxufTtcbnZhciBEZWZhdWx0R2VuZXJhdGVkRmlsZVdpdGhUeXBlID0gY2xhc3MgZXh0ZW5kcyBEZWZhdWx0R2VuZXJhdGVkRmlsZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgICB0aGlzLnR5cGUgPSBcImZpbGVcIjtcbiAgfVxufTtcblxuLy8gc3JjL2dlbmVyYXRlLXRleHQvaXMtYXBwcm92YWwtbmVlZGVkLnRzXG5hc3luYyBmdW5jdGlvbiBpc0FwcHJvdmFsTmVlZGVkKHtcbiAgdG9vbDogdG9vbDIsXG4gIHRvb2xDYWxsLFxuICBtZXNzYWdlcyxcbiAgZXhwZXJpbWVudGFsX2NvbnRleHRcbn0pIHtcbiAgaWYgKHRvb2wyLm5lZWRzQXBwcm92YWwgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIHRvb2wyLm5lZWRzQXBwcm92YWwgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIHRvb2wyLm5lZWRzQXBwcm92YWw7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IHRvb2wyLm5lZWRzQXBwcm92YWwodG9vbENhbGwuaW5wdXQsIHtcbiAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgIG1lc3NhZ2VzLFxuICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0XG4gIH0pO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9vdXRwdXQudHNcbnZhciBvdXRwdXRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQob3V0cHV0X2V4cG9ydHMsIHtcbiAgYXJyYXk6ICgpID0+IGFycmF5LFxuICBjaG9pY2U6ICgpID0+IGNob2ljZSxcbiAganNvbjogKCkgPT4ganNvbixcbiAgb2JqZWN0OiAoKSA9PiBvYmplY3QsXG4gIHRleHQ6ICgpID0+IHRleHRcbn0pO1xuaW1wb3J0IHtcbiAgVHlwZVZhbGlkYXRpb25FcnJvciBhcyBUeXBlVmFsaWRhdGlvbkVycm9yMlxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHtcbiAgYXNTY2hlbWEgYXMgYXNTY2hlbWEyLFxuICByZXNvbHZlLFxuICBzYWZlUGFyc2VKU09OIGFzIHNhZmVQYXJzZUpTT04yLFxuICBzYWZlVmFsaWRhdGVUeXBlcyBhcyBzYWZlVmFsaWRhdGVUeXBlczJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL3V0aWwvcGFyc2UtcGFydGlhbC1qc29uLnRzXG5pbXBvcnQgeyBzYWZlUGFyc2VKU09OIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL3V0aWwvZml4LWpzb24udHNcbmZ1bmN0aW9uIGZpeEpzb24oaW5wdXQpIHtcbiAgY29uc3Qgc3RhY2sgPSBbXCJST09UXCJdO1xuICBsZXQgbGFzdFZhbGlkSW5kZXggPSAtMTtcbiAgbGV0IGxpdGVyYWxTdGFydCA9IG51bGw7XG4gIGZ1bmN0aW9uIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIHN3YXBTdGF0ZSkge1xuICAgIHtcbiAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICBjYXNlICdcIic6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfU1RSSU5HXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJmXCI6XG4gICAgICAgIGNhc2UgXCJ0XCI6XG4gICAgICAgIGNhc2UgXCJuXCI6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgbGl0ZXJhbFN0YXJ0ID0gaTtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBzdGFjay5wdXNoKHN3YXBTdGF0ZSk7XG4gICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9MSVRFUkFMXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCItXCI6IHtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBzdGFjay5wdXNoKHN3YXBTdGF0ZSk7XG4gICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9OVU1CRVJcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIjBcIjpcbiAgICAgICAgY2FzZSBcIjFcIjpcbiAgICAgICAgY2FzZSBcIjJcIjpcbiAgICAgICAgY2FzZSBcIjNcIjpcbiAgICAgICAgY2FzZSBcIjRcIjpcbiAgICAgICAgY2FzZSBcIjVcIjpcbiAgICAgICAgY2FzZSBcIjZcIjpcbiAgICAgICAgY2FzZSBcIjdcIjpcbiAgICAgICAgY2FzZSBcIjhcIjpcbiAgICAgICAgY2FzZSBcIjlcIjoge1xuICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBzdGFjay5wdXNoKHN3YXBTdGF0ZSk7XG4gICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9OVU1CRVJcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIntcIjoge1xuICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBzdGFjay5wdXNoKHN3YXBTdGF0ZSk7XG4gICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfU1RBUlRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIltcIjoge1xuICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBzdGFjay5wdXNoKHN3YXBTdGF0ZSk7XG4gICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9BUlJBWV9TVEFSVFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwcm9jZXNzQWZ0ZXJPYmplY3RWYWx1ZShjaGFyLCBpKSB7XG4gICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICBjYXNlIFwiLFwiOiB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX09CSkVDVF9BRlRFUl9DT01NQVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwifVwiOiB7XG4gICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwcm9jZXNzQWZ0ZXJBcnJheVZhbHVlKGNoYXIsIGkpIHtcbiAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgIGNhc2UgXCIsXCI6IHtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfQVJSQVlfQUZURVJfQ09NTUFcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIl1cIjoge1xuICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoYXIgPSBpbnB1dFtpXTtcbiAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICBzd2l0Y2ggKGN1cnJlbnRTdGF0ZSkge1xuICAgICAgY2FzZSBcIlJPT1RcIjpcbiAgICAgICAgcHJvY2Vzc1ZhbHVlU3RhcnQoY2hhciwgaSwgXCJGSU5JU0hcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfU1RBUlRcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlICdcIic6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfS0VZXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ9XCI6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQUZURVJfQ09NTUFcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlICdcIic6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfS0VZXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfS0VZXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0FGVEVSX0tFWVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX0tFWVwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgXCI6XCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfQkVGT1JFX1ZBTFVFXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQkVGT1JFX1ZBTFVFXCI6IHtcbiAgICAgICAgcHJvY2Vzc1ZhbHVlU3RhcnQoY2hhciwgaSwgXCJJTlNJREVfT0JKRUNUX0FGVEVSX1ZBTFVFXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX1ZBTFVFXCI6IHtcbiAgICAgICAgcHJvY2Vzc0FmdGVyT2JqZWN0VmFsdWUoY2hhciwgaSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9TVFJJTkdcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlICdcIic6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJcXFxcXCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfU1RSSU5HX0VTQ0FQRVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9BUlJBWV9TVEFSVFwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgXCJdXCI6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgXCIsXCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9BUlJBWV9BRlRFUl9DT01NQVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiXVwiOiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX0FGVEVSX0NPTU1BXCI6IHtcbiAgICAgICAgcHJvY2Vzc1ZhbHVlU3RhcnQoY2hhciwgaSwgXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9TVFJJTkdfRVNDQVBFXCI6IHtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX05VTUJFUlwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgXCIwXCI6XG4gICAgICAgICAgY2FzZSBcIjFcIjpcbiAgICAgICAgICBjYXNlIFwiMlwiOlxuICAgICAgICAgIGNhc2UgXCIzXCI6XG4gICAgICAgICAgY2FzZSBcIjRcIjpcbiAgICAgICAgICBjYXNlIFwiNVwiOlxuICAgICAgICAgIGNhc2UgXCI2XCI6XG4gICAgICAgICAgY2FzZSBcIjdcIjpcbiAgICAgICAgICBjYXNlIFwiOFwiOlxuICAgICAgICAgIGNhc2UgXCI5XCI6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiZVwiOlxuICAgICAgICAgIGNhc2UgXCJFXCI6XG4gICAgICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgICBjYXNlIFwiLlwiOiB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIixcIjoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCIpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzc0FmdGVyQXJyYXlWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJJTlNJREVfT0JKRUNUX0FGVEVSX1ZBTFVFXCIpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzc0FmdGVyT2JqZWN0VmFsdWUoY2hhciwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIn1cIjoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3NBZnRlck9iamVjdFZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJdXCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3NBZnRlckFycmF5VmFsdWUoY2hhciwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX0xJVEVSQUxcIjoge1xuICAgICAgICBjb25zdCBwYXJ0aWFsTGl0ZXJhbCA9IGlucHV0LnN1YnN0cmluZyhsaXRlcmFsU3RhcnQsIGkgKyAxKTtcbiAgICAgICAgaWYgKCFcImZhbHNlXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkgJiYgIVwidHJ1ZVwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpICYmICFcIm51bGxcIi5zdGFydHNXaXRoKHBhcnRpYWxMaXRlcmFsKSkge1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJJTlNJREVfT0JKRUNUX0FGVEVSX1ZBTFVFXCIpIHtcbiAgICAgICAgICAgIHByb2Nlc3NBZnRlck9iamVjdFZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCIpIHtcbiAgICAgICAgICAgIHByb2Nlc3NBZnRlckFycmF5VmFsdWUoY2hhciwgaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IHJlc3VsdCA9IGlucHV0LnNsaWNlKDAsIGxhc3RWYWxpZEluZGV4ICsgMSk7XG4gIGZvciAobGV0IGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IHN0YXRlID0gc3RhY2tbaV07XG4gICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgY2FzZSBcIklOU0lERV9TVFJJTkdcIjoge1xuICAgICAgICByZXN1bHQgKz0gJ1wiJztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9LRVlcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX0tFWVwiOlxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQUZURVJfQ09NTUFcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX1NUQVJUXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9CRUZPUkVfVkFMVUVcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX1ZBTFVFXCI6IHtcbiAgICAgICAgcmVzdWx0ICs9IFwifVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfU1RBUlRcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfQUZURVJfQ09NTUFcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIjoge1xuICAgICAgICByZXN1bHQgKz0gXCJdXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9MSVRFUkFMXCI6IHtcbiAgICAgICAgY29uc3QgcGFydGlhbExpdGVyYWwgPSBpbnB1dC5zdWJzdHJpbmcobGl0ZXJhbFN0YXJ0LCBpbnB1dC5sZW5ndGgpO1xuICAgICAgICBpZiAoXCJ0cnVlXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkpIHtcbiAgICAgICAgICByZXN1bHQgKz0gXCJ0cnVlXCIuc2xpY2UocGFydGlhbExpdGVyYWwubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmIChcImZhbHNlXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkpIHtcbiAgICAgICAgICByZXN1bHQgKz0gXCJmYWxzZVwiLnNsaWNlKHBhcnRpYWxMaXRlcmFsLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoXCJudWxsXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkpIHtcbiAgICAgICAgICByZXN1bHQgKz0gXCJudWxsXCIuc2xpY2UocGFydGlhbExpdGVyYWwubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBzcmMvdXRpbC9wYXJzZS1wYXJ0aWFsLWpzb24udHNcbmFzeW5jIGZ1bmN0aW9uIHBhcnNlUGFydGlhbEpzb24oanNvblRleHQpIHtcbiAgaWYgKGpzb25UZXh0ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdm9pZCAwLCBzdGF0ZTogXCJ1bmRlZmluZWQtaW5wdXRcIiB9O1xuICB9XG4gIGxldCByZXN1bHQgPSBhd2FpdCBzYWZlUGFyc2VKU09OKHsgdGV4dDoganNvblRleHQgfSk7XG4gIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgIHJldHVybiB7IHZhbHVlOiByZXN1bHQudmFsdWUsIHN0YXRlOiBcInN1Y2Nlc3NmdWwtcGFyc2VcIiB9O1xuICB9XG4gIHJlc3VsdCA9IGF3YWl0IHNhZmVQYXJzZUpTT04oeyB0ZXh0OiBmaXhKc29uKGpzb25UZXh0KSB9KTtcbiAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHJlc3VsdC52YWx1ZSwgc3RhdGU6IFwicmVwYWlyZWQtcGFyc2VcIiB9O1xuICB9XG4gIHJldHVybiB7IHZhbHVlOiB2b2lkIDAsIHN0YXRlOiBcImZhaWxlZC1wYXJzZVwiIH07XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L291dHB1dC50c1xudmFyIHRleHQgPSAoKSA9PiAoe1xuICBuYW1lOiBcInRleHRcIixcbiAgcmVzcG9uc2VGb3JtYXQ6IFByb21pc2UucmVzb2x2ZSh7IHR5cGU6IFwidGV4dFwiIH0pLFxuICBhc3luYyBwYXJzZUNvbXBsZXRlT3V0cHV0KHsgdGV4dDogdGV4dDIgfSkge1xuICAgIHJldHVybiB0ZXh0MjtcbiAgfSxcbiAgYXN5bmMgcGFyc2VQYXJ0aWFsT3V0cHV0KHsgdGV4dDogdGV4dDIgfSkge1xuICAgIHJldHVybiB7IHBhcnRpYWw6IHRleHQyIH07XG4gIH0sXG4gIGNyZWF0ZUVsZW1lbnRTdHJlYW1UcmFuc2Zvcm0oKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufSk7XG52YXIgb2JqZWN0ID0gKHtcbiAgc2NoZW1hOiBpbnB1dFNjaGVtYSxcbiAgbmFtZTogbmFtZTIxLFxuICBkZXNjcmlwdGlvblxufSkgPT4ge1xuICBjb25zdCBzY2hlbWEgPSBhc1NjaGVtYTIoaW5wdXRTY2hlbWEpO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IFwib2JqZWN0XCIsXG4gICAgcmVzcG9uc2VGb3JtYXQ6IHJlc29sdmUoc2NoZW1hLmpzb25TY2hlbWEpLnRoZW4oKGpzb25TY2hlbWEyKSA9PiAoe1xuICAgICAgdHlwZTogXCJqc29uXCIsXG4gICAgICBzY2hlbWE6IGpzb25TY2hlbWEyLFxuICAgICAgLi4ubmFtZTIxICE9IG51bGwgJiYgeyBuYW1lOiBuYW1lMjEgfSxcbiAgICAgIC4uLmRlc2NyaXB0aW9uICE9IG51bGwgJiYgeyBkZXNjcmlwdGlvbiB9XG4gICAgfSkpLFxuICAgIGFzeW5jIHBhcnNlQ29tcGxldGVPdXRwdXQoeyB0ZXh0OiB0ZXh0MiB9LCBjb250ZXh0Mikge1xuICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSBhd2FpdCBzYWZlUGFyc2VKU09OMih7IHRleHQ6IHRleHQyIH0pO1xuICAgICAgaWYgKCFwYXJzZVJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIk5vIG9iamVjdCBnZW5lcmF0ZWQ6IGNvdWxkIG5vdCBwYXJzZSB0aGUgcmVzcG9uc2UuXCIsXG4gICAgICAgICAgY2F1c2U6IHBhcnNlUmVzdWx0LmVycm9yLFxuICAgICAgICAgIHRleHQ6IHRleHQyLFxuICAgICAgICAgIHJlc3BvbnNlOiBjb250ZXh0Mi5yZXNwb25zZSxcbiAgICAgICAgICB1c2FnZTogY29udGV4dDIudXNhZ2UsXG4gICAgICAgICAgZmluaXNoUmVhc29uOiBjb250ZXh0Mi5maW5pc2hSZWFzb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gYXdhaXQgc2FmZVZhbGlkYXRlVHlwZXMyKHtcbiAgICAgICAgdmFsdWU6IHBhcnNlUmVzdWx0LnZhbHVlLFxuICAgICAgICBzY2hlbWFcbiAgICAgIH0pO1xuICAgICAgaWYgKCF2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IFwiTm8gb2JqZWN0IGdlbmVyYXRlZDogcmVzcG9uc2UgZGlkIG5vdCBtYXRjaCBzY2hlbWEuXCIsXG4gICAgICAgICAgY2F1c2U6IHZhbGlkYXRpb25SZXN1bHQuZXJyb3IsXG4gICAgICAgICAgdGV4dDogdGV4dDIsXG4gICAgICAgICAgcmVzcG9uc2U6IGNvbnRleHQyLnJlc3BvbnNlLFxuICAgICAgICAgIHVzYWdlOiBjb250ZXh0Mi51c2FnZSxcbiAgICAgICAgICBmaW5pc2hSZWFzb246IGNvbnRleHQyLmZpbmlzaFJlYXNvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWxpZGF0aW9uUmVzdWx0LnZhbHVlO1xuICAgIH0sXG4gICAgYXN5bmMgcGFyc2VQYXJ0aWFsT3V0cHV0KHsgdGV4dDogdGV4dDIgfSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcGFyc2VQYXJ0aWFsSnNvbih0ZXh0Mik7XG4gICAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgICBjYXNlIFwiZmFpbGVkLXBhcnNlXCI6XG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWQtaW5wdXRcIjoge1xuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInJlcGFpcmVkLXBhcnNlXCI6XG4gICAgICAgIGNhc2UgXCJzdWNjZXNzZnVsLXBhcnNlXCI6IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gTm90ZTogY3VycmVudGx5IG5vIHZhbGlkYXRpb24gb2YgcGFydGlhbCByZXN1bHRzOlxuICAgICAgICAgICAgcGFydGlhbDogcmVzdWx0LnZhbHVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlRWxlbWVudFN0cmVhbVRyYW5zZm9ybSgpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICB9O1xufTtcbnZhciBhcnJheSA9ICh7XG4gIGVsZW1lbnQ6IGlucHV0RWxlbWVudFNjaGVtYSxcbiAgbmFtZTogbmFtZTIxLFxuICBkZXNjcmlwdGlvblxufSkgPT4ge1xuICBjb25zdCBlbGVtZW50U2NoZW1hID0gYXNTY2hlbWEyKGlucHV0RWxlbWVudFNjaGVtYSk7XG4gIHJldHVybiB7XG4gICAgbmFtZTogXCJhcnJheVwiLFxuICAgIC8vIEpTT04gc2NoZW1hIHRoYXQgZGVzY3JpYmVzIGFuIGFycmF5IG9mIGVsZW1lbnRzOlxuICAgIHJlc3BvbnNlRm9ybWF0OiByZXNvbHZlKGVsZW1lbnRTY2hlbWEuanNvblNjaGVtYSkudGhlbigoanNvblNjaGVtYTIpID0+IHtcbiAgICAgIGNvbnN0IHsgJHNjaGVtYSwgLi4uaXRlbVNjaGVtYSB9ID0ganNvblNjaGVtYTI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImpzb25cIixcbiAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgJHNjaGVtYTogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNcIixcbiAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVsZW1lbnRzOiB7IHR5cGU6IFwiYXJyYXlcIiwgaXRlbXM6IGl0ZW1TY2hlbWEgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVxdWlyZWQ6IFtcImVsZW1lbnRzXCJdLFxuICAgICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICAuLi5uYW1lMjEgIT0gbnVsbCAmJiB7IG5hbWU6IG5hbWUyMSB9LFxuICAgICAgICAuLi5kZXNjcmlwdGlvbiAhPSBudWxsICYmIHsgZGVzY3JpcHRpb24gfVxuICAgICAgfTtcbiAgICB9KSxcbiAgICBhc3luYyBwYXJzZUNvbXBsZXRlT3V0cHV0KHsgdGV4dDogdGV4dDIgfSwgY29udGV4dDIpIHtcbiAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gYXdhaXQgc2FmZVBhcnNlSlNPTjIoeyB0ZXh0OiB0ZXh0MiB9KTtcbiAgICAgIGlmICghcGFyc2VSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiBjb3VsZCBub3QgcGFyc2UgdGhlIHJlc3BvbnNlLlwiLFxuICAgICAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvcixcbiAgICAgICAgICB0ZXh0OiB0ZXh0MixcbiAgICAgICAgICByZXNwb25zZTogY29udGV4dDIucmVzcG9uc2UsXG4gICAgICAgICAgdXNhZ2U6IGNvbnRleHQyLnVzYWdlLFxuICAgICAgICAgIGZpbmlzaFJlYXNvbjogY29udGV4dDIuZmluaXNoUmVhc29uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3V0ZXJWYWx1ZSA9IHBhcnNlUmVzdWx0LnZhbHVlO1xuICAgICAgaWYgKG91dGVyVmFsdWUgPT0gbnVsbCB8fCB0eXBlb2Ygb3V0ZXJWYWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwiZWxlbWVudHNcIiBpbiBvdXRlclZhbHVlKSB8fCAhQXJyYXkuaXNBcnJheShvdXRlclZhbHVlLmVsZW1lbnRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiByZXNwb25zZSBkaWQgbm90IG1hdGNoIHNjaGVtYS5cIixcbiAgICAgICAgICBjYXVzZTogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3IyKHtcbiAgICAgICAgICAgIHZhbHVlOiBvdXRlclZhbHVlLFxuICAgICAgICAgICAgY2F1c2U6IFwicmVzcG9uc2UgbXVzdCBiZSBhbiBvYmplY3Qgd2l0aCBhbiBlbGVtZW50cyBhcnJheVwiXG4gICAgICAgICAgfSksXG4gICAgICAgICAgdGV4dDogdGV4dDIsXG4gICAgICAgICAgcmVzcG9uc2U6IGNvbnRleHQyLnJlc3BvbnNlLFxuICAgICAgICAgIHVzYWdlOiBjb250ZXh0Mi51c2FnZSxcbiAgICAgICAgICBmaW5pc2hSZWFzb246IGNvbnRleHQyLmZpbmlzaFJlYXNvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBvdXRlclZhbHVlLmVsZW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSBhd2FpdCBzYWZlVmFsaWRhdGVUeXBlczIoe1xuICAgICAgICAgIHZhbHVlOiBlbGVtZW50LFxuICAgICAgICAgIHNjaGVtYTogZWxlbWVudFNjaGVtYVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIk5vIG9iamVjdCBnZW5lcmF0ZWQ6IHJlc3BvbnNlIGRpZCBub3QgbWF0Y2ggc2NoZW1hLlwiLFxuICAgICAgICAgICAgY2F1c2U6IHZhbGlkYXRpb25SZXN1bHQuZXJyb3IsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0MixcbiAgICAgICAgICAgIHJlc3BvbnNlOiBjb250ZXh0Mi5yZXNwb25zZSxcbiAgICAgICAgICAgIHVzYWdlOiBjb250ZXh0Mi51c2FnZSxcbiAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogY29udGV4dDIuZmluaXNoUmVhc29uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRlclZhbHVlLmVsZW1lbnRzO1xuICAgIH0sXG4gICAgYXN5bmMgcGFyc2VQYXJ0aWFsT3V0cHV0KHsgdGV4dDogdGV4dDIgfSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcGFyc2VQYXJ0aWFsSnNvbih0ZXh0Mik7XG4gICAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgICBjYXNlIFwiZmFpbGVkLXBhcnNlXCI6XG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWQtaW5wdXRcIjoge1xuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInJlcGFpcmVkLXBhcnNlXCI6XG4gICAgICAgIGNhc2UgXCJzdWNjZXNzZnVsLXBhcnNlXCI6IHtcbiAgICAgICAgICBjb25zdCBvdXRlclZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgIGlmIChvdXRlclZhbHVlID09IG51bGwgfHwgdHlwZW9mIG91dGVyVmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcImVsZW1lbnRzXCIgaW4gb3V0ZXJWYWx1ZSkgfHwgIUFycmF5LmlzQXJyYXkob3V0ZXJWYWx1ZS5lbGVtZW50cykpIHtcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHJhd0VsZW1lbnRzID0gcmVzdWx0LnN0YXRlID09PSBcInJlcGFpcmVkLXBhcnNlXCIgJiYgb3V0ZXJWYWx1ZS5lbGVtZW50cy5sZW5ndGggPiAwID8gb3V0ZXJWYWx1ZS5lbGVtZW50cy5zbGljZSgwLCAtMSkgOiBvdXRlclZhbHVlLmVsZW1lbnRzO1xuICAgICAgICAgIGNvbnN0IHBhcnNlZEVsZW1lbnRzID0gW107XG4gICAgICAgICAgZm9yIChjb25zdCByYXdFbGVtZW50IG9mIHJhd0VsZW1lbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gYXdhaXQgc2FmZVZhbGlkYXRlVHlwZXMyKHtcbiAgICAgICAgICAgICAgdmFsdWU6IHJhd0VsZW1lbnQsXG4gICAgICAgICAgICAgIHNjaGVtYTogZWxlbWVudFNjaGVtYVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgIHBhcnNlZEVsZW1lbnRzLnB1c2godmFsaWRhdGlvblJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7IHBhcnRpYWw6IHBhcnNlZEVsZW1lbnRzIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZUVsZW1lbnRTdHJlYW1UcmFuc2Zvcm0oKSB7XG4gICAgICBsZXQgcHVibGlzaGVkRWxlbWVudHMgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICB0cmFuc2Zvcm0oeyBwYXJ0aWFsT3V0cHV0IH0sIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBpZiAocGFydGlhbE91dHB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKDsgcHVibGlzaGVkRWxlbWVudHMgPCBwYXJ0aWFsT3V0cHV0Lmxlbmd0aDsgcHVibGlzaGVkRWxlbWVudHMrKykge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUocGFydGlhbE91dHB1dFtwdWJsaXNoZWRFbGVtZW50c10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufTtcbnZhciBjaG9pY2UgPSAoe1xuICBvcHRpb25zOiBjaG9pY2VPcHRpb25zLFxuICBuYW1lOiBuYW1lMjEsXG4gIGRlc2NyaXB0aW9uXG59KSA9PiB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogXCJjaG9pY2VcIixcbiAgICAvLyBKU09OIHNjaGVtYSB0aGF0IGRlc2NyaWJlcyBhbiBlbnVtZXJhdGlvbjpcbiAgICByZXNwb25zZUZvcm1hdDogUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIHR5cGU6IFwianNvblwiLFxuICAgICAgc2NoZW1hOiB7XG4gICAgICAgICRzY2hlbWE6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCIsXG4gICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICByZXN1bHQ6IHsgdHlwZTogXCJzdHJpbmdcIiwgZW51bTogY2hvaWNlT3B0aW9ucyB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVpcmVkOiBbXCJyZXN1bHRcIl0sXG4gICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIC4uLm5hbWUyMSAhPSBudWxsICYmIHsgbmFtZTogbmFtZTIxIH0sXG4gICAgICAuLi5kZXNjcmlwdGlvbiAhPSBudWxsICYmIHsgZGVzY3JpcHRpb24gfVxuICAgIH0pLFxuICAgIGFzeW5jIHBhcnNlQ29tcGxldGVPdXRwdXQoeyB0ZXh0OiB0ZXh0MiB9LCBjb250ZXh0Mikge1xuICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSBhd2FpdCBzYWZlUGFyc2VKU09OMih7IHRleHQ6IHRleHQyIH0pO1xuICAgICAgaWYgKCFwYXJzZVJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIk5vIG9iamVjdCBnZW5lcmF0ZWQ6IGNvdWxkIG5vdCBwYXJzZSB0aGUgcmVzcG9uc2UuXCIsXG4gICAgICAgICAgY2F1c2U6IHBhcnNlUmVzdWx0LmVycm9yLFxuICAgICAgICAgIHRleHQ6IHRleHQyLFxuICAgICAgICAgIHJlc3BvbnNlOiBjb250ZXh0Mi5yZXNwb25zZSxcbiAgICAgICAgICB1c2FnZTogY29udGV4dDIudXNhZ2UsXG4gICAgICAgICAgZmluaXNoUmVhc29uOiBjb250ZXh0Mi5maW5pc2hSZWFzb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBvdXRlclZhbHVlID0gcGFyc2VSZXN1bHQudmFsdWU7XG4gICAgICBpZiAob3V0ZXJWYWx1ZSA9PSBudWxsIHx8IHR5cGVvZiBvdXRlclZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJyZXN1bHRcIiBpbiBvdXRlclZhbHVlKSB8fCB0eXBlb2Ygb3V0ZXJWYWx1ZS5yZXN1bHQgIT09IFwic3RyaW5nXCIgfHwgIWNob2ljZU9wdGlvbnMuaW5jbHVkZXMob3V0ZXJWYWx1ZS5yZXN1bHQpKSB7XG4gICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIk5vIG9iamVjdCBnZW5lcmF0ZWQ6IHJlc3BvbnNlIGRpZCBub3QgbWF0Y2ggc2NoZW1hLlwiLFxuICAgICAgICAgIGNhdXNlOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcjIoe1xuICAgICAgICAgICAgdmFsdWU6IG91dGVyVmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogXCJyZXNwb25zZSBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgY2hvaWNlIHZhbHVlLlwiXG4gICAgICAgICAgfSksXG4gICAgICAgICAgdGV4dDogdGV4dDIsXG4gICAgICAgICAgcmVzcG9uc2U6IGNvbnRleHQyLnJlc3BvbnNlLFxuICAgICAgICAgIHVzYWdlOiBjb250ZXh0Mi51c2FnZSxcbiAgICAgICAgICBmaW5pc2hSZWFzb246IGNvbnRleHQyLmZpbmlzaFJlYXNvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRlclZhbHVlLnJlc3VsdDtcbiAgICB9LFxuICAgIGFzeW5jIHBhcnNlUGFydGlhbE91dHB1dCh7IHRleHQ6IHRleHQyIH0pIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHBhcnNlUGFydGlhbEpzb24odGV4dDIpO1xuICAgICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgICAgY2FzZSBcImZhaWxlZC1wYXJzZVwiOlxuICAgICAgICBjYXNlIFwidW5kZWZpbmVkLWlucHV0XCI6IHtcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJyZXBhaXJlZC1wYXJzZVwiOlxuICAgICAgICBjYXNlIFwic3VjY2Vzc2Z1bC1wYXJzZVwiOiB7XG4gICAgICAgICAgY29uc3Qgb3V0ZXJWYWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICBpZiAob3V0ZXJWYWx1ZSA9PSBudWxsIHx8IHR5cGVvZiBvdXRlclZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJyZXN1bHRcIiBpbiBvdXRlclZhbHVlKSB8fCB0eXBlb2Ygb3V0ZXJWYWx1ZS5yZXN1bHQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHBvdGVudGlhbE1hdGNoZXMgPSBjaG9pY2VPcHRpb25zLmZpbHRlcihcbiAgICAgICAgICAgIChjaG9pY2VPcHRpb24pID0+IGNob2ljZU9wdGlvbi5zdGFydHNXaXRoKG91dGVyVmFsdWUucmVzdWx0KVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5zdGF0ZSA9PT0gXCJzdWNjZXNzZnVsLXBhcnNlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBwb3RlbnRpYWxNYXRjaGVzLmluY2x1ZGVzKG91dGVyVmFsdWUucmVzdWx0KSA/IHsgcGFydGlhbDogb3V0ZXJWYWx1ZS5yZXN1bHQgfSA6IHZvaWQgMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBvdGVudGlhbE1hdGNoZXMubGVuZ3RoID09PSAxID8geyBwYXJ0aWFsOiBwb3RlbnRpYWxNYXRjaGVzWzBdIH0gOiB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVFbGVtZW50U3RyZWFtVHJhbnNmb3JtKCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gIH07XG59O1xudmFyIGpzb24gPSAoe1xuICBuYW1lOiBuYW1lMjEsXG4gIGRlc2NyaXB0aW9uXG59ID0ge30pID0+IHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBcImpzb25cIixcbiAgICByZXNwb25zZUZvcm1hdDogUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIHR5cGU6IFwianNvblwiLFxuICAgICAgLi4ubmFtZTIxICE9IG51bGwgJiYgeyBuYW1lOiBuYW1lMjEgfSxcbiAgICAgIC4uLmRlc2NyaXB0aW9uICE9IG51bGwgJiYgeyBkZXNjcmlwdGlvbiB9XG4gICAgfSksXG4gICAgYXN5bmMgcGFyc2VDb21wbGV0ZU91dHB1dCh7IHRleHQ6IHRleHQyIH0sIGNvbnRleHQyKSB7XG4gICAgICBjb25zdCBwYXJzZVJlc3VsdCA9IGF3YWl0IHNhZmVQYXJzZUpTT04yKHsgdGV4dDogdGV4dDIgfSk7XG4gICAgICBpZiAoIXBhcnNlUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IFwiTm8gb2JqZWN0IGdlbmVyYXRlZDogY291bGQgbm90IHBhcnNlIHRoZSByZXNwb25zZS5cIixcbiAgICAgICAgICBjYXVzZTogcGFyc2VSZXN1bHQuZXJyb3IsXG4gICAgICAgICAgdGV4dDogdGV4dDIsXG4gICAgICAgICAgcmVzcG9uc2U6IGNvbnRleHQyLnJlc3BvbnNlLFxuICAgICAgICAgIHVzYWdlOiBjb250ZXh0Mi51c2FnZSxcbiAgICAgICAgICBmaW5pc2hSZWFzb246IGNvbnRleHQyLmZpbmlzaFJlYXNvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZVJlc3VsdC52YWx1ZTtcbiAgICB9LFxuICAgIGFzeW5jIHBhcnNlUGFydGlhbE91dHB1dCh7IHRleHQ6IHRleHQyIH0pIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHBhcnNlUGFydGlhbEpzb24odGV4dDIpO1xuICAgICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgICAgY2FzZSBcImZhaWxlZC1wYXJzZVwiOlxuICAgICAgICBjYXNlIFwidW5kZWZpbmVkLWlucHV0XCI6IHtcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJyZXBhaXJlZC1wYXJzZVwiOlxuICAgICAgICBjYXNlIFwic3VjY2Vzc2Z1bC1wYXJzZVwiOiB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogeyBwYXJ0aWFsOiByZXN1bHQudmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlRWxlbWVudFN0cmVhbVRyYW5zZm9ybSgpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICB9O1xufTtcblxuLy8gc3JjL2dlbmVyYXRlLXRleHQvcGFyc2UtdG9vbC1jYWxsLnRzXG5pbXBvcnQge1xuICBhc1NjaGVtYSBhcyBhc1NjaGVtYTMsXG4gIHNhZmVQYXJzZUpTT04gYXMgc2FmZVBhcnNlSlNPTjMsXG4gIHNhZmVWYWxpZGF0ZVR5cGVzIGFzIHNhZmVWYWxpZGF0ZVR5cGVzM1xufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuYXN5bmMgZnVuY3Rpb24gcGFyc2VUb29sQ2FsbCh7XG4gIHRvb2xDYWxsLFxuICB0b29scyxcbiAgcmVwYWlyVG9vbENhbGwsXG4gIHN5c3RlbSxcbiAgbWVzc2FnZXNcbn0pIHtcbiAgdmFyIF9hMjE7XG4gIHRyeSB7XG4gICAgaWYgKHRvb2xzID09IG51bGwpIHtcbiAgICAgIGlmICh0b29sQ2FsbC5wcm92aWRlckV4ZWN1dGVkICYmIHRvb2xDYWxsLmR5bmFtaWMpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHBhcnNlUHJvdmlkZXJFeGVjdXRlZER5bmFtaWNUb29sQ2FsbCh0b29sQ2FsbCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoVG9vbEVycm9yKHsgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lIH0pO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGRvUGFyc2VUb29sQ2FsbCh7IHRvb2xDYWxsLCB0b29scyB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKHJlcGFpclRvb2xDYWxsID09IG51bGwgfHwgIShOb1N1Y2hUb29sRXJyb3IuaXNJbnN0YW5jZShlcnJvcikgfHwgSW52YWxpZFRvb2xJbnB1dEVycm9yLmlzSW5zdGFuY2UoZXJyb3IpKSkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIGxldCByZXBhaXJlZFRvb2xDYWxsID0gbnVsbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcGFpcmVkVG9vbENhbGwgPSBhd2FpdCByZXBhaXJUb29sQ2FsbCh7XG4gICAgICAgICAgdG9vbENhbGwsXG4gICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgaW5wdXRTY2hlbWE6IGFzeW5jICh7IHRvb2xOYW1lIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaW5wdXRTY2hlbWEgfSA9IHRvb2xzW3Rvb2xOYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBhc1NjaGVtYTMoaW5wdXRTY2hlbWEpLmpzb25TY2hlbWE7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzeXN0ZW0sXG4gICAgICAgICAgbWVzc2FnZXMsXG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChyZXBhaXJFcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgVG9vbENhbGxSZXBhaXJFcnJvcih7XG4gICAgICAgICAgY2F1c2U6IHJlcGFpckVycm9yLFxuICAgICAgICAgIG9yaWdpbmFsRXJyb3I6IGVycm9yXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHJlcGFpcmVkVG9vbENhbGwgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhd2FpdCBkb1BhcnNlVG9vbENhbGwoeyB0b29sQ2FsbDogcmVwYWlyZWRUb29sQ2FsbCwgdG9vbHMgfSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IHBhcnNlZElucHV0ID0gYXdhaXQgc2FmZVBhcnNlSlNPTjMoeyB0ZXh0OiB0b29sQ2FsbC5pbnB1dCB9KTtcbiAgICBjb25zdCBpbnB1dCA9IHBhcnNlZElucHV0LnN1Y2Nlc3MgPyBwYXJzZWRJbnB1dC52YWx1ZSA6IHRvb2xDYWxsLmlucHV0O1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInRvb2wtY2FsbFwiLFxuICAgICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICAgIGlucHV0LFxuICAgICAgZHluYW1pYzogdHJ1ZSxcbiAgICAgIGludmFsaWQ6IHRydWUsXG4gICAgICBlcnJvcixcbiAgICAgIHRpdGxlOiAoX2EyMSA9IHRvb2xzID09IG51bGwgPyB2b2lkIDAgOiB0b29sc1t0b29sQ2FsbC50b29sTmFtZV0pID09IG51bGwgPyB2b2lkIDAgOiBfYTIxLnRpdGxlLFxuICAgICAgcHJvdmlkZXJFeGVjdXRlZDogdG9vbENhbGwucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHRvb2xDYWxsLnByb3ZpZGVyTWV0YWRhdGFcbiAgICB9O1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBwYXJzZVByb3ZpZGVyRXhlY3V0ZWREeW5hbWljVG9vbENhbGwodG9vbENhbGwpIHtcbiAgY29uc3QgcGFyc2VSZXN1bHQgPSB0b29sQ2FsbC5pbnB1dC50cmltKCkgPT09IFwiXCIgPyB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlOiB7fSB9IDogYXdhaXQgc2FmZVBhcnNlSlNPTjMoeyB0ZXh0OiB0b29sQ2FsbC5pbnB1dCB9KTtcbiAgaWYgKHBhcnNlUmVzdWx0LnN1Y2Nlc3MgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRUb29sSW5wdXRFcnJvcih7XG4gICAgICB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgICB0b29sSW5wdXQ6IHRvb2xDYWxsLmlucHV0LFxuICAgICAgY2F1c2U6IHBhcnNlUmVzdWx0LmVycm9yXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInRvb2wtY2FsbFwiLFxuICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgIGlucHV0OiBwYXJzZVJlc3VsdC52YWx1ZSxcbiAgICBwcm92aWRlckV4ZWN1dGVkOiB0cnVlLFxuICAgIGR5bmFtaWM6IHRydWUsXG4gICAgcHJvdmlkZXJNZXRhZGF0YTogdG9vbENhbGwucHJvdmlkZXJNZXRhZGF0YVxuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gZG9QYXJzZVRvb2xDYWxsKHtcbiAgdG9vbENhbGwsXG4gIHRvb2xzXG59KSB7XG4gIGNvbnN0IHRvb2xOYW1lID0gdG9vbENhbGwudG9vbE5hbWU7XG4gIGNvbnN0IHRvb2wyID0gdG9vbHNbdG9vbE5hbWVdO1xuICBpZiAodG9vbDIgPT0gbnVsbCkge1xuICAgIGlmICh0b29sQ2FsbC5wcm92aWRlckV4ZWN1dGVkICYmIHRvb2xDYWxsLmR5bmFtaWMpIHtcbiAgICAgIHJldHVybiBhd2FpdCBwYXJzZVByb3ZpZGVyRXhlY3V0ZWREeW5hbWljVG9vbENhbGwodG9vbENhbGwpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgTm9TdWNoVG9vbEVycm9yKHtcbiAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICAgIGF2YWlsYWJsZVRvb2xzOiBPYmplY3Qua2V5cyh0b29scylcbiAgICB9KTtcbiAgfVxuICBjb25zdCBzY2hlbWEgPSBhc1NjaGVtYTModG9vbDIuaW5wdXRTY2hlbWEpO1xuICBjb25zdCBwYXJzZVJlc3VsdCA9IHRvb2xDYWxsLmlucHV0LnRyaW0oKSA9PT0gXCJcIiA/IGF3YWl0IHNhZmVWYWxpZGF0ZVR5cGVzMyh7IHZhbHVlOiB7fSwgc2NoZW1hIH0pIDogYXdhaXQgc2FmZVBhcnNlSlNPTjMoeyB0ZXh0OiB0b29sQ2FsbC5pbnB1dCwgc2NoZW1hIH0pO1xuICBpZiAocGFyc2VSZXN1bHQuc3VjY2VzcyA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFRvb2xJbnB1dEVycm9yKHtcbiAgICAgIHRvb2xOYW1lLFxuICAgICAgdG9vbElucHV0OiB0b29sQ2FsbC5pbnB1dCxcbiAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvclxuICAgIH0pO1xuICB9XG4gIHJldHVybiB0b29sMi50eXBlID09PSBcImR5bmFtaWNcIiA/IHtcbiAgICB0eXBlOiBcInRvb2wtY2FsbFwiLFxuICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgIGlucHV0OiBwYXJzZVJlc3VsdC52YWx1ZSxcbiAgICBwcm92aWRlckV4ZWN1dGVkOiB0b29sQ2FsbC5wcm92aWRlckV4ZWN1dGVkLFxuICAgIHByb3ZpZGVyTWV0YWRhdGE6IHRvb2xDYWxsLnByb3ZpZGVyTWV0YWRhdGEsXG4gICAgZHluYW1pYzogdHJ1ZSxcbiAgICB0aXRsZTogdG9vbDIudGl0bGVcbiAgfSA6IHtcbiAgICB0eXBlOiBcInRvb2wtY2FsbFwiLFxuICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgdG9vbE5hbWUsXG4gICAgaW5wdXQ6IHBhcnNlUmVzdWx0LnZhbHVlLFxuICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHRvb2xDYWxsLnByb3ZpZGVyRXhlY3V0ZWQsXG4gICAgcHJvdmlkZXJNZXRhZGF0YTogdG9vbENhbGwucHJvdmlkZXJNZXRhZGF0YSxcbiAgICB0aXRsZTogdG9vbDIudGl0bGVcbiAgfTtcbn1cblxuLy8gc3JjL2dlbmVyYXRlLXRleHQvc3RlcC1yZXN1bHQudHNcbnZhciBEZWZhdWx0U3RlcFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHN0ZXBOdW1iZXIsXG4gICAgbW9kZWwsXG4gICAgZnVuY3Rpb25JZCxcbiAgICBtZXRhZGF0YSxcbiAgICBleHBlcmltZW50YWxfY29udGV4dCxcbiAgICBjb250ZW50LFxuICAgIGZpbmlzaFJlYXNvbixcbiAgICByYXdGaW5pc2hSZWFzb24sXG4gICAgdXNhZ2UsXG4gICAgd2FybmluZ3MsXG4gICAgcmVxdWVzdCxcbiAgICByZXNwb25zZSxcbiAgICBwcm92aWRlck1ldGFkYXRhXG4gIH0pIHtcbiAgICB0aGlzLnN0ZXBOdW1iZXIgPSBzdGVwTnVtYmVyO1xuICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICB0aGlzLmZ1bmN0aW9uSWQgPSBmdW5jdGlvbklkO1xuICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICB0aGlzLmV4cGVyaW1lbnRhbF9jb250ZXh0ID0gZXhwZXJpbWVudGFsX2NvbnRleHQ7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB0aGlzLmZpbmlzaFJlYXNvbiA9IGZpbmlzaFJlYXNvbjtcbiAgICB0aGlzLnJhd0ZpbmlzaFJlYXNvbiA9IHJhd0ZpbmlzaFJlYXNvbjtcbiAgICB0aGlzLnVzYWdlID0gdXNhZ2U7XG4gICAgdGhpcy53YXJuaW5ncyA9IHdhcm5pbmdzO1xuICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIHRoaXMucHJvdmlkZXJNZXRhZGF0YSA9IHByb3ZpZGVyTWV0YWRhdGE7XG4gIH1cbiAgZ2V0IHRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5maWx0ZXIoKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJ0ZXh0XCIpLm1hcCgocGFydCkgPT4gcGFydC50ZXh0KS5qb2luKFwiXCIpO1xuICB9XG4gIGdldCByZWFzb25pbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5maWx0ZXIoKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJyZWFzb25pbmdcIik7XG4gIH1cbiAgZ2V0IHJlYXNvbmluZ1RleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhc29uaW5nLmxlbmd0aCA9PT0gMCA/IHZvaWQgMCA6IHRoaXMucmVhc29uaW5nLm1hcCgocGFydCkgPT4gcGFydC50ZXh0KS5qb2luKFwiXCIpO1xuICB9XG4gIGdldCBmaWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50LmZpbHRlcigocGFydCkgPT4gcGFydC50eXBlID09PSBcImZpbGVcIikubWFwKChwYXJ0KSA9PiBwYXJ0LmZpbGUpO1xuICB9XG4gIGdldCBzb3VyY2VzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwic291cmNlXCIpO1xuICB9XG4gIGdldCB0b29sQ2FsbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5maWx0ZXIoKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJ0b29sLWNhbGxcIik7XG4gIH1cbiAgZ2V0IHN0YXRpY1Rvb2xDYWxscygpIHtcbiAgICByZXR1cm4gdGhpcy50b29sQ2FsbHMuZmlsdGVyKFxuICAgICAgKHRvb2xDYWxsKSA9PiB0b29sQ2FsbC5keW5hbWljICE9PSB0cnVlXG4gICAgKTtcbiAgfVxuICBnZXQgZHluYW1pY1Rvb2xDYWxscygpIHtcbiAgICByZXR1cm4gdGhpcy50b29sQ2FsbHMuZmlsdGVyKFxuICAgICAgKHRvb2xDYWxsKSA9PiB0b29sQ2FsbC5keW5hbWljID09PSB0cnVlXG4gICAgKTtcbiAgfVxuICBnZXQgdG9vbFJlc3VsdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5maWx0ZXIoKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJ0b29sLXJlc3VsdFwiKTtcbiAgfVxuICBnZXQgc3RhdGljVG9vbFJlc3VsdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9vbFJlc3VsdHMuZmlsdGVyKFxuICAgICAgKHRvb2xSZXN1bHQpID0+IHRvb2xSZXN1bHQuZHluYW1pYyAhPT0gdHJ1ZVxuICAgICk7XG4gIH1cbiAgZ2V0IGR5bmFtaWNUb29sUmVzdWx0cygpIHtcbiAgICByZXR1cm4gdGhpcy50b29sUmVzdWx0cy5maWx0ZXIoXG4gICAgICAodG9vbFJlc3VsdCkgPT4gdG9vbFJlc3VsdC5keW5hbWljID09PSB0cnVlXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL2dlbmVyYXRlLXRleHQvc3RvcC1jb25kaXRpb24udHNcbmZ1bmN0aW9uIHN0ZXBDb3VudElzKHN0ZXBDb3VudCkge1xuICByZXR1cm4gKHsgc3RlcHMgfSkgPT4gc3RlcHMubGVuZ3RoID09PSBzdGVwQ291bnQ7XG59XG5mdW5jdGlvbiBoYXNUb29sQ2FsbCh0b29sTmFtZSkge1xuICByZXR1cm4gKHsgc3RlcHMgfSkgPT4ge1xuICAgIHZhciBfYTIxLCBfYiwgX2M7XG4gICAgcmV0dXJuIChfYyA9IChfYiA9IChfYTIxID0gc3RlcHNbc3RlcHMubGVuZ3RoIC0gMV0pID09IG51bGwgPyB2b2lkIDAgOiBfYTIxLnRvb2xDYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnNvbWUoXG4gICAgICAodG9vbENhbGwpID0+IHRvb2xDYWxsLnRvb2xOYW1lID09PSB0b29sTmFtZVxuICAgICkpICE9IG51bGwgPyBfYyA6IGZhbHNlO1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gaXNTdG9wQ29uZGl0aW9uTWV0KHtcbiAgc3RvcENvbmRpdGlvbnMsXG4gIHN0ZXBzXG59KSB7XG4gIHJldHVybiAoYXdhaXQgUHJvbWlzZS5hbGwoc3RvcENvbmRpdGlvbnMubWFwKChjb25kaXRpb24pID0+IGNvbmRpdGlvbih7IHN0ZXBzIH0pKSkpLnNvbWUoKHJlc3VsdCkgPT4gcmVzdWx0KTtcbn1cblxuLy8gc3JjL2dlbmVyYXRlLXRleHQvdG8tcmVzcG9uc2UtbWVzc2FnZXMudHNcbmFzeW5jIGZ1bmN0aW9uIHRvUmVzcG9uc2VNZXNzYWdlcyh7XG4gIGNvbnRlbnQ6IGlucHV0Q29udGVudCxcbiAgdG9vbHNcbn0pIHtcbiAgY29uc3QgcmVzcG9uc2VNZXNzYWdlcyA9IFtdO1xuICBjb25zdCBjb250ZW50ID0gW107XG4gIGZvciAoY29uc3QgcGFydCBvZiBpbnB1dENvbnRlbnQpIHtcbiAgICBpZiAocGFydC50eXBlID09PSBcInNvdXJjZVwiKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKChwYXJ0LnR5cGUgPT09IFwidG9vbC1yZXN1bHRcIiB8fCBwYXJ0LnR5cGUgPT09IFwidG9vbC1lcnJvclwiKSAmJiAhcGFydC5wcm92aWRlckV4ZWN1dGVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0ZXh0XCIgJiYgcGFydC50ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgIHRleHQ6IHBhcnQudGV4dCxcbiAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHBhcnQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicmVhc29uaW5nXCI6XG4gICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJyZWFzb25pbmdcIixcbiAgICAgICAgICB0ZXh0OiBwYXJ0LnRleHQsXG4gICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImZpbGVcIjpcbiAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICBkYXRhOiBwYXJ0LmZpbGUuYmFzZTY0LFxuICAgICAgICAgIG1lZGlhVHlwZTogcGFydC5maWxlLm1lZGlhVHlwZSxcbiAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHBhcnQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidG9vbC1jYWxsXCI6XG4gICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgaW5wdXQ6IHBhcnQuaW5wdXQsXG4gICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogcGFydC5wcm92aWRlckV4ZWN1dGVkLFxuICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ0b29sLXJlc3VsdFwiOiB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IGNyZWF0ZVRvb2xNb2RlbE91dHB1dCh7XG4gICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgIGlucHV0OiBwYXJ0LmlucHV0LFxuICAgICAgICAgIHRvb2w6IHRvb2xzID09IG51bGwgPyB2b2lkIDAgOiB0b29sc1twYXJ0LnRvb2xOYW1lXSxcbiAgICAgICAgICBvdXRwdXQ6IHBhcnQub3V0cHV0LFxuICAgICAgICAgIGVycm9yTW9kZTogXCJub25lXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInRvb2wtZXJyb3JcIjoge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCBjcmVhdGVUb29sTW9kZWxPdXRwdXQoe1xuICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICBpbnB1dDogcGFydC5pbnB1dCxcbiAgICAgICAgICB0b29sOiB0b29scyA9PSBudWxsID8gdm9pZCAwIDogdG9vbHNbcGFydC50b29sTmFtZV0sXG4gICAgICAgICAgb3V0cHV0OiBwYXJ0LmVycm9yLFxuICAgICAgICAgIGVycm9yTW9kZTogXCJqc29uXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInRvb2wtYXBwcm92YWwtcmVxdWVzdFwiOlxuICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCIsXG4gICAgICAgICAgYXBwcm92YWxJZDogcGFydC5hcHByb3ZhbElkLFxuICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGwudG9vbENhbGxJZFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChjb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICByZXNwb25zZU1lc3NhZ2VzLnB1c2goe1xuICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgIGNvbnRlbnRcbiAgICB9KTtcbiAgfVxuICBjb25zdCB0b29sUmVzdWx0Q29udGVudCA9IFtdO1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgaW5wdXRDb250ZW50KSB7XG4gICAgaWYgKCEocGFydC50eXBlID09PSBcInRvb2wtcmVzdWx0XCIgfHwgcGFydC50eXBlID09PSBcInRvb2wtZXJyb3JcIikgfHwgcGFydC5wcm92aWRlckV4ZWN1dGVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgY3JlYXRlVG9vbE1vZGVsT3V0cHV0KHtcbiAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgIGlucHV0OiBwYXJ0LmlucHV0LFxuICAgICAgdG9vbDogdG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xzW3BhcnQudG9vbE5hbWVdLFxuICAgICAgb3V0cHV0OiBwYXJ0LnR5cGUgPT09IFwidG9vbC1yZXN1bHRcIiA/IHBhcnQub3V0cHV0IDogcGFydC5lcnJvcixcbiAgICAgIGVycm9yTW9kZTogcGFydC50eXBlID09PSBcInRvb2wtZXJyb3JcIiA/IFwidGV4dFwiIDogXCJub25lXCJcbiAgICB9KTtcbiAgICB0b29sUmVzdWx0Q29udGVudC5wdXNoKHtcbiAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgb3V0cHV0LFxuICAgICAgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgIH0pO1xuICB9XG4gIGlmICh0b29sUmVzdWx0Q29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgcmVzcG9uc2VNZXNzYWdlcy5wdXNoKHtcbiAgICAgIHJvbGU6IFwidG9vbFwiLFxuICAgICAgY29udGVudDogdG9vbFJlc3VsdENvbnRlbnRcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzcG9uc2VNZXNzYWdlcztcbn1cblxuLy8gc3JjL3V0aWwvbWVyZ2UtYWJvcnQtc2lnbmFscy50c1xuZnVuY3Rpb24gbWVyZ2VBYm9ydFNpZ25hbHMoLi4uc2lnbmFscykge1xuICBjb25zdCB2YWxpZFNpZ25hbHMgPSBzaWduYWxzLmZpbHRlcihcbiAgICAoc2lnbmFsKSA9PiBzaWduYWwgIT0gbnVsbFxuICApO1xuICBpZiAodmFsaWRTaWduYWxzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKHZhbGlkU2lnbmFscy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gdmFsaWRTaWduYWxzWzBdO1xuICB9XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gIGZvciAoY29uc3Qgc2lnbmFsIG9mIHZhbGlkU2lnbmFscykge1xuICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgY29udHJvbGxlci5hYm9ydChzaWduYWwucmVhc29uKTtcbiAgICAgIHJldHVybiBjb250cm9sbGVyLnNpZ25hbDtcbiAgICB9XG4gICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcImFib3J0XCIsXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoc2lnbmFsLnJlYXNvbik7XG4gICAgICB9LFxuICAgICAgeyBvbmNlOiB0cnVlIH1cbiAgICApO1xuICB9XG4gIHJldHVybiBjb250cm9sbGVyLnNpZ25hbDtcbn1cblxuLy8gc3JjL2dlbmVyYXRlLXRleHQvZ2VuZXJhdGUtdGV4dC50c1xudmFyIG9yaWdpbmFsR2VuZXJhdGVJZCA9IGNyZWF0ZUlkR2VuZXJhdG9yKHtcbiAgcHJlZml4OiBcImFpdHh0XCIsXG4gIHNpemU6IDI0XG59KTtcbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlVGV4dCh7XG4gIG1vZGVsOiBtb2RlbEFyZyxcbiAgdG9vbHMsXG4gIHRvb2xDaG9pY2UsXG4gIHN5c3RlbSxcbiAgcHJvbXB0LFxuICBtZXNzYWdlcyxcbiAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgYWJvcnRTaWduYWwsXG4gIHRpbWVvdXQsXG4gIGhlYWRlcnMsXG4gIHN0b3BXaGVuID0gc3RlcENvdW50SXMoMSksXG4gIGV4cGVyaW1lbnRhbF9vdXRwdXQsXG4gIG91dHB1dCA9IGV4cGVyaW1lbnRhbF9vdXRwdXQsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeSxcbiAgcHJvdmlkZXJPcHRpb25zLFxuICBleHBlcmltZW50YWxfYWN0aXZlVG9vbHMsXG4gIGFjdGl2ZVRvb2xzID0gZXhwZXJpbWVudGFsX2FjdGl2ZVRvb2xzLFxuICBleHBlcmltZW50YWxfcHJlcGFyZVN0ZXAsXG4gIHByZXBhcmVTdGVwID0gZXhwZXJpbWVudGFsX3ByZXBhcmVTdGVwLFxuICBleHBlcmltZW50YWxfcmVwYWlyVG9vbENhbGw6IHJlcGFpclRvb2xDYWxsLFxuICBleHBlcmltZW50YWxfZG93bmxvYWQ6IGRvd25sb2FkMixcbiAgZXhwZXJpbWVudGFsX2NvbnRleHQsXG4gIGV4cGVyaW1lbnRhbF9pbmNsdWRlOiBpbmNsdWRlLFxuICBfaW50ZXJuYWw6IHsgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDIgPSBvcmlnaW5hbEdlbmVyYXRlSWQgfSA9IHt9LFxuICBleHBlcmltZW50YWxfb25TdGFydDogb25TdGFydCxcbiAgZXhwZXJpbWVudGFsX29uU3RlcFN0YXJ0OiBvblN0ZXBTdGFydCxcbiAgZXhwZXJpbWVudGFsX29uVG9vbENhbGxTdGFydDogb25Ub29sQ2FsbFN0YXJ0LFxuICBleHBlcmltZW50YWxfb25Ub29sQ2FsbEZpbmlzaDogb25Ub29sQ2FsbEZpbmlzaCxcbiAgb25TdGVwRmluaXNoLFxuICBvbkZpbmlzaCxcbiAgLi4uc2V0dGluZ3Ncbn0pIHtcbiAgY29uc3QgbW9kZWwgPSByZXNvbHZlTGFuZ3VhZ2VNb2RlbChtb2RlbEFyZyk7XG4gIGNvbnN0IHN0b3BDb25kaXRpb25zID0gYXNBcnJheShzdG9wV2hlbik7XG4gIGNvbnN0IHRvdGFsVGltZW91dE1zID0gZ2V0VG90YWxUaW1lb3V0TXModGltZW91dCk7XG4gIGNvbnN0IHN0ZXBUaW1lb3V0TXMgPSBnZXRTdGVwVGltZW91dE1zKHRpbWVvdXQpO1xuICBjb25zdCBzdGVwQWJvcnRDb250cm9sbGVyID0gc3RlcFRpbWVvdXRNcyAhPSBudWxsID8gbmV3IEFib3J0Q29udHJvbGxlcigpIDogdm9pZCAwO1xuICBjb25zdCBtZXJnZWRBYm9ydFNpZ25hbCA9IG1lcmdlQWJvcnRTaWduYWxzKFxuICAgIGFib3J0U2lnbmFsLFxuICAgIHRvdGFsVGltZW91dE1zICE9IG51bGwgPyBBYm9ydFNpZ25hbC50aW1lb3V0KHRvdGFsVGltZW91dE1zKSA6IHZvaWQgMCxcbiAgICBzdGVwQWJvcnRDb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBzdGVwQWJvcnRDb250cm9sbGVyLnNpZ25hbFxuICApO1xuICBjb25zdCB7IG1heFJldHJpZXMsIHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7XG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICBhYm9ydFNpZ25hbDogbWVyZ2VkQWJvcnRTaWduYWxcbiAgfSk7XG4gIGNvbnN0IGNhbGxTZXR0aW5ncyA9IHByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpO1xuICBjb25zdCBoZWFkZXJzV2l0aFVzZXJBZ2VudCA9IHdpdGhVc2VyQWdlbnRTdWZmaXgyKFxuICAgIGhlYWRlcnMgIT0gbnVsbCA/IGhlYWRlcnMgOiB7fSxcbiAgICBgYWkvJHtWRVJTSU9OfWBcbiAgKTtcbiAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnM6IGhlYWRlcnNXaXRoVXNlckFnZW50LFxuICAgIHNldHRpbmdzOiB7IC4uLmNhbGxTZXR0aW5ncywgbWF4UmV0cmllcyB9XG4gIH0pO1xuICBjb25zdCBtb2RlbEluZm8gPSB7IHByb3ZpZGVyOiBtb2RlbC5wcm92aWRlciwgbW9kZWxJZDogbW9kZWwubW9kZWxJZCB9O1xuICBjb25zdCBpbml0aWFsUHJvbXB0ID0gYXdhaXQgc3RhbmRhcmRpemVQcm9tcHQoe1xuICAgIHN5c3RlbSxcbiAgICBwcm9tcHQsXG4gICAgbWVzc2FnZXNcbiAgfSk7XG4gIHRyeSB7XG4gICAgYXdhaXQgKG9uU3RhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uU3RhcnQoe1xuICAgICAgbW9kZWw6IG1vZGVsSW5mbyxcbiAgICAgIHN5c3RlbSxcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2VzLFxuICAgICAgdG9vbHMsXG4gICAgICB0b29sQ2hvaWNlLFxuICAgICAgYWN0aXZlVG9vbHMsXG4gICAgICBtYXhPdXRwdXRUb2tlbnM6IGNhbGxTZXR0aW5ncy5tYXhPdXRwdXRUb2tlbnMsXG4gICAgICB0ZW1wZXJhdHVyZTogY2FsbFNldHRpbmdzLnRlbXBlcmF0dXJlLFxuICAgICAgdG9wUDogY2FsbFNldHRpbmdzLnRvcFAsXG4gICAgICB0b3BLOiBjYWxsU2V0dGluZ3MudG9wSyxcbiAgICAgIHByZXNlbmNlUGVuYWx0eTogY2FsbFNldHRpbmdzLnByZXNlbmNlUGVuYWx0eSxcbiAgICAgIGZyZXF1ZW5jeVBlbmFsdHk6IGNhbGxTZXR0aW5ncy5mcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgc3RvcFNlcXVlbmNlczogY2FsbFNldHRpbmdzLnN0b3BTZXF1ZW5jZXMsXG4gICAgICBzZWVkOiBjYWxsU2V0dGluZ3Muc2VlZCxcbiAgICAgIG1heFJldHJpZXMsXG4gICAgICB0aW1lb3V0LFxuICAgICAgaGVhZGVycyxcbiAgICAgIHByb3ZpZGVyT3B0aW9ucyxcbiAgICAgIHN0b3BXaGVuLFxuICAgICAgb3V0cHV0LFxuICAgICAgYWJvcnRTaWduYWwsXG4gICAgICBpbmNsdWRlLFxuICAgICAgZnVuY3Rpb25JZDogdGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuZnVuY3Rpb25JZCxcbiAgICAgIG1ldGFkYXRhOiB0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5tZXRhZGF0YSxcbiAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0XG4gICAgfSkpO1xuICB9IGNhdGNoIChfaWdub3JlZCkge1xuICB9XG4gIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcih0ZWxlbWV0cnkpO1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCByZWNvcmRTcGFuKHtcbiAgICAgIG5hbWU6IFwiYWkuZ2VuZXJhdGVUZXh0XCIsXG4gICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmdlbmVyYXRlVGV4dFwiLFxuICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgfSksXG4gICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgLy8gbW9kZWw6XG4gICAgICAgICAgXCJhaS5tb2RlbC5wcm92aWRlclwiOiBtb2RlbC5wcm92aWRlcixcbiAgICAgICAgICBcImFpLm1vZGVsLmlkXCI6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICAgIFwiYWkucHJvbXB0XCI6IHtcbiAgICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICB0cmFjZXIsXG4gICAgICBmbjogYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgICAgdmFyIF9hMjEsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaSwgX2osIF9rLCBfbCwgX207XG4gICAgICAgIGNvbnN0IGluaXRpYWxNZXNzYWdlcyA9IGluaXRpYWxQcm9tcHQubWVzc2FnZXM7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlTWVzc2FnZXMgPSBbXTtcbiAgICAgICAgY29uc3QgeyBhcHByb3ZlZFRvb2xBcHByb3ZhbHMsIGRlbmllZFRvb2xBcHByb3ZhbHMgfSA9IGNvbGxlY3RUb29sQXBwcm92YWxzKHsgbWVzc2FnZXM6IGluaXRpYWxNZXNzYWdlcyB9KTtcbiAgICAgICAgY29uc3QgbG9jYWxBcHByb3ZlZFRvb2xBcHByb3ZhbHMgPSBhcHByb3ZlZFRvb2xBcHByb3ZhbHMuZmlsdGVyKFxuICAgICAgICAgICh0b29sQXBwcm92YWwpID0+ICF0b29sQXBwcm92YWwudG9vbENhbGwucHJvdmlkZXJFeGVjdXRlZFxuICAgICAgICApO1xuICAgICAgICBpZiAoZGVuaWVkVG9vbEFwcHJvdmFscy5sZW5ndGggPiAwIHx8IGxvY2FsQXBwcm92ZWRUb29sQXBwcm92YWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCB0b29sT3V0cHV0cyA9IGF3YWl0IGV4ZWN1dGVUb29scyh7XG4gICAgICAgICAgICB0b29sQ2FsbHM6IGxvY2FsQXBwcm92ZWRUb29sQXBwcm92YWxzLm1hcChcbiAgICAgICAgICAgICAgKHRvb2xBcHByb3ZhbCkgPT4gdG9vbEFwcHJvdmFsLnRvb2xDYWxsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICBtZXNzYWdlczogaW5pdGlhbE1lc3NhZ2VzLFxuICAgICAgICAgICAgYWJvcnRTaWduYWw6IG1lcmdlZEFib3J0U2lnbmFsLFxuICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHQsXG4gICAgICAgICAgICBzdGVwTnVtYmVyOiAwLFxuICAgICAgICAgICAgbW9kZWw6IG1vZGVsSW5mbyxcbiAgICAgICAgICAgIG9uVG9vbENhbGxTdGFydCxcbiAgICAgICAgICAgIG9uVG9vbENhbGxGaW5pc2hcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCB0b29sQ29udGVudCA9IFtdO1xuICAgICAgICAgIGZvciAoY29uc3Qgb3V0cHV0MiBvZiB0b29sT3V0cHV0cykge1xuICAgICAgICAgICAgY29uc3QgbW9kZWxPdXRwdXQgPSBhd2FpdCBjcmVhdGVUb29sTW9kZWxPdXRwdXQoe1xuICAgICAgICAgICAgICB0b29sQ2FsbElkOiBvdXRwdXQyLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgIGlucHV0OiBvdXRwdXQyLmlucHV0LFxuICAgICAgICAgICAgICB0b29sOiB0b29scyA9PSBudWxsID8gdm9pZCAwIDogdG9vbHNbb3V0cHV0Mi50b29sTmFtZV0sXG4gICAgICAgICAgICAgIG91dHB1dDogb3V0cHV0Mi50eXBlID09PSBcInRvb2wtcmVzdWx0XCIgPyBvdXRwdXQyLm91dHB1dCA6IG91dHB1dDIuZXJyb3IsXG4gICAgICAgICAgICAgIGVycm9yTW9kZTogb3V0cHV0Mi50eXBlID09PSBcInRvb2wtZXJyb3JcIiA/IFwianNvblwiIDogXCJub25lXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdG9vbENvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogb3V0cHV0Mi50b29sQ2FsbElkLFxuICAgICAgICAgICAgICB0b29sTmFtZTogb3V0cHV0Mi50b29sTmFtZSxcbiAgICAgICAgICAgICAgb3V0cHV0OiBtb2RlbE91dHB1dFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoY29uc3QgdG9vbEFwcHJvdmFsIG9mIGRlbmllZFRvb2xBcHByb3ZhbHMpIHtcbiAgICAgICAgICAgIHRvb2xDb250ZW50LnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xBcHByb3ZhbC50b29sQ2FsbC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICB0b29sTmFtZTogdG9vbEFwcHJvdmFsLnRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgICAgICAgICBvdXRwdXQ6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImV4ZWN1dGlvbi1kZW5pZWRcIixcbiAgICAgICAgICAgICAgICByZWFzb246IHRvb2xBcHByb3ZhbC5hcHByb3ZhbFJlc3BvbnNlLnJlYXNvbixcbiAgICAgICAgICAgICAgICAvLyBGb3IgcHJvdmlkZXItZXhlY3V0ZWQgdG9vbHMsIGluY2x1ZGUgYXBwcm92YWxJZCBzbyBwcm92aWRlciBjYW4gY29ycmVsYXRlXG4gICAgICAgICAgICAgICAgLi4udG9vbEFwcHJvdmFsLnRvb2xDYWxsLnByb3ZpZGVyRXhlY3V0ZWQgJiYge1xuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5haToge1xuICAgICAgICAgICAgICAgICAgICAgIGFwcHJvdmFsSWQ6IHRvb2xBcHByb3ZhbC5hcHByb3ZhbFJlc3BvbnNlLmFwcHJvdmFsSWRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgICByb2xlOiBcInRvb2xcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRvb2xDb250ZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvdmlkZXJFeGVjdXRlZFRvb2xBcHByb3ZhbHMgPSBbXG4gICAgICAgICAgLi4uYXBwcm92ZWRUb29sQXBwcm92YWxzLFxuICAgICAgICAgIC4uLmRlbmllZFRvb2xBcHByb3ZhbHNcbiAgICAgICAgXS5maWx0ZXIoKHRvb2xBcHByb3ZhbCkgPT4gdG9vbEFwcHJvdmFsLnRvb2xDYWxsLnByb3ZpZGVyRXhlY3V0ZWQpO1xuICAgICAgICBpZiAocHJvdmlkZXJFeGVjdXRlZFRvb2xBcHByb3ZhbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgICByb2xlOiBcInRvb2xcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IHByb3ZpZGVyRXhlY3V0ZWRUb29sQXBwcm92YWxzLm1hcChcbiAgICAgICAgICAgICAgKHRvb2xBcHByb3ZhbCkgPT4gKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtYXBwcm92YWwtcmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICBhcHByb3ZhbElkOiB0b29sQXBwcm92YWwuYXBwcm92YWxSZXNwb25zZS5hcHByb3ZhbElkLFxuICAgICAgICAgICAgICAgIGFwcHJvdmVkOiB0b29sQXBwcm92YWwuYXBwcm92YWxSZXNwb25zZS5hcHByb3ZlZCxcbiAgICAgICAgICAgICAgICByZWFzb246IHRvb2xBcHByb3ZhbC5hcHByb3ZhbFJlc3BvbnNlLnJlYXNvbixcbiAgICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB0cnVlXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FsbFNldHRpbmdzMiA9IHByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgICAgICBsZXQgY3VycmVudE1vZGVsUmVzcG9uc2U7XG4gICAgICAgIGxldCBjbGllbnRUb29sQ2FsbHMgPSBbXTtcbiAgICAgICAgbGV0IGNsaWVudFRvb2xPdXRwdXRzID0gW107XG4gICAgICAgIGNvbnN0IHN0ZXBzID0gW107XG4gICAgICAgIGNvbnN0IHBlbmRpbmdEZWZlcnJlZFRvb2xDYWxscyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBjb25zdCBzdGVwVGltZW91dElkID0gc3RlcFRpbWVvdXRNcyAhPSBudWxsID8gc2V0VGltZW91dCgoKSA9PiBzdGVwQWJvcnRDb250cm9sbGVyLmFib3J0KCksIHN0ZXBUaW1lb3V0TXMpIDogdm9pZCAwO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzdGVwSW5wdXRNZXNzYWdlcyA9IFsuLi5pbml0aWFsTWVzc2FnZXMsIC4uLnJlc3BvbnNlTWVzc2FnZXNdO1xuICAgICAgICAgICAgY29uc3QgcHJlcGFyZVN0ZXBSZXN1bHQgPSBhd2FpdCAocHJlcGFyZVN0ZXAgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwKHtcbiAgICAgICAgICAgICAgbW9kZWwsXG4gICAgICAgICAgICAgIHN0ZXBzLFxuICAgICAgICAgICAgICBzdGVwTnVtYmVyOiBzdGVwcy5sZW5ndGgsXG4gICAgICAgICAgICAgIG1lc3NhZ2VzOiBzdGVwSW5wdXRNZXNzYWdlcyxcbiAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHRcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBNb2RlbCA9IHJlc29sdmVMYW5ndWFnZU1vZGVsKFxuICAgICAgICAgICAgICAoX2EyMSA9IHByZXBhcmVTdGVwUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcFJlc3VsdC5tb2RlbCkgIT0gbnVsbCA/IF9hMjEgOiBtb2RlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBNb2RlbEluZm8gPSB7XG4gICAgICAgICAgICAgIHByb3ZpZGVyOiBzdGVwTW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgIG1vZGVsSWQ6IHN0ZXBNb2RlbC5tb2RlbElkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcHJvbXB0TWVzc2FnZXMgPSBhd2FpdCBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgICAgICAgICAgICAgcHJvbXB0OiB7XG4gICAgICAgICAgICAgICAgc3lzdGVtOiAoX2IgPSBwcmVwYXJlU3RlcFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZVN0ZXBSZXN1bHQuc3lzdGVtKSAhPSBudWxsID8gX2IgOiBpbml0aWFsUHJvbXB0LnN5c3RlbSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlczogKF9jID0gcHJlcGFyZVN0ZXBSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwUmVzdWx0Lm1lc3NhZ2VzKSAhPSBudWxsID8gX2MgOiBzdGVwSW5wdXRNZXNzYWdlc1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzdXBwb3J0ZWRVcmxzOiBhd2FpdCBzdGVwTW9kZWwuc3VwcG9ydGVkVXJscyxcbiAgICAgICAgICAgICAgZG93bmxvYWQ6IGRvd25sb2FkMlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlcmltZW50YWxfY29udGV4dCA9IChfZCA9IHByZXBhcmVTdGVwUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcFJlc3VsdC5leHBlcmltZW50YWxfY29udGV4dCkgIT0gbnVsbCA/IF9kIDogZXhwZXJpbWVudGFsX2NvbnRleHQ7XG4gICAgICAgICAgICBjb25zdCBzdGVwQWN0aXZlVG9vbHMgPSAoX2UgPSBwcmVwYXJlU3RlcFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZVN0ZXBSZXN1bHQuYWN0aXZlVG9vbHMpICE9IG51bGwgPyBfZSA6IGFjdGl2ZVRvb2xzO1xuICAgICAgICAgICAgY29uc3QgeyB0b29sQ2hvaWNlOiBzdGVwVG9vbENob2ljZSwgdG9vbHM6IHN0ZXBUb29scyB9ID0gYXdhaXQgcHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZSh7XG4gICAgICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgICAgICB0b29sQ2hvaWNlOiAoX2YgPSBwcmVwYXJlU3RlcFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZVN0ZXBSZXN1bHQudG9vbENob2ljZSkgIT0gbnVsbCA/IF9mIDogdG9vbENob2ljZSxcbiAgICAgICAgICAgICAgYWN0aXZlVG9vbHM6IHN0ZXBBY3RpdmVUb29sc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzdGVwTWVzc2FnZXMgPSAoX2cgPSBwcmVwYXJlU3RlcFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZVN0ZXBSZXN1bHQubWVzc2FnZXMpICE9IG51bGwgPyBfZyA6IHN0ZXBJbnB1dE1lc3NhZ2VzO1xuICAgICAgICAgICAgY29uc3Qgc3RlcFN5c3RlbSA9IChfaCA9IHByZXBhcmVTdGVwUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcFJlc3VsdC5zeXN0ZW0pICE9IG51bGwgPyBfaCA6IGluaXRpYWxQcm9tcHQuc3lzdGVtO1xuICAgICAgICAgICAgY29uc3Qgc3RlcFByb3ZpZGVyT3B0aW9ucyA9IG1lcmdlT2JqZWN0cyhcbiAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zLFxuICAgICAgICAgICAgICBwcmVwYXJlU3RlcFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZVN0ZXBSZXN1bHQucHJvdmlkZXJPcHRpb25zXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXdhaXQgKG9uU3RlcFN0YXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvblN0ZXBTdGFydCh7XG4gICAgICAgICAgICAgICAgc3RlcE51bWJlcjogc3RlcHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG1vZGVsOiBzdGVwTW9kZWxJbmZvLFxuICAgICAgICAgICAgICAgIHN5c3RlbTogc3RlcFN5c3RlbSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlczogc3RlcE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgICAgICAgIHRvb2xDaG9pY2U6IHN0ZXBUb29sQ2hvaWNlLFxuICAgICAgICAgICAgICAgIGFjdGl2ZVRvb2xzOiBzdGVwQWN0aXZlVG9vbHMsXG4gICAgICAgICAgICAgICAgc3RlcHM6IFsuLi5zdGVwc10sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBzdGVwUHJvdmlkZXJPcHRpb25zLFxuICAgICAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzdG9wV2hlbixcbiAgICAgICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgaW5jbHVkZSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbklkOiB0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5mdW5jdGlvbklkLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiB0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBleHBlcmltZW50YWxfY29udGV4dFxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9IGNhdGNoIChfaWdub3JlZCkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudE1vZGVsUmVzcG9uc2UgPSBhd2FpdCByZXRyeShcbiAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTIyO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwiYWkuZ2VuZXJhdGVUZXh0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZ2VuZXJhdGVUZXh0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIG1vZGVsOlxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkubW9kZWwucHJvdmlkZXJcIjogc3RlcE1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkubW9kZWwuaWRcIjogc3RlcE1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gcHJvbXB0OlxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0Lm1lc3NhZ2VzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBzdHJpbmdpZnlGb3JUZWxlbWV0cnkocHJvbXB0TWVzc2FnZXMpXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnByb21wdC50b29sc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHRoZSBsYW5ndWFnZSBtb2RlbCBsZXZlbCB0b29sczpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBzdGVwVG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHN0ZXBUb29scy5tYXAoKHRvb2wyKSA9PiBKU09OLnN0cmluZ2lmeSh0b29sMikpXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnByb21wdC50b29sQ2hvaWNlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBzdGVwVG9vbENob2ljZSAhPSBudWxsID8gSlNPTi5zdHJpbmdpZnkoc3RlcFRvb2xDaG9pY2UpIDogdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkuc3lzdGVtXCI6IHN0ZXBNb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1vZGVsXCI6IHN0ZXBNb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QuZnJlcXVlbmN5X3BlbmFsdHlcIjogc2V0dGluZ3MuZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1heF90b2tlbnNcIjogc2V0dGluZ3MubWF4T3V0cHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QucHJlc2VuY2VfcGVuYWx0eVwiOiBzZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHksXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5zdG9wX3NlcXVlbmNlc1wiOiBzZXR0aW5ncy5zdG9wU2VxdWVuY2VzLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudGVtcGVyYXR1cmVcIjogKF9hMjIgPSBzZXR0aW5ncy50ZW1wZXJhdHVyZSkgIT0gbnVsbCA/IF9hMjIgOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3Bfa1wiOiBzZXR0aW5ncy50b3BLLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX3BcIjogc2V0dGluZ3MudG9wUFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgICAgICAgIGZuOiBhc3luYyAoc3BhbjIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hMjMsIF9iMiwgX2MyLCBfZDIsIF9lMiwgX2YyLCBfZzIsIF9oMjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3RlcE1vZGVsLmRvR2VuZXJhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgIC4uLmNhbGxTZXR0aW5nczIsXG4gICAgICAgICAgICAgICAgICAgICAgdG9vbHM6IHN0ZXBUb29scyxcbiAgICAgICAgICAgICAgICAgICAgICB0b29sQ2hvaWNlOiBzdGVwVG9vbENob2ljZSxcbiAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZUZvcm1hdDogYXdhaXQgKG91dHB1dCA9PSBudWxsID8gdm9pZCAwIDogb3V0cHV0LnJlc3BvbnNlRm9ybWF0KSxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9tcHQ6IHByb21wdE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogc3RlcFByb3ZpZGVyT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogbWVyZ2VkQWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyc1dpdGhVc2VyQWdlbnRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICBpZDogKF9iMiA9IChfYTIzID0gcmVzdWx0LnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyMy5pZCkgIT0gbnVsbCA/IF9iMiA6IGdlbmVyYXRlSWQyKCksXG4gICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiAoX2QyID0gKF9jMiA9IHJlc3VsdC5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jMi50aW1lc3RhbXApICE9IG51bGwgPyBfZDIgOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICAgICAgICBtb2RlbElkOiAoX2YyID0gKF9lMiA9IHJlc3VsdC5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lMi5tb2RlbElkKSAhPSBudWxsID8gX2YyIDogc3RlcE1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogKF9nMiA9IHJlc3VsdC5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nMi5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IChfaDIgPSByZXN1bHQucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfaDIuYm9keVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBzcGFuMi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiByZXN1bHQuZmluaXNoUmVhc29uLnVuaWZpZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGV4dFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBleHRyYWN0VGV4dENvbnRlbnQocmVzdWx0LmNvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UucmVhc29uaW5nXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGV4dHJhY3RSZWFzb25pbmdDb250ZW50KHJlc3VsdC5jb250ZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRvb2xDYWxsc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSBhc1Rvb2xDYWxscyhyZXN1bHQuY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9vbENhbGxzID09IG51bGwgPyB2b2lkIDAgOiBKU09OLnN0cmluZ2lmeSh0b29sQ2FsbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5pZFwiOiByZXNwb25zZURhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGltZXN0YW1wXCI6IHJlc3BvbnNlRGF0YS50aW1lc3RhbXAudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5wcm92aWRlck1ldGFkYXRhXCI6IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gcmVuYW1lIHRlbGVtZXRyeSBhdHRyaWJ1dGVzIHRvIGlucHV0VG9rZW5zIGFuZCBvdXRwdXRUb2tlbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogcmVzdWx0LnVzYWdlLmlucHV0VG9rZW5zLnRvdGFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogcmVzdWx0LnVzYWdlLm91dHB1dFRva2Vucy50b3RhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5maW5pc2hfcmVhc29uc1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmZpbmlzaFJlYXNvbi51bmlmaWVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmlkXCI6IHJlc3BvbnNlRGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmlucHV0X3Rva2Vuc1wiOiByZXN1bHQudXNhZ2UuaW5wdXRUb2tlbnMudG90YWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogcmVzdWx0LnVzYWdlLm91dHB1dFRva2Vucy50b3RhbFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLnJlc3VsdCwgcmVzcG9uc2U6IHJlc3BvbnNlRGF0YSB9O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3Qgc3RlcFRvb2xDYWxscyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgICBjdXJyZW50TW9kZWxSZXNwb25zZS5jb250ZW50LmZpbHRlcihcbiAgICAgICAgICAgICAgICAocGFydCkgPT4gcGFydC50eXBlID09PSBcInRvb2wtY2FsbFwiXG4gICAgICAgICAgICAgICkubWFwKFxuICAgICAgICAgICAgICAgICh0b29sQ2FsbCkgPT4gcGFyc2VUb29sQ2FsbCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbCxcbiAgICAgICAgICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgICAgICAgICAgcmVwYWlyVG9vbENhbGwsXG4gICAgICAgICAgICAgICAgICBzeXN0ZW0sXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlczogc3RlcElucHV0TWVzc2FnZXNcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgdG9vbEFwcHJvdmFsUmVxdWVzdHMgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbENhbGwgb2Ygc3RlcFRvb2xDYWxscykge1xuICAgICAgICAgICAgICBpZiAodG9vbENhbGwuaW52YWxpZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHRvb2wyID0gdG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xzW3Rvb2xDYWxsLnRvb2xOYW1lXTtcbiAgICAgICAgICAgICAgaWYgKHRvb2wyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoKHRvb2wyID09IG51bGwgPyB2b2lkIDAgOiB0b29sMi5vbklucHV0QXZhaWxhYmxlKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdG9vbDIub25JbnB1dEF2YWlsYWJsZSh7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogdG9vbENhbGwuaW5wdXQsXG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZXM6IHN0ZXBJbnB1dE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IG1lcmdlZEFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoYXdhaXQgaXNBcHByb3ZhbE5lZWRlZCh7XG4gICAgICAgICAgICAgICAgdG9vbDogdG9vbDIsXG4gICAgICAgICAgICAgICAgdG9vbENhbGwsXG4gICAgICAgICAgICAgICAgbWVzc2FnZXM6IHN0ZXBJbnB1dE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0XG4gICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgdG9vbEFwcHJvdmFsUmVxdWVzdHNbdG9vbENhbGwudG9vbENhbGxJZF0gPSB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtYXBwcm92YWwtcmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgICAgYXBwcm92YWxJZDogZ2VuZXJhdGVJZDIoKSxcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW52YWxpZFRvb2xDYWxscyA9IHN0ZXBUb29sQ2FsbHMuZmlsdGVyKFxuICAgICAgICAgICAgICAodG9vbENhbGwpID0+IHRvb2xDYWxsLmludmFsaWQgJiYgdG9vbENhbGwuZHluYW1pY1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNsaWVudFRvb2xPdXRwdXRzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2xDYWxsIG9mIGludmFsaWRUb29sQ2FsbHMpIHtcbiAgICAgICAgICAgICAgY2xpZW50VG9vbE91dHB1dHMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWVycm9yXCIsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IHRvb2xDYWxsLmlucHV0LFxuICAgICAgICAgICAgICAgIGVycm9yOiBnZXRFcnJvck1lc3NhZ2U1KHRvb2xDYWxsLmVycm9yKSxcbiAgICAgICAgICAgICAgICBkeW5hbWljOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xpZW50VG9vbENhbGxzID0gc3RlcFRvb2xDYWxscy5maWx0ZXIoXG4gICAgICAgICAgICAgICh0b29sQ2FsbCkgPT4gIXRvb2xDYWxsLnByb3ZpZGVyRXhlY3V0ZWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAodG9vbHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjbGllbnRUb29sT3V0cHV0cy5wdXNoKFxuICAgICAgICAgICAgICAgIC4uLmF3YWl0IGV4ZWN1dGVUb29scyh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbHM6IGNsaWVudFRvb2xDYWxscy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAgICh0b29sQ2FsbCkgPT4gIXRvb2xDYWxsLmludmFsaWQgJiYgdG9vbEFwcHJvdmFsUmVxdWVzdHNbdG9vbENhbGwudG9vbENhbGxJZF0gPT0gbnVsbFxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZXM6IHN0ZXBJbnB1dE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IG1lcmdlZEFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHQsXG4gICAgICAgICAgICAgICAgICBzdGVwTnVtYmVyOiBzdGVwcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICBtb2RlbDogc3RlcE1vZGVsSW5mbyxcbiAgICAgICAgICAgICAgICAgIG9uVG9vbENhbGxTdGFydCxcbiAgICAgICAgICAgICAgICAgIG9uVG9vbENhbGxGaW5pc2hcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCB0b29sQ2FsbCBvZiBzdGVwVG9vbENhbGxzKSB7XG4gICAgICAgICAgICAgIGlmICghdG9vbENhbGwucHJvdmlkZXJFeGVjdXRlZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgY29uc3QgdG9vbDIgPSB0b29scyA9PSBudWxsID8gdm9pZCAwIDogdG9vbHNbdG9vbENhbGwudG9vbE5hbWVdO1xuICAgICAgICAgICAgICBpZiAoKHRvb2wyID09IG51bGwgPyB2b2lkIDAgOiB0b29sMi50eXBlKSA9PT0gXCJwcm92aWRlclwiICYmIHRvb2wyLnN1cHBvcnRzRGVmZXJyZWRSZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzUmVzdWx0SW5SZXNwb25zZSA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLmNvbnRlbnQuc29tZShcbiAgICAgICAgICAgICAgICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwidG9vbC1yZXN1bHRcIiAmJiBwYXJ0LnRvb2xDYWxsSWQgPT09IHRvb2xDYWxsLnRvb2xDYWxsSWRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmICghaGFzUmVzdWx0SW5SZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgcGVuZGluZ0RlZmVycmVkVG9vbENhbGxzLnNldCh0b29sQ2FsbC50b29sQ2FsbElkLCB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgY3VycmVudE1vZGVsUmVzcG9uc2UuY29udGVudCkge1xuICAgICAgICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRvb2wtcmVzdWx0XCIpIHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nRGVmZXJyZWRUb29sQ2FsbHMuZGVsZXRlKHBhcnQudG9vbENhbGxJZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0ZXBDb250ZW50ID0gYXNDb250ZW50KHtcbiAgICAgICAgICAgICAgY29udGVudDogY3VycmVudE1vZGVsUmVzcG9uc2UuY29udGVudCxcbiAgICAgICAgICAgICAgdG9vbENhbGxzOiBzdGVwVG9vbENhbGxzLFxuICAgICAgICAgICAgICB0b29sT3V0cHV0czogY2xpZW50VG9vbE91dHB1dHMsXG4gICAgICAgICAgICAgIHRvb2xBcHByb3ZhbFJlcXVlc3RzOiBPYmplY3QudmFsdWVzKHRvb2xBcHByb3ZhbFJlcXVlc3RzKSxcbiAgICAgICAgICAgICAgdG9vbHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzcG9uc2VNZXNzYWdlcy5wdXNoKFxuICAgICAgICAgICAgICAuLi5hd2FpdCB0b1Jlc3BvbnNlTWVzc2FnZXMoe1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHN0ZXBDb250ZW50LFxuICAgICAgICAgICAgICAgIHRvb2xzXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3Qgc3RlcFJlcXVlc3QgPSAoKF9pID0gaW5jbHVkZSA9PSBudWxsID8gdm9pZCAwIDogaW5jbHVkZS5yZXF1ZXN0Qm9keSkgIT0gbnVsbCA/IF9pIDogdHJ1ZSkgPyAoX2ogPSBjdXJyZW50TW9kZWxSZXNwb25zZS5yZXF1ZXN0KSAhPSBudWxsID8gX2ogOiB7fSA6IHsgLi4uY3VycmVudE1vZGVsUmVzcG9uc2UucmVxdWVzdCwgYm9keTogdm9pZCAwIH07XG4gICAgICAgICAgICBjb25zdCBzdGVwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgIC4uLmN1cnJlbnRNb2RlbFJlc3BvbnNlLnJlc3BvbnNlLFxuICAgICAgICAgICAgICAvLyBkZWVwIGNsb25lIG1zZ3MgdG8gYXZvaWQgbXV0YXRpbmcgcGFzdCBtZXNzYWdlcyBpbiBtdWx0aS1zdGVwOlxuICAgICAgICAgICAgICBtZXNzYWdlczogc3RydWN0dXJlZENsb25lKHJlc3BvbnNlTWVzc2FnZXMpLFxuICAgICAgICAgICAgICAvLyBDb25kaXRpb25hbGx5IGluY2x1ZGUgcmVzcG9uc2UgYm9keTpcbiAgICAgICAgICAgICAgYm9keTogKChfayA9IGluY2x1ZGUgPT0gbnVsbCA/IHZvaWQgMCA6IGluY2x1ZGUucmVzcG9uc2VCb2R5KSAhPSBudWxsID8gX2sgOiB0cnVlKSA/IChfbCA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2wuYm9keSA6IHZvaWQgMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBOdW1iZXIgPSBzdGVwcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U3RlcFJlc3VsdCA9IG5ldyBEZWZhdWx0U3RlcFJlc3VsdCh7XG4gICAgICAgICAgICAgIHN0ZXBOdW1iZXIsXG4gICAgICAgICAgICAgIG1vZGVsOiBzdGVwTW9kZWxJbmZvLFxuICAgICAgICAgICAgICBmdW5jdGlvbklkOiB0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5mdW5jdGlvbklkLFxuICAgICAgICAgICAgICBtZXRhZGF0YTogdGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkubWV0YWRhdGEsXG4gICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0LFxuICAgICAgICAgICAgICBjb250ZW50OiBzdGVwQ29udGVudCxcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBjdXJyZW50TW9kZWxSZXNwb25zZS5maW5pc2hSZWFzb24udW5pZmllZCxcbiAgICAgICAgICAgICAgcmF3RmluaXNoUmVhc29uOiBjdXJyZW50TW9kZWxSZXNwb25zZS5maW5pc2hSZWFzb24ucmF3LFxuICAgICAgICAgICAgICB1c2FnZTogYXNMYW5ndWFnZU1vZGVsVXNhZ2UoY3VycmVudE1vZGVsUmVzcG9uc2UudXNhZ2UpLFxuICAgICAgICAgICAgICB3YXJuaW5nczogY3VycmVudE1vZGVsUmVzcG9uc2Uud2FybmluZ3MsXG4gICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgIHJlcXVlc3Q6IHN0ZXBSZXF1ZXN0LFxuICAgICAgICAgICAgICByZXNwb25zZTogc3RlcFJlc3BvbnNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxvZ1dhcm5pbmdzKHtcbiAgICAgICAgICAgICAgd2FybmluZ3M6IChfbSA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLndhcm5pbmdzKSAhPSBudWxsID8gX20gOiBbXSxcbiAgICAgICAgICAgICAgcHJvdmlkZXI6IHN0ZXBNb2RlbEluZm8ucHJvdmlkZXIsXG4gICAgICAgICAgICAgIG1vZGVsOiBzdGVwTW9kZWxJbmZvLm1vZGVsSWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RlcHMucHVzaChjdXJyZW50U3RlcFJlc3VsdCk7XG4gICAgICAgICAgICBhd2FpdCAob25TdGVwRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvblN0ZXBGaW5pc2goY3VycmVudFN0ZXBSZXN1bHQpKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKHN0ZXBUaW1lb3V0SWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoc3RlcFRpbWVvdXRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChcbiAgICAgICAgICAvLyBDb250aW51ZSBpZjpcbiAgICAgICAgICAvLyAxLiBUaGVyZSBhcmUgY2xpZW50IHRvb2wgY2FsbHMgdGhhdCBoYXZlIGFsbCBiZWVuIGV4ZWN1dGVkLCBPUlxuICAgICAgICAgIC8vIDIuIFRoZXJlIGFyZSBwZW5kaW5nIGRlZmVycmVkIHJlc3VsdHMgZnJvbSBwcm92aWRlci1leGVjdXRlZCB0b29sc1xuICAgICAgICAgIChjbGllbnRUb29sQ2FsbHMubGVuZ3RoID4gMCAmJiBjbGllbnRUb29sT3V0cHV0cy5sZW5ndGggPT09IGNsaWVudFRvb2xDYWxscy5sZW5ndGggfHwgcGVuZGluZ0RlZmVycmVkVG9vbENhbGxzLnNpemUgPiAwKSAmJiAvLyBjb250aW51ZSB1bnRpbCBhIHN0b3AgY29uZGl0aW9uIGlzIG1ldDpcbiAgICAgICAgICAhYXdhaXQgaXNTdG9wQ29uZGl0aW9uTWV0KHsgc3RvcENvbmRpdGlvbnMsIHN0ZXBzIH0pXG4gICAgICAgICk7XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICBhd2FpdCBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogY3VycmVudE1vZGVsUmVzcG9uc2UuZmluaXNoUmVhc29uLnVuaWZpZWQsXG4gICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGV4dFwiOiB7XG4gICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBleHRyYWN0VGV4dENvbnRlbnQoY3VycmVudE1vZGVsUmVzcG9uc2UuY29udGVudClcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5yZWFzb25pbmdcIjoge1xuICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gZXh0cmFjdFJlYXNvbmluZ0NvbnRlbnQoY3VycmVudE1vZGVsUmVzcG9uc2UuY29udGVudClcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdG9vbENhbGxzID0gYXNUb29sQ2FsbHMoY3VycmVudE1vZGVsUmVzcG9uc2UuY29udGVudCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdG9vbENhbGxzID09IG51bGwgPyB2b2lkIDAgOiBKU09OLnN0cmluZ2lmeSh0b29sQ2FsbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5wcm92aWRlck1ldGFkYXRhXCI6IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgIGN1cnJlbnRNb2RlbFJlc3BvbnNlLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgLy8gVE9ETyByZW5hbWUgdGVsZW1ldHJ5IGF0dHJpYnV0ZXMgdG8gaW5wdXRUb2tlbnMgYW5kIG91dHB1dFRva2Vuc1xuICAgICAgICAgICAgICBcImFpLnVzYWdlLnByb21wdFRva2Vuc1wiOiBjdXJyZW50TW9kZWxSZXNwb25zZS51c2FnZS5pbnB1dFRva2Vucy50b3RhbCxcbiAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnVzYWdlLm91dHB1dFRva2Vucy50b3RhbFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGxhc3RTdGVwID0gc3RlcHNbc3RlcHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGNvbnN0IHRvdGFsVXNhZ2UgPSBzdGVwcy5yZWR1Y2UoXG4gICAgICAgICAgKHRvdGFsVXNhZ2UyLCBzdGVwKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYWRkTGFuZ3VhZ2VNb2RlbFVzYWdlKHRvdGFsVXNhZ2UyLCBzdGVwLnVzYWdlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlucHV0VG9rZW5zOiB2b2lkIDAsXG4gICAgICAgICAgICBvdXRwdXRUb2tlbnM6IHZvaWQgMCxcbiAgICAgICAgICAgIHRvdGFsVG9rZW5zOiB2b2lkIDAsXG4gICAgICAgICAgICByZWFzb25pbmdUb2tlbnM6IHZvaWQgMCxcbiAgICAgICAgICAgIGNhY2hlZElucHV0VG9rZW5zOiB2b2lkIDBcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIGF3YWl0IChvbkZpbmlzaCA9PSBudWxsID8gdm9pZCAwIDogb25GaW5pc2goe1xuICAgICAgICAgIHN0ZXBOdW1iZXI6IGxhc3RTdGVwLnN0ZXBOdW1iZXIsXG4gICAgICAgICAgbW9kZWw6IGxhc3RTdGVwLm1vZGVsLFxuICAgICAgICAgIGZ1bmN0aW9uSWQ6IGxhc3RTdGVwLmZ1bmN0aW9uSWQsXG4gICAgICAgICAgbWV0YWRhdGE6IGxhc3RTdGVwLm1ldGFkYXRhLFxuICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0OiBsYXN0U3RlcC5leHBlcmltZW50YWxfY29udGV4dCxcbiAgICAgICAgICBmaW5pc2hSZWFzb246IGxhc3RTdGVwLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICByYXdGaW5pc2hSZWFzb246IGxhc3RTdGVwLnJhd0ZpbmlzaFJlYXNvbixcbiAgICAgICAgICB1c2FnZTogbGFzdFN0ZXAudXNhZ2UsXG4gICAgICAgICAgY29udGVudDogbGFzdFN0ZXAuY29udGVudCxcbiAgICAgICAgICB0ZXh0OiBsYXN0U3RlcC50ZXh0LFxuICAgICAgICAgIHJlYXNvbmluZ1RleHQ6IGxhc3RTdGVwLnJlYXNvbmluZ1RleHQsXG4gICAgICAgICAgcmVhc29uaW5nOiBsYXN0U3RlcC5yZWFzb25pbmcsXG4gICAgICAgICAgZmlsZXM6IGxhc3RTdGVwLmZpbGVzLFxuICAgICAgICAgIHNvdXJjZXM6IGxhc3RTdGVwLnNvdXJjZXMsXG4gICAgICAgICAgdG9vbENhbGxzOiBsYXN0U3RlcC50b29sQ2FsbHMsXG4gICAgICAgICAgc3RhdGljVG9vbENhbGxzOiBsYXN0U3RlcC5zdGF0aWNUb29sQ2FsbHMsXG4gICAgICAgICAgZHluYW1pY1Rvb2xDYWxsczogbGFzdFN0ZXAuZHluYW1pY1Rvb2xDYWxscyxcbiAgICAgICAgICB0b29sUmVzdWx0czogbGFzdFN0ZXAudG9vbFJlc3VsdHMsXG4gICAgICAgICAgc3RhdGljVG9vbFJlc3VsdHM6IGxhc3RTdGVwLnN0YXRpY1Rvb2xSZXN1bHRzLFxuICAgICAgICAgIGR5bmFtaWNUb29sUmVzdWx0czogbGFzdFN0ZXAuZHluYW1pY1Rvb2xSZXN1bHRzLFxuICAgICAgICAgIHJlcXVlc3Q6IGxhc3RTdGVwLnJlcXVlc3QsXG4gICAgICAgICAgcmVzcG9uc2U6IGxhc3RTdGVwLnJlc3BvbnNlLFxuICAgICAgICAgIHdhcm5pbmdzOiBsYXN0U3RlcC53YXJuaW5ncyxcbiAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBsYXN0U3RlcC5wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgIHN0ZXBzLFxuICAgICAgICAgIHRvdGFsVXNhZ2VcbiAgICAgICAgfSkpO1xuICAgICAgICBsZXQgcmVzb2x2ZWRPdXRwdXQ7XG4gICAgICAgIGlmIChsYXN0U3RlcC5maW5pc2hSZWFzb24gPT09IFwic3RvcFwiKSB7XG4gICAgICAgICAgY29uc3Qgb3V0cHV0U3BlY2lmaWNhdGlvbiA9IG91dHB1dCAhPSBudWxsID8gb3V0cHV0IDogdGV4dCgpO1xuICAgICAgICAgIHJlc29sdmVkT3V0cHV0ID0gYXdhaXQgb3V0cHV0U3BlY2lmaWNhdGlvbi5wYXJzZUNvbXBsZXRlT3V0cHV0KFxuICAgICAgICAgICAgeyB0ZXh0OiBsYXN0U3RlcC50ZXh0IH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJlc3BvbnNlOiBsYXN0U3RlcC5yZXNwb25zZSxcbiAgICAgICAgICAgICAgdXNhZ2U6IGxhc3RTdGVwLnVzYWdlLFxuICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IGxhc3RTdGVwLmZpbmlzaFJlYXNvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0R2VuZXJhdGVUZXh0UmVzdWx0KHtcbiAgICAgICAgICBzdGVwcyxcbiAgICAgICAgICB0b3RhbFVzYWdlLFxuICAgICAgICAgIG91dHB1dDogcmVzb2x2ZWRPdXRwdXRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgd3JhcEdhdGV3YXlFcnJvcihlcnJvcik7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVUb29scyh7XG4gIHRvb2xDYWxscyxcbiAgdG9vbHMsXG4gIHRyYWNlcixcbiAgdGVsZW1ldHJ5LFxuICBtZXNzYWdlcyxcbiAgYWJvcnRTaWduYWwsXG4gIGV4cGVyaW1lbnRhbF9jb250ZXh0LFxuICBzdGVwTnVtYmVyLFxuICBtb2RlbCxcbiAgb25Ub29sQ2FsbFN0YXJ0LFxuICBvblRvb2xDYWxsRmluaXNoXG59KSB7XG4gIGNvbnN0IHRvb2xPdXRwdXRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgdG9vbENhbGxzLm1hcChcbiAgICAgIGFzeW5jICh0b29sQ2FsbCkgPT4gZXhlY3V0ZVRvb2xDYWxsKHtcbiAgICAgICAgdG9vbENhbGwsXG4gICAgICAgIHRvb2xzLFxuICAgICAgICB0cmFjZXIsXG4gICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgbWVzc2FnZXMsXG4gICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICBleHBlcmltZW50YWxfY29udGV4dCxcbiAgICAgICAgc3RlcE51bWJlcixcbiAgICAgICAgbW9kZWwsXG4gICAgICAgIG9uVG9vbENhbGxTdGFydCxcbiAgICAgICAgb25Ub29sQ2FsbEZpbmlzaFxuICAgICAgfSlcbiAgICApXG4gICk7XG4gIHJldHVybiB0b29sT3V0cHV0cy5maWx0ZXIoXG4gICAgKG91dHB1dCkgPT4gb3V0cHV0ICE9IG51bGxcbiAgKTtcbn1cbnZhciBEZWZhdWx0R2VuZXJhdGVUZXh0UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5zdGVwcyA9IG9wdGlvbnMuc3RlcHM7XG4gICAgdGhpcy5fb3V0cHV0ID0gb3B0aW9ucy5vdXRwdXQ7XG4gICAgdGhpcy50b3RhbFVzYWdlID0gb3B0aW9ucy50b3RhbFVzYWdlO1xuICB9XG4gIGdldCBmaW5hbFN0ZXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RlcHNbdGhpcy5zdGVwcy5sZW5ndGggLSAxXTtcbiAgfVxuICBnZXQgY29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAuY29udGVudDtcbiAgfVxuICBnZXQgdGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGV4dDtcbiAgfVxuICBnZXQgZmlsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLmZpbGVzO1xuICB9XG4gIGdldCByZWFzb25pbmdUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC5yZWFzb25pbmdUZXh0O1xuICB9XG4gIGdldCByZWFzb25pbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnJlYXNvbmluZztcbiAgfVxuICBnZXQgdG9vbENhbGxzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50b29sQ2FsbHM7XG4gIH1cbiAgZ2V0IHN0YXRpY1Rvb2xDYWxscygpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAuc3RhdGljVG9vbENhbGxzO1xuICB9XG4gIGdldCBkeW5hbWljVG9vbENhbGxzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC5keW5hbWljVG9vbENhbGxzO1xuICB9XG4gIGdldCB0b29sUmVzdWx0cygpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudG9vbFJlc3VsdHM7XG4gIH1cbiAgZ2V0IHN0YXRpY1Rvb2xSZXN1bHRzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC5zdGF0aWNUb29sUmVzdWx0cztcbiAgfVxuICBnZXQgZHluYW1pY1Rvb2xSZXN1bHRzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC5keW5hbWljVG9vbFJlc3VsdHM7XG4gIH1cbiAgZ2V0IHNvdXJjZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnNvdXJjZXM7XG4gIH1cbiAgZ2V0IGZpbmlzaFJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAuZmluaXNoUmVhc29uO1xuICB9XG4gIGdldCByYXdGaW5pc2hSZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnJhd0ZpbmlzaFJlYXNvbjtcbiAgfVxuICBnZXQgd2FybmluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLndhcm5pbmdzO1xuICB9XG4gIGdldCBwcm92aWRlck1ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC5wcm92aWRlck1ldGFkYXRhO1xuICB9XG4gIGdldCByZXNwb25zZSgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAucmVzcG9uc2U7XG4gIH1cbiAgZ2V0IHJlcXVlc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnJlcXVlc3Q7XG4gIH1cbiAgZ2V0IHVzYWdlKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC51c2FnZTtcbiAgfVxuICBnZXQgZXhwZXJpbWVudGFsX291dHB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXQ7XG4gIH1cbiAgZ2V0IG91dHB1dCgpIHtcbiAgICBpZiAodGhpcy5fb3V0cHV0ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb091dHB1dEdlbmVyYXRlZEVycm9yKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9vdXRwdXQ7XG4gIH1cbn07XG5mdW5jdGlvbiBhc1Rvb2xDYWxscyhjb250ZW50KSB7XG4gIGNvbnN0IHBhcnRzID0gY29udGVudC5maWx0ZXIoXG4gICAgKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJ0b29sLWNhbGxcIlxuICApO1xuICBpZiAocGFydHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gcGFydHMubWFwKCh0b29sQ2FsbCkgPT4gKHtcbiAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICBpbnB1dDogdG9vbENhbGwuaW5wdXRcbiAgfSkpO1xufVxuZnVuY3Rpb24gYXNDb250ZW50KHtcbiAgY29udGVudCxcbiAgdG9vbENhbGxzLFxuICB0b29sT3V0cHV0cyxcbiAgdG9vbEFwcHJvdmFsUmVxdWVzdHMsXG4gIHRvb2xzXG59KSB7XG4gIGNvbnN0IGNvbnRlbnRQYXJ0cyA9IFtdO1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgY29udGVudCkge1xuICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgY2FzZSBcInJlYXNvbmluZ1wiOlxuICAgICAgY2FzZSBcInNvdXJjZVwiOlxuICAgICAgICBjb250ZW50UGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZmlsZVwiOiB7XG4gICAgICAgIGNvbnRlbnRQYXJ0cy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICBmaWxlOiBuZXcgRGVmYXVsdEdlbmVyYXRlZEZpbGUocGFydCksXG4gICAgICAgICAgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgIGNvbnRlbnRQYXJ0cy5wdXNoKFxuICAgICAgICAgIHRvb2xDYWxscy5maW5kKCh0b29sQ2FsbCkgPT4gdG9vbENhbGwudG9vbENhbGxJZCA9PT0gcGFydC50b29sQ2FsbElkKVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ0b29sLXJlc3VsdFwiOiB7XG4gICAgICAgIGNvbnN0IHRvb2xDYWxsID0gdG9vbENhbGxzLmZpbmQoXG4gICAgICAgICAgKHRvb2xDYWxsMikgPT4gdG9vbENhbGwyLnRvb2xDYWxsSWQgPT09IHBhcnQudG9vbENhbGxJZFxuICAgICAgICApO1xuICAgICAgICBpZiAodG9vbENhbGwgPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IHRvb2wyID0gdG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xzW3BhcnQudG9vbE5hbWVdO1xuICAgICAgICAgIGNvbnN0IHN1cHBvcnRzRGVmZXJyZWRSZXN1bHRzID0gKHRvb2wyID09IG51bGwgPyB2b2lkIDAgOiB0b29sMi50eXBlKSA9PT0gXCJwcm92aWRlclwiICYmIHRvb2wyLnN1cHBvcnRzRGVmZXJyZWRSZXN1bHRzO1xuICAgICAgICAgIGlmICghc3VwcG9ydHNEZWZlcnJlZFJlc3VsdHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVG9vbCBjYWxsICR7cGFydC50b29sQ2FsbElkfSBub3QgZm91bmQuYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJ0LmlzRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnRlbnRQYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWVycm9yXCIsXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgICAgIGlucHV0OiB2b2lkIDAsXG4gICAgICAgICAgICAgIGVycm9yOiBwYXJ0LnJlc3VsdCxcbiAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgZHluYW1pYzogcGFydC5keW5hbWljXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGVudFBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgICAgIGlucHV0OiB2b2lkIDAsXG4gICAgICAgICAgICAgIG91dHB1dDogcGFydC5yZXN1bHQsXG4gICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgIGR5bmFtaWM6IHBhcnQuZHluYW1pY1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LmlzRXJyb3IpIHtcbiAgICAgICAgICBjb250ZW50UGFydHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcInRvb2wtZXJyb3JcIixcbiAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgICAgaW5wdXQ6IHRvb2xDYWxsLmlucHV0LFxuICAgICAgICAgICAgZXJyb3I6IHBhcnQucmVzdWx0LFxuICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGR5bmFtaWM6IHRvb2xDYWxsLmR5bmFtaWNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZW50UGFydHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICAgIGlucHV0OiB0b29sQ2FsbC5pbnB1dCxcbiAgICAgICAgICAgIG91dHB1dDogcGFydC5yZXN1bHQsXG4gICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB0cnVlLFxuICAgICAgICAgICAgZHluYW1pYzogdG9vbENhbGwuZHluYW1pY1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInRvb2wtYXBwcm92YWwtcmVxdWVzdFwiOiB7XG4gICAgICAgIGNvbnN0IHRvb2xDYWxsID0gdG9vbENhbGxzLmZpbmQoXG4gICAgICAgICAgKHRvb2xDYWxsMikgPT4gdG9vbENhbGwyLnRvb2xDYWxsSWQgPT09IHBhcnQudG9vbENhbGxJZFxuICAgICAgICApO1xuICAgICAgICBpZiAodG9vbENhbGwgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBUb29sQ2FsbE5vdEZvdW5kRm9yQXBwcm92YWxFcnJvcih7XG4gICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICBhcHByb3ZhbElkOiBwYXJ0LmFwcHJvdmFsSWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZW50UGFydHMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJ0b29sLWFwcHJvdmFsLXJlcXVlc3RcIixcbiAgICAgICAgICBhcHByb3ZhbElkOiBwYXJ0LmFwcHJvdmFsSWQsXG4gICAgICAgICAgdG9vbENhbGxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gWy4uLmNvbnRlbnRQYXJ0cywgLi4udG9vbE91dHB1dHMsIC4uLnRvb2xBcHByb3ZhbFJlcXVlc3RzXTtcbn1cblxuLy8gc3JjL2dlbmVyYXRlLXRleHQvc3RyZWFtLXRleHQudHNcbmltcG9ydCB7XG4gIGdldEVycm9yTWVzc2FnZSBhcyBnZXRFcnJvck1lc3NhZ2U3LFxuICBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvciBhcyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcjJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7XG4gIGNyZWF0ZUlkR2VuZXJhdG9yIGFzIGNyZWF0ZUlkR2VuZXJhdG9yMixcbiAgRGVsYXllZFByb21pc2UsXG4gIGlzQWJvcnRFcnJvciBhcyBpc0Fib3J0RXJyb3IyXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy91dGlsL3ByZXBhcmUtaGVhZGVycy50c1xuZnVuY3Rpb24gcHJlcGFyZUhlYWRlcnMoaGVhZGVycywgZGVmYXVsdEhlYWRlcnMpIHtcbiAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gbmV3IEhlYWRlcnMoaGVhZGVycyAhPSBudWxsID8gaGVhZGVycyA6IHt9KTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZGVmYXVsdEhlYWRlcnMpKSB7XG4gICAgaWYgKCFyZXNwb25zZUhlYWRlcnMuaGFzKGtleSkpIHtcbiAgICAgIHJlc3BvbnNlSGVhZGVycy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNwb25zZUhlYWRlcnM7XG59XG5cbi8vIHNyYy90ZXh0LXN0cmVhbS9jcmVhdGUtdGV4dC1zdHJlYW0tcmVzcG9uc2UudHNcbmZ1bmN0aW9uIGNyZWF0ZVRleHRTdHJlYW1SZXNwb25zZSh7XG4gIHN0YXR1cyxcbiAgc3RhdHVzVGV4dCxcbiAgaGVhZGVycyxcbiAgdGV4dFN0cmVhbVxufSkge1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKHRleHRTdHJlYW0ucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpLCB7XG4gICAgc3RhdHVzOiBzdGF0dXMgIT0gbnVsbCA/IHN0YXR1cyA6IDIwMCxcbiAgICBzdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6IHByZXBhcmVIZWFkZXJzKGhlYWRlcnMsIHtcbiAgICAgIFwiY29udGVudC10eXBlXCI6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgfSlcbiAgfSk7XG59XG5cbi8vIHNyYy91dGlsL3dyaXRlLXRvLXNlcnZlci1yZXNwb25zZS50c1xuZnVuY3Rpb24gd3JpdGVUb1NlcnZlclJlc3BvbnNlKHtcbiAgcmVzcG9uc2UsXG4gIHN0YXR1cyxcbiAgc3RhdHVzVGV4dCxcbiAgaGVhZGVycyxcbiAgc3RyZWFtXG59KSB7XG4gIGNvbnN0IHN0YXR1c0NvZGUgPSBzdGF0dXMgIT0gbnVsbCA/IHN0YXR1cyA6IDIwMDtcbiAgaWYgKHN0YXR1c1RleHQgIT09IHZvaWQgMCkge1xuICAgIHJlc3BvbnNlLndyaXRlSGVhZChzdGF0dXNDb2RlLCBzdGF0dXNUZXh0LCBoZWFkZXJzKTtcbiAgfSBlbHNlIHtcbiAgICByZXNwb25zZS53cml0ZUhlYWQoc3RhdHVzQ29kZSwgaGVhZGVycyk7XG4gIH1cbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICBjb25zdCByZWFkID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY29uc3QgY2FuQ29udGludWUgPSByZXNwb25zZS53cml0ZSh2YWx1ZSk7XG4gICAgICAgIGlmICghY2FuQ29udGludWUpIHtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZTMpID0+IHtcbiAgICAgICAgICAgIHJlc3BvbnNlLm9uY2UoXCJkcmFpblwiLCByZXNvbHZlMyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlc3BvbnNlLmVuZCgpO1xuICAgIH1cbiAgfTtcbiAgcmVhZCgpO1xufVxuXG4vLyBzcmMvdGV4dC1zdHJlYW0vcGlwZS10ZXh0LXN0cmVhbS10by1yZXNwb25zZS50c1xuZnVuY3Rpb24gcGlwZVRleHRTdHJlYW1Ub1Jlc3BvbnNlKHtcbiAgcmVzcG9uc2UsXG4gIHN0YXR1cyxcbiAgc3RhdHVzVGV4dCxcbiAgaGVhZGVycyxcbiAgdGV4dFN0cmVhbVxufSkge1xuICB3cml0ZVRvU2VydmVyUmVzcG9uc2Uoe1xuICAgIHJlc3BvbnNlLFxuICAgIHN0YXR1cyxcbiAgICBzdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIHByZXBhcmVIZWFkZXJzKGhlYWRlcnMsIHtcbiAgICAgICAgXCJjb250ZW50LXR5cGVcIjogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAgICAgIH0pLmVudHJpZXMoKVxuICAgICksXG4gICAgc3RyZWFtOiB0ZXh0U3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKVxuICB9KTtcbn1cblxuLy8gc3JjL3VpLW1lc3NhZ2Utc3RyZWFtL2pzb24tdG8tc3NlLXRyYW5zZm9ybS1zdHJlYW0udHNcbnZhciBKc29uVG9Tc2VUcmFuc2Zvcm1TdHJlYW0gPSBjbGFzcyBleHRlbmRzIFRyYW5zZm9ybVN0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIHRyYW5zZm9ybShwYXJ0LCBjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShgZGF0YTogJHtKU09OLnN0cmluZ2lmeShwYXJ0KX1cblxuYCk7XG4gICAgICB9LFxuICAgICAgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXCJkYXRhOiBbRE9ORV1cXG5cXG5cIik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy91aS1tZXNzYWdlLXN0cmVhbS91aS1tZXNzYWdlLXN0cmVhbS1oZWFkZXJzLnRzXG52YXIgVUlfTUVTU0FHRV9TVFJFQU1fSEVBREVSUyA9IHtcbiAgXCJjb250ZW50LXR5cGVcIjogXCJ0ZXh0L2V2ZW50LXN0cmVhbVwiLFxuICBcImNhY2hlLWNvbnRyb2xcIjogXCJuby1jYWNoZVwiLFxuICBjb25uZWN0aW9uOiBcImtlZXAtYWxpdmVcIixcbiAgXCJ4LXZlcmNlbC1haS11aS1tZXNzYWdlLXN0cmVhbVwiOiBcInYxXCIsXG4gIFwieC1hY2NlbC1idWZmZXJpbmdcIjogXCJub1wiXG4gIC8vIGRpc2FibGUgbmdpbnggYnVmZmVyaW5nXG59O1xuXG4vLyBzcmMvdWktbWVzc2FnZS1zdHJlYW0vY3JlYXRlLXVpLW1lc3NhZ2Utc3RyZWFtLXJlc3BvbnNlLnRzXG5mdW5jdGlvbiBjcmVhdGVVSU1lc3NhZ2VTdHJlYW1SZXNwb25zZSh7XG4gIHN0YXR1cyxcbiAgc3RhdHVzVGV4dCxcbiAgaGVhZGVycyxcbiAgc3RyZWFtLFxuICBjb25zdW1lU3NlU3RyZWFtXG59KSB7XG4gIGxldCBzc2VTdHJlYW0gPSBzdHJlYW0ucGlwZVRocm91Z2gobmV3IEpzb25Ub1NzZVRyYW5zZm9ybVN0cmVhbSgpKTtcbiAgaWYgKGNvbnN1bWVTc2VTdHJlYW0pIHtcbiAgICBjb25zdCBbc3RyZWFtMSwgc3RyZWFtMl0gPSBzc2VTdHJlYW0udGVlKCk7XG4gICAgc3NlU3RyZWFtID0gc3RyZWFtMTtcbiAgICBjb25zdW1lU3NlU3RyZWFtKHsgc3RyZWFtOiBzdHJlYW0yIH0pO1xuICB9XG4gIHJldHVybiBuZXcgUmVzcG9uc2Uoc3NlU3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKSwge1xuICAgIHN0YXR1cyxcbiAgICBzdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6IHByZXBhcmVIZWFkZXJzKGhlYWRlcnMsIFVJX01FU1NBR0VfU1RSRUFNX0hFQURFUlMpXG4gIH0pO1xufVxuXG4vLyBzcmMvdWktbWVzc2FnZS1zdHJlYW0vZ2V0LXJlc3BvbnNlLXVpLW1lc3NhZ2UtaWQudHNcbmZ1bmN0aW9uIGdldFJlc3BvbnNlVUlNZXNzYWdlSWQoe1xuICBvcmlnaW5hbE1lc3NhZ2VzLFxuICByZXNwb25zZU1lc3NhZ2VJZFxufSkge1xuICBpZiAob3JpZ2luYWxNZXNzYWdlcyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCBsYXN0TWVzc2FnZSA9IG9yaWdpbmFsTWVzc2FnZXNbb3JpZ2luYWxNZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIChsYXN0TWVzc2FnZSA9PSBudWxsID8gdm9pZCAwIDogbGFzdE1lc3NhZ2Uucm9sZSkgPT09IFwiYXNzaXN0YW50XCIgPyBsYXN0TWVzc2FnZS5pZCA6IHR5cGVvZiByZXNwb25zZU1lc3NhZ2VJZCA9PT0gXCJmdW5jdGlvblwiID8gcmVzcG9uc2VNZXNzYWdlSWQoKSA6IHJlc3BvbnNlTWVzc2FnZUlkO1xufVxuXG4vLyBzcmMvdWkvcHJvY2Vzcy11aS1tZXNzYWdlLXN0cmVhbS50c1xuaW1wb3J0IHsgdmFsaWRhdGVUeXBlcyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy91aS1tZXNzYWdlLXN0cmVhbS91aS1tZXNzYWdlLWNodW5rcy50c1xuaW1wb3J0IHsgeiBhcyB6NyB9IGZyb20gXCJ6b2QvdjRcIjtcbmltcG9ydCB7IGxhenlTY2hlbWEsIHpvZFNjaGVtYSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG52YXIgdWlNZXNzYWdlQ2h1bmtTY2hlbWEgPSBsYXp5U2NoZW1hKFxuICAoKSA9PiB6b2RTY2hlbWEoXG4gICAgejcudW5pb24oW1xuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcInRleHQtc3RhcnRcIiksXG4gICAgICAgIGlkOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJ0ZXh0LWRlbHRhXCIpLFxuICAgICAgICBpZDogejcuc3RyaW5nKCksXG4gICAgICAgIGRlbHRhOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJ0ZXh0LWVuZFwiKSxcbiAgICAgICAgaWQ6IHo3LnN0cmluZygpLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcImVycm9yXCIpLFxuICAgICAgICBlcnJvclRleHQ6IHo3LnN0cmluZygpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJ0b29sLWlucHV0LXN0YXJ0XCIpLFxuICAgICAgICB0b29sQ2FsbElkOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgdG9vbE5hbWU6IHo3LnN0cmluZygpLFxuICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICAgICAgICBkeW5hbWljOiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgdGl0bGU6IHo3LnN0cmluZygpLm9wdGlvbmFsKClcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcInRvb2wtaW5wdXQtZGVsdGFcIiksXG4gICAgICAgIHRvb2xDYWxsSWQ6IHo3LnN0cmluZygpLFxuICAgICAgICBpbnB1dFRleHREZWx0YTogejcuc3RyaW5nKClcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcInRvb2wtaW5wdXQtYXZhaWxhYmxlXCIpLFxuICAgICAgICB0b29sQ2FsbElkOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgdG9vbE5hbWU6IHo3LnN0cmluZygpLFxuICAgICAgICBpbnB1dDogejcudW5rbm93bigpLFxuICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICAgICAgICBkeW5hbWljOiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgdGl0bGU6IHo3LnN0cmluZygpLm9wdGlvbmFsKClcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcInRvb2wtaW5wdXQtZXJyb3JcIiksXG4gICAgICAgIHRvb2xDYWxsSWQ6IHo3LnN0cmluZygpLFxuICAgICAgICB0b29sTmFtZTogejcuc3RyaW5nKCksXG4gICAgICAgIGlucHV0OiB6Ny51bmtub3duKCksXG4gICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHo3LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgICAgIGR5bmFtaWM6IHo3LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICBlcnJvclRleHQ6IHo3LnN0cmluZygpLFxuICAgICAgICB0aXRsZTogejcuc3RyaW5nKCkub3B0aW9uYWwoKVxuICAgICAgfSksXG4gICAgICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgICAgICB0eXBlOiB6Ny5saXRlcmFsKFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCIpLFxuICAgICAgICBhcHByb3ZhbElkOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgdG9vbENhbGxJZDogejcuc3RyaW5nKClcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcInRvb2wtb3V0cHV0LWF2YWlsYWJsZVwiKSxcbiAgICAgICAgdG9vbENhbGxJZDogejcuc3RyaW5nKCksXG4gICAgICAgIG91dHB1dDogejcudW5rbm93bigpLFxuICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgZHluYW1pYzogejcuYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgIHByZWxpbWluYXJ5OiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKVxuICAgICAgfSksXG4gICAgICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgICAgICB0eXBlOiB6Ny5saXRlcmFsKFwidG9vbC1vdXRwdXQtZXJyb3JcIiksXG4gICAgICAgIHRvb2xDYWxsSWQ6IHo3LnN0cmluZygpLFxuICAgICAgICBlcnJvclRleHQ6IHo3LnN0cmluZygpLFxuICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgZHluYW1pYzogejcuYm9vbGVhbigpLm9wdGlvbmFsKClcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcInRvb2wtb3V0cHV0LWRlbmllZFwiKSxcbiAgICAgICAgdG9vbENhbGxJZDogejcuc3RyaW5nKClcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcInJlYXNvbmluZy1zdGFydFwiKSxcbiAgICAgICAgaWQ6IHo3LnN0cmluZygpLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcInJlYXNvbmluZy1kZWx0YVwiKSxcbiAgICAgICAgaWQ6IHo3LnN0cmluZygpLFxuICAgICAgICBkZWx0YTogejcuc3RyaW5nKCksXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgICAgfSksXG4gICAgICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgICAgICB0eXBlOiB6Ny5saXRlcmFsKFwicmVhc29uaW5nLWVuZFwiKSxcbiAgICAgICAgaWQ6IHo3LnN0cmluZygpLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcInNvdXJjZS11cmxcIiksXG4gICAgICAgIHNvdXJjZUlkOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgdXJsOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgdGl0bGU6IHo3LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgICAgfSksXG4gICAgICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgICAgICB0eXBlOiB6Ny5saXRlcmFsKFwic291cmNlLWRvY3VtZW50XCIpLFxuICAgICAgICBzb3VyY2VJZDogejcuc3RyaW5nKCksXG4gICAgICAgIG1lZGlhVHlwZTogejcuc3RyaW5nKCksXG4gICAgICAgIHRpdGxlOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgZmlsZW5hbWU6IHo3LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgICAgfSksXG4gICAgICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgICAgICB0eXBlOiB6Ny5saXRlcmFsKFwiZmlsZVwiKSxcbiAgICAgICAgdXJsOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgbWVkaWFUeXBlOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmN1c3RvbShcbiAgICAgICAgICAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5zdGFydHNXaXRoKFwiZGF0YS1cIiksXG4gICAgICAgICAgeyBtZXNzYWdlOiAnVHlwZSBtdXN0IHN0YXJ0IHdpdGggXCJkYXRhLVwiJyB9XG4gICAgICAgICksXG4gICAgICAgIGlkOiB6Ny5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgICAgICBkYXRhOiB6Ny51bmtub3duKCksXG4gICAgICAgIHRyYW5zaWVudDogejcuYm9vbGVhbigpLm9wdGlvbmFsKClcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcInN0YXJ0LXN0ZXBcIilcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcImZpbmlzaC1zdGVwXCIpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJzdGFydFwiKSxcbiAgICAgICAgbWVzc2FnZUlkOiB6Ny5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgICAgICBtZXNzYWdlTWV0YWRhdGE6IHo3LnVua25vd24oKS5vcHRpb25hbCgpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJmaW5pc2hcIiksXG4gICAgICAgIGZpbmlzaFJlYXNvbjogejcuZW51bShbXG4gICAgICAgICAgXCJzdG9wXCIsXG4gICAgICAgICAgXCJsZW5ndGhcIixcbiAgICAgICAgICBcImNvbnRlbnQtZmlsdGVyXCIsXG4gICAgICAgICAgXCJ0b29sLWNhbGxzXCIsXG4gICAgICAgICAgXCJlcnJvclwiLFxuICAgICAgICAgIFwib3RoZXJcIlxuICAgICAgICBdKS5vcHRpb25hbCgpLFxuICAgICAgICBtZXNzYWdlTWV0YWRhdGE6IHo3LnVua25vd24oKS5vcHRpb25hbCgpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJhYm9ydFwiKSxcbiAgICAgICAgcmVhc29uOiB6Ny5zdHJpbmcoKS5vcHRpb25hbCgpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJtZXNzYWdlLW1ldGFkYXRhXCIpLFxuICAgICAgICBtZXNzYWdlTWV0YWRhdGE6IHo3LnVua25vd24oKVxuICAgICAgfSlcbiAgICBdKVxuICApXG4pO1xuZnVuY3Rpb24gaXNEYXRhVUlNZXNzYWdlQ2h1bmsoY2h1bmspIHtcbiAgcmV0dXJuIGNodW5rLnR5cGUuc3RhcnRzV2l0aChcImRhdGEtXCIpO1xufVxuXG4vLyBzcmMvdWkvdWktbWVzc2FnZXMudHNcbmZ1bmN0aW9uIGlzRGF0YVVJUGFydChwYXJ0KSB7XG4gIHJldHVybiBwYXJ0LnR5cGUuc3RhcnRzV2l0aChcImRhdGEtXCIpO1xufVxuZnVuY3Rpb24gaXNUZXh0VUlQYXJ0KHBhcnQpIHtcbiAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJ0ZXh0XCI7XG59XG5mdW5jdGlvbiBpc0ZpbGVVSVBhcnQocGFydCkge1xuICByZXR1cm4gcGFydC50eXBlID09PSBcImZpbGVcIjtcbn1cbmZ1bmN0aW9uIGlzUmVhc29uaW5nVUlQYXJ0KHBhcnQpIHtcbiAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJyZWFzb25pbmdcIjtcbn1cbmZ1bmN0aW9uIGlzU3RhdGljVG9vbFVJUGFydChwYXJ0KSB7XG4gIHJldHVybiBwYXJ0LnR5cGUuc3RhcnRzV2l0aChcInRvb2wtXCIpO1xufVxuZnVuY3Rpb24gaXNEeW5hbWljVG9vbFVJUGFydChwYXJ0KSB7XG4gIHJldHVybiBwYXJ0LnR5cGUgPT09IFwiZHluYW1pYy10b29sXCI7XG59XG5mdW5jdGlvbiBpc1Rvb2xVSVBhcnQocGFydCkge1xuICByZXR1cm4gaXNTdGF0aWNUb29sVUlQYXJ0KHBhcnQpIHx8IGlzRHluYW1pY1Rvb2xVSVBhcnQocGFydCk7XG59XG52YXIgaXNUb29sT3JEeW5hbWljVG9vbFVJUGFydCA9IGlzVG9vbFVJUGFydDtcbmZ1bmN0aW9uIGdldFN0YXRpY1Rvb2xOYW1lKHBhcnQpIHtcbiAgcmV0dXJuIHBhcnQudHlwZS5zcGxpdChcIi1cIikuc2xpY2UoMSkuam9pbihcIi1cIik7XG59XG5mdW5jdGlvbiBnZXRUb29sTmFtZShwYXJ0KSB7XG4gIHJldHVybiBpc0R5bmFtaWNUb29sVUlQYXJ0KHBhcnQpID8gcGFydC50b29sTmFtZSA6IGdldFN0YXRpY1Rvb2xOYW1lKHBhcnQpO1xufVxudmFyIGdldFRvb2xPckR5bmFtaWNUb29sTmFtZSA9IGdldFRvb2xOYW1lO1xuXG4vLyBzcmMvdWkvcHJvY2Vzcy11aS1tZXNzYWdlLXN0cmVhbS50c1xuZnVuY3Rpb24gY3JlYXRlU3RyZWFtaW5nVUlNZXNzYWdlU3RhdGUoe1xuICBsYXN0TWVzc2FnZSxcbiAgbWVzc2FnZUlkXG59KSB7XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZTogKGxhc3RNZXNzYWdlID09IG51bGwgPyB2b2lkIDAgOiBsYXN0TWVzc2FnZS5yb2xlKSA9PT0gXCJhc3Npc3RhbnRcIiA/IGxhc3RNZXNzYWdlIDoge1xuICAgICAgaWQ6IG1lc3NhZ2VJZCxcbiAgICAgIG1ldGFkYXRhOiB2b2lkIDAsXG4gICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgcGFydHM6IFtdXG4gICAgfSxcbiAgICBhY3RpdmVUZXh0UGFydHM6IHt9LFxuICAgIGFjdGl2ZVJlYXNvbmluZ1BhcnRzOiB7fSxcbiAgICBwYXJ0aWFsVG9vbENhbGxzOiB7fVxuICB9O1xufVxuZnVuY3Rpb24gcHJvY2Vzc1VJTWVzc2FnZVN0cmVhbSh7XG4gIHN0cmVhbSxcbiAgbWVzc2FnZU1ldGFkYXRhU2NoZW1hLFxuICBkYXRhUGFydFNjaGVtYXMsXG4gIHJ1blVwZGF0ZU1lc3NhZ2VKb2IsXG4gIG9uRXJyb3IsXG4gIG9uVG9vbENhbGwsXG4gIG9uRGF0YVxufSkge1xuICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIGF3YWl0IHJ1blVwZGF0ZU1lc3NhZ2VKb2IoYXN5bmMgKHsgc3RhdGUsIHdyaXRlIH0pID0+IHtcbiAgICAgICAgICB2YXIgX2EyMSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICBmdW5jdGlvbiBnZXRUb29sSW52b2NhdGlvbih0b29sQ2FsbElkKSB7XG4gICAgICAgICAgICBjb25zdCB0b29sSW52b2NhdGlvbnMgPSBzdGF0ZS5tZXNzYWdlLnBhcnRzLmZpbHRlcihpc1Rvb2xVSVBhcnQpO1xuICAgICAgICAgICAgY29uc3QgdG9vbEludm9jYXRpb24gPSB0b29sSW52b2NhdGlvbnMuZmluZChcbiAgICAgICAgICAgICAgKGludm9jYXRpb24pID0+IGludm9jYXRpb24udG9vbENhbGxJZCA9PT0gdG9vbENhbGxJZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICh0b29sSW52b2NhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBVSU1lc3NhZ2VTdHJlYW1FcnJvcih7XG4gICAgICAgICAgICAgICAgY2h1bmtUeXBlOiBcInRvb2wtaW52b2NhdGlvblwiLFxuICAgICAgICAgICAgICAgIGNodW5rSWQ6IHRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYE5vIHRvb2wgaW52b2NhdGlvbiBmb3VuZCBmb3IgdG9vbCBjYWxsIElEIFwiJHt0b29sQ2FsbElkfVwiLmBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9vbEludm9jYXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVRvb2xQYXJ0KG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYTIyO1xuICAgICAgICAgICAgY29uc3QgcGFydCA9IHN0YXRlLm1lc3NhZ2UucGFydHMuZmluZChcbiAgICAgICAgICAgICAgKHBhcnQyKSA9PiBpc1N0YXRpY1Rvb2xVSVBhcnQocGFydDIpICYmIHBhcnQyLnRvb2xDYWxsSWQgPT09IG9wdGlvbnMudG9vbENhbGxJZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IGFueU9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgYW55UGFydCA9IHBhcnQ7XG4gICAgICAgICAgICBpZiAocGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHBhcnQuc3RhdGUgPSBvcHRpb25zLnN0YXRlO1xuICAgICAgICAgICAgICBhbnlQYXJ0LmlucHV0ID0gYW55T3B0aW9ucy5pbnB1dDtcbiAgICAgICAgICAgICAgYW55UGFydC5vdXRwdXQgPSBhbnlPcHRpb25zLm91dHB1dDtcbiAgICAgICAgICAgICAgYW55UGFydC5lcnJvclRleHQgPSBhbnlPcHRpb25zLmVycm9yVGV4dDtcbiAgICAgICAgICAgICAgYW55UGFydC5yYXdJbnB1dCA9IGFueU9wdGlvbnMucmF3SW5wdXQ7XG4gICAgICAgICAgICAgIGFueVBhcnQucHJlbGltaW5hcnkgPSBhbnlPcHRpb25zLnByZWxpbWluYXJ5O1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy50aXRsZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgYW55UGFydC50aXRsZSA9IG9wdGlvbnMudGl0bGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYW55UGFydC5wcm92aWRlckV4ZWN1dGVkID0gKF9hMjIgPSBhbnlPcHRpb25zLnByb3ZpZGVyRXhlY3V0ZWQpICE9IG51bGwgPyBfYTIyIDogcGFydC5wcm92aWRlckV4ZWN1dGVkO1xuICAgICAgICAgICAgICBpZiAoYW55T3B0aW9ucy5wcm92aWRlck1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXJ0LmNhbGxQcm92aWRlck1ldGFkYXRhID0gYW55T3B0aW9ucy5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdGF0ZS5tZXNzYWdlLnBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IGB0b29sLSR7b3B0aW9ucy50b29sTmFtZX1gLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IG9wdGlvbnMudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICBzdGF0ZTogb3B0aW9ucy5zdGF0ZSxcbiAgICAgICAgICAgICAgICB0aXRsZTogb3B0aW9ucy50aXRsZSxcbiAgICAgICAgICAgICAgICBpbnB1dDogYW55T3B0aW9ucy5pbnB1dCxcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IGFueU9wdGlvbnMub3V0cHV0LFxuICAgICAgICAgICAgICAgIHJhd0lucHV0OiBhbnlPcHRpb25zLnJhd0lucHV0LFxuICAgICAgICAgICAgICAgIGVycm9yVGV4dDogYW55T3B0aW9ucy5lcnJvclRleHQsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogYW55T3B0aW9ucy5wcm92aWRlckV4ZWN1dGVkLFxuICAgICAgICAgICAgICAgIHByZWxpbWluYXJ5OiBhbnlPcHRpb25zLnByZWxpbWluYXJ5LFxuICAgICAgICAgICAgICAgIC4uLmFueU9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBjYWxsUHJvdmlkZXJNZXRhZGF0YTogYW55T3B0aW9ucy5wcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gdXBkYXRlRHluYW1pY1Rvb2xQYXJ0KG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYTIyLCBfYjI7XG4gICAgICAgICAgICBjb25zdCBwYXJ0ID0gc3RhdGUubWVzc2FnZS5wYXJ0cy5maW5kKFxuICAgICAgICAgICAgICAocGFydDIpID0+IHBhcnQyLnR5cGUgPT09IFwiZHluYW1pYy10b29sXCIgJiYgcGFydDIudG9vbENhbGxJZCA9PT0gb3B0aW9ucy50b29sQ2FsbElkXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgYW55T3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBhbnlQYXJ0ID0gcGFydDtcbiAgICAgICAgICAgIGlmIChwYXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcGFydC5zdGF0ZSA9IG9wdGlvbnMuc3RhdGU7XG4gICAgICAgICAgICAgIGFueVBhcnQudG9vbE5hbWUgPSBvcHRpb25zLnRvb2xOYW1lO1xuICAgICAgICAgICAgICBhbnlQYXJ0LmlucHV0ID0gYW55T3B0aW9ucy5pbnB1dDtcbiAgICAgICAgICAgICAgYW55UGFydC5vdXRwdXQgPSBhbnlPcHRpb25zLm91dHB1dDtcbiAgICAgICAgICAgICAgYW55UGFydC5lcnJvclRleHQgPSBhbnlPcHRpb25zLmVycm9yVGV4dDtcbiAgICAgICAgICAgICAgYW55UGFydC5yYXdJbnB1dCA9IChfYTIyID0gYW55T3B0aW9ucy5yYXdJbnB1dCkgIT0gbnVsbCA/IF9hMjIgOiBhbnlQYXJ0LnJhd0lucHV0O1xuICAgICAgICAgICAgICBhbnlQYXJ0LnByZWxpbWluYXJ5ID0gYW55T3B0aW9ucy5wcmVsaW1pbmFyeTtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudGl0bGUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIGFueVBhcnQudGl0bGUgPSBvcHRpb25zLnRpdGxlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFueVBhcnQucHJvdmlkZXJFeGVjdXRlZCA9IChfYjIgPSBhbnlPcHRpb25zLnByb3ZpZGVyRXhlY3V0ZWQpICE9IG51bGwgPyBfYjIgOiBwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQ7XG4gICAgICAgICAgICAgIGlmIChhbnlPcHRpb25zLnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBhcnQuY2FsbFByb3ZpZGVyTWV0YWRhdGEgPSBhbnlPcHRpb25zLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0YXRlLm1lc3NhZ2UucGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJkeW5hbWljLXRvb2xcIixcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogb3B0aW9ucy50b29sTmFtZSxcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBvcHRpb25zLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgc3RhdGU6IG9wdGlvbnMuc3RhdGUsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IGFueU9wdGlvbnMuaW5wdXQsXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBhbnlPcHRpb25zLm91dHB1dCxcbiAgICAgICAgICAgICAgICBlcnJvclRleHQ6IGFueU9wdGlvbnMuZXJyb3JUZXh0LFxuICAgICAgICAgICAgICAgIHByZWxpbWluYXJ5OiBhbnlPcHRpb25zLnByZWxpbWluYXJ5LFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IGFueU9wdGlvbnMucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgICAgICAgICAgICB0aXRsZTogb3B0aW9ucy50aXRsZSxcbiAgICAgICAgICAgICAgICAuLi5hbnlPcHRpb25zLnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgY2FsbFByb3ZpZGVyTWV0YWRhdGE6IGFueU9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZU1lc3NhZ2VNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICAgICAgaWYgKG1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgY29uc3QgbWVyZ2VkTWV0YWRhdGEgPSBzdGF0ZS5tZXNzYWdlLm1ldGFkYXRhICE9IG51bGwgPyBtZXJnZU9iamVjdHMoc3RhdGUubWVzc2FnZS5tZXRhZGF0YSwgbWV0YWRhdGEpIDogbWV0YWRhdGE7XG4gICAgICAgICAgICAgIGlmIChtZXNzYWdlTWV0YWRhdGFTY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHZhbGlkYXRlVHlwZXMoe1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IG1lcmdlZE1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgc2NoZW1hOiBtZXNzYWdlTWV0YWRhdGFTY2hlbWEsXG4gICAgICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBcIm1lc3NhZ2UubWV0YWRhdGFcIixcbiAgICAgICAgICAgICAgICAgICAgZW50aXR5SWQ6IHN0YXRlLm1lc3NhZ2UuaWRcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdGF0ZS5tZXNzYWdlLm1ldGFkYXRhID0gbWVyZ2VkTWV0YWRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInRleHQtc3RhcnRcIjoge1xuICAgICAgICAgICAgICBjb25zdCB0ZXh0UGFydCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGNodW5rLnByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgc3RhdGU6IFwic3RyZWFtaW5nXCJcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlVGV4dFBhcnRzW2NodW5rLmlkXSA9IHRleHRQYXJ0O1xuICAgICAgICAgICAgICBzdGF0ZS5tZXNzYWdlLnBhcnRzLnB1c2godGV4dFBhcnQpO1xuICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgdGV4dFBhcnQgPSBzdGF0ZS5hY3RpdmVUZXh0UGFydHNbY2h1bmsuaWRdO1xuICAgICAgICAgICAgICBpZiAodGV4dFBhcnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVSU1lc3NhZ2VTdHJlYW1FcnJvcih7XG4gICAgICAgICAgICAgICAgICBjaHVua1R5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgY2h1bmtJZDogY2h1bmsuaWQsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgUmVjZWl2ZWQgdGV4dC1kZWx0YSBmb3IgbWlzc2luZyB0ZXh0IHBhcnQgd2l0aCBJRCBcIiR7Y2h1bmsuaWR9XCIuIEVuc3VyZSBhIFwidGV4dC1zdGFydFwiIGNodW5rIGlzIHNlbnQgYmVmb3JlIGFueSBcInRleHQtZGVsdGFcIiBjaHVua3MuYFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRleHRQYXJ0LnRleHQgKz0gY2h1bmsuZGVsdGE7XG4gICAgICAgICAgICAgIHRleHRQYXJ0LnByb3ZpZGVyTWV0YWRhdGEgPSAoX2EyMSA9IGNodW5rLnByb3ZpZGVyTWV0YWRhdGEpICE9IG51bGwgPyBfYTIxIDogdGV4dFBhcnQucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidGV4dC1lbmRcIjoge1xuICAgICAgICAgICAgICBjb25zdCB0ZXh0UGFydCA9IHN0YXRlLmFjdGl2ZVRleHRQYXJ0c1tjaHVuay5pZF07XG4gICAgICAgICAgICAgIGlmICh0ZXh0UGFydCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVJTWVzc2FnZVN0cmVhbUVycm9yKHtcbiAgICAgICAgICAgICAgICAgIGNodW5rVHlwZTogXCJ0ZXh0LWVuZFwiLFxuICAgICAgICAgICAgICAgICAgY2h1bmtJZDogY2h1bmsuaWQsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgUmVjZWl2ZWQgdGV4dC1lbmQgZm9yIG1pc3NpbmcgdGV4dCBwYXJ0IHdpdGggSUQgXCIke2NodW5rLmlkfVwiLiBFbnN1cmUgYSBcInRleHQtc3RhcnRcIiBjaHVuayBpcyBzZW50IGJlZm9yZSBhbnkgXCJ0ZXh0LWVuZFwiIGNodW5rcy5gXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGV4dFBhcnQuc3RhdGUgPSBcImRvbmVcIjtcbiAgICAgICAgICAgICAgdGV4dFBhcnQucHJvdmlkZXJNZXRhZGF0YSA9IChfYiA9IGNodW5rLnByb3ZpZGVyTWV0YWRhdGEpICE9IG51bGwgPyBfYiA6IHRleHRQYXJ0LnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5hY3RpdmVUZXh0UGFydHNbY2h1bmsuaWRdO1xuICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJyZWFzb25pbmctc3RhcnRcIjoge1xuICAgICAgICAgICAgICBjb25zdCByZWFzb25pbmdQYXJ0ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nXCIsXG4gICAgICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjaHVuay5wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIHN0YXRlOiBcInN0cmVhbWluZ1wiXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVJlYXNvbmluZ1BhcnRzW2NodW5rLmlkXSA9IHJlYXNvbmluZ1BhcnQ7XG4gICAgICAgICAgICAgIHN0YXRlLm1lc3NhZ2UucGFydHMucHVzaChyZWFzb25pbmdQYXJ0KTtcbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nLWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVhc29uaW5nUGFydCA9IHN0YXRlLmFjdGl2ZVJlYXNvbmluZ1BhcnRzW2NodW5rLmlkXTtcbiAgICAgICAgICAgICAgaWYgKHJlYXNvbmluZ1BhcnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVSU1lc3NhZ2VTdHJlYW1FcnJvcih7XG4gICAgICAgICAgICAgICAgICBjaHVua1R5cGU6IFwicmVhc29uaW5nLWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICBjaHVua0lkOiBjaHVuay5pZCxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBSZWNlaXZlZCByZWFzb25pbmctZGVsdGEgZm9yIG1pc3NpbmcgcmVhc29uaW5nIHBhcnQgd2l0aCBJRCBcIiR7Y2h1bmsuaWR9XCIuIEVuc3VyZSBhIFwicmVhc29uaW5nLXN0YXJ0XCIgY2h1bmsgaXMgc2VudCBiZWZvcmUgYW55IFwicmVhc29uaW5nLWRlbHRhXCIgY2h1bmtzLmBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZWFzb25pbmdQYXJ0LnRleHQgKz0gY2h1bmsuZGVsdGE7XG4gICAgICAgICAgICAgIHJlYXNvbmluZ1BhcnQucHJvdmlkZXJNZXRhZGF0YSA9IChfYyA9IGNodW5rLnByb3ZpZGVyTWV0YWRhdGEpICE9IG51bGwgPyBfYyA6IHJlYXNvbmluZ1BhcnQucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nLWVuZFwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlYXNvbmluZ1BhcnQgPSBzdGF0ZS5hY3RpdmVSZWFzb25pbmdQYXJ0c1tjaHVuay5pZF07XG4gICAgICAgICAgICAgIGlmIChyZWFzb25pbmdQYXJ0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVUlNZXNzYWdlU3RyZWFtRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgY2h1bmtUeXBlOiBcInJlYXNvbmluZy1lbmRcIixcbiAgICAgICAgICAgICAgICAgIGNodW5rSWQ6IGNodW5rLmlkLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYFJlY2VpdmVkIHJlYXNvbmluZy1lbmQgZm9yIG1pc3NpbmcgcmVhc29uaW5nIHBhcnQgd2l0aCBJRCBcIiR7Y2h1bmsuaWR9XCIuIEVuc3VyZSBhIFwicmVhc29uaW5nLXN0YXJ0XCIgY2h1bmsgaXMgc2VudCBiZWZvcmUgYW55IFwicmVhc29uaW5nLWVuZFwiIGNodW5rcy5gXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVhc29uaW5nUGFydC5wcm92aWRlck1ldGFkYXRhID0gKF9kID0gY2h1bmsucHJvdmlkZXJNZXRhZGF0YSkgIT0gbnVsbCA/IF9kIDogcmVhc29uaW5nUGFydC5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgICAgICByZWFzb25pbmdQYXJ0LnN0YXRlID0gXCJkb25lXCI7XG4gICAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5hY3RpdmVSZWFzb25pbmdQYXJ0c1tjaHVuay5pZF07XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImZpbGVcIjoge1xuICAgICAgICAgICAgICBzdGF0ZS5tZXNzYWdlLnBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAgICAgICAgIG1lZGlhVHlwZTogY2h1bmsubWVkaWFUeXBlLFxuICAgICAgICAgICAgICAgIHVybDogY2h1bmsudXJsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzb3VyY2UtdXJsXCI6IHtcbiAgICAgICAgICAgICAgc3RhdGUubWVzc2FnZS5wYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInNvdXJjZS11cmxcIixcbiAgICAgICAgICAgICAgICBzb3VyY2VJZDogY2h1bmsuc291cmNlSWQsXG4gICAgICAgICAgICAgICAgdXJsOiBjaHVuay51cmwsXG4gICAgICAgICAgICAgICAgdGl0bGU6IGNodW5rLnRpdGxlLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGNodW5rLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInNvdXJjZS1kb2N1bWVudFwiOiB7XG4gICAgICAgICAgICAgIHN0YXRlLm1lc3NhZ2UucGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzb3VyY2UtZG9jdW1lbnRcIixcbiAgICAgICAgICAgICAgICBzb3VyY2VJZDogY2h1bmsuc291cmNlSWQsXG4gICAgICAgICAgICAgICAgbWVkaWFUeXBlOiBjaHVuay5tZWRpYVR5cGUsXG4gICAgICAgICAgICAgICAgdGl0bGU6IGNodW5rLnRpdGxlLFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBjaHVuay5maWxlbmFtZSxcbiAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjaHVuay5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLWlucHV0LXN0YXJ0XCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgdG9vbEludm9jYXRpb25zID0gc3RhdGUubWVzc2FnZS5wYXJ0cy5maWx0ZXIoaXNTdGF0aWNUb29sVUlQYXJ0KTtcbiAgICAgICAgICAgICAgc3RhdGUucGFydGlhbFRvb2xDYWxsc1tjaHVuay50b29sQ2FsbElkXSA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSxcbiAgICAgICAgICAgICAgICBpbmRleDogdG9vbEludm9jYXRpb25zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBkeW5hbWljOiBjaHVuay5keW5hbWljLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBjaHVuay50aXRsZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZiAoY2h1bmsuZHluYW1pYykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUR5bmFtaWNUb29sUGFydCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiaW5wdXQtc3RyZWFtaW5nXCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dDogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogY2h1bmsucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgICAgICAgICAgICAgIHRpdGxlOiBjaHVuay50aXRsZSxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGNodW5rLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVUb29sUGFydCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiaW5wdXQtc3RyZWFtaW5nXCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dDogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogY2h1bmsucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgICAgICAgICAgICAgIHRpdGxlOiBjaHVuay50aXRsZSxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGNodW5rLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLWlucHV0LWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgcGFydGlhbFRvb2xDYWxsID0gc3RhdGUucGFydGlhbFRvb2xDYWxsc1tjaHVuay50b29sQ2FsbElkXTtcbiAgICAgICAgICAgICAgaWYgKHBhcnRpYWxUb29sQ2FsbCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVJTWVzc2FnZVN0cmVhbUVycm9yKHtcbiAgICAgICAgICAgICAgICAgIGNodW5rVHlwZTogXCJ0b29sLWlucHV0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICBjaHVua0lkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYFJlY2VpdmVkIHRvb2wtaW5wdXQtZGVsdGEgZm9yIG1pc3NpbmcgdG9vbCBjYWxsIHdpdGggSUQgXCIke2NodW5rLnRvb2xDYWxsSWR9XCIuIEVuc3VyZSBhIFwidG9vbC1pbnB1dC1zdGFydFwiIGNodW5rIGlzIHNlbnQgYmVmb3JlIGFueSBcInRvb2wtaW5wdXQtZGVsdGFcIiBjaHVua3MuYFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBhcnRpYWxUb29sQ2FsbC50ZXh0ICs9IGNodW5rLmlucHV0VGV4dERlbHRhO1xuICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlOiBwYXJ0aWFsQXJncyB9ID0gYXdhaXQgcGFyc2VQYXJ0aWFsSnNvbihcbiAgICAgICAgICAgICAgICBwYXJ0aWFsVG9vbENhbGwudGV4dFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAocGFydGlhbFRvb2xDYWxsLmR5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVEeW5hbWljVG9vbFBhcnQoe1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0aWFsVG9vbENhbGwudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogXCJpbnB1dC1zdHJlYW1pbmdcIixcbiAgICAgICAgICAgICAgICAgIGlucHV0OiBwYXJ0aWFsQXJncyxcbiAgICAgICAgICAgICAgICAgIHRpdGxlOiBwYXJ0aWFsVG9vbENhbGwudGl0bGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVUb29sUGFydCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IHBhcnRpYWxUb29sQ2FsbC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiBcImlucHV0LXN0cmVhbWluZ1wiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IHBhcnRpYWxBcmdzLFxuICAgICAgICAgICAgICAgICAgdGl0bGU6IHBhcnRpYWxUb29sQ2FsbC50aXRsZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtaW5wdXQtYXZhaWxhYmxlXCI6IHtcbiAgICAgICAgICAgICAgaWYgKGNodW5rLmR5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVEeW5hbWljVG9vbFBhcnQoe1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiBcImlucHV0LWF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IGNodW5rLmlucHV0LFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogY2h1bmsucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGNodW5rLnByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICB0aXRsZTogY2h1bmsudGl0bGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVUb29sUGFydCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiaW5wdXQtYXZhaWxhYmxlXCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dDogY2h1bmsuaW5wdXQsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiBjaHVuay5wcm92aWRlckV4ZWN1dGVkLFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogY2h1bmsucHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgIHRpdGxlOiBjaHVuay50aXRsZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGlmIChvblRvb2xDYWxsICYmICFjaHVuay5wcm92aWRlckV4ZWN1dGVkKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgb25Ub29sQ2FsbCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbDogY2h1bmtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLWlucHV0LWVycm9yXCI6IHtcbiAgICAgICAgICAgICAgaWYgKGNodW5rLmR5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVEeW5hbWljVG9vbFBhcnQoe1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiBcIm91dHB1dC1lcnJvclwiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IGNodW5rLmlucHV0LFxuICAgICAgICAgICAgICAgICAgZXJyb3JUZXh0OiBjaHVuay5lcnJvclRleHQsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiBjaHVuay5wcm92aWRlckV4ZWN1dGVkLFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogY2h1bmsucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVRvb2xQYXJ0KHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogY2h1bmsudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogXCJvdXRwdXQtZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgIGlucHV0OiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICByYXdJbnB1dDogY2h1bmsuaW5wdXQsXG4gICAgICAgICAgICAgICAgICBlcnJvclRleHQ6IGNodW5rLmVycm9yVGV4dCxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IGNodW5rLnByb3ZpZGVyRXhlY3V0ZWQsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjaHVuay5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgdG9vbEludm9jYXRpb24gPSBnZXRUb29sSW52b2NhdGlvbihjaHVuay50b29sQ2FsbElkKTtcbiAgICAgICAgICAgICAgdG9vbEludm9jYXRpb24uc3RhdGUgPSBcImFwcHJvdmFsLXJlcXVlc3RlZFwiO1xuICAgICAgICAgICAgICB0b29sSW52b2NhdGlvbi5hcHByb3ZhbCA9IHsgaWQ6IGNodW5rLmFwcHJvdmFsSWQgfTtcbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1vdXRwdXQtZGVuaWVkXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgdG9vbEludm9jYXRpb24gPSBnZXRUb29sSW52b2NhdGlvbihjaHVuay50b29sQ2FsbElkKTtcbiAgICAgICAgICAgICAgdG9vbEludm9jYXRpb24uc3RhdGUgPSBcIm91dHB1dC1kZW5pZWRcIjtcbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1vdXRwdXQtYXZhaWxhYmxlXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgdG9vbEludm9jYXRpb24gPSBnZXRUb29sSW52b2NhdGlvbihjaHVuay50b29sQ2FsbElkKTtcbiAgICAgICAgICAgICAgaWYgKHRvb2xJbnZvY2F0aW9uLnR5cGUgPT09IFwiZHluYW1pYy10b29sXCIpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVEeW5hbWljVG9vbFBhcnQoe1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiB0b29sSW52b2NhdGlvbi50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiBcIm91dHB1dC1hdmFpbGFibGVcIixcbiAgICAgICAgICAgICAgICAgIGlucHV0OiB0b29sSW52b2NhdGlvbi5pbnB1dCxcbiAgICAgICAgICAgICAgICAgIG91dHB1dDogY2h1bmsub3V0cHV0LFxuICAgICAgICAgICAgICAgICAgcHJlbGltaW5hcnk6IGNodW5rLnByZWxpbWluYXJ5LFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogY2h1bmsucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgICAgICAgICAgICAgIHRpdGxlOiB0b29sSW52b2NhdGlvbi50aXRsZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVRvb2xQYXJ0KHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogZ2V0U3RhdGljVG9vbE5hbWUodG9vbEludm9jYXRpb24pLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6IFwib3V0cHV0LWF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRvb2xJbnZvY2F0aW9uLmlucHV0LFxuICAgICAgICAgICAgICAgICAgb3V0cHV0OiBjaHVuay5vdXRwdXQsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiBjaHVuay5wcm92aWRlckV4ZWN1dGVkLFxuICAgICAgICAgICAgICAgICAgcHJlbGltaW5hcnk6IGNodW5rLnByZWxpbWluYXJ5LFxuICAgICAgICAgICAgICAgICAgdGl0bGU6IHRvb2xJbnZvY2F0aW9uLnRpdGxlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1vdXRwdXQtZXJyb3JcIjoge1xuICAgICAgICAgICAgICBjb25zdCB0b29sSW52b2NhdGlvbiA9IGdldFRvb2xJbnZvY2F0aW9uKGNodW5rLnRvb2xDYWxsSWQpO1xuICAgICAgICAgICAgICBpZiAodG9vbEludm9jYXRpb24udHlwZSA9PT0gXCJkeW5hbWljLXRvb2xcIikge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUR5bmFtaWNUb29sUGFydCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IHRvb2xJbnZvY2F0aW9uLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6IFwib3V0cHV0LWVycm9yXCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dDogdG9vbEludm9jYXRpb24uaW5wdXQsXG4gICAgICAgICAgICAgICAgICBlcnJvclRleHQ6IGNodW5rLmVycm9yVGV4dCxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IGNodW5rLnByb3ZpZGVyRXhlY3V0ZWQsXG4gICAgICAgICAgICAgICAgICB0aXRsZTogdG9vbEludm9jYXRpb24udGl0bGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVUb29sUGFydCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IGdldFN0YXRpY1Rvb2xOYW1lKHRvb2xJbnZvY2F0aW9uKSxcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiBcIm91dHB1dC1lcnJvclwiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRvb2xJbnZvY2F0aW9uLmlucHV0LFxuICAgICAgICAgICAgICAgICAgcmF3SW5wdXQ6IHRvb2xJbnZvY2F0aW9uLnJhd0lucHV0LFxuICAgICAgICAgICAgICAgICAgZXJyb3JUZXh0OiBjaHVuay5lcnJvclRleHQsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiBjaHVuay5wcm92aWRlckV4ZWN1dGVkLFxuICAgICAgICAgICAgICAgICAgdGl0bGU6IHRvb2xJbnZvY2F0aW9uLnRpdGxlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic3RhcnQtc3RlcFwiOiB7XG4gICAgICAgICAgICAgIHN0YXRlLm1lc3NhZ2UucGFydHMucHVzaCh7IHR5cGU6IFwic3RlcC1zdGFydFwiIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJmaW5pc2gtc3RlcFwiOiB7XG4gICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVRleHRQYXJ0cyA9IHt9O1xuICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVSZWFzb25pbmdQYXJ0cyA9IHt9O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzdGFydFwiOiB7XG4gICAgICAgICAgICAgIGlmIChjaHVuay5tZXNzYWdlSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLm1lc3NhZ2UuaWQgPSBjaHVuay5tZXNzYWdlSWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXdhaXQgdXBkYXRlTWVzc2FnZU1ldGFkYXRhKGNodW5rLm1lc3NhZ2VNZXRhZGF0YSk7XG4gICAgICAgICAgICAgIGlmIChjaHVuay5tZXNzYWdlSWQgIT0gbnVsbCB8fCBjaHVuay5tZXNzYWdlTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6IHtcbiAgICAgICAgICAgICAgaWYgKGNodW5rLmZpbmlzaFJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuZmluaXNoUmVhc29uID0gY2h1bmsuZmluaXNoUmVhc29uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGF3YWl0IHVwZGF0ZU1lc3NhZ2VNZXRhZGF0YShjaHVuay5tZXNzYWdlTWV0YWRhdGEpO1xuICAgICAgICAgICAgICBpZiAoY2h1bmsubWVzc2FnZU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2UtbWV0YWRhdGFcIjoge1xuICAgICAgICAgICAgICBhd2FpdCB1cGRhdGVNZXNzYWdlTWV0YWRhdGEoY2h1bmsubWVzc2FnZU1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgaWYgKGNodW5rLm1lc3NhZ2VNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOiB7XG4gICAgICAgICAgICAgIG9uRXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRXJyb3IobmV3IEVycm9yKGNodW5rLmVycm9yVGV4dCkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgaWYgKGlzRGF0YVVJTWVzc2FnZUNodW5rKGNodW5rKSkge1xuICAgICAgICAgICAgICAgIGlmICgoZGF0YVBhcnRTY2hlbWFzID09IG51bGwgPyB2b2lkIDAgOiBkYXRhUGFydFNjaGVtYXNbY2h1bmsudHlwZV0pICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRJZHggPSBzdGF0ZS5tZXNzYWdlLnBhcnRzLmZpbmRJbmRleChcbiAgICAgICAgICAgICAgICAgICAgKHApID0+IFwiaWRcIiBpbiBwICYmIFwiZGF0YVwiIGluIHAgJiYgcC5pZCA9PT0gY2h1bmsuaWQgJiYgcC50eXBlID09PSBjaHVuay50eXBlXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgY29uc3QgYWN0dWFsUGFydElkeCA9IHBhcnRJZHggPj0gMCA/IHBhcnRJZHggOiBzdGF0ZS5tZXNzYWdlLnBhcnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIGF3YWl0IHZhbGlkYXRlVHlwZXMoe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2h1bmsuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hOiBkYXRhUGFydFNjaGVtYXNbY2h1bmsudHlwZV0sXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogYG1lc3NhZ2UucGFydHNbJHthY3R1YWxQYXJ0SWR4fV0uZGF0YWAsXG4gICAgICAgICAgICAgICAgICAgICAgZW50aXR5TmFtZTogY2h1bmsudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICBlbnRpdHlJZDogY2h1bmsuaWRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFDaHVuayA9IGNodW5rO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhQ2h1bmsudHJhbnNpZW50KSB7XG4gICAgICAgICAgICAgICAgICBvbkRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRGF0YShkYXRhQ2h1bmspO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVUlQYXJ0ID0gZGF0YUNodW5rLmlkICE9IG51bGwgPyBzdGF0ZS5tZXNzYWdlLnBhcnRzLmZpbmQoXG4gICAgICAgICAgICAgICAgICAoY2h1bmtBcmcpID0+IGRhdGFDaHVuay50eXBlID09PSBjaHVua0FyZy50eXBlICYmIGRhdGFDaHVuay5pZCA9PT0gY2h1bmtBcmcuaWRcbiAgICAgICAgICAgICAgICApIDogdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ1VJUGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBleGlzdGluZ1VJUGFydC5kYXRhID0gZGF0YUNodW5rLmRhdGE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHN0YXRlLm1lc3NhZ2UucGFydHMucHVzaChkYXRhQ2h1bmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvbkRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRGF0YShkYXRhQ2h1bmspO1xuICAgICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSlcbiAgKTtcbn1cblxuLy8gc3JjL3VpLW1lc3NhZ2Utc3RyZWFtL2hhbmRsZS11aS1tZXNzYWdlLXN0cmVhbS1maW5pc2gudHNcbmZ1bmN0aW9uIGhhbmRsZVVJTWVzc2FnZVN0cmVhbUZpbmlzaCh7XG4gIG1lc3NhZ2VJZCxcbiAgb3JpZ2luYWxNZXNzYWdlcyA9IFtdLFxuICBvblN0ZXBGaW5pc2gsXG4gIG9uRmluaXNoLFxuICBvbkVycm9yLFxuICBzdHJlYW1cbn0pIHtcbiAgbGV0IGxhc3RNZXNzYWdlID0gb3JpZ2luYWxNZXNzYWdlcyA9PSBudWxsID8gdm9pZCAwIDogb3JpZ2luYWxNZXNzYWdlc1tvcmlnaW5hbE1lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICBpZiAoKGxhc3RNZXNzYWdlID09IG51bGwgPyB2b2lkIDAgOiBsYXN0TWVzc2FnZS5yb2xlKSAhPT0gXCJhc3Npc3RhbnRcIikge1xuICAgIGxhc3RNZXNzYWdlID0gdm9pZCAwO1xuICB9IGVsc2Uge1xuICAgIG1lc3NhZ2VJZCA9IGxhc3RNZXNzYWdlLmlkO1xuICB9XG4gIGxldCBpc0Fib3J0ZWQgPSBmYWxzZTtcbiAgY29uc3QgaWRJbmplY3RlZFN0cmVhbSA9IHN0cmVhbS5waXBlVGhyb3VnaChcbiAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJzdGFydFwiKSB7XG4gICAgICAgICAgY29uc3Qgc3RhcnRDaHVuayA9IGNodW5rO1xuICAgICAgICAgIGlmIChzdGFydENodW5rLm1lc3NhZ2VJZCA9PSBudWxsICYmIG1lc3NhZ2VJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzdGFydENodW5rLm1lc3NhZ2VJZCA9IG1lc3NhZ2VJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwiYWJvcnRcIikge1xuICAgICAgICAgIGlzQWJvcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgIH1cbiAgICB9KVxuICApO1xuICBpZiAob25GaW5pc2ggPT0gbnVsbCAmJiBvblN0ZXBGaW5pc2ggPT0gbnVsbCkge1xuICAgIHJldHVybiBpZEluamVjdGVkU3RyZWFtO1xuICB9XG4gIGNvbnN0IHN0YXRlID0gY3JlYXRlU3RyZWFtaW5nVUlNZXNzYWdlU3RhdGUoe1xuICAgIGxhc3RNZXNzYWdlOiBsYXN0TWVzc2FnZSA/IHN0cnVjdHVyZWRDbG9uZShsYXN0TWVzc2FnZSkgOiB2b2lkIDAsXG4gICAgbWVzc2FnZUlkOiBtZXNzYWdlSWQgIT0gbnVsbCA/IG1lc3NhZ2VJZCA6IFwiXCJcbiAgICAvLyB3aWxsIGJlIG92ZXJyaWRkZW4gYnkgdGhlIHN0cmVhbVxuICB9KTtcbiAgY29uc3QgcnVuVXBkYXRlTWVzc2FnZUpvYiA9IGFzeW5jIChqb2IpID0+IHtcbiAgICBhd2FpdCBqb2IoeyBzdGF0ZSwgd3JpdGU6ICgpID0+IHtcbiAgICB9IH0pO1xuICB9O1xuICBsZXQgZmluaXNoQ2FsbGVkID0gZmFsc2U7XG4gIGNvbnN0IGNhbGxPbkZpbmlzaCA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoZmluaXNoQ2FsbGVkIHx8ICFvbkZpbmlzaCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaW5pc2hDYWxsZWQgPSB0cnVlO1xuICAgIGNvbnN0IGlzQ29udGludWF0aW9uID0gc3RhdGUubWVzc2FnZS5pZCA9PT0gKGxhc3RNZXNzYWdlID09IG51bGwgPyB2b2lkIDAgOiBsYXN0TWVzc2FnZS5pZCk7XG4gICAgYXdhaXQgb25GaW5pc2goe1xuICAgICAgaXNBYm9ydGVkLFxuICAgICAgaXNDb250aW51YXRpb24sXG4gICAgICByZXNwb25zZU1lc3NhZ2U6IHN0YXRlLm1lc3NhZ2UsXG4gICAgICBtZXNzYWdlczogW1xuICAgICAgICAuLi5pc0NvbnRpbnVhdGlvbiA/IG9yaWdpbmFsTWVzc2FnZXMuc2xpY2UoMCwgLTEpIDogb3JpZ2luYWxNZXNzYWdlcyxcbiAgICAgICAgc3RhdGUubWVzc2FnZVxuICAgICAgXSxcbiAgICAgIGZpbmlzaFJlYXNvbjogc3RhdGUuZmluaXNoUmVhc29uXG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IGNhbGxPblN0ZXBGaW5pc2ggPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFvblN0ZXBGaW5pc2gpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXNDb250aW51YXRpb24gPSBzdGF0ZS5tZXNzYWdlLmlkID09PSAobGFzdE1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RNZXNzYWdlLmlkKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgb25TdGVwRmluaXNoKHtcbiAgICAgICAgaXNDb250aW51YXRpb24sXG4gICAgICAgIHJlc3BvbnNlTWVzc2FnZTogc3RydWN0dXJlZENsb25lKHN0YXRlLm1lc3NhZ2UpLFxuICAgICAgICBtZXNzYWdlczogW1xuICAgICAgICAgIC4uLmlzQ29udGludWF0aW9uID8gb3JpZ2luYWxNZXNzYWdlcy5zbGljZSgwLCAtMSkgOiBvcmlnaW5hbE1lc3NhZ2VzLFxuICAgICAgICAgIHN0cnVjdHVyZWRDbG9uZShzdGF0ZS5tZXNzYWdlKVxuICAgICAgICBdXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgfVxuICB9O1xuICByZXR1cm4gcHJvY2Vzc1VJTWVzc2FnZVN0cmVhbSh7XG4gICAgc3RyZWFtOiBpZEluamVjdGVkU3RyZWFtLFxuICAgIHJ1blVwZGF0ZU1lc3NhZ2VKb2IsXG4gICAgb25FcnJvclxuICB9KS5waXBlVGhyb3VnaChcbiAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJmaW5pc2gtc3RlcFwiKSB7XG4gICAgICAgICAgYXdhaXQgY2FsbE9uU3RlcEZpbmlzaCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICB9LFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBjYW5jZWwgaXMgc3RpbGwgbmV3IGFuZCBtaXNzaW5nIGZyb20gdHlwZXMgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RyYW5zZm9ybVN0cmVhbSNicm93c2VyX2NvbXBhdGliaWxpdHlcbiAgICAgIGFzeW5jIGNhbmNlbCgpIHtcbiAgICAgICAgYXdhaXQgY2FsbE9uRmluaXNoKCk7XG4gICAgICB9LFxuICAgICAgYXN5bmMgZmx1c2goKSB7XG4gICAgICAgIGF3YWl0IGNhbGxPbkZpbmlzaCgpO1xuICAgICAgfVxuICAgIH0pXG4gICk7XG59XG5cbi8vIHNyYy91aS1tZXNzYWdlLXN0cmVhbS9waXBlLXVpLW1lc3NhZ2Utc3RyZWFtLXRvLXJlc3BvbnNlLnRzXG5mdW5jdGlvbiBwaXBlVUlNZXNzYWdlU3RyZWFtVG9SZXNwb25zZSh7XG4gIHJlc3BvbnNlLFxuICBzdGF0dXMsXG4gIHN0YXR1c1RleHQsXG4gIGhlYWRlcnMsXG4gIHN0cmVhbSxcbiAgY29uc3VtZVNzZVN0cmVhbVxufSkge1xuICBsZXQgc3NlU3RyZWFtID0gc3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBKc29uVG9Tc2VUcmFuc2Zvcm1TdHJlYW0oKSk7XG4gIGlmIChjb25zdW1lU3NlU3RyZWFtKSB7XG4gICAgY29uc3QgW3N0cmVhbTEsIHN0cmVhbTJdID0gc3NlU3RyZWFtLnRlZSgpO1xuICAgIHNzZVN0cmVhbSA9IHN0cmVhbTE7XG4gICAgY29uc3VtZVNzZVN0cmVhbSh7IHN0cmVhbTogc3RyZWFtMiB9KTtcbiAgfVxuICB3cml0ZVRvU2VydmVyUmVzcG9uc2Uoe1xuICAgIHJlc3BvbnNlLFxuICAgIHN0YXR1cyxcbiAgICBzdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIHByZXBhcmVIZWFkZXJzKGhlYWRlcnMsIFVJX01FU1NBR0VfU1RSRUFNX0hFQURFUlMpLmVudHJpZXMoKVxuICAgICksXG4gICAgc3RyZWFtOiBzc2VTdHJlYW0ucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpXG4gIH0pO1xufVxuXG4vLyBzcmMvdXRpbC9hc3luYy1pdGVyYWJsZS1zdHJlYW0udHNcbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oc291cmNlKSB7XG4gIGNvbnN0IHN0cmVhbSA9IHNvdXJjZS5waXBlVGhyb3VnaChuZXcgVHJhbnNmb3JtU3RyZWFtKCkpO1xuICBzdHJlYW1bU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgcmVhZGVyID0gdGhpcy5nZXRSZWFkZXIoKTtcbiAgICBsZXQgZmluaXNoZWQgPSBmYWxzZTtcbiAgICBhc3luYyBmdW5jdGlvbiBjbGVhbnVwKGNhbmNlbFN0cmVhbSkge1xuICAgICAgdmFyIF9hMjE7XG4gICAgICBpZiAoZmluaXNoZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChjYW5jZWxTdHJlYW0pIHtcbiAgICAgICAgICBhd2FpdCAoKF9hMjEgPSByZWFkZXIuY2FuY2VsKSA9PSBudWxsID8gdm9pZCAwIDogX2EyMS5jYWxsKHJlYWRlcikpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC8qKlxuICAgICAgICogUmVhZHMgdGhlIG5leHQgY2h1bmsgZnJvbSB0aGUgc3RyZWFtLlxuICAgICAgICogQHJldHVybnMgQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgbmV4dCBJdGVyYXRvclJlc3VsdC5cbiAgICAgICAqL1xuICAgICAgYXN5bmMgbmV4dCgpIHtcbiAgICAgICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHZvaWQgMCB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgYXdhaXQgY2xlYW51cCh0cnVlKTtcbiAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdm9pZCAwIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlIH07XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBNYXkgYmUgY2FsbGVkIG9uIGVhcmx5IGV4aXQgKGUuZy4sIGJyZWFrIGZyb20gZm9yLWF3YWl0KSBvciBhZnRlciBjb21wbGV0aW9uLlxuICAgICAgICogRW5zdXJlcyB0aGUgc3RyZWFtIGlzIGNhbmNlbGxlZCBhbmQgcmVzb3VyY2VzIGFyZSByZWxlYXNlZC5cbiAgICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gYSBjb21wbGV0ZWQgSXRlcmF0b3JSZXN1bHQuXG4gICAgICAgKi9cbiAgICAgIGFzeW5jIHJldHVybigpIHtcbiAgICAgICAgYXdhaXQgY2xlYW51cCh0cnVlKTtcbiAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHZvaWQgMCB9O1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGVkIG9uIGVhcmx5IGV4aXQgd2l0aCBlcnJvci5cbiAgICAgICAqIEVuc3VyZXMgdGhlIHN0cmVhbSBpcyBjYW5jZWxsZWQgYW5kIHJlc291cmNlcyBhcmUgcmVsZWFzZWQsIHRoZW4gcmV0aHJvd3MgdGhlIGVycm9yLlxuICAgICAgICogQHBhcmFtIGVyciBUaGUgZXJyb3IgdG8gdGhyb3cuXG4gICAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZWplY3RzIHdpdGggdGhlIHByb3ZpZGVkIGVycm9yLlxuICAgICAgICovXG4gICAgICBhc3luYyB0aHJvdyhlcnIpIHtcbiAgICAgICAgYXdhaXQgY2xlYW51cCh0cnVlKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIHJldHVybiBzdHJlYW07XG59XG5cbi8vIHNyYy91dGlsL2NvbnN1bWUtc3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiBjb25zdW1lU3RyZWFtKHtcbiAgc3RyZWFtLFxuICBvbkVycm9yXG59KSB7XG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgdHJ5IHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgeyBkb25lIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgaWYgKGRvbmUpXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBvbkVycm9yID09IG51bGwgPyB2b2lkIDAgOiBvbkVycm9yKGVycm9yKTtcbiAgfSBmaW5hbGx5IHtcbiAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbC9jcmVhdGUtcmVzb2x2YWJsZS1wcm9taXNlLnRzXG5mdW5jdGlvbiBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpIHtcbiAgbGV0IHJlc29sdmUzO1xuICBsZXQgcmVqZWN0O1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgcmVzb2x2ZTMgPSByZXM7XG4gICAgcmVqZWN0ID0gcmVqO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBwcm9taXNlLFxuICAgIHJlc29sdmU6IHJlc29sdmUzLFxuICAgIHJlamVjdFxuICB9O1xufVxuXG4vLyBzcmMvdXRpbC9jcmVhdGUtc3RpdGNoYWJsZS1zdHJlYW0udHNcbmZ1bmN0aW9uIGNyZWF0ZVN0aXRjaGFibGVTdHJlYW0oKSB7XG4gIGxldCBpbm5lclN0cmVhbVJlYWRlcnMgPSBbXTtcbiAgbGV0IGNvbnRyb2xsZXIgPSBudWxsO1xuICBsZXQgaXNDbG9zZWQgPSBmYWxzZTtcbiAgbGV0IHdhaXRGb3JOZXdTdHJlYW0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICBjb25zdCB0ZXJtaW5hdGUgPSAoKSA9PiB7XG4gICAgaXNDbG9zZWQgPSB0cnVlO1xuICAgIHdhaXRGb3JOZXdTdHJlYW0ucmVzb2x2ZSgpO1xuICAgIGlubmVyU3RyZWFtUmVhZGVycy5mb3JFYWNoKChyZWFkZXIpID0+IHJlYWRlci5jYW5jZWwoKSk7XG4gICAgaW5uZXJTdHJlYW1SZWFkZXJzID0gW107XG4gICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5jbG9zZSgpO1xuICB9O1xuICBjb25zdCBwcm9jZXNzUHVsbCA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoaXNDbG9zZWQgJiYgaW5uZXJTdHJlYW1SZWFkZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaW5uZXJTdHJlYW1SZWFkZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgd2FpdEZvck5ld1N0cmVhbSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgICBhd2FpdCB3YWl0Rm9yTmV3U3RyZWFtLnByb21pc2U7XG4gICAgICByZXR1cm4gcHJvY2Vzc1B1bGwoKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IGlubmVyU3RyZWFtUmVhZGVyc1swXS5yZWFkKCk7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICBpbm5lclN0cmVhbVJlYWRlcnMuc2hpZnQoKTtcbiAgICAgICAgaWYgKGlubmVyU3RyZWFtUmVhZGVycy5sZW5ndGggPT09IDAgJiYgaXNDbG9zZWQpIHtcbiAgICAgICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXdhaXQgcHJvY2Vzc1B1bGwoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5lcnJvcihlcnJvcik7XG4gICAgICBpbm5lclN0cmVhbVJlYWRlcnMuc2hpZnQoKTtcbiAgICAgIHRlcm1pbmF0ZSgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBzdHJlYW06IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICBzdGFydChjb250cm9sbGVyUGFyYW0pIHtcbiAgICAgICAgY29udHJvbGxlciA9IGNvbnRyb2xsZXJQYXJhbTtcbiAgICAgIH0sXG4gICAgICBwdWxsOiBwcm9jZXNzUHVsbCxcbiAgICAgIGFzeW5jIGNhbmNlbCgpIHtcbiAgICAgICAgZm9yIChjb25zdCByZWFkZXIgb2YgaW5uZXJTdHJlYW1SZWFkZXJzKSB7XG4gICAgICAgICAgYXdhaXQgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICAgIGlubmVyU3RyZWFtUmVhZGVycyA9IFtdO1xuICAgICAgICBpc0Nsb3NlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSksXG4gICAgYWRkU3RyZWFtOiAoaW5uZXJTdHJlYW0pID0+IHtcbiAgICAgIGlmIChpc0Nsb3NlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYWRkIGlubmVyIHN0cmVhbTogb3V0ZXIgc3RyZWFtIGlzIGNsb3NlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlubmVyU3RyZWFtUmVhZGVycy5wdXNoKGlubmVyU3RyZWFtLmdldFJlYWRlcigpKTtcbiAgICAgIHdhaXRGb3JOZXdTdHJlYW0ucmVzb2x2ZSgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR3JhY2VmdWxseSBjbG9zZSB0aGUgb3V0ZXIgc3RyZWFtLiBUaGlzIHdpbGwgbGV0IHRoZSBpbm5lciBzdHJlYW1zXG4gICAgICogZmluaXNoIHByb2Nlc3NpbmcgYW5kIHRoZW4gY2xvc2UgdGhlIG91dGVyIHN0cmVhbS5cbiAgICAgKi9cbiAgICBjbG9zZTogKCkgPT4ge1xuICAgICAgaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgd2FpdEZvck5ld1N0cmVhbS5yZXNvbHZlKCk7XG4gICAgICBpZiAoaW5uZXJTdHJlYW1SZWFkZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJbW1lZGlhdGVseSBjbG9zZSB0aGUgb3V0ZXIgc3RyZWFtLiBUaGlzIHdpbGwgY2FuY2VsIGFsbCBpbm5lciBzdHJlYW1zXG4gICAgICogYW5kIGNsb3NlIHRoZSBvdXRlciBzdHJlYW0uXG4gICAgICovXG4gICAgdGVybWluYXRlXG4gIH07XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L3J1bi10b29scy10cmFuc2Zvcm1hdGlvbi50c1xuaW1wb3J0IHtcbiAgZ2V0RXJyb3JNZXNzYWdlIGFzIGdldEVycm9yTWVzc2FnZTZcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmZ1bmN0aW9uIHJ1blRvb2xzVHJhbnNmb3JtYXRpb24oe1xuICB0b29scyxcbiAgZ2VuZXJhdG9yU3RyZWFtLFxuICB0cmFjZXIsXG4gIHRlbGVtZXRyeSxcbiAgc3lzdGVtLFxuICBtZXNzYWdlcyxcbiAgYWJvcnRTaWduYWwsXG4gIHJlcGFpclRvb2xDYWxsLFxuICBleHBlcmltZW50YWxfY29udGV4dCxcbiAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDIsXG4gIHN0ZXBOdW1iZXIsXG4gIG1vZGVsLFxuICBvblRvb2xDYWxsU3RhcnQsXG4gIG9uVG9vbENhbGxGaW5pc2hcbn0pIHtcbiAgbGV0IHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlciA9IG51bGw7XG4gIGNvbnN0IHRvb2xSZXN1bHRzU3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IG91dHN0YW5kaW5nVG9vbFJlc3VsdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCB0b29sSW5wdXRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgdG9vbENhbGxzQnlUb29sQ2FsbElkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IGNhbkNsb3NlID0gZmFsc2U7XG4gIGxldCBmaW5pc2hDaHVuayA9IHZvaWQgMDtcbiAgZnVuY3Rpb24gYXR0ZW1wdENsb3NlKCkge1xuICAgIGlmIChjYW5DbG9zZSAmJiBvdXRzdGFuZGluZ1Rvb2xSZXN1bHRzLnNpemUgPT09IDApIHtcbiAgICAgIGlmIChmaW5pc2hDaHVuayAhPSBudWxsKSB7XG4gICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKGZpbmlzaENodW5rKTtcbiAgICAgIH1cbiAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5jbG9zZSgpO1xuICAgIH1cbiAgfVxuICBjb25zdCBmb3J3YXJkU3RyZWFtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBjaHVua1R5cGUgPSBjaHVuay50eXBlO1xuICAgICAgc3dpdGNoIChjaHVua1R5cGUpIHtcbiAgICAgICAgY2FzZSBcInN0cmVhbS1zdGFydFwiOlxuICAgICAgICBjYXNlIFwidGV4dC1zdGFydFwiOlxuICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICBjYXNlIFwidGV4dC1lbmRcIjpcbiAgICAgICAgY2FzZSBcInJlYXNvbmluZy1zdGFydFwiOlxuICAgICAgICBjYXNlIFwicmVhc29uaW5nLWRlbHRhXCI6XG4gICAgICAgIGNhc2UgXCJyZWFzb25pbmctZW5kXCI6XG4gICAgICAgIGNhc2UgXCJ0b29sLWlucHV0LXN0YXJ0XCI6XG4gICAgICAgIGNhc2UgXCJ0b29sLWlucHV0LWRlbHRhXCI6XG4gICAgICAgIGNhc2UgXCJ0b29sLWlucHV0LWVuZFwiOlxuICAgICAgICBjYXNlIFwic291cmNlXCI6XG4gICAgICAgIGNhc2UgXCJyZXNwb25zZS1tZXRhZGF0YVwiOlxuICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgY2FzZSBcInJhd1wiOiB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZmlsZVwiOiB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAgICAgZmlsZTogbmV3IERlZmF1bHRHZW5lcmF0ZWRGaWxlV2l0aFR5cGUoe1xuICAgICAgICAgICAgICBkYXRhOiBjaHVuay5kYXRhLFxuICAgICAgICAgICAgICBtZWRpYVR5cGU6IGNodW5rLm1lZGlhVHlwZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZmluaXNoXCI6IHtcbiAgICAgICAgICBmaW5pc2hDaHVuayA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZmluaXNoXCIsXG4gICAgICAgICAgICBmaW5pc2hSZWFzb246IGNodW5rLmZpbmlzaFJlYXNvbi51bmlmaWVkLFxuICAgICAgICAgICAgcmF3RmluaXNoUmVhc29uOiBjaHVuay5maW5pc2hSZWFzb24ucmF3LFxuICAgICAgICAgICAgdXNhZ2U6IGFzTGFuZ3VhZ2VNb2RlbFVzYWdlKGNodW5rLnVzYWdlKSxcbiAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGNodW5rLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ0b29sLWFwcHJvdmFsLXJlcXVlc3RcIjoge1xuICAgICAgICAgIGNvbnN0IHRvb2xDYWxsID0gdG9vbENhbGxzQnlUb29sQ2FsbElkLmdldChjaHVuay50b29sQ2FsbElkKTtcbiAgICAgICAgICBpZiAodG9vbENhbGwgPT0gbnVsbCkge1xuICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgIGVycm9yOiBuZXcgVG9vbENhbGxOb3RGb3VuZEZvckFwcHJvdmFsRXJyb3Ioe1xuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgYXBwcm92YWxJZDogY2h1bmsuYXBwcm92YWxJZFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgIHR5cGU6IFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCIsXG4gICAgICAgICAgICBhcHByb3ZhbElkOiBjaHVuay5hcHByb3ZhbElkLFxuICAgICAgICAgICAgdG9vbENhbGxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwidG9vbC1jYWxsXCI6IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdG9vbENhbGwgPSBhd2FpdCBwYXJzZVRvb2xDYWxsKHtcbiAgICAgICAgICAgICAgdG9vbENhbGw6IGNodW5rLFxuICAgICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgICAgcmVwYWlyVG9vbENhbGwsXG4gICAgICAgICAgICAgIHN5c3RlbSxcbiAgICAgICAgICAgICAgbWVzc2FnZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdG9vbENhbGxzQnlUb29sQ2FsbElkLnNldCh0b29sQ2FsbC50b29sQ2FsbElkLCB0b29sQ2FsbCk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodG9vbENhbGwpO1xuICAgICAgICAgICAgaWYgKHRvb2xDYWxsLmludmFsaWQpIHtcbiAgICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1lcnJvclwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIGlucHV0OiB0b29sQ2FsbC5pbnB1dCxcbiAgICAgICAgICAgICAgICBlcnJvcjogZ2V0RXJyb3JNZXNzYWdlNih0b29sQ2FsbC5lcnJvciksXG4gICAgICAgICAgICAgICAgZHluYW1pYzogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0aXRsZTogdG9vbENhbGwudGl0bGVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdG9vbDIgPSB0b29scyA9PSBudWxsID8gdm9pZCAwIDogdG9vbHNbdG9vbENhbGwudG9vbE5hbWVdO1xuICAgICAgICAgICAgaWYgKHRvb2wyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9vbDIub25JbnB1dEF2YWlsYWJsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGF3YWl0IHRvb2wyLm9uSW5wdXRBdmFpbGFibGUoe1xuICAgICAgICAgICAgICAgIGlucHV0OiB0b29sQ2FsbC5pbnB1dCxcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF3YWl0IGlzQXBwcm92YWxOZWVkZWQoe1xuICAgICAgICAgICAgICB0b29sOiB0b29sMixcbiAgICAgICAgICAgICAgdG9vbENhbGwsXG4gICAgICAgICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICAgICAgICBleHBlcmltZW50YWxfY29udGV4dFxuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCIsXG4gICAgICAgICAgICAgICAgYXBwcm92YWxJZDogZ2VuZXJhdGVJZDIoKSxcbiAgICAgICAgICAgICAgICB0b29sQ2FsbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b29sSW5wdXRzLnNldCh0b29sQ2FsbC50b29sQ2FsbElkLCB0b29sQ2FsbC5pbnB1dCk7XG4gICAgICAgICAgICBpZiAodG9vbDIuZXhlY3V0ZSAhPSBudWxsICYmIHRvb2xDYWxsLnByb3ZpZGVyRXhlY3V0ZWQgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgY29uc3QgdG9vbEV4ZWN1dGlvbklkID0gZ2VuZXJhdGVJZDIoKTtcbiAgICAgICAgICAgICAgb3V0c3RhbmRpbmdUb29sUmVzdWx0cy5hZGQodG9vbEV4ZWN1dGlvbklkKTtcbiAgICAgICAgICAgICAgZXhlY3V0ZVRvb2xDYWxsKHtcbiAgICAgICAgICAgICAgICB0b29sQ2FsbCxcbiAgICAgICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0LFxuICAgICAgICAgICAgICAgIHN0ZXBOdW1iZXIsXG4gICAgICAgICAgICAgICAgbW9kZWwsXG4gICAgICAgICAgICAgICAgb25Ub29sQ2FsbFN0YXJ0LFxuICAgICAgICAgICAgICAgIG9uVG9vbENhbGxGaW5pc2gsXG4gICAgICAgICAgICAgICAgb25QcmVsaW1pbmFyeVRvb2xSZXN1bHQ6IChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZShyZXN1bHQpO1xuICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICBvdXRzdGFuZGluZ1Rvb2xSZXN1bHRzLmRlbGV0ZSh0b29sRXhlY3V0aW9uSWQpO1xuICAgICAgICAgICAgICAgIGF0dGVtcHRDbG9zZSgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcImVycm9yXCIsIGVycm9yIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwidG9vbC1yZXN1bHRcIjoge1xuICAgICAgICAgIGNvbnN0IHRvb2xOYW1lID0gY2h1bmsudG9vbE5hbWU7XG4gICAgICAgICAgaWYgKGNodW5rLmlzRXJyb3IpIHtcbiAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWVycm9yXCIsXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgIHRvb2xOYW1lLFxuICAgICAgICAgICAgICBpbnB1dDogdG9vbElucHV0cy5nZXQoY2h1bmsudG9vbENhbGxJZCksXG4gICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgIGVycm9yOiBjaHVuay5yZXN1bHQsXG4gICAgICAgICAgICAgIGR5bmFtaWM6IGNodW5rLmR5bmFtaWNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgIHRvb2xOYW1lLFxuICAgICAgICAgICAgICBpbnB1dDogdG9vbElucHV0cy5nZXQoY2h1bmsudG9vbENhbGxJZCksXG4gICAgICAgICAgICAgIG91dHB1dDogY2h1bmsucmVzdWx0LFxuICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB0cnVlLFxuICAgICAgICAgICAgICBkeW5hbWljOiBjaHVuay5keW5hbWljXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBjaHVua1R5cGU7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmhhbmRsZWQgY2h1bmsgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBmbHVzaCgpIHtcbiAgICAgIGNhbkNsb3NlID0gdHJ1ZTtcbiAgICAgIGF0dGVtcHRDbG9zZSgpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgIGdlbmVyYXRvclN0cmVhbS5waXBlVGhyb3VnaChmb3J3YXJkU3RyZWFtKS5waXBlVG8oXG4gICAgICAgICAgbmV3IFdyaXRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIHdyaXRlKGNodW5rKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKSxcbiAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW0ucGlwZVRvKFxuICAgICAgICAgIG5ldyBXcml0YWJsZVN0cmVhbSh7XG4gICAgICAgICAgICB3cml0ZShjaHVuaykge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlKCkge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgXSk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2dlbmVyYXRlLXRleHQvc3RyZWFtLXRleHQudHNcbnZhciBvcmlnaW5hbEdlbmVyYXRlSWQyID0gY3JlYXRlSWRHZW5lcmF0b3IyKHtcbiAgcHJlZml4OiBcImFpdHh0XCIsXG4gIHNpemU6IDI0XG59KTtcbmZ1bmN0aW9uIHN0cmVhbVRleHQoe1xuICBtb2RlbCxcbiAgdG9vbHMsXG4gIHRvb2xDaG9pY2UsXG4gIHN5c3RlbSxcbiAgcHJvbXB0LFxuICBtZXNzYWdlcyxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIHRpbWVvdXQsXG4gIGhlYWRlcnMsXG4gIHN0b3BXaGVuID0gc3RlcENvdW50SXMoMSksXG4gIGV4cGVyaW1lbnRhbF9vdXRwdXQsXG4gIG91dHB1dCA9IGV4cGVyaW1lbnRhbF9vdXRwdXQsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeSxcbiAgcHJlcGFyZVN0ZXAsXG4gIHByb3ZpZGVyT3B0aW9ucyxcbiAgZXhwZXJpbWVudGFsX2FjdGl2ZVRvb2xzLFxuICBhY3RpdmVUb29scyA9IGV4cGVyaW1lbnRhbF9hY3RpdmVUb29scyxcbiAgZXhwZXJpbWVudGFsX3JlcGFpclRvb2xDYWxsOiByZXBhaXJUb29sQ2FsbCxcbiAgZXhwZXJpbWVudGFsX3RyYW5zZm9ybTogdHJhbnNmb3JtLFxuICBleHBlcmltZW50YWxfZG93bmxvYWQ6IGRvd25sb2FkMixcbiAgaW5jbHVkZVJhd0NodW5rcyA9IGZhbHNlLFxuICBvbkNodW5rLFxuICBvbkVycm9yID0gKHsgZXJyb3IgfSkgPT4ge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICB9LFxuICBvbkZpbmlzaCxcbiAgb25BYm9ydCxcbiAgb25TdGVwRmluaXNoLFxuICBleHBlcmltZW50YWxfb25TdGFydDogb25TdGFydCxcbiAgZXhwZXJpbWVudGFsX29uU3RlcFN0YXJ0OiBvblN0ZXBTdGFydCxcbiAgZXhwZXJpbWVudGFsX29uVG9vbENhbGxTdGFydDogb25Ub29sQ2FsbFN0YXJ0LFxuICBleHBlcmltZW50YWxfb25Ub29sQ2FsbEZpbmlzaDogb25Ub29sQ2FsbEZpbmlzaCxcbiAgZXhwZXJpbWVudGFsX2NvbnRleHQsXG4gIGV4cGVyaW1lbnRhbF9pbmNsdWRlOiBpbmNsdWRlLFxuICBfaW50ZXJuYWw6IHsgbm93OiBub3cyID0gbm93LCBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMiA9IG9yaWdpbmFsR2VuZXJhdGVJZDIgfSA9IHt9LFxuICAuLi5zZXR0aW5nc1xufSkge1xuICBjb25zdCB0b3RhbFRpbWVvdXRNcyA9IGdldFRvdGFsVGltZW91dE1zKHRpbWVvdXQpO1xuICBjb25zdCBzdGVwVGltZW91dE1zID0gZ2V0U3RlcFRpbWVvdXRNcyh0aW1lb3V0KTtcbiAgY29uc3QgY2h1bmtUaW1lb3V0TXMgPSBnZXRDaHVua1RpbWVvdXRNcyh0aW1lb3V0KTtcbiAgY29uc3Qgc3RlcEFib3J0Q29udHJvbGxlciA9IHN0ZXBUaW1lb3V0TXMgIT0gbnVsbCA/IG5ldyBBYm9ydENvbnRyb2xsZXIoKSA6IHZvaWQgMDtcbiAgY29uc3QgY2h1bmtBYm9ydENvbnRyb2xsZXIgPSBjaHVua1RpbWVvdXRNcyAhPSBudWxsID8gbmV3IEFib3J0Q29udHJvbGxlcigpIDogdm9pZCAwO1xuICByZXR1cm4gbmV3IERlZmF1bHRTdHJlYW1UZXh0UmVzdWx0KHtcbiAgICBtb2RlbDogcmVzb2x2ZUxhbmd1YWdlTW9kZWwobW9kZWwpLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzLFxuICAgIG1heFJldHJpZXMsXG4gICAgYWJvcnRTaWduYWw6IG1lcmdlQWJvcnRTaWduYWxzKFxuICAgICAgYWJvcnRTaWduYWwsXG4gICAgICB0b3RhbFRpbWVvdXRNcyAhPSBudWxsID8gQWJvcnRTaWduYWwudGltZW91dCh0b3RhbFRpbWVvdXRNcykgOiB2b2lkIDAsXG4gICAgICBzdGVwQWJvcnRDb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBzdGVwQWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgIGNodW5rQWJvcnRDb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjaHVua0Fib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICApLFxuICAgIHN0ZXBUaW1lb3V0TXMsXG4gICAgc3RlcEFib3J0Q29udHJvbGxlcixcbiAgICBjaHVua1RpbWVvdXRNcyxcbiAgICBjaHVua0Fib3J0Q29udHJvbGxlcixcbiAgICBzeXN0ZW0sXG4gICAgcHJvbXB0LFxuICAgIG1lc3NhZ2VzLFxuICAgIHRvb2xzLFxuICAgIHRvb2xDaG9pY2UsXG4gICAgdHJhbnNmb3JtczogYXNBcnJheSh0cmFuc2Zvcm0pLFxuICAgIGFjdGl2ZVRvb2xzLFxuICAgIHJlcGFpclRvb2xDYWxsLFxuICAgIHN0b3BDb25kaXRpb25zOiBhc0FycmF5KHN0b3BXaGVuKSxcbiAgICBvdXRwdXQsXG4gICAgcHJvdmlkZXJPcHRpb25zLFxuICAgIHByZXBhcmVTdGVwLFxuICAgIGluY2x1ZGVSYXdDaHVua3MsXG4gICAgdGltZW91dCxcbiAgICBzdG9wV2hlbixcbiAgICBvcmlnaW5hbEFib3J0U2lnbmFsOiBhYm9ydFNpZ25hbCxcbiAgICBvbkNodW5rLFxuICAgIG9uRXJyb3IsXG4gICAgb25GaW5pc2gsXG4gICAgb25BYm9ydCxcbiAgICBvblN0ZXBGaW5pc2gsXG4gICAgb25TdGFydCxcbiAgICBvblN0ZXBTdGFydCxcbiAgICBvblRvb2xDYWxsU3RhcnQsXG4gICAgb25Ub29sQ2FsbEZpbmlzaCxcbiAgICBub3c6IG5vdzIsXG4gICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDIsXG4gICAgZXhwZXJpbWVudGFsX2NvbnRleHQsXG4gICAgZG93bmxvYWQ6IGRvd25sb2FkMixcbiAgICBpbmNsdWRlXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlT3V0cHV0VHJhbnNmb3JtU3RyZWFtKG91dHB1dCkge1xuICBsZXQgZmlyc3RUZXh0Q2h1bmtJZCA9IHZvaWQgMDtcbiAgbGV0IHRleHQyID0gXCJcIjtcbiAgbGV0IHRleHRDaHVuayA9IFwiXCI7XG4gIGxldCB0ZXh0UHJvdmlkZXJNZXRhZGF0YSA9IHZvaWQgMDtcbiAgbGV0IGxhc3RQdWJsaXNoZWRKc29uID0gXCJcIjtcbiAgZnVuY3Rpb24gcHVibGlzaFRleHRDaHVuayh7XG4gICAgY29udHJvbGxlcixcbiAgICBwYXJ0aWFsT3V0cHV0ID0gdm9pZCAwXG4gIH0pIHtcbiAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgcGFydDoge1xuICAgICAgICB0eXBlOiBcInRleHQtZGVsdGFcIixcbiAgICAgICAgaWQ6IGZpcnN0VGV4dENodW5rSWQsXG4gICAgICAgIHRleHQ6IHRleHRDaHVuayxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogdGV4dFByb3ZpZGVyTWV0YWRhdGFcbiAgICAgIH0sXG4gICAgICBwYXJ0aWFsT3V0cHV0XG4gICAgfSk7XG4gICAgdGV4dENodW5rID0gXCJcIjtcbiAgfVxuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICB2YXIgX2EyMTtcbiAgICAgIGlmIChjaHVuay50eXBlID09PSBcImZpbmlzaC1zdGVwXCIgJiYgdGV4dENodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcHVibGlzaFRleHRDaHVuayh7IGNvbnRyb2xsZXIgfSk7XG4gICAgICB9XG4gICAgICBpZiAoY2h1bmsudHlwZSAhPT0gXCJ0ZXh0LWRlbHRhXCIgJiYgY2h1bmsudHlwZSAhPT0gXCJ0ZXh0LXN0YXJ0XCIgJiYgY2h1bmsudHlwZSAhPT0gXCJ0ZXh0LWVuZFwiKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHBhcnQ6IGNodW5rLCBwYXJ0aWFsT3V0cHV0OiB2b2lkIDAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChmaXJzdFRleHRDaHVua0lkID09IG51bGwpIHtcbiAgICAgICAgZmlyc3RUZXh0Q2h1bmtJZCA9IGNodW5rLmlkO1xuICAgICAgfSBlbHNlIGlmIChjaHVuay5pZCAhPT0gZmlyc3RUZXh0Q2h1bmtJZCkge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyBwYXJ0OiBjaHVuaywgcGFydGlhbE91dHB1dDogdm9pZCAwIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LXN0YXJ0XCIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgcGFydDogY2h1bmssIHBhcnRpYWxPdXRwdXQ6IHZvaWQgMCB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwidGV4dC1lbmRcIikge1xuICAgICAgICBpZiAodGV4dENodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBwdWJsaXNoVGV4dENodW5rKHsgY29udHJvbGxlciB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyBwYXJ0OiBjaHVuaywgcGFydGlhbE91dHB1dDogdm9pZCAwIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0ZXh0MiArPSBjaHVuay50ZXh0O1xuICAgICAgdGV4dENodW5rICs9IGNodW5rLnRleHQ7XG4gICAgICB0ZXh0UHJvdmlkZXJNZXRhZGF0YSA9IChfYTIxID0gY2h1bmsucHJvdmlkZXJNZXRhZGF0YSkgIT0gbnVsbCA/IF9hMjEgOiB0ZXh0UHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG91dHB1dC5wYXJzZVBhcnRpYWxPdXRwdXQoeyB0ZXh0OiB0ZXh0MiB9KTtcbiAgICAgIGlmIChyZXN1bHQgIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBjdXJyZW50SnNvbiA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdC5wYXJ0aWFsKTtcbiAgICAgICAgaWYgKGN1cnJlbnRKc29uICE9PSBsYXN0UHVibGlzaGVkSnNvbikge1xuICAgICAgICAgIHB1Ymxpc2hUZXh0Q2h1bmsoeyBjb250cm9sbGVyLCBwYXJ0aWFsT3V0cHV0OiByZXN1bHQucGFydGlhbCB9KTtcbiAgICAgICAgICBsYXN0UHVibGlzaGVkSnNvbiA9IGN1cnJlbnRKc29uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbnZhciBEZWZhdWx0U3RyZWFtVGV4dFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzLFxuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gICAgYWJvcnRTaWduYWwsXG4gICAgc3RlcFRpbWVvdXRNcyxcbiAgICBzdGVwQWJvcnRDb250cm9sbGVyLFxuICAgIGNodW5rVGltZW91dE1zLFxuICAgIGNodW5rQWJvcnRDb250cm9sbGVyLFxuICAgIHN5c3RlbSxcbiAgICBwcm9tcHQsXG4gICAgbWVzc2FnZXMsXG4gICAgdG9vbHMsXG4gICAgdG9vbENob2ljZSxcbiAgICB0cmFuc2Zvcm1zLFxuICAgIGFjdGl2ZVRvb2xzLFxuICAgIHJlcGFpclRvb2xDYWxsLFxuICAgIHN0b3BDb25kaXRpb25zLFxuICAgIG91dHB1dCxcbiAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgcHJlcGFyZVN0ZXAsXG4gICAgaW5jbHVkZVJhd0NodW5rcyxcbiAgICBub3c6IG5vdzIsXG4gICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDIsXG4gICAgdGltZW91dCxcbiAgICBzdG9wV2hlbixcbiAgICBvcmlnaW5hbEFib3J0U2lnbmFsLFxuICAgIG9uQ2h1bmssXG4gICAgb25FcnJvcixcbiAgICBvbkZpbmlzaCxcbiAgICBvbkFib3J0LFxuICAgIG9uU3RlcEZpbmlzaCxcbiAgICBvblN0YXJ0LFxuICAgIG9uU3RlcFN0YXJ0LFxuICAgIG9uVG9vbENhbGxTdGFydCxcbiAgICBvblRvb2xDYWxsRmluaXNoLFxuICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0LFxuICAgIGRvd25sb2FkOiBkb3dubG9hZDIsXG4gICAgaW5jbHVkZVxuICB9KSB7XG4gICAgdGhpcy5fdG90YWxVc2FnZSA9IG5ldyBEZWxheWVkUHJvbWlzZSgpO1xuICAgIHRoaXMuX2ZpbmlzaFJlYXNvbiA9IG5ldyBEZWxheWVkUHJvbWlzZSgpO1xuICAgIHRoaXMuX3Jhd0ZpbmlzaFJlYXNvbiA9IG5ldyBEZWxheWVkUHJvbWlzZSgpO1xuICAgIHRoaXMuX3N0ZXBzID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy5vdXRwdXRTcGVjaWZpY2F0aW9uID0gb3V0cHV0O1xuICAgIHRoaXMuaW5jbHVkZVJhd0NodW5rcyA9IGluY2x1ZGVSYXdDaHVua3M7XG4gICAgdGhpcy50b29scyA9IHRvb2xzO1xuICAgIGxldCBzdGVwRmluaXNoO1xuICAgIGxldCByZWNvcmRlZENvbnRlbnQgPSBbXTtcbiAgICBjb25zdCByZWNvcmRlZFJlc3BvbnNlTWVzc2FnZXMgPSBbXTtcbiAgICBsZXQgcmVjb3JkZWRGaW5pc2hSZWFzb24gPSB2b2lkIDA7XG4gICAgbGV0IHJlY29yZGVkUmF3RmluaXNoUmVhc29uID0gdm9pZCAwO1xuICAgIGxldCByZWNvcmRlZFRvdGFsVXNhZ2UgPSB2b2lkIDA7XG4gICAgbGV0IHJlY29yZGVkUmVxdWVzdCA9IHt9O1xuICAgIGxldCByZWNvcmRlZFdhcm5pbmdzID0gW107XG4gICAgY29uc3QgcmVjb3JkZWRTdGVwcyA9IFtdO1xuICAgIGNvbnN0IHBlbmRpbmdEZWZlcnJlZFRvb2xDYWxscyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgbGV0IHJvb3RTcGFuO1xuICAgIGxldCBhY3RpdmVUZXh0Q29udGVudCA9IHt9O1xuICAgIGxldCBhY3RpdmVSZWFzb25pbmdDb250ZW50ID0ge307XG4gICAgY29uc3QgZXZlbnRQcm9jZXNzb3IgPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICB2YXIgX2EyMSwgX2IsIF9jLCBfZDtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgY29uc3QgeyBwYXJ0IH0gPSBjaHVuaztcbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0ZXh0LWRlbHRhXCIgfHwgcGFydC50eXBlID09PSBcInJlYXNvbmluZy1kZWx0YVwiIHx8IHBhcnQudHlwZSA9PT0gXCJzb3VyY2VcIiB8fCBwYXJ0LnR5cGUgPT09IFwidG9vbC1jYWxsXCIgfHwgcGFydC50eXBlID09PSBcInRvb2wtcmVzdWx0XCIgfHwgcGFydC50eXBlID09PSBcInRvb2wtaW5wdXQtc3RhcnRcIiB8fCBwYXJ0LnR5cGUgPT09IFwidG9vbC1pbnB1dC1kZWx0YVwiIHx8IHBhcnQudHlwZSA9PT0gXCJyYXdcIikge1xuICAgICAgICAgIGF3YWl0IChvbkNodW5rID09IG51bGwgPyB2b2lkIDAgOiBvbkNodW5rKHsgY2h1bms6IHBhcnQgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgIGF3YWl0IG9uRXJyb3IoeyBlcnJvcjogd3JhcEdhdGV3YXlFcnJvcihwYXJ0LmVycm9yKSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRleHQtc3RhcnRcIikge1xuICAgICAgICAgIGFjdGl2ZVRleHRDb250ZW50W3BhcnQuaWRdID0ge1xuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZWNvcmRlZENvbnRlbnQucHVzaChhY3RpdmVUZXh0Q29udGVudFtwYXJ0LmlkXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgICBjb25zdCBhY3RpdmVUZXh0ID0gYWN0aXZlVGV4dENvbnRlbnRbcGFydC5pZF07XG4gICAgICAgICAgaWYgKGFjdGl2ZVRleHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgcGFydDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICBlcnJvcjogYHRleHQgcGFydCAke3BhcnQuaWR9IG5vdCBmb3VuZGBcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcGFydGlhbE91dHB1dDogdm9pZCAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWN0aXZlVGV4dC50ZXh0ICs9IHBhcnQudGV4dDtcbiAgICAgICAgICBhY3RpdmVUZXh0LnByb3ZpZGVyTWV0YWRhdGEgPSAoX2EyMSA9IHBhcnQucHJvdmlkZXJNZXRhZGF0YSkgIT0gbnVsbCA/IF9hMjEgOiBhY3RpdmVUZXh0LnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0ZXh0LWVuZFwiKSB7XG4gICAgICAgICAgY29uc3QgYWN0aXZlVGV4dCA9IGFjdGl2ZVRleHRDb250ZW50W3BhcnQuaWRdO1xuICAgICAgICAgIGlmIChhY3RpdmVUZXh0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgIHBhcnQ6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGB0ZXh0IHBhcnQgJHtwYXJ0LmlkfSBub3QgZm91bmRgXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHBhcnRpYWxPdXRwdXQ6IHZvaWQgMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGFjdGl2ZVRleHQucHJvdmlkZXJNZXRhZGF0YSA9IChfYiA9IHBhcnQucHJvdmlkZXJNZXRhZGF0YSkgIT0gbnVsbCA/IF9iIDogYWN0aXZlVGV4dC5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgIGRlbGV0ZSBhY3RpdmVUZXh0Q29udGVudFtwYXJ0LmlkXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInJlYXNvbmluZy1zdGFydFwiKSB7XG4gICAgICAgICAgYWN0aXZlUmVhc29uaW5nQ29udGVudFtwYXJ0LmlkXSA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nXCIsXG4gICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZWNvcmRlZENvbnRlbnQucHVzaChhY3RpdmVSZWFzb25pbmdDb250ZW50W3BhcnQuaWRdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInJlYXNvbmluZy1kZWx0YVwiKSB7XG4gICAgICAgICAgY29uc3QgYWN0aXZlUmVhc29uaW5nID0gYWN0aXZlUmVhc29uaW5nQ29udGVudFtwYXJ0LmlkXTtcbiAgICAgICAgICBpZiAoYWN0aXZlUmVhc29uaW5nID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgIHBhcnQ6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGByZWFzb25pbmcgcGFydCAke3BhcnQuaWR9IG5vdCBmb3VuZGBcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcGFydGlhbE91dHB1dDogdm9pZCAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWN0aXZlUmVhc29uaW5nLnRleHQgKz0gcGFydC50ZXh0O1xuICAgICAgICAgIGFjdGl2ZVJlYXNvbmluZy5wcm92aWRlck1ldGFkYXRhID0gKF9jID0gcGFydC5wcm92aWRlck1ldGFkYXRhKSAhPSBudWxsID8gX2MgOiBhY3RpdmVSZWFzb25pbmcucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInJlYXNvbmluZy1lbmRcIikge1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZVJlYXNvbmluZyA9IGFjdGl2ZVJlYXNvbmluZ0NvbnRlbnRbcGFydC5pZF07XG4gICAgICAgICAgaWYgKGFjdGl2ZVJlYXNvbmluZyA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICBwYXJ0OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIGVycm9yOiBgcmVhc29uaW5nIHBhcnQgJHtwYXJ0LmlkfSBub3QgZm91bmRgXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHBhcnRpYWxPdXRwdXQ6IHZvaWQgMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGFjdGl2ZVJlYXNvbmluZy5wcm92aWRlck1ldGFkYXRhID0gKF9kID0gcGFydC5wcm92aWRlck1ldGFkYXRhKSAhPSBudWxsID8gX2QgOiBhY3RpdmVSZWFzb25pbmcucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICBkZWxldGUgYWN0aXZlUmVhc29uaW5nQ29udGVudFtwYXJ0LmlkXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcImZpbGVcIikge1xuICAgICAgICAgIHJlY29yZGVkQ29udGVudC5wdXNoKHsgdHlwZTogXCJmaWxlXCIsIGZpbGU6IHBhcnQuZmlsZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInNvdXJjZVwiKSB7XG4gICAgICAgICAgcmVjb3JkZWRDb250ZW50LnB1c2gocGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0b29sLWNhbGxcIikge1xuICAgICAgICAgIHJlY29yZGVkQ29udGVudC5wdXNoKHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidG9vbC1yZXN1bHRcIiAmJiAhcGFydC5wcmVsaW1pbmFyeSkge1xuICAgICAgICAgIHJlY29yZGVkQ29udGVudC5wdXNoKHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCIpIHtcbiAgICAgICAgICByZWNvcmRlZENvbnRlbnQucHVzaChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRvb2wtZXJyb3JcIikge1xuICAgICAgICAgIHJlY29yZGVkQ29udGVudC5wdXNoKHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwic3RhcnQtc3RlcFwiKSB7XG4gICAgICAgICAgcmVjb3JkZWRDb250ZW50ID0gW107XG4gICAgICAgICAgYWN0aXZlUmVhc29uaW5nQ29udGVudCA9IHt9O1xuICAgICAgICAgIGFjdGl2ZVRleHRDb250ZW50ID0ge307XG4gICAgICAgICAgcmVjb3JkZWRSZXF1ZXN0ID0gcGFydC5yZXF1ZXN0O1xuICAgICAgICAgIHJlY29yZGVkV2FybmluZ3MgPSBwYXJ0Lndhcm5pbmdzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwiZmluaXNoLXN0ZXBcIikge1xuICAgICAgICAgIGNvbnN0IHN0ZXBNZXNzYWdlcyA9IGF3YWl0IHRvUmVzcG9uc2VNZXNzYWdlcyh7XG4gICAgICAgICAgICBjb250ZW50OiByZWNvcmRlZENvbnRlbnQsXG4gICAgICAgICAgICB0b29sc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdGVwUmVzdWx0ID0gbmV3IERlZmF1bHRTdGVwUmVzdWx0KHtcbiAgICAgICAgICAgIHN0ZXBOdW1iZXI6IHJlY29yZGVkU3RlcHMubGVuZ3RoLFxuICAgICAgICAgICAgbW9kZWw6IG1vZGVsSW5mbyxcbiAgICAgICAgICAgIC4uLmNhbGxiYWNrVGVsZW1ldHJ5UHJvcHMsXG4gICAgICAgICAgICBleHBlcmltZW50YWxfY29udGV4dCxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHJlY29yZGVkQ29udGVudCxcbiAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogcGFydC5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICByYXdGaW5pc2hSZWFzb246IHBhcnQucmF3RmluaXNoUmVhc29uLFxuICAgICAgICAgICAgdXNhZ2U6IHBhcnQudXNhZ2UsXG4gICAgICAgICAgICB3YXJuaW5nczogcmVjb3JkZWRXYXJuaW5ncyxcbiAgICAgICAgICAgIHJlcXVlc3Q6IHJlY29yZGVkUmVxdWVzdCxcbiAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgIC4uLnBhcnQucmVzcG9uc2UsXG4gICAgICAgICAgICAgIG1lc3NhZ2VzOiBbLi4ucmVjb3JkZWRSZXNwb25zZU1lc3NhZ2VzLCAuLi5zdGVwTWVzc2FnZXNdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXdhaXQgKG9uU3RlcEZpbmlzaCA9PSBudWxsID8gdm9pZCAwIDogb25TdGVwRmluaXNoKGN1cnJlbnRTdGVwUmVzdWx0KSk7XG4gICAgICAgICAgbG9nV2FybmluZ3Moe1xuICAgICAgICAgICAgd2FybmluZ3M6IHJlY29yZGVkV2FybmluZ3MsXG4gICAgICAgICAgICBwcm92aWRlcjogbW9kZWxJbmZvLnByb3ZpZGVyLFxuICAgICAgICAgICAgbW9kZWw6IG1vZGVsSW5mby5tb2RlbElkXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVjb3JkZWRTdGVwcy5wdXNoKGN1cnJlbnRTdGVwUmVzdWx0KTtcbiAgICAgICAgICByZWNvcmRlZFJlc3BvbnNlTWVzc2FnZXMucHVzaCguLi5zdGVwTWVzc2FnZXMpO1xuICAgICAgICAgIHN0ZXBGaW5pc2gucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwiZmluaXNoXCIpIHtcbiAgICAgICAgICByZWNvcmRlZFRvdGFsVXNhZ2UgPSBwYXJ0LnRvdGFsVXNhZ2U7XG4gICAgICAgICAgcmVjb3JkZWRGaW5pc2hSZWFzb24gPSBwYXJ0LmZpbmlzaFJlYXNvbjtcbiAgICAgICAgICByZWNvcmRlZFJhd0ZpbmlzaFJlYXNvbiA9IHBhcnQucmF3RmluaXNoUmVhc29uO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYXN5bmMgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChyZWNvcmRlZFN0ZXBzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSAoYWJvcnRTaWduYWwgPT0gbnVsbCA/IHZvaWQgMCA6IGFib3J0U2lnbmFsLmFib3J0ZWQpID8gYWJvcnRTaWduYWwucmVhc29uIDogbmV3IE5vT3V0cHV0R2VuZXJhdGVkRXJyb3Ioe1xuICAgICAgICAgICAgICBtZXNzYWdlOiBcIk5vIG91dHB1dCBnZW5lcmF0ZWQuIENoZWNrIHRoZSBzdHJlYW0gZm9yIGVycm9ycy5cIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxmLl9maW5pc2hSZWFzb24ucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIHNlbGYuX3Jhd0ZpbmlzaFJlYXNvbi5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgc2VsZi5fdG90YWxVc2FnZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgc2VsZi5fc3RlcHMucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZmluaXNoUmVhc29uID0gcmVjb3JkZWRGaW5pc2hSZWFzb24gIT0gbnVsbCA/IHJlY29yZGVkRmluaXNoUmVhc29uIDogXCJvdGhlclwiO1xuICAgICAgICAgIGNvbnN0IHRvdGFsVXNhZ2UgPSByZWNvcmRlZFRvdGFsVXNhZ2UgIT0gbnVsbCA/IHJlY29yZGVkVG90YWxVc2FnZSA6IGNyZWF0ZU51bGxMYW5ndWFnZU1vZGVsVXNhZ2UoKTtcbiAgICAgICAgICBzZWxmLl9maW5pc2hSZWFzb24ucmVzb2x2ZShmaW5pc2hSZWFzb24pO1xuICAgICAgICAgIHNlbGYuX3Jhd0ZpbmlzaFJlYXNvbi5yZXNvbHZlKHJlY29yZGVkUmF3RmluaXNoUmVhc29uKTtcbiAgICAgICAgICBzZWxmLl90b3RhbFVzYWdlLnJlc29sdmUodG90YWxVc2FnZSk7XG4gICAgICAgICAgc2VsZi5fc3RlcHMucmVzb2x2ZShyZWNvcmRlZFN0ZXBzKTtcbiAgICAgICAgICBjb25zdCBmaW5hbFN0ZXAgPSByZWNvcmRlZFN0ZXBzW3JlY29yZGVkU3RlcHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgYXdhaXQgKG9uRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvbkZpbmlzaCh7XG4gICAgICAgICAgICBzdGVwTnVtYmVyOiBmaW5hbFN0ZXAuc3RlcE51bWJlcixcbiAgICAgICAgICAgIG1vZGVsOiBmaW5hbFN0ZXAubW9kZWwsXG4gICAgICAgICAgICBmdW5jdGlvbklkOiBmaW5hbFN0ZXAuZnVuY3Rpb25JZCxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBmaW5hbFN0ZXAubWV0YWRhdGEsXG4gICAgICAgICAgICBleHBlcmltZW50YWxfY29udGV4dDogZmluYWxTdGVwLmV4cGVyaW1lbnRhbF9jb250ZXh0LFxuICAgICAgICAgICAgZmluaXNoUmVhc29uOiBmaW5hbFN0ZXAuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgcmF3RmluaXNoUmVhc29uOiBmaW5hbFN0ZXAucmF3RmluaXNoUmVhc29uLFxuICAgICAgICAgICAgdG90YWxVc2FnZSxcbiAgICAgICAgICAgIHVzYWdlOiBmaW5hbFN0ZXAudXNhZ2UsXG4gICAgICAgICAgICBjb250ZW50OiBmaW5hbFN0ZXAuY29udGVudCxcbiAgICAgICAgICAgIHRleHQ6IGZpbmFsU3RlcC50ZXh0LFxuICAgICAgICAgICAgcmVhc29uaW5nVGV4dDogZmluYWxTdGVwLnJlYXNvbmluZ1RleHQsXG4gICAgICAgICAgICByZWFzb25pbmc6IGZpbmFsU3RlcC5yZWFzb25pbmcsXG4gICAgICAgICAgICBmaWxlczogZmluYWxTdGVwLmZpbGVzLFxuICAgICAgICAgICAgc291cmNlczogZmluYWxTdGVwLnNvdXJjZXMsXG4gICAgICAgICAgICB0b29sQ2FsbHM6IGZpbmFsU3RlcC50b29sQ2FsbHMsXG4gICAgICAgICAgICBzdGF0aWNUb29sQ2FsbHM6IGZpbmFsU3RlcC5zdGF0aWNUb29sQ2FsbHMsXG4gICAgICAgICAgICBkeW5hbWljVG9vbENhbGxzOiBmaW5hbFN0ZXAuZHluYW1pY1Rvb2xDYWxscyxcbiAgICAgICAgICAgIHRvb2xSZXN1bHRzOiBmaW5hbFN0ZXAudG9vbFJlc3VsdHMsXG4gICAgICAgICAgICBzdGF0aWNUb29sUmVzdWx0czogZmluYWxTdGVwLnN0YXRpY1Rvb2xSZXN1bHRzLFxuICAgICAgICAgICAgZHluYW1pY1Rvb2xSZXN1bHRzOiBmaW5hbFN0ZXAuZHluYW1pY1Rvb2xSZXN1bHRzLFxuICAgICAgICAgICAgcmVxdWVzdDogZmluYWxTdGVwLnJlcXVlc3QsXG4gICAgICAgICAgICByZXNwb25zZTogZmluYWxTdGVwLnJlc3BvbnNlLFxuICAgICAgICAgICAgd2FybmluZ3M6IGZpbmFsU3RlcC53YXJuaW5ncyxcbiAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGZpbmFsU3RlcC5wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgc3RlcHM6IHJlY29yZGVkU3RlcHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcm9vdFNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgIGF3YWl0IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiBmaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50ZXh0XCI6IHsgb3V0cHV0OiAoKSA9PiBmaW5hbFN0ZXAudGV4dCB9LFxuICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UucmVhc29uaW5nXCI6IHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gZmluYWxTdGVwLnJlYXNvbmluZ1RleHRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudG9vbENhbGxzXCI6IHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EyMTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoX2EyMSA9IGZpbmFsU3RlcC50b29sQ2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIxLmxlbmd0aCkgPyBKU09OLnN0cmluZ2lmeShmaW5hbFN0ZXAudG9vbENhbGxzKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YVwiOiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgIGZpbmFsU3RlcC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmlucHV0VG9rZW5zXCI6IHRvdGFsVXNhZ2UuaW5wdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgXCJhaS51c2FnZS5vdXRwdXRUb2tlbnNcIjogdG90YWxVc2FnZS5vdXRwdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgXCJhaS51c2FnZS50b3RhbFRva2Vuc1wiOiB0b3RhbFVzYWdlLnRvdGFsVG9rZW5zLFxuICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucmVhc29uaW5nVG9rZW5zXCI6IHRvdGFsVXNhZ2UucmVhc29uaW5nVG9rZW5zLFxuICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY2FjaGVkSW5wdXRUb2tlbnNcIjogdG90YWxVc2FnZS5jYWNoZWRJbnB1dFRva2Vuc1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lcnJvcihlcnJvcik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgcm9vdFNwYW4uZW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBzdGl0Y2hhYmxlU3RyZWFtID0gY3JlYXRlU3RpdGNoYWJsZVN0cmVhbSgpO1xuICAgIHRoaXMuYWRkU3RyZWFtID0gc3RpdGNoYWJsZVN0cmVhbS5hZGRTdHJlYW07XG4gICAgdGhpcy5jbG9zZVN0cmVhbSA9IHN0aXRjaGFibGVTdHJlYW0uY2xvc2U7XG4gICAgY29uc3QgcmVhZGVyID0gc3RpdGNoYWJsZVN0cmVhbS5zdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgbGV0IHN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwic3RhcnRcIiB9KTtcbiAgICAgIH0sXG4gICAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICAgICAgb25BYm9ydCA9PSBudWxsID8gdm9pZCAwIDogb25BYm9ydCh7IHN0ZXBzOiByZWNvcmRlZFN0ZXBzIH0pO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICB0eXBlOiBcImFib3J0XCIsXG4gICAgICAgICAgICAvLyBUaGUgYHJlYXNvbmAgaXMgdXN1YWxseSBvZiB0eXBlIERPTUV4Y2VwdGlvbiwgYnV0IGl0IGNhbiBhbHNvIGJlIG9mIGFueSB0eXBlLFxuICAgICAgICAgICAgLy8gc28gd2UgdXNlIGdldEVycm9yTWVzc2FnZSBmb3Igc2VyaWFsaXphdGlvbiBiZWNhdXNlIGl0IGlzIGFscmVhZHkgZGVzaWduZWQgdG8gYWNjZXB0IHZhbHVlcyBvZiB0aGUgdW5rbm93biB0eXBlLlxuICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQWJvcnRTaWduYWwvcmVhc29uXG4gICAgICAgICAgICAuLi4oYWJvcnRTaWduYWwgPT0gbnVsbCA/IHZvaWQgMCA6IGFib3J0U2lnbmFsLnJlYXNvbikgIT09IHZvaWQgMCA/IHsgcmVhc29uOiBnZXRFcnJvck1lc3NhZ2U3KGFib3J0U2lnbmFsLnJlYXNvbikgfSA6IHt9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYWJvcnRTaWduYWwgPT0gbnVsbCA/IHZvaWQgMCA6IGFib3J0U2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaWYgKGlzQWJvcnRFcnJvcjIoZXJyb3IpICYmIChhYm9ydFNpZ25hbCA9PSBudWxsID8gdm9pZCAwIDogYWJvcnRTaWduYWwuYWJvcnRlZCkpIHtcbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbmNlbChyZWFzb24pIHtcbiAgICAgICAgcmV0dXJuIHN0aXRjaGFibGVTdHJlYW0uc3RyZWFtLmNhbmNlbChyZWFzb24pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZvciAoY29uc3QgdHJhbnNmb3JtIG9mIHRyYW5zZm9ybXMpIHtcbiAgICAgIHN0cmVhbSA9IHN0cmVhbS5waXBlVGhyb3VnaChcbiAgICAgICAgdHJhbnNmb3JtKHtcbiAgICAgICAgICB0b29scyxcbiAgICAgICAgICBzdG9wU3RyZWFtKCkge1xuICAgICAgICAgICAgc3RpdGNoYWJsZVN0cmVhbS50ZXJtaW5hdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmJhc2VTdHJlYW0gPSBzdHJlYW0ucGlwZVRocm91Z2goY3JlYXRlT3V0cHV0VHJhbnNmb3JtU3RyZWFtKG91dHB1dCAhPSBudWxsID8gb3V0cHV0IDogdGV4dCgpKSkucGlwZVRocm91Z2goZXZlbnRQcm9jZXNzb3IpO1xuICAgIGNvbnN0IHsgbWF4UmV0cmllcywgcmV0cnkgfSA9IHByZXBhcmVSZXRyaWVzKHtcbiAgICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gICAgICBhYm9ydFNpZ25hbFxuICAgIH0pO1xuICAgIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcih0ZWxlbWV0cnkpO1xuICAgIGNvbnN0IGNhbGxTZXR0aW5ncyA9IHByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgbW9kZWwsXG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBoZWFkZXJzLFxuICAgICAgc2V0dGluZ3M6IHsgLi4uY2FsbFNldHRpbmdzLCBtYXhSZXRyaWVzIH1cbiAgICB9KTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCBtb2RlbEluZm8gPSB7IHByb3ZpZGVyOiBtb2RlbC5wcm92aWRlciwgbW9kZWxJZDogbW9kZWwubW9kZWxJZCB9O1xuICAgIGNvbnN0IGNhbGxiYWNrVGVsZW1ldHJ5UHJvcHMgPSB7XG4gICAgICBmdW5jdGlvbklkOiB0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5mdW5jdGlvbklkLFxuICAgICAgbWV0YWRhdGE6IHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5Lm1ldGFkYXRhXG4gICAgfTtcbiAgICByZWNvcmRTcGFuKHtcbiAgICAgIG5hbWU6IFwiYWkuc3RyZWFtVGV4dFwiLFxuICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7IG9wZXJhdGlvbklkOiBcImFpLnN0cmVhbVRleHRcIiwgdGVsZW1ldHJ5IH0pLFxuICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgICBcImFpLnByb21wdFwiOiB7XG4gICAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoeyBzeXN0ZW0sIHByb21wdCwgbWVzc2FnZXMgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgdHJhY2VyLFxuICAgICAgZW5kV2hlbkRvbmU6IGZhbHNlLFxuICAgICAgZm46IGFzeW5jIChyb290U3BhbkFyZykgPT4ge1xuICAgICAgICByb290U3BhbiA9IHJvb3RTcGFuQXJnO1xuICAgICAgICBjb25zdCBpbml0aWFsUHJvbXB0ID0gYXdhaXQgc3RhbmRhcmRpemVQcm9tcHQoe1xuICAgICAgICAgIHN5c3RlbSxcbiAgICAgICAgICBwcm9tcHQsXG4gICAgICAgICAgbWVzc2FnZXNcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgKG9uU3RhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uU3RhcnQoe1xuICAgICAgICAgICAgbW9kZWw6IG1vZGVsSW5mbyxcbiAgICAgICAgICAgIHN5c3RlbSxcbiAgICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgICB0b29sQ2hvaWNlLFxuICAgICAgICAgICAgYWN0aXZlVG9vbHMsXG4gICAgICAgICAgICBtYXhPdXRwdXRUb2tlbnM6IGNhbGxTZXR0aW5ncy5tYXhPdXRwdXRUb2tlbnMsXG4gICAgICAgICAgICB0ZW1wZXJhdHVyZTogY2FsbFNldHRpbmdzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgdG9wUDogY2FsbFNldHRpbmdzLnRvcFAsXG4gICAgICAgICAgICB0b3BLOiBjYWxsU2V0dGluZ3MudG9wSyxcbiAgICAgICAgICAgIHByZXNlbmNlUGVuYWx0eTogY2FsbFNldHRpbmdzLnByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgICAgIGZyZXF1ZW5jeVBlbmFsdHk6IGNhbGxTZXR0aW5ncy5mcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICAgICAgc3RvcFNlcXVlbmNlczogY2FsbFNldHRpbmdzLnN0b3BTZXF1ZW5jZXMsXG4gICAgICAgICAgICBzZWVkOiBjYWxsU2V0dGluZ3Muc2VlZCxcbiAgICAgICAgICAgIG1heFJldHJpZXMsXG4gICAgICAgICAgICB0aW1lb3V0LFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9ucyxcbiAgICAgICAgICAgIHN0b3BXaGVuLFxuICAgICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgICAgYWJvcnRTaWduYWw6IG9yaWdpbmFsQWJvcnRTaWduYWwsXG4gICAgICAgICAgICBpbmNsdWRlLFxuICAgICAgICAgICAgLi4uY2FsbGJhY2tUZWxlbWV0cnlQcm9wcyxcbiAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9IGNhdGNoIChfaWdub3JlZCkge1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluaXRpYWxNZXNzYWdlcyA9IGluaXRpYWxQcm9tcHQubWVzc2FnZXM7XG4gICAgICAgIGNvbnN0IGluaXRpYWxSZXNwb25zZU1lc3NhZ2VzID0gW107XG4gICAgICAgIGNvbnN0IHsgYXBwcm92ZWRUb29sQXBwcm92YWxzLCBkZW5pZWRUb29sQXBwcm92YWxzIH0gPSBjb2xsZWN0VG9vbEFwcHJvdmFscyh7IG1lc3NhZ2VzOiBpbml0aWFsTWVzc2FnZXMgfSk7XG4gICAgICAgIGlmIChkZW5pZWRUb29sQXBwcm92YWxzLmxlbmd0aCA+IDAgfHwgYXBwcm92ZWRUb29sQXBwcm92YWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBwcm92aWRlckV4ZWN1dGVkVG9vbEFwcHJvdmFscyA9IFtcbiAgICAgICAgICAgIC4uLmFwcHJvdmVkVG9vbEFwcHJvdmFscyxcbiAgICAgICAgICAgIC4uLmRlbmllZFRvb2xBcHByb3ZhbHNcbiAgICAgICAgICBdLmZpbHRlcigodG9vbEFwcHJvdmFsKSA9PiB0b29sQXBwcm92YWwudG9vbENhbGwucHJvdmlkZXJFeGVjdXRlZCk7XG4gICAgICAgICAgY29uc3QgbG9jYWxBcHByb3ZlZFRvb2xBcHByb3ZhbHMgPSBhcHByb3ZlZFRvb2xBcHByb3ZhbHMuZmlsdGVyKFxuICAgICAgICAgICAgKHRvb2xBcHByb3ZhbCkgPT4gIXRvb2xBcHByb3ZhbC50b29sQ2FsbC5wcm92aWRlckV4ZWN1dGVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBsb2NhbERlbmllZFRvb2xBcHByb3ZhbHMgPSBkZW5pZWRUb29sQXBwcm92YWxzLmZpbHRlcihcbiAgICAgICAgICAgICh0b29sQXBwcm92YWwpID0+ICF0b29sQXBwcm92YWwudG9vbENhbGwucHJvdmlkZXJFeGVjdXRlZFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgZGVuaWVkUHJvdmlkZXJFeGVjdXRlZFRvb2xBcHByb3ZhbHMgPSBkZW5pZWRUb29sQXBwcm92YWxzLmZpbHRlcihcbiAgICAgICAgICAgICh0b29sQXBwcm92YWwpID0+IHRvb2xBcHByb3ZhbC50b29sQ2FsbC5wcm92aWRlckV4ZWN1dGVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgdG9vbEV4ZWN1dGlvblN0ZXBTdHJlYW1Db250cm9sbGVyO1xuICAgICAgICAgIGNvbnN0IHRvb2xFeGVjdXRpb25TdGVwU3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgdG9vbEV4ZWN1dGlvblN0ZXBTdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZWxmLmFkZFN0cmVhbSh0b29sRXhlY3V0aW9uU3RlcFN0cmVhbSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbEFwcHJvdmFsIG9mIFtcbiAgICAgICAgICAgICAgLi4ubG9jYWxEZW5pZWRUb29sQXBwcm92YWxzLFxuICAgICAgICAgICAgICAuLi5kZW5pZWRQcm92aWRlckV4ZWN1dGVkVG9vbEFwcHJvdmFsc1xuICAgICAgICAgICAgXSkge1xuICAgICAgICAgICAgICB0b29sRXhlY3V0aW9uU3RlcFN0cmVhbUNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xFeGVjdXRpb25TdGVwU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtb3V0cHV0LWRlbmllZFwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xBcHByb3ZhbC50b29sQ2FsbC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiB0b29sQXBwcm92YWwudG9vbENhbGwudG9vbE5hbWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0b29sT3V0cHV0cyA9IFtdO1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICAgIGxvY2FsQXBwcm92ZWRUb29sQXBwcm92YWxzLm1hcChhc3luYyAodG9vbEFwcHJvdmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXhlY3V0ZVRvb2xDYWxsKHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsOiB0b29sQXBwcm92YWwudG9vbENhbGwsXG4gICAgICAgICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiBpbml0aWFsTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgc3RlcE51bWJlcjogcmVjb3JkZWRTdGVwcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICBtb2RlbDogbW9kZWxJbmZvLFxuICAgICAgICAgICAgICAgICAgb25Ub29sQ2FsbFN0YXJ0LFxuICAgICAgICAgICAgICAgICAgb25Ub29sQ2FsbEZpbmlzaCxcbiAgICAgICAgICAgICAgICAgIG9uUHJlbGltaW5hcnlUb29sUmVzdWx0OiAocmVzdWx0MikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0b29sRXhlY3V0aW9uU3RlcFN0cmVhbUNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xFeGVjdXRpb25TdGVwU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHJlc3VsdDIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgdG9vbEV4ZWN1dGlvblN0ZXBTdHJlYW1Db250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiB0b29sRXhlY3V0aW9uU3RlcFN0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgdG9vbE91dHB1dHMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAocHJvdmlkZXJFeGVjdXRlZFRvb2xBcHByb3ZhbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBpbml0aWFsUmVzcG9uc2VNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICByb2xlOiBcInRvb2xcIixcbiAgICAgICAgICAgICAgICBjb250ZW50OiBwcm92aWRlckV4ZWN1dGVkVG9vbEFwcHJvdmFscy5tYXAoXG4gICAgICAgICAgICAgICAgICAodG9vbEFwcHJvdmFsKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtYXBwcm92YWwtcmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICAgICAgYXBwcm92YWxJZDogdG9vbEFwcHJvdmFsLmFwcHJvdmFsUmVzcG9uc2UuYXBwcm92YWxJZCxcbiAgICAgICAgICAgICAgICAgICAgYXBwcm92ZWQ6IHRvb2xBcHByb3ZhbC5hcHByb3ZhbFJlc3BvbnNlLmFwcHJvdmVkLFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IHRvb2xBcHByb3ZhbC5hcHByb3ZhbFJlc3BvbnNlLnJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvb2xPdXRwdXRzLmxlbmd0aCA+IDAgfHwgbG9jYWxEZW5pZWRUb29sQXBwcm92YWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgbG9jYWxUb29sQ29udGVudCA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IG91dHB1dDIgb2YgdG9vbE91dHB1dHMpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFRvb2xDb250ZW50LnB1c2goe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogb3V0cHV0Mi50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IG91dHB1dDIudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICBvdXRwdXQ6IGF3YWl0IGNyZWF0ZVRvb2xNb2RlbE91dHB1dCh7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IG91dHB1dDIudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IG91dHB1dDIuaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIHRvb2w6IHRvb2xzID09IG51bGwgPyB2b2lkIDAgOiB0b29sc1tvdXRwdXQyLnRvb2xOYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiBvdXRwdXQyLnR5cGUgPT09IFwidG9vbC1yZXN1bHRcIiA/IG91dHB1dDIub3V0cHV0IDogb3V0cHV0Mi5lcnJvcixcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNb2RlOiBvdXRwdXQyLnR5cGUgPT09IFwidG9vbC1lcnJvclwiID8gXCJqc29uXCIgOiBcIm5vbmVcIlxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2xBcHByb3ZhbCBvZiBsb2NhbERlbmllZFRvb2xBcHByb3ZhbHMpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFRvb2xDb250ZW50LnB1c2goe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbEFwcHJvdmFsLnRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogdG9vbEFwcHJvdmFsLnRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgb3V0cHV0OiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZXhlY3V0aW9uLWRlbmllZFwiLFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IHRvb2xBcHByb3ZhbC5hcHByb3ZhbFJlc3BvbnNlLnJlYXNvblxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGluaXRpYWxSZXNwb25zZU1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIHJvbGU6IFwidG9vbFwiLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGxvY2FsVG9vbENvbnRlbnRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRvb2xFeGVjdXRpb25TdGVwU3RyZWFtQ29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogdG9vbEV4ZWN1dGlvblN0ZXBTdHJlYW1Db250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlY29yZGVkUmVzcG9uc2VNZXNzYWdlcy5wdXNoKC4uLmluaXRpYWxSZXNwb25zZU1lc3NhZ2VzKTtcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gc3RyZWFtU3RlcCh7XG4gICAgICAgICAgY3VycmVudFN0ZXAsXG4gICAgICAgICAgcmVzcG9uc2VNZXNzYWdlcyxcbiAgICAgICAgICB1c2FnZVxuICAgICAgICB9KSB7XG4gICAgICAgICAgdmFyIF9hMjEsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaTtcbiAgICAgICAgICBjb25zdCBpbmNsdWRlUmF3Q2h1bmtzMiA9IHNlbGYuaW5jbHVkZVJhd0NodW5rcztcbiAgICAgICAgICBjb25zdCBzdGVwVGltZW91dElkID0gc3RlcFRpbWVvdXRNcyAhPSBudWxsID8gc2V0VGltZW91dCgoKSA9PiBzdGVwQWJvcnRDb250cm9sbGVyLmFib3J0KCksIHN0ZXBUaW1lb3V0TXMpIDogdm9pZCAwO1xuICAgICAgICAgIGxldCBjaHVua1RpbWVvdXRJZCA9IHZvaWQgMDtcbiAgICAgICAgICBmdW5jdGlvbiByZXNldENodW5rVGltZW91dCgpIHtcbiAgICAgICAgICAgIGlmIChjaHVua1RpbWVvdXRNcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmIChjaHVua1RpbWVvdXRJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNodW5rVGltZW91dElkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjaHVua1RpbWVvdXRJZCA9IHNldFRpbWVvdXQoXG4gICAgICAgICAgICAgICAgKCkgPT4gY2h1bmtBYm9ydENvbnRyb2xsZXIuYWJvcnQoKSxcbiAgICAgICAgICAgICAgICBjaHVua1RpbWVvdXRNc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBjbGVhckNodW5rVGltZW91dCgpIHtcbiAgICAgICAgICAgIGlmIChjaHVua1RpbWVvdXRJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dChjaHVua1RpbWVvdXRJZCk7XG4gICAgICAgICAgICAgIGNodW5rVGltZW91dElkID0gdm9pZCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBjbGVhclN0ZXBUaW1lb3V0KCkge1xuICAgICAgICAgICAgaWYgKHN0ZXBUaW1lb3V0SWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoc3RlcFRpbWVvdXRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdGVwRmluaXNoID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgICAgICAgICBjb25zdCBzdGVwSW5wdXRNZXNzYWdlcyA9IFsuLi5pbml0aWFsTWVzc2FnZXMsIC4uLnJlc3BvbnNlTWVzc2FnZXNdO1xuICAgICAgICAgICAgY29uc3QgcHJlcGFyZVN0ZXBSZXN1bHQgPSBhd2FpdCAocHJlcGFyZVN0ZXAgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwKHtcbiAgICAgICAgICAgICAgbW9kZWwsXG4gICAgICAgICAgICAgIHN0ZXBzOiByZWNvcmRlZFN0ZXBzLFxuICAgICAgICAgICAgICBzdGVwTnVtYmVyOiByZWNvcmRlZFN0ZXBzLmxlbmd0aCxcbiAgICAgICAgICAgICAgbWVzc2FnZXM6IHN0ZXBJbnB1dE1lc3NhZ2VzLFxuICAgICAgICAgICAgICBleHBlcmltZW50YWxfY29udGV4dFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgY29uc3Qgc3RlcE1vZGVsID0gcmVzb2x2ZUxhbmd1YWdlTW9kZWwoXG4gICAgICAgICAgICAgIChfYTIxID0gcHJlcGFyZVN0ZXBSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwUmVzdWx0Lm1vZGVsKSAhPSBudWxsID8gX2EyMSA6IG1vZGVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3Qgc3RlcE1vZGVsSW5mbyA9IHtcbiAgICAgICAgICAgICAgcHJvdmlkZXI6IHN0ZXBNb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgbW9kZWxJZDogc3RlcE1vZGVsLm1vZGVsSWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBwcm9tcHRNZXNzYWdlcyA9IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICAgICAgICBwcm9tcHQ6IHtcbiAgICAgICAgICAgICAgICBzeXN0ZW06IChfYiA9IHByZXBhcmVTdGVwUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcFJlc3VsdC5zeXN0ZW0pICE9IG51bGwgPyBfYiA6IGluaXRpYWxQcm9tcHQuc3lzdGVtLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiAoX2MgPSBwcmVwYXJlU3RlcFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZVN0ZXBSZXN1bHQubWVzc2FnZXMpICE9IG51bGwgPyBfYyA6IHN0ZXBJbnB1dE1lc3NhZ2VzXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHN1cHBvcnRlZFVybHM6IGF3YWl0IHN0ZXBNb2RlbC5zdXBwb3J0ZWRVcmxzLFxuICAgICAgICAgICAgICBkb3dubG9hZDogZG93bmxvYWQyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBBY3RpdmVUb29scyA9IChfZCA9IHByZXBhcmVTdGVwUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcFJlc3VsdC5hY3RpdmVUb29scykgIT0gbnVsbCA/IF9kIDogYWN0aXZlVG9vbHM7XG4gICAgICAgICAgICBjb25zdCB7IHRvb2xDaG9pY2U6IHN0ZXBUb29sQ2hvaWNlLCB0b29sczogc3RlcFRvb2xzIH0gPSBhd2FpdCBwcmVwYXJlVG9vbHNBbmRUb29sQ2hvaWNlKHtcbiAgICAgICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgICAgIHRvb2xDaG9pY2U6IChfZSA9IHByZXBhcmVTdGVwUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcFJlc3VsdC50b29sQ2hvaWNlKSAhPSBudWxsID8gX2UgOiB0b29sQ2hvaWNlLFxuICAgICAgICAgICAgICBhY3RpdmVUb29sczogc3RlcEFjdGl2ZVRvb2xzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0ID0gKF9mID0gcHJlcGFyZVN0ZXBSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwUmVzdWx0LmV4cGVyaW1lbnRhbF9jb250ZXh0KSAhPSBudWxsID8gX2YgOiBleHBlcmltZW50YWxfY29udGV4dDtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBNZXNzYWdlcyA9IChfZyA9IHByZXBhcmVTdGVwUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcFJlc3VsdC5tZXNzYWdlcykgIT0gbnVsbCA/IF9nIDogc3RlcElucHV0TWVzc2FnZXM7XG4gICAgICAgICAgICBjb25zdCBzdGVwU3lzdGVtID0gKF9oID0gcHJlcGFyZVN0ZXBSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwUmVzdWx0LnN5c3RlbSkgIT0gbnVsbCA/IF9oIDogaW5pdGlhbFByb21wdC5zeXN0ZW07XG4gICAgICAgICAgICBjb25zdCBzdGVwUHJvdmlkZXJPcHRpb25zID0gbWVyZ2VPYmplY3RzKFxuICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgICAgICAgICAgIHByZXBhcmVTdGVwUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcFJlc3VsdC5wcm92aWRlck9wdGlvbnNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBhd2FpdCAob25TdGVwU3RhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uU3RlcFN0YXJ0KHtcbiAgICAgICAgICAgICAgICBzdGVwTnVtYmVyOiByZWNvcmRlZFN0ZXBzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBtb2RlbDogc3RlcE1vZGVsSW5mbyxcbiAgICAgICAgICAgICAgICBzeXN0ZW06IHN0ZXBTeXN0ZW0sXG4gICAgICAgICAgICAgICAgbWVzc2FnZXM6IHN0ZXBNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgICAgICB0b29sQ2hvaWNlOiBzdGVwVG9vbENob2ljZSxcbiAgICAgICAgICAgICAgICBhY3RpdmVUb29sczogc3RlcEFjdGl2ZVRvb2xzLFxuICAgICAgICAgICAgICAgIHN0ZXBzOiBbLi4ucmVjb3JkZWRTdGVwc10sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBzdGVwUHJvdmlkZXJPcHRpb25zLFxuICAgICAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzdG9wV2hlbixcbiAgICAgICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IG9yaWdpbmFsQWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgaW5jbHVkZSxcbiAgICAgICAgICAgICAgICAuLi5jYWxsYmFja1RlbGVtZXRyeVByb3BzLFxuICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0XG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF9pZ25vcmVkKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHJlc3VsdDogeyBzdHJlYW06IHN0cmVhbTIsIHJlc3BvbnNlLCByZXF1ZXN0IH0sXG4gICAgICAgICAgICAgIGRvU3RyZWFtU3BhbixcbiAgICAgICAgICAgICAgc3RhcnRUaW1lc3RhbXBNc1xuICAgICAgICAgICAgfSA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAgICAgICAoKSA9PiByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImFpLnN0cmVhbVRleHQuZG9TdHJlYW1cIixcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5zdHJlYW1UZXh0LmRvU3RyZWFtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgLy8gbW9kZWw6XG4gICAgICAgICAgICAgICAgICAgIFwiYWkubW9kZWwucHJvdmlkZXJcIjogc3RlcE1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgICAgICBcImFpLm1vZGVsLmlkXCI6IHN0ZXBNb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAvLyBwcm9tcHQ6XG4gICAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0Lm1lc3NhZ2VzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gc3RyaW5naWZ5Rm9yVGVsZW1ldHJ5KHByb21wdE1lc3NhZ2VzKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcImFpLnByb21wdC50b29sc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydCB0aGUgbGFuZ3VhZ2UgbW9kZWwgbGV2ZWwgdG9vbHM6XG4gICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHN0ZXBUb29scyA9PSBudWxsID8gdm9pZCAwIDogc3RlcFRvb2xzLm1hcCgodG9vbDIpID0+IEpTT04uc3RyaW5naWZ5KHRvb2wyKSlcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQudG9vbENob2ljZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHN0ZXBUb29sQ2hvaWNlICE9IG51bGwgPyBKU09OLnN0cmluZ2lmeShzdGVwVG9vbENob2ljZSkgOiB2b2lkIDBcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5zeXN0ZW1cIjogc3RlcE1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1vZGVsXCI6IHN0ZXBNb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LmZyZXF1ZW5jeV9wZW5hbHR5XCI6IGNhbGxTZXR0aW5ncy5mcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1heF90b2tlbnNcIjogY2FsbFNldHRpbmdzLm1heE91dHB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5wcmVzZW5jZV9wZW5hbHR5XCI6IGNhbGxTZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHksXG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3Quc3RvcF9zZXF1ZW5jZXNcIjogY2FsbFNldHRpbmdzLnN0b3BTZXF1ZW5jZXMsXG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudGVtcGVyYXR1cmVcIjogY2FsbFNldHRpbmdzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9rXCI6IGNhbGxTZXR0aW5ncy50b3BLLFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9wXCI6IGNhbGxTZXR0aW5ncy50b3BQXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICAgIGVuZFdoZW5Eb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBmbjogYXN5bmMgKGRvU3RyZWFtU3BhbjIpID0+ICh7XG4gICAgICAgICAgICAgICAgICBzdGFydFRpbWVzdGFtcE1zOiBub3cyKCksXG4gICAgICAgICAgICAgICAgICAvLyBnZXQgYmVmb3JlIHRoZSBjYWxsXG4gICAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW46IGRvU3RyZWFtU3BhbjIsXG4gICAgICAgICAgICAgICAgICByZXN1bHQ6IGF3YWl0IHN0ZXBNb2RlbC5kb1N0cmVhbSh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNhbGxTZXR0aW5ncyxcbiAgICAgICAgICAgICAgICAgICAgdG9vbHM6IHN0ZXBUb29scyxcbiAgICAgICAgICAgICAgICAgICAgdG9vbENob2ljZTogc3RlcFRvb2xDaG9pY2UsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlRm9ybWF0OiBhd2FpdCAob3V0cHV0ID09IG51bGwgPyB2b2lkIDAgOiBvdXRwdXQucmVzcG9uc2VGb3JtYXQpLFxuICAgICAgICAgICAgICAgICAgICBwcm9tcHQ6IHByb21wdE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHN0ZXBQcm92aWRlck9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdWRlUmF3Q2h1bmtzOiBpbmNsdWRlUmF3Q2h1bmtzMlxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbVdpdGhUb29sUmVzdWx0cyA9IHJ1blRvb2xzVHJhbnNmb3JtYXRpb24oe1xuICAgICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgICAgZ2VuZXJhdG9yU3RyZWFtOiBzdHJlYW0yLFxuICAgICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgc3lzdGVtLFxuICAgICAgICAgICAgICBtZXNzYWdlczogc3RlcElucHV0TWVzc2FnZXMsXG4gICAgICAgICAgICAgIHJlcGFpclRvb2xDYWxsLFxuICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHQsXG4gICAgICAgICAgICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQyLFxuICAgICAgICAgICAgICBzdGVwTnVtYmVyOiByZWNvcmRlZFN0ZXBzLmxlbmd0aCxcbiAgICAgICAgICAgICAgbW9kZWw6IHN0ZXBNb2RlbEluZm8sXG4gICAgICAgICAgICAgIG9uVG9vbENhbGxTdGFydCxcbiAgICAgICAgICAgICAgb25Ub29sQ2FsbEZpbmlzaFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzdGVwUmVxdWVzdCA9ICgoX2kgPSBpbmNsdWRlID09IG51bGwgPyB2b2lkIDAgOiBpbmNsdWRlLnJlcXVlc3RCb2R5KSAhPSBudWxsID8gX2kgOiB0cnVlKSA/IHJlcXVlc3QgIT0gbnVsbCA/IHJlcXVlc3QgOiB7fSA6IHsgLi4ucmVxdWVzdCwgYm9keTogdm9pZCAwIH07XG4gICAgICAgICAgICBjb25zdCBzdGVwVG9vbENhbGxzID0gW107XG4gICAgICAgICAgICBjb25zdCBzdGVwVG9vbE91dHB1dHMgPSBbXTtcbiAgICAgICAgICAgIGxldCB3YXJuaW5ncztcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZVRvb2xDYWxsVG9vbE5hbWVzID0ge307XG4gICAgICAgICAgICBsZXQgc3RlcEZpbmlzaFJlYXNvbiA9IFwib3RoZXJcIjtcbiAgICAgICAgICAgIGxldCBzdGVwUmF3RmluaXNoUmVhc29uID0gdm9pZCAwO1xuICAgICAgICAgICAgbGV0IHN0ZXBVc2FnZSA9IGNyZWF0ZU51bGxMYW5ndWFnZU1vZGVsVXNhZ2UoKTtcbiAgICAgICAgICAgIGxldCBzdGVwUHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICAgIGxldCBzdGVwRmlyc3RDaHVuayA9IHRydWU7XG4gICAgICAgICAgICBsZXQgc3RlcFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICBpZDogZ2VuZXJhdGVJZDIoKSxcbiAgICAgICAgICAgICAgdGltZXN0YW1wOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgbW9kZWxJZDogbW9kZWxJbmZvLm1vZGVsSWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgYWN0aXZlVGV4dCA9IFwiXCI7XG4gICAgICAgICAgICBzZWxmLmFkZFN0cmVhbShcbiAgICAgICAgICAgICAgc3RyZWFtV2l0aFRvb2xSZXN1bHRzLnBpcGVUaHJvdWdoKFxuICAgICAgICAgICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgICAgICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTIyLCBfYjIsIF9jMiwgX2QyLCBfZTI7XG4gICAgICAgICAgICAgICAgICAgIHJlc2V0Q2h1bmtUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVuay50eXBlID09PSBcInN0cmVhbS1zdGFydFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgd2FybmluZ3MgPSBjaHVuay53YXJuaW5ncztcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0ZXBGaXJzdENodW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgbXNUb0ZpcnN0Q2h1bmsgPSBub3cyKCkgLSBzdGFydFRpbWVzdGFtcE1zO1xuICAgICAgICAgICAgICAgICAgICAgIHN0ZXBGaXJzdENodW5rID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLmFkZEV2ZW50KFwiYWkuc3RyZWFtLmZpcnN0Q2h1bmtcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5tc1RvRmlyc3RDaHVua1wiOiBtc1RvRmlyc3RDaHVua1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubXNUb0ZpcnN0Q2h1bmtcIjogbXNUb0ZpcnN0Q2h1bmtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdGFydC1zdGVwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiBzdGVwUmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzOiB3YXJuaW5ncyAhPSBudWxsID8gd2FybmluZ3MgOiBbXVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rVHlwZSA9IGNodW5rLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2h1bmtUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtYXBwcm92YWwtcmVxdWVzdFwiOlxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LXN0YXJ0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQtZW5kXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rLmRlbHRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHQtZGVsdGFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogY2h1bmsuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY2h1bmsuZGVsdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogY2h1bmsucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlVGV4dCArPSBjaHVuay5kZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nLXN0YXJ0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZy1lbmRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nLWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nLWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBjaHVuay5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY2h1bmsuZGVsdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGNodW5rLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGxcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBUb29sQ2FsbHMucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtcmVzdWx0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNodW5rLnByZWxpbWluYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBUb29sT3V0cHV0cy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidG9vbC1lcnJvclwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcFRvb2xPdXRwdXRzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZXNwb25zZS1tZXRhZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAoX2EyMiA9IGNodW5rLmlkKSAhPSBudWxsID8gX2EyMiA6IHN0ZXBSZXNwb25zZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiAoX2IyID0gY2h1bmsudGltZXN0YW1wKSAhPSBudWxsID8gX2IyIDogc3RlcFJlc3BvbnNlLnRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxJZDogKF9jMiA9IGNodW5rLm1vZGVsSWQpICE9IG51bGwgPyBfYzIgOiBzdGVwUmVzcG9uc2UubW9kZWxJZFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBVc2FnZSA9IGNodW5rLnVzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcEZpbmlzaFJlYXNvbiA9IGNodW5rLmZpbmlzaFJlYXNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBSYXdGaW5pc2hSZWFzb24gPSBjaHVuay5yYXdGaW5pc2hSZWFzb247XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwUHJvdmlkZXJNZXRhZGF0YSA9IGNodW5rLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtc1RvRmluaXNoID0gbm93MigpIC0gc3RhcnRUaW1lc3RhbXBNcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5hZGRFdmVudChcImFpLnN0cmVhbS5maW5pc2hcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubXNUb0ZpbmlzaFwiOiBtc1RvRmluaXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmF2Z091dHB1dFRva2Vuc1BlclNlY29uZFwiOiAxZTMgKiAoKF9kMiA9IHN0ZXBVc2FnZS5vdXRwdXRUb2tlbnMpICE9IG51bGwgPyBfZDIgOiAwKSAvIG1zVG9GaW5pc2hcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmaWxlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNvdXJjZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0b29sLWlucHV0LXN0YXJ0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVRvb2xDYWxsVG9vbE5hbWVzW2NodW5rLmlkXSA9IGNodW5rLnRvb2xOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9vbDIgPSB0b29scyA9PSBudWxsID8gdm9pZCAwIDogdG9vbHNbY2h1bmsudG9vbE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIub25JbnB1dFN0YXJ0KSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRvb2wyLm9uSW5wdXRTdGFydCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXM6IHN0ZXBJbnB1dE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uY2h1bmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGR5bmFtaWM6IChfZTIgPSBjaHVuay5keW5hbWljKSAhPSBudWxsID8gX2UyIDogKHRvb2wyID09IG51bGwgPyB2b2lkIDAgOiB0b29sMi50eXBlKSA9PT0gXCJkeW5hbWljXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIudGl0bGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0b29sLWlucHV0LWVuZFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYWN0aXZlVG9vbENhbGxUb29sTmFtZXNbY2h1bmsuaWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidG9vbC1pbnB1dC1kZWx0YVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b29sTmFtZSA9IGFjdGl2ZVRvb2xDYWxsVG9vbE5hbWVzW2NodW5rLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvb2wyID0gdG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xzW3Rvb2xOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodG9vbDIgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2wyLm9uSW5wdXREZWx0YSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0b29sMi5vbklucHV0RGVsdGEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VGV4dERlbHRhOiBjaHVuay5kZWx0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlczogc3RlcElucHV0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcEZpbmlzaFJlYXNvbiA9IFwiZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmF3XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlUmF3Q2h1bmtzMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aGF1c3RpdmVDaGVjayA9IGNodW5rVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYFVua25vd24gY2h1bmsgdHlwZTogJHtleGhhdXN0aXZlQ2hlY2t9YFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAvLyBpbnZva2Ugb25GaW5pc2ggY2FsbGJhY2sgYW5kIHJlc29sdmUgdG9vbFJlc3VsdHMgcHJvbWlzZSB3aGVuIHRoZSBzdHJlYW0gaXMgYWJvdXQgdG8gY2xvc2U6XG4gICAgICAgICAgICAgICAgICBhc3luYyBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXBUb29sQ2FsbHNKc29uID0gc3RlcFRvb2xDYWxscy5sZW5ndGggPiAwID8gSlNPTi5zdHJpbmdpZnkoc3RlcFRvb2xDYWxscykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogc3RlcEZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRleHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBhY3RpdmVUZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnJlYXNvbmluZ1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVhc29uaW5nUGFydHMgPSByZWNvcmRlZENvbnRlbnQuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjKSA9PiBjLnR5cGUgPT09IFwicmVhc29uaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYXNvbmluZ1BhcnRzLmxlbmd0aCA+IDAgPyByZWFzb25pbmdQYXJ0cy5tYXAoKHIpID0+IHIudGV4dCkuam9pbihcIlxcblwiKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudG9vbENhbGxzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gc3RlcFRvb2xDYWxsc0pzb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuaWRcIjogc3RlcFJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogc3RlcFJlc3BvbnNlLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50aW1lc3RhbXBcIjogc3RlcFJlc3BvbnNlLnRpbWVzdGFtcC50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YVwiOiBKU09OLnN0cmluZ2lmeShzdGVwUHJvdmlkZXJNZXRhZGF0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5pbnB1dFRva2Vuc1wiOiBzdGVwVXNhZ2UuaW5wdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5vdXRwdXRUb2tlbnNcIjogc3RlcFVzYWdlLm91dHB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnRvdGFsVG9rZW5zXCI6IHN0ZXBVc2FnZS50b3RhbFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnJlYXNvbmluZ1Rva2Vuc1wiOiBzdGVwVXNhZ2UucmVhc29uaW5nVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY2FjaGVkSW5wdXRUb2tlbnNcIjogc3RlcFVzYWdlLmNhY2hlZElucHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5maW5pc2hfcmVhc29uc1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwRmluaXNoUmVhc29uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5pZFwiOiBzdGVwUmVzcG9uc2UuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UubW9kZWxcIjogc3RlcFJlc3BvbnNlLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2UuaW5wdXRfdG9rZW5zXCI6IHN0ZXBVc2FnZS5pbnB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5vdXRwdXRfdG9rZW5zXCI6IHN0ZXBVc2FnZS5vdXRwdXRUb2tlbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZmluaXNoLXN0ZXBcIixcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IHN0ZXBGaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgcmF3RmluaXNoUmVhc29uOiBzdGVwUmF3RmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgIHVzYWdlOiBzdGVwVXNhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogc3RlcFByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnN0ZXBSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tYmluZWRVc2FnZSA9IGFkZExhbmd1YWdlTW9kZWxVc2FnZShcbiAgICAgICAgICAgICAgICAgICAgICB1c2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICBzdGVwVXNhZ2VcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc3RlcEZpbmlzaC5wcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRUb29sQ2FsbHMgPSBzdGVwVG9vbENhbGxzLmZpbHRlcihcbiAgICAgICAgICAgICAgICAgICAgICAodG9vbENhbGwpID0+IHRvb2xDYWxsLnByb3ZpZGVyRXhlY3V0ZWQgIT09IHRydWVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpZW50VG9vbE91dHB1dHMgPSBzdGVwVG9vbE91dHB1dHMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgICAgICh0b29sT3V0cHV0KSA9PiB0b29sT3V0cHV0LnByb3ZpZGVyRXhlY3V0ZWQgIT09IHRydWVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB0b29sQ2FsbCBvZiBzdGVwVG9vbENhbGxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHRvb2xDYWxsLnByb3ZpZGVyRXhlY3V0ZWQgIT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b29sMiA9IHRvb2xzID09IG51bGwgPyB2b2lkIDAgOiB0b29sc1t0b29sQ2FsbC50b29sTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIudHlwZSkgPT09IFwicHJvdmlkZXJcIiAmJiB0b29sMi5zdXBwb3J0c0RlZmVycmVkUmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzUmVzdWx0SW5TdGVwID0gc3RlcFRvb2xPdXRwdXRzLnNvbWUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChvdXRwdXQyKSA9PiAob3V0cHV0Mi50eXBlID09PSBcInRvb2wtcmVzdWx0XCIgfHwgb3V0cHV0Mi50eXBlID09PSBcInRvb2wtZXJyb3JcIikgJiYgb3V0cHV0Mi50b29sQ2FsbElkID09PSB0b29sQ2FsbC50b29sQ2FsbElkXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNSZXN1bHRJblN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0RlZmVycmVkVG9vbENhbGxzLnNldCh0b29sQ2FsbC50b29sQ2FsbElkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG91dHB1dDIgb2Ygc3RlcFRvb2xPdXRwdXRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dDIudHlwZSA9PT0gXCJ0b29sLXJlc3VsdFwiIHx8IG91dHB1dDIudHlwZSA9PT0gXCJ0b29sLWVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdEZWZlcnJlZFRvb2xDYWxscy5kZWxldGUob3V0cHV0Mi50b29sQ2FsbElkKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2xlYXJTdGVwVGltZW91dCgpO1xuICAgICAgICAgICAgICAgICAgICBjbGVhckNodW5rVGltZW91dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgLy8gQ29udGludWUgaWY6XG4gICAgICAgICAgICAgICAgICAgICAgLy8gMS4gVGhlcmUgYXJlIGNsaWVudCB0b29sIGNhbGxzIHRoYXQgaGF2ZSBhbGwgYmVlbiBleGVjdXRlZCwgT1JcbiAgICAgICAgICAgICAgICAgICAgICAvLyAyLiBUaGVyZSBhcmUgcGVuZGluZyBkZWZlcnJlZCByZXN1bHRzIGZyb20gcHJvdmlkZXItZXhlY3V0ZWQgdG9vbHNcbiAgICAgICAgICAgICAgICAgICAgICAoY2xpZW50VG9vbENhbGxzLmxlbmd0aCA+IDAgJiYgY2xpZW50VG9vbE91dHB1dHMubGVuZ3RoID09PSBjbGllbnRUb29sQ2FsbHMubGVuZ3RoIHx8IHBlbmRpbmdEZWZlcnJlZFRvb2xDYWxscy5zaXplID4gMCkgJiYgLy8gY29udGludWUgdW50aWwgYSBzdG9wIGNvbmRpdGlvbiBpcyBtZXQ6XG4gICAgICAgICAgICAgICAgICAgICAgIWF3YWl0IGlzU3RvcENvbmRpdGlvbk1ldCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wQ29uZGl0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBzOiByZWNvcmRlZFN0ZXBzXG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VNZXNzYWdlcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYXdhaXQgdG9SZXNwb25zZU1lc3NhZ2VzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZSB0cmFuc2Zvcm1lZCBjb250ZW50IHRvIGNyZWF0ZSB0aGUgbWVzc2FnZXMgZm9yIHRoZSBuZXh0IHN0ZXA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkZWRTdGVwc1tyZWNvcmRlZFN0ZXBzLmxlbmd0aCAtIDFdLmNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgc3RyZWFtU3RlcCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGVwOiBjdXJyZW50U3RlcCArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHVzYWdlOiBjb21iaW5lZFVzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNsb3NlU3RyZWFtKCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZpbmlzaFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3RmluaXNoUmVhc29uOiBzdGVwUmF3RmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxVc2FnZTogY29tYmluZWRVc2FnZVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2xvc2VTdHJlYW0oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGNsZWFyU3RlcFRpbWVvdXQoKTtcbiAgICAgICAgICAgIGNsZWFyQ2h1bmtUaW1lb3V0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHN0cmVhbVN0ZXAoe1xuICAgICAgICAgIGN1cnJlbnRTdGVwOiAwLFxuICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZXM6IGluaXRpYWxSZXNwb25zZU1lc3NhZ2VzLFxuICAgICAgICAgIHVzYWdlOiBjcmVhdGVOdWxsTGFuZ3VhZ2VNb2RlbFVzYWdlKClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICBzZWxmLmFkZFN0cmVhbShcbiAgICAgICAgbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcImVycm9yXCIsIGVycm9yIH0pO1xuICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBzZWxmLmNsb3NlU3RyZWFtKCk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0IHN0ZXBzKCkge1xuICAgIHRoaXMuY29uc3VtZVN0cmVhbSgpO1xuICAgIHJldHVybiB0aGlzLl9zdGVwcy5wcm9taXNlO1xuICB9XG4gIGdldCBmaW5hbFN0ZXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RlcHMudGhlbigoc3RlcHMpID0+IHN0ZXBzW3N0ZXBzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBnZXQgY29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4gc3RlcC5jb250ZW50KTtcbiAgfVxuICBnZXQgd2FybmluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAud2FybmluZ3MpO1xuICB9XG4gIGdldCBwcm92aWRlck1ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnByb3ZpZGVyTWV0YWRhdGEpO1xuICB9XG4gIGdldCB0ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnRleHQpO1xuICB9XG4gIGdldCByZWFzb25pbmdUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnJlYXNvbmluZ1RleHQpO1xuICB9XG4gIGdldCByZWFzb25pbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAucmVhc29uaW5nKTtcbiAgfVxuICBnZXQgc291cmNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4gc3RlcC5zb3VyY2VzKTtcbiAgfVxuICBnZXQgZmlsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAuZmlsZXMpO1xuICB9XG4gIGdldCB0b29sQ2FsbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAudG9vbENhbGxzKTtcbiAgfVxuICBnZXQgc3RhdGljVG9vbENhbGxzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnN0YXRpY1Rvb2xDYWxscyk7XG4gIH1cbiAgZ2V0IGR5bmFtaWNUb29sQ2FsbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAuZHluYW1pY1Rvb2xDYWxscyk7XG4gIH1cbiAgZ2V0IHRvb2xSZXN1bHRzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnRvb2xSZXN1bHRzKTtcbiAgfVxuICBnZXQgc3RhdGljVG9vbFJlc3VsdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAuc3RhdGljVG9vbFJlc3VsdHMpO1xuICB9XG4gIGdldCBkeW5hbWljVG9vbFJlc3VsdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAuZHluYW1pY1Rvb2xSZXN1bHRzKTtcbiAgfVxuICBnZXQgdXNhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAudXNhZ2UpO1xuICB9XG4gIGdldCByZXF1ZXN0KCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnJlcXVlc3QpO1xuICB9XG4gIGdldCByZXNwb25zZSgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4gc3RlcC5yZXNwb25zZSk7XG4gIH1cbiAgZ2V0IHRvdGFsVXNhZ2UoKSB7XG4gICAgdGhpcy5jb25zdW1lU3RyZWFtKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RvdGFsVXNhZ2UucHJvbWlzZTtcbiAgfVxuICBnZXQgZmluaXNoUmVhc29uKCkge1xuICAgIHRoaXMuY29uc3VtZVN0cmVhbSgpO1xuICAgIHJldHVybiB0aGlzLl9maW5pc2hSZWFzb24ucHJvbWlzZTtcbiAgfVxuICBnZXQgcmF3RmluaXNoUmVhc29uKCkge1xuICAgIHRoaXMuY29uc3VtZVN0cmVhbSgpO1xuICAgIHJldHVybiB0aGlzLl9yYXdGaW5pc2hSZWFzb24ucHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogU3BsaXQgb3V0IGEgbmV3IHN0cmVhbSBmcm9tIHRoZSBvcmlnaW5hbCBzdHJlYW0uXG4gICAqIFRoZSBvcmlnaW5hbCBzdHJlYW0gaXMgcmVwbGFjZWQgdG8gYWxsb3cgZm9yIGZ1cnRoZXIgc3BsaXR0aW5nLFxuICAgKiBzaW5jZSB3ZSBkbyBub3Qga25vdyBob3cgbWFueSB0aW1lcyB0aGUgc3RyZWFtIHdpbGwgYmUgc3BsaXQuXG4gICAqXG4gICAqIE5vdGU6IHRoaXMgbGVhZHMgdG8gYnVmZmVyaW5nIHRoZSBzdHJlYW0gY29udGVudCBvbiB0aGUgc2VydmVyLlxuICAgKiBIb3dldmVyLCB0aGUgTExNIHJlc3VsdHMgYXJlIGV4cGVjdGVkIHRvIGJlIHNtYWxsIGVub3VnaCB0byBub3QgY2F1c2UgaXNzdWVzLlxuICAgKi9cbiAgdGVlU3RyZWFtKCkge1xuICAgIGNvbnN0IFtzdHJlYW0xLCBzdHJlYW0yXSA9IHRoaXMuYmFzZVN0cmVhbS50ZWUoKTtcbiAgICB0aGlzLmJhc2VTdHJlYW0gPSBzdHJlYW0yO1xuICAgIHJldHVybiBzdHJlYW0xO1xuICB9XG4gIGdldCB0ZXh0U3RyZWFtKCkge1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKFxuICAgICAgdGhpcy50ZWVTdHJlYW0oKS5waXBlVGhyb3VnaChcbiAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgdHJhbnNmb3JtKHsgcGFydCB9LCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRleHQtZGVsdGFcIikge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUocGFydC50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBnZXQgZnVsbFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShcbiAgICAgIHRoaXMudGVlU3RyZWFtKCkucGlwZVRocm91Z2goXG4gICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgIHRyYW5zZm9ybSh7IHBhcnQgfSwgY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHBhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGFzeW5jIGNvbnN1bWVTdHJlYW0ob3B0aW9ucykge1xuICAgIHZhciBfYTIxO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBjb25zdW1lU3RyZWFtKHtcbiAgICAgICAgc3RyZWFtOiB0aGlzLmZ1bGxTdHJlYW0sXG4gICAgICAgIG9uRXJyb3I6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMub25FcnJvclxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIChfYTIxID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5vbkVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2EyMS5jYWxsKG9wdGlvbnMsIGVycm9yKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGV4cGVyaW1lbnRhbF9wYXJ0aWFsT3V0cHV0U3RyZWFtKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnRpYWxPdXRwdXRTdHJlYW07XG4gIH1cbiAgZ2V0IHBhcnRpYWxPdXRwdXRTdHJlYW0oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oXG4gICAgICB0aGlzLnRlZVN0cmVhbSgpLnBpcGVUaHJvdWdoKFxuICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICB0cmFuc2Zvcm0oeyBwYXJ0aWFsT3V0cHV0IH0sIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0aWFsT3V0cHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHBhcnRpYWxPdXRwdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGdldCBlbGVtZW50U3RyZWFtKCkge1xuICAgIHZhciBfYTIxLCBfYiwgX2M7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gKF9hMjEgPSB0aGlzLm91dHB1dFNwZWNpZmljYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYTIxLmNyZWF0ZUVsZW1lbnRTdHJlYW1UcmFuc2Zvcm0oKTtcbiAgICBpZiAodHJhbnNmb3JtID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcjIoe1xuICAgICAgICBmdW5jdGlvbmFsaXR5OiBgZWxlbWVudCBzdHJlYW1zIGluICR7KF9jID0gKF9iID0gdGhpcy5vdXRwdXRTcGVjaWZpY2F0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2IubmFtZSkgIT0gbnVsbCA/IF9jIDogXCJ0ZXh0XCJ9IG1vZGVgXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0odGhpcy50ZWVTdHJlYW0oKS5waXBlVGhyb3VnaCh0cmFuc2Zvcm0pKTtcbiAgfVxuICBnZXQgb3V0cHV0KCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiB7XG4gICAgICB2YXIgX2EyMTtcbiAgICAgIGNvbnN0IG91dHB1dCA9IChfYTIxID0gdGhpcy5vdXRwdXRTcGVjaWZpY2F0aW9uKSAhPSBudWxsID8gX2EyMSA6IHRleHQoKTtcbiAgICAgIHJldHVybiBvdXRwdXQucGFyc2VDb21wbGV0ZU91dHB1dChcbiAgICAgICAgeyB0ZXh0OiBzdGVwLnRleHQgfSxcbiAgICAgICAge1xuICAgICAgICAgIHJlc3BvbnNlOiBzdGVwLnJlc3BvbnNlLFxuICAgICAgICAgIHVzYWdlOiBzdGVwLnVzYWdlLFxuICAgICAgICAgIGZpbmlzaFJlYXNvbjogc3RlcC5maW5pc2hSZWFzb25cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICB0b1VJTWVzc2FnZVN0cmVhbSh7XG4gICAgb3JpZ2luYWxNZXNzYWdlcyxcbiAgICBnZW5lcmF0ZU1lc3NhZ2VJZCxcbiAgICBvbkZpbmlzaCxcbiAgICBtZXNzYWdlTWV0YWRhdGEsXG4gICAgc2VuZFJlYXNvbmluZyA9IHRydWUsXG4gICAgc2VuZFNvdXJjZXMgPSBmYWxzZSxcbiAgICBzZW5kU3RhcnQgPSB0cnVlLFxuICAgIHNlbmRGaW5pc2ggPSB0cnVlLFxuICAgIG9uRXJyb3IgPSBnZXRFcnJvck1lc3NhZ2U3XG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IHJlc3BvbnNlTWVzc2FnZUlkID0gZ2VuZXJhdGVNZXNzYWdlSWQgIT0gbnVsbCA/IGdldFJlc3BvbnNlVUlNZXNzYWdlSWQoe1xuICAgICAgb3JpZ2luYWxNZXNzYWdlcyxcbiAgICAgIHJlc3BvbnNlTWVzc2FnZUlkOiBnZW5lcmF0ZU1lc3NhZ2VJZFxuICAgIH0pIDogdm9pZCAwO1xuICAgIGNvbnN0IGlzRHluYW1pYyA9IChwYXJ0KSA9PiB7XG4gICAgICB2YXIgX2EyMTtcbiAgICAgIGNvbnN0IHRvb2wyID0gKF9hMjEgPSB0aGlzLnRvb2xzKSA9PSBudWxsID8gdm9pZCAwIDogX2EyMVtwYXJ0LnRvb2xOYW1lXTtcbiAgICAgIGlmICh0b29sMiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBwYXJ0LmR5bmFtaWM7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHRvb2wyID09IG51bGwgPyB2b2lkIDAgOiB0b29sMi50eXBlKSA9PT0gXCJkeW5hbWljXCIgPyB0cnVlIDogdm9pZCAwO1xuICAgIH07XG4gICAgY29uc3QgYmFzZVN0cmVhbSA9IHRoaXMuZnVsbFN0cmVhbS5waXBlVGhyb3VnaChcbiAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICB0cmFuc2Zvcm06IGFzeW5jIChwYXJ0LCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZU1ldGFkYXRhVmFsdWUgPSBtZXNzYWdlTWV0YWRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IG1lc3NhZ2VNZXRhZGF0YSh7IHBhcnQgfSk7XG4gICAgICAgICAgY29uc3QgcGFydFR5cGUgPSBwYXJ0LnR5cGU7XG4gICAgICAgICAgc3dpdGNoIChwYXJ0VHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInRleHQtc3RhcnRcIjoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1zdGFydFwiLFxuICAgICAgICAgICAgICAgIGlkOiBwYXJ0LmlkLFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRleHQtZGVsdGFcIixcbiAgICAgICAgICAgICAgICBpZDogcGFydC5pZCxcbiAgICAgICAgICAgICAgICBkZWx0YTogcGFydC50ZXh0LFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWVuZFwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LWVuZFwiLFxuICAgICAgICAgICAgICAgIGlkOiBwYXJ0LmlkLFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJyZWFzb25pbmctc3RhcnRcIjoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nLXN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgaWQ6IHBhcnQuaWQsXG4gICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZy1kZWx0YVwiOiB7XG4gICAgICAgICAgICAgIGlmIChzZW5kUmVhc29uaW5nKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nLWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICBpZDogcGFydC5pZCxcbiAgICAgICAgICAgICAgICAgIGRlbHRhOiBwYXJ0LnRleHQsXG4gICAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5wcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZy1lbmRcIjoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nLWVuZFwiLFxuICAgICAgICAgICAgICAgIGlkOiBwYXJ0LmlkLFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJmaWxlXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgICAgICBtZWRpYVR5cGU6IHBhcnQuZmlsZS5tZWRpYVR5cGUsXG4gICAgICAgICAgICAgICAgdXJsOiBgZGF0YToke3BhcnQuZmlsZS5tZWRpYVR5cGV9O2Jhc2U2NCwke3BhcnQuZmlsZS5iYXNlNjR9YFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic291cmNlXCI6IHtcbiAgICAgICAgICAgICAgaWYgKHNlbmRTb3VyY2VzICYmIHBhcnQuc291cmNlVHlwZSA9PT0gXCJ1cmxcIikge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInNvdXJjZS11cmxcIixcbiAgICAgICAgICAgICAgICAgIHNvdXJjZUlkOiBwYXJ0LmlkLFxuICAgICAgICAgICAgICAgICAgdXJsOiBwYXJ0LnVybCxcbiAgICAgICAgICAgICAgICAgIHRpdGxlOiBwYXJ0LnRpdGxlLFxuICAgICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc2VuZFNvdXJjZXMgJiYgcGFydC5zb3VyY2VUeXBlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJzb3VyY2UtZG9jdW1lbnRcIixcbiAgICAgICAgICAgICAgICAgIHNvdXJjZUlkOiBwYXJ0LmlkLFxuICAgICAgICAgICAgICAgICAgbWVkaWFUeXBlOiBwYXJ0Lm1lZGlhVHlwZSxcbiAgICAgICAgICAgICAgICAgIHRpdGxlOiBwYXJ0LnRpdGxlLFxuICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IHBhcnQuZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5wcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtaW5wdXQtc3RhcnRcIjoge1xuICAgICAgICAgICAgICBjb25zdCBkeW5hbWljID0gaXNEeW5hbWljKHBhcnQpO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1pbnB1dC1zdGFydFwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQuaWQsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlckV4ZWN1dGVkICE9IG51bGwgPyB7IHByb3ZpZGVyRXhlY3V0ZWQ6IHBhcnQucHJvdmlkZXJFeGVjdXRlZCB9IDoge30sXG4gICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YSB9IDoge30sXG4gICAgICAgICAgICAgICAgLi4uZHluYW1pYyAhPSBudWxsID8geyBkeW5hbWljIH0gOiB7fSxcbiAgICAgICAgICAgICAgICAuLi5wYXJ0LnRpdGxlICE9IG51bGwgPyB7IHRpdGxlOiBwYXJ0LnRpdGxlIH0gOiB7fVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1pbnB1dC1kZWx0YVwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWlucHV0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC5pZCxcbiAgICAgICAgICAgICAgICBpbnB1dFRleHREZWx0YTogcGFydC5kZWx0YVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgZHluYW1pYyA9IGlzRHluYW1pYyhwYXJ0KTtcbiAgICAgICAgICAgICAgaWYgKHBhcnQuaW52YWxpZCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtaW5wdXQtZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IHBhcnQuaW5wdXQsXG4gICAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgIT0gbnVsbCA/IHsgcHJvdmlkZXJFeGVjdXRlZDogcGFydC5wcm92aWRlckV4ZWN1dGVkIH0gOiB7fSxcbiAgICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9LFxuICAgICAgICAgICAgICAgICAgLi4uZHluYW1pYyAhPSBudWxsID8geyBkeW5hbWljIH0gOiB7fSxcbiAgICAgICAgICAgICAgICAgIGVycm9yVGV4dDogb25FcnJvcihwYXJ0LmVycm9yKSxcbiAgICAgICAgICAgICAgICAgIC4uLnBhcnQudGl0bGUgIT0gbnVsbCA/IHsgdGl0bGU6IHBhcnQudGl0bGUgfSA6IHt9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1pbnB1dC1hdmFpbGFibGVcIixcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IHBhcnQuaW5wdXQsXG4gICAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgIT0gbnVsbCA/IHsgcHJvdmlkZXJFeGVjdXRlZDogcGFydC5wcm92aWRlckV4ZWN1dGVkIH0gOiB7fSxcbiAgICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9LFxuICAgICAgICAgICAgICAgICAgLi4uZHluYW1pYyAhPSBudWxsID8geyBkeW5hbWljIH0gOiB7fSxcbiAgICAgICAgICAgICAgICAgIC4uLnBhcnQudGl0bGUgIT0gbnVsbCA/IHsgdGl0bGU6IHBhcnQudGl0bGUgfSA6IHt9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtYXBwcm92YWwtcmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgIGFwcHJvdmFsSWQ6IHBhcnQuYXBwcm92YWxJZCxcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsLnRvb2xDYWxsSWRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtcmVzdWx0XCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgZHluYW1pYyA9IGlzRHluYW1pYyhwYXJ0KTtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtb3V0cHV0LWF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IHBhcnQub3V0cHV0LFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJFeGVjdXRlZCAhPSBudWxsID8geyBwcm92aWRlckV4ZWN1dGVkOiBwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgfSA6IHt9LFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJlbGltaW5hcnkgIT0gbnVsbCA/IHsgcHJlbGltaW5hcnk6IHBhcnQucHJlbGltaW5hcnkgfSA6IHt9LFxuICAgICAgICAgICAgICAgIC4uLmR5bmFtaWMgIT0gbnVsbCA/IHsgZHluYW1pYyB9IDoge31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtZXJyb3JcIjoge1xuICAgICAgICAgICAgICBjb25zdCBkeW5hbWljID0gaXNEeW5hbWljKHBhcnQpO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1vdXRwdXQtZXJyb3JcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgZXJyb3JUZXh0OiBvbkVycm9yKHBhcnQuZXJyb3IpLFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJFeGVjdXRlZCAhPSBudWxsID8geyBwcm92aWRlckV4ZWN1dGVkOiBwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgfSA6IHt9LFxuICAgICAgICAgICAgICAgIC4uLmR5bmFtaWMgIT0gbnVsbCA/IHsgZHluYW1pYyB9IDoge31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtb3V0cHV0LWRlbmllZFwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLW91dHB1dC1kZW5pZWRcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgZXJyb3JUZXh0OiBvbkVycm9yKHBhcnQuZXJyb3IpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzdGFydC1zdGVwXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJzdGFydC1zdGVwXCIgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImZpbmlzaC1zdGVwXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJmaW5pc2gtc3RlcFwiIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzdGFydFwiOiB7XG4gICAgICAgICAgICAgIGlmIChzZW5kU3RhcnQpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdGFydFwiLFxuICAgICAgICAgICAgICAgICAgLi4ubWVzc2FnZU1ldGFkYXRhVmFsdWUgIT0gbnVsbCA/IHsgbWVzc2FnZU1ldGFkYXRhOiBtZXNzYWdlTWV0YWRhdGFWYWx1ZSB9IDoge30sXG4gICAgICAgICAgICAgICAgICAuLi5yZXNwb25zZU1lc3NhZ2VJZCAhPSBudWxsID8geyBtZXNzYWdlSWQ6IHJlc3BvbnNlTWVzc2FnZUlkIH0gOiB7fVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOiB7XG4gICAgICAgICAgICAgIGlmIChzZW5kRmluaXNoKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZmluaXNoXCIsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IHBhcnQuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgLi4ubWVzc2FnZU1ldGFkYXRhVmFsdWUgIT0gbnVsbCA/IHsgbWVzc2FnZU1ldGFkYXRhOiBtZXNzYWdlTWV0YWRhdGFWYWx1ZSB9IDoge31cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJhYm9ydFwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShwYXJ0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1pbnB1dC1lbmRcIjoge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjoge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gcGFydFR5cGU7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBjaHVuayB0eXBlOiAke2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2VNZXRhZGF0YVZhbHVlICE9IG51bGwgJiYgcGFydFR5cGUgIT09IFwic3RhcnRcIiAmJiBwYXJ0VHlwZSAhPT0gXCJmaW5pc2hcIikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJtZXNzYWdlLW1ldGFkYXRhXCIsXG4gICAgICAgICAgICAgIG1lc3NhZ2VNZXRhZGF0YTogbWVzc2FnZU1ldGFkYXRhVmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKFxuICAgICAgaGFuZGxlVUlNZXNzYWdlU3RyZWFtRmluaXNoKHtcbiAgICAgICAgc3RyZWFtOiBiYXNlU3RyZWFtLFxuICAgICAgICBtZXNzYWdlSWQ6IHJlc3BvbnNlTWVzc2FnZUlkICE9IG51bGwgPyByZXNwb25zZU1lc3NhZ2VJZCA6IGdlbmVyYXRlTWVzc2FnZUlkID09IG51bGwgPyB2b2lkIDAgOiBnZW5lcmF0ZU1lc3NhZ2VJZCgpLFxuICAgICAgICBvcmlnaW5hbE1lc3NhZ2VzLFxuICAgICAgICBvbkZpbmlzaCxcbiAgICAgICAgb25FcnJvclxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIHBpcGVVSU1lc3NhZ2VTdHJlYW1Ub1Jlc3BvbnNlKHJlc3BvbnNlLCB7XG4gICAgb3JpZ2luYWxNZXNzYWdlcyxcbiAgICBnZW5lcmF0ZU1lc3NhZ2VJZCxcbiAgICBvbkZpbmlzaCxcbiAgICBtZXNzYWdlTWV0YWRhdGEsXG4gICAgc2VuZFJlYXNvbmluZyxcbiAgICBzZW5kU291cmNlcyxcbiAgICBzZW5kRmluaXNoLFxuICAgIHNlbmRTdGFydCxcbiAgICBvbkVycm9yLFxuICAgIC4uLmluaXRcbiAgfSA9IHt9KSB7XG4gICAgcGlwZVVJTWVzc2FnZVN0cmVhbVRvUmVzcG9uc2Uoe1xuICAgICAgcmVzcG9uc2UsXG4gICAgICBzdHJlYW06IHRoaXMudG9VSU1lc3NhZ2VTdHJlYW0oe1xuICAgICAgICBvcmlnaW5hbE1lc3NhZ2VzLFxuICAgICAgICBnZW5lcmF0ZU1lc3NhZ2VJZCxcbiAgICAgICAgb25GaW5pc2gsXG4gICAgICAgIG1lc3NhZ2VNZXRhZGF0YSxcbiAgICAgICAgc2VuZFJlYXNvbmluZyxcbiAgICAgICAgc2VuZFNvdXJjZXMsXG4gICAgICAgIHNlbmRGaW5pc2gsXG4gICAgICAgIHNlbmRTdGFydCxcbiAgICAgICAgb25FcnJvclxuICAgICAgfSksXG4gICAgICAuLi5pbml0XG4gICAgfSk7XG4gIH1cbiAgcGlwZVRleHRTdHJlYW1Ub1Jlc3BvbnNlKHJlc3BvbnNlLCBpbml0KSB7XG4gICAgcGlwZVRleHRTdHJlYW1Ub1Jlc3BvbnNlKHtcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgdGV4dFN0cmVhbTogdGhpcy50ZXh0U3RyZWFtLFxuICAgICAgLi4uaW5pdFxuICAgIH0pO1xuICB9XG4gIHRvVUlNZXNzYWdlU3RyZWFtUmVzcG9uc2Uoe1xuICAgIG9yaWdpbmFsTWVzc2FnZXMsXG4gICAgZ2VuZXJhdGVNZXNzYWdlSWQsXG4gICAgb25GaW5pc2gsXG4gICAgbWVzc2FnZU1ldGFkYXRhLFxuICAgIHNlbmRSZWFzb25pbmcsXG4gICAgc2VuZFNvdXJjZXMsXG4gICAgc2VuZEZpbmlzaCxcbiAgICBzZW5kU3RhcnQsXG4gICAgb25FcnJvcixcbiAgICAuLi5pbml0XG4gIH0gPSB7fSkge1xuICAgIHJldHVybiBjcmVhdGVVSU1lc3NhZ2VTdHJlYW1SZXNwb25zZSh7XG4gICAgICBzdHJlYW06IHRoaXMudG9VSU1lc3NhZ2VTdHJlYW0oe1xuICAgICAgICBvcmlnaW5hbE1lc3NhZ2VzLFxuICAgICAgICBnZW5lcmF0ZU1lc3NhZ2VJZCxcbiAgICAgICAgb25GaW5pc2gsXG4gICAgICAgIG1lc3NhZ2VNZXRhZGF0YSxcbiAgICAgICAgc2VuZFJlYXNvbmluZyxcbiAgICAgICAgc2VuZFNvdXJjZXMsXG4gICAgICAgIHNlbmRGaW5pc2gsXG4gICAgICAgIHNlbmRTdGFydCxcbiAgICAgICAgb25FcnJvclxuICAgICAgfSksXG4gICAgICAuLi5pbml0XG4gICAgfSk7XG4gIH1cbiAgdG9UZXh0U3RyZWFtUmVzcG9uc2UoaW5pdCkge1xuICAgIHJldHVybiBjcmVhdGVUZXh0U3RyZWFtUmVzcG9uc2Uoe1xuICAgICAgdGV4dFN0cmVhbTogdGhpcy50ZXh0U3RyZWFtLFxuICAgICAgLi4uaW5pdFxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvYWdlbnQvdG9vbC1sb29wLWFnZW50LnRzXG52YXIgVG9vbExvb3BBZ2VudCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICB0aGlzLnZlcnNpb24gPSBcImFnZW50LXYxXCI7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaWQgb2YgdGhlIGFnZW50LlxuICAgKi9cbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiB0aGlzLnNldHRpbmdzLmlkO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgdG9vbHMgdGhhdCB0aGUgYWdlbnQgY2FuIHVzZS5cbiAgICovXG4gIGdldCB0b29scygpIHtcbiAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy50b29scztcbiAgfVxuICBhc3luYyBwcmVwYXJlQ2FsbChvcHRpb25zKSB7XG4gICAgdmFyIF9hMjEsIF9iLCBfYywgX2Q7XG4gICAgY29uc3Qge1xuICAgICAgZXhwZXJpbWVudGFsX29uU3RhcnQ6IF9zZXR0aW5nc09uU3RhcnQsXG4gICAgICBleHBlcmltZW50YWxfb25TdGVwU3RhcnQ6IF9zZXR0aW5nc09uU3RlcFN0YXJ0LFxuICAgICAgZXhwZXJpbWVudGFsX29uVG9vbENhbGxTdGFydDogX3NldHRpbmdzT25Ub29sQ2FsbFN0YXJ0LFxuICAgICAgZXhwZXJpbWVudGFsX29uVG9vbENhbGxGaW5pc2g6IF9zZXR0aW5nc09uVG9vbENhbGxGaW5pc2gsXG4gICAgICBvblN0ZXBGaW5pc2g6IF9zZXR0aW5nc09uU3RlcEZpbmlzaCxcbiAgICAgIG9uRmluaXNoOiBfc2V0dGluZ3NPbkZpbmlzaCxcbiAgICAgIC4uLnNldHRpbmdzV2l0aG91dENhbGxiYWNrc1xuICAgIH0gPSB0aGlzLnNldHRpbmdzO1xuICAgIGNvbnN0IGJhc2VDYWxsQXJncyA9IHtcbiAgICAgIC4uLnNldHRpbmdzV2l0aG91dENhbGxiYWNrcyxcbiAgICAgIHN0b3BXaGVuOiAoX2EyMSA9IHRoaXMuc2V0dGluZ3Muc3RvcFdoZW4pICE9IG51bGwgPyBfYTIxIDogc3RlcENvdW50SXMoMjApLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG4gICAgY29uc3QgcHJlcGFyZWRDYWxsQXJncyA9IChfZCA9IGF3YWl0ICgoX2MgPSAoX2IgPSB0aGlzLnNldHRpbmdzKS5wcmVwYXJlQ2FsbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmNhbGwoXG4gICAgICBfYixcbiAgICAgIGJhc2VDYWxsQXJnc1xuICAgICkpKSAhPSBudWxsID8gX2QgOiBiYXNlQ2FsbEFyZ3M7XG4gICAgY29uc3QgeyBpbnN0cnVjdGlvbnMsIG1lc3NhZ2VzLCBwcm9tcHQsIC4uLmNhbGxBcmdzIH0gPSBwcmVwYXJlZENhbGxBcmdzO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5jYWxsQXJncyxcbiAgICAgIC8vIHJlc3RvcmUgcHJvbXB0IHR5cGVzXG4gICAgICAuLi57IHN5c3RlbTogaW5zdHJ1Y3Rpb25zLCBtZXNzYWdlcywgcHJvbXB0IH1cbiAgICB9O1xuICB9XG4gIG1lcmdlQ2FsbGJhY2tzKHNldHRpbmdzQ2FsbGJhY2ssIG1ldGhvZENhbGxiYWNrKSB7XG4gICAgaWYgKG1ldGhvZENhbGxiYWNrICYmIHNldHRpbmdzQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgYXdhaXQgc2V0dGluZ3NDYWxsYmFjayhldmVudCk7XG4gICAgICAgIGF3YWl0IG1ldGhvZENhbGxiYWNrKGV2ZW50KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBtZXRob2RDYWxsYmFjayAhPSBudWxsID8gbWV0aG9kQ2FsbGJhY2sgOiBzZXR0aW5nc0NhbGxiYWNrO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYW4gb3V0cHV0IGZyb20gdGhlIGFnZW50IChub24tc3RyZWFtaW5nKS5cbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlKHtcbiAgICBhYm9ydFNpZ25hbCxcbiAgICB0aW1lb3V0LFxuICAgIGV4cGVyaW1lbnRhbF9vblN0YXJ0LFxuICAgIGV4cGVyaW1lbnRhbF9vblN0ZXBTdGFydCxcbiAgICBleHBlcmltZW50YWxfb25Ub29sQ2FsbFN0YXJ0LFxuICAgIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsRmluaXNoLFxuICAgIG9uU3RlcEZpbmlzaCxcbiAgICBvbkZpbmlzaCxcbiAgICAuLi5vcHRpb25zXG4gIH0pIHtcbiAgICByZXR1cm4gZ2VuZXJhdGVUZXh0KHtcbiAgICAgIC4uLmF3YWl0IHRoaXMucHJlcGFyZUNhbGwob3B0aW9ucyksXG4gICAgICBhYm9ydFNpZ25hbCxcbiAgICAgIHRpbWVvdXQsXG4gICAgICBleHBlcmltZW50YWxfb25TdGFydDogdGhpcy5tZXJnZUNhbGxiYWNrcyhcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5leHBlcmltZW50YWxfb25TdGFydCxcbiAgICAgICAgZXhwZXJpbWVudGFsX29uU3RhcnRcbiAgICAgICksXG4gICAgICBleHBlcmltZW50YWxfb25TdGVwU3RhcnQ6IHRoaXMubWVyZ2VDYWxsYmFja3MoXG4gICAgICAgIHRoaXMuc2V0dGluZ3MuZXhwZXJpbWVudGFsX29uU3RlcFN0YXJ0LFxuICAgICAgICBleHBlcmltZW50YWxfb25TdGVwU3RhcnRcbiAgICAgICksXG4gICAgICBleHBlcmltZW50YWxfb25Ub29sQ2FsbFN0YXJ0OiB0aGlzLm1lcmdlQ2FsbGJhY2tzKFxuICAgICAgICB0aGlzLnNldHRpbmdzLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsU3RhcnQsXG4gICAgICAgIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsU3RhcnRcbiAgICAgICksXG4gICAgICBleHBlcmltZW50YWxfb25Ub29sQ2FsbEZpbmlzaDogdGhpcy5tZXJnZUNhbGxiYWNrcyhcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5leHBlcmltZW50YWxfb25Ub29sQ2FsbEZpbmlzaCxcbiAgICAgICAgZXhwZXJpbWVudGFsX29uVG9vbENhbGxGaW5pc2hcbiAgICAgICksXG4gICAgICBvblN0ZXBGaW5pc2g6IHRoaXMubWVyZ2VDYWxsYmFja3MoXG4gICAgICAgIHRoaXMuc2V0dGluZ3Mub25TdGVwRmluaXNoLFxuICAgICAgICBvblN0ZXBGaW5pc2hcbiAgICAgICksXG4gICAgICBvbkZpbmlzaDogdGhpcy5tZXJnZUNhbGxiYWNrcyh0aGlzLnNldHRpbmdzLm9uRmluaXNoLCBvbkZpbmlzaClcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3RyZWFtcyBhbiBvdXRwdXQgZnJvbSB0aGUgYWdlbnQgKHN0cmVhbWluZykuXG4gICAqL1xuICBhc3luYyBzdHJlYW0oe1xuICAgIGFib3J0U2lnbmFsLFxuICAgIHRpbWVvdXQsXG4gICAgZXhwZXJpbWVudGFsX3RyYW5zZm9ybSxcbiAgICBleHBlcmltZW50YWxfb25TdGFydCxcbiAgICBleHBlcmltZW50YWxfb25TdGVwU3RhcnQsXG4gICAgZXhwZXJpbWVudGFsX29uVG9vbENhbGxTdGFydCxcbiAgICBleHBlcmltZW50YWxfb25Ub29sQ2FsbEZpbmlzaCxcbiAgICBvblN0ZXBGaW5pc2gsXG4gICAgb25GaW5pc2gsXG4gICAgLi4ub3B0aW9uc1xuICB9KSB7XG4gICAgcmV0dXJuIHN0cmVhbVRleHQoe1xuICAgICAgLi4uYXdhaXQgdGhpcy5wcmVwYXJlQ2FsbChvcHRpb25zKSxcbiAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgdGltZW91dCxcbiAgICAgIGV4cGVyaW1lbnRhbF90cmFuc2Zvcm0sXG4gICAgICBleHBlcmltZW50YWxfb25TdGFydDogdGhpcy5tZXJnZUNhbGxiYWNrcyhcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5leHBlcmltZW50YWxfb25TdGFydCxcbiAgICAgICAgZXhwZXJpbWVudGFsX29uU3RhcnRcbiAgICAgICksXG4gICAgICBleHBlcmltZW50YWxfb25TdGVwU3RhcnQ6IHRoaXMubWVyZ2VDYWxsYmFja3MoXG4gICAgICAgIHRoaXMuc2V0dGluZ3MuZXhwZXJpbWVudGFsX29uU3RlcFN0YXJ0LFxuICAgICAgICBleHBlcmltZW50YWxfb25TdGVwU3RhcnRcbiAgICAgICksXG4gICAgICBleHBlcmltZW50YWxfb25Ub29sQ2FsbFN0YXJ0OiB0aGlzLm1lcmdlQ2FsbGJhY2tzKFxuICAgICAgICB0aGlzLnNldHRpbmdzLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsU3RhcnQsXG4gICAgICAgIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsU3RhcnRcbiAgICAgICksXG4gICAgICBleHBlcmltZW50YWxfb25Ub29sQ2FsbEZpbmlzaDogdGhpcy5tZXJnZUNhbGxiYWNrcyhcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5leHBlcmltZW50YWxfb25Ub29sQ2FsbEZpbmlzaCxcbiAgICAgICAgZXhwZXJpbWVudGFsX29uVG9vbENhbGxGaW5pc2hcbiAgICAgICksXG4gICAgICBvblN0ZXBGaW5pc2g6IHRoaXMubWVyZ2VDYWxsYmFja3MoXG4gICAgICAgIHRoaXMuc2V0dGluZ3Mub25TdGVwRmluaXNoLFxuICAgICAgICBvblN0ZXBGaW5pc2hcbiAgICAgICksXG4gICAgICBvbkZpbmlzaDogdGhpcy5tZXJnZUNhbGxiYWNrcyh0aGlzLnNldHRpbmdzLm9uRmluaXNoLCBvbkZpbmlzaClcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL3VpLW1lc3NhZ2Utc3RyZWFtL2NyZWF0ZS11aS1tZXNzYWdlLXN0cmVhbS50c1xuaW1wb3J0IHtcbiAgZ2VuZXJhdGVJZCBhcyBnZW5lcmF0ZUlkRnVuYyxcbiAgZ2V0RXJyb3JNZXNzYWdlIGFzIGdldEVycm9yTWVzc2FnZThcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmZ1bmN0aW9uIGNyZWF0ZVVJTWVzc2FnZVN0cmVhbSh7XG4gIGV4ZWN1dGUsXG4gIG9uRXJyb3IgPSBnZXRFcnJvck1lc3NhZ2U4LFxuICBvcmlnaW5hbE1lc3NhZ2VzLFxuICBvblN0ZXBGaW5pc2gsXG4gIG9uRmluaXNoLFxuICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMiA9IGdlbmVyYXRlSWRGdW5jXG59KSB7XG4gIGxldCBjb250cm9sbGVyO1xuICBjb25zdCBvbmdvaW5nU3RyZWFtUHJvbWlzZXMgPSBbXTtcbiAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyQXJnKSB7XG4gICAgICBjb250cm9sbGVyID0gY29udHJvbGxlckFyZztcbiAgICB9XG4gIH0pO1xuICBmdW5jdGlvbiBzYWZlRW5xdWV1ZShkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShkYXRhKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgIH1cbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGV4ZWN1dGUoe1xuICAgICAgd3JpdGVyOiB7XG4gICAgICAgIHdyaXRlKHBhcnQpIHtcbiAgICAgICAgICBzYWZlRW5xdWV1ZShwYXJ0KTtcbiAgICAgICAgfSxcbiAgICAgICAgbWVyZ2Uoc3RyZWFtQXJnKSB7XG4gICAgICAgICAgb25nb2luZ1N0cmVhbVByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW1BcmcuZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHNhZmVFbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgc2FmZUVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICBlcnJvclRleHQ6IG9uRXJyb3IoZXJyb3IpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgb25nb2luZ1N0cmVhbVByb21pc2VzLnB1c2goXG4gICAgICAgIHJlc3VsdC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICBzYWZlRW5xdWV1ZSh7XG4gICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICBlcnJvclRleHQ6IG9uRXJyb3IoZXJyb3IpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBzYWZlRW5xdWV1ZSh7XG4gICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICBlcnJvclRleHQ6IG9uRXJyb3IoZXJyb3IpXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgd2FpdEZvclN0cmVhbXMgPSBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZTMpID0+IHtcbiAgICB3aGlsZSAob25nb2luZ1N0cmVhbVByb21pc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIGF3YWl0IG9uZ29pbmdTdHJlYW1Qcm9taXNlcy5zaGlmdCgpO1xuICAgIH1cbiAgICByZXNvbHZlMygpO1xuICB9KTtcbiAgd2FpdEZvclN0cmVhbXMuZmluYWxseSgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBoYW5kbGVVSU1lc3NhZ2VTdHJlYW1GaW5pc2goe1xuICAgIHN0cmVhbSxcbiAgICBtZXNzYWdlSWQ6IGdlbmVyYXRlSWQyKCksXG4gICAgb3JpZ2luYWxNZXNzYWdlcyxcbiAgICBvblN0ZXBGaW5pc2gsXG4gICAgb25GaW5pc2gsXG4gICAgb25FcnJvclxuICB9KTtcbn1cblxuLy8gc3JjL3VpLW1lc3NhZ2Utc3RyZWFtL3JlYWQtdWktbWVzc2FnZS1zdHJlYW0udHNcbmZ1bmN0aW9uIHJlYWRVSU1lc3NhZ2VTdHJlYW0oe1xuICBtZXNzYWdlLFxuICBzdHJlYW0sXG4gIG9uRXJyb3IsXG4gIHRlcm1pbmF0ZU9uRXJyb3IgPSBmYWxzZVxufSkge1xuICB2YXIgX2EyMTtcbiAgbGV0IGNvbnRyb2xsZXI7XG4gIGxldCBoYXNFcnJvcmVkID0gZmFsc2U7XG4gIGNvbnN0IG91dHB1dFN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgc3RhcnQoY29udHJvbGxlclBhcmFtKSB7XG4gICAgICBjb250cm9sbGVyID0gY29udHJvbGxlclBhcmFtO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHN0YXRlID0gY3JlYXRlU3RyZWFtaW5nVUlNZXNzYWdlU3RhdGUoe1xuICAgIG1lc3NhZ2VJZDogKF9hMjEgPSBtZXNzYWdlID09IG51bGwgPyB2b2lkIDAgOiBtZXNzYWdlLmlkKSAhPSBudWxsID8gX2EyMSA6IFwiXCIsXG4gICAgbGFzdE1lc3NhZ2U6IG1lc3NhZ2VcbiAgfSk7XG4gIGNvbnN0IGhhbmRsZUVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgb25FcnJvciA9PSBudWxsID8gdm9pZCAwIDogb25FcnJvcihlcnJvcik7XG4gICAgaWYgKCFoYXNFcnJvcmVkICYmIHRlcm1pbmF0ZU9uRXJyb3IpIHtcbiAgICAgIGhhc0Vycm9yZWQgPSB0cnVlO1xuICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5lcnJvcihlcnJvcik7XG4gICAgfVxuICB9O1xuICBjb25zdW1lU3RyZWFtKHtcbiAgICBzdHJlYW06IHByb2Nlc3NVSU1lc3NhZ2VTdHJlYW0oe1xuICAgICAgc3RyZWFtLFxuICAgICAgcnVuVXBkYXRlTWVzc2FnZUpvYihqb2IpIHtcbiAgICAgICAgcmV0dXJuIGpvYih7XG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgd3JpdGU6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuZW5xdWV1ZShzdHJ1Y3R1cmVkQ2xvbmUoc3RhdGUubWVzc2FnZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgb25FcnJvcjogaGFuZGxlRXJyb3JcbiAgICB9KSxcbiAgICBvbkVycm9yOiBoYW5kbGVFcnJvclxuICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICBpZiAoIWhhc0Vycm9yZWQpIHtcbiAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShvdXRwdXRTdHJlYW0pO1xufVxuXG4vLyBzcmMvdWkvY29udmVydC10by1tb2RlbC1tZXNzYWdlcy50c1xuaW1wb3J0IHtcbiAgaXNOb25OdWxsYWJsZVxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuYXN5bmMgZnVuY3Rpb24gY29udmVydFRvTW9kZWxNZXNzYWdlcyhtZXNzYWdlcywgb3B0aW9ucykge1xuICBjb25zdCBtb2RlbE1lc3NhZ2VzID0gW107XG4gIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmlnbm9yZUluY29tcGxldGVUb29sQ2FsbHMpIHtcbiAgICBtZXNzYWdlcyA9IG1lc3NhZ2VzLm1hcCgobWVzc2FnZSkgPT4gKHtcbiAgICAgIC4uLm1lc3NhZ2UsXG4gICAgICBwYXJ0czogbWVzc2FnZS5wYXJ0cy5maWx0ZXIoXG4gICAgICAgIChwYXJ0KSA9PiAhaXNUb29sVUlQYXJ0KHBhcnQpIHx8IHBhcnQuc3RhdGUgIT09IFwiaW5wdXQtc3RyZWFtaW5nXCIgJiYgcGFydC5zdGF0ZSAhPT0gXCJpbnB1dC1hdmFpbGFibGVcIlxuICAgICAgKVxuICAgIH0pKTtcbiAgfVxuICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcbiAgICBzd2l0Y2ggKG1lc3NhZ2Uucm9sZSkge1xuICAgICAgY2FzZSBcInN5c3RlbVwiOiB7XG4gICAgICAgIGNvbnN0IHRleHRQYXJ0cyA9IG1lc3NhZ2UucGFydHMuZmlsdGVyKFxuICAgICAgICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwidGV4dFwiXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyTWV0YWRhdGEgPSB0ZXh0UGFydHMucmVkdWNlKChhY2MsIHBhcnQpID0+IHtcbiAgICAgICAgICBpZiAocGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IC4uLmFjYywgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgbW9kZWxNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiBcInN5c3RlbVwiLFxuICAgICAgICAgIGNvbnRlbnQ6IHRleHRQYXJ0cy5tYXAoKHBhcnQpID0+IHBhcnQudGV4dCkuam9pbihcIlwiKSxcbiAgICAgICAgICAuLi5PYmplY3Qua2V5cyhwcm92aWRlck1ldGFkYXRhKS5sZW5ndGggPiAwID8geyBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ1c2VyXCI6IHtcbiAgICAgICAgbW9kZWxNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICBjb250ZW50OiBtZXNzYWdlLnBhcnRzLm1hcCgocGFydCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hMjE7XG4gICAgICAgICAgICBpZiAoaXNUZXh0VUlQYXJ0KHBhcnQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgdGV4dDogcGFydC50ZXh0LFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck9wdGlvbnM6IHBhcnQucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0ZpbGVVSVBhcnQocGFydCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgICAgICBtZWRpYVR5cGU6IHBhcnQubWVkaWFUeXBlLFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBwYXJ0LmZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIGRhdGE6IHBhcnQudXJsLFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck9wdGlvbnM6IHBhcnQucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0RhdGFVSVBhcnQocGFydCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIChfYTIxID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5jb252ZXJ0RGF0YVBhcnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIxLmNhbGwoXG4gICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICBwYXJ0XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkuZmlsdGVyKGlzTm9uTnVsbGFibGUpXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJhc3Npc3RhbnRcIjoge1xuICAgICAgICBpZiAobWVzc2FnZS5wYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgICAgbGV0IGJsb2NrID0gW107XG4gICAgICAgICAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0Jsb2NrKCkge1xuICAgICAgICAgICAgdmFyIF9hMjEsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgICAgIGlmIChibG9jay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIGJsb2NrKSB7XG4gICAgICAgICAgICAgIGlmIChpc1RleHRVSVBhcnQocGFydCkpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICB0ZXh0OiBwYXJ0LnRleHQsXG4gICAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNGaWxlVUlQYXJ0KHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAgICAgICAgICAgbWVkaWFUeXBlOiBwYXJ0Lm1lZGlhVHlwZSxcbiAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBwYXJ0LmZpbGVuYW1lLFxuICAgICAgICAgICAgICAgICAgZGF0YTogcGFydC51cmxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1JlYXNvbmluZ1VJUGFydChwYXJ0KSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZ1wiLFxuICAgICAgICAgICAgICAgICAgdGV4dDogcGFydC50ZXh0LFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1Rvb2xVSVBhcnQocGFydCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29sTmFtZSA9IGdldFRvb2xOYW1lKHBhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0LnN0YXRlICE9PSBcImlucHV0LXN0cmVhbWluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtY2FsbFwiLFxuICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dDogcGFydC5zdGF0ZSA9PT0gXCJvdXRwdXQtZXJyb3JcIiA/IChfYTIxID0gcGFydC5pbnB1dCkgIT0gbnVsbCA/IF9hMjEgOiBcInJhd0lucHV0XCIgaW4gcGFydCA/IHBhcnQucmF3SW5wdXQgOiB2b2lkIDAgOiBwYXJ0LmlucHV0LFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiBwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQsXG4gICAgICAgICAgICAgICAgICAgIC4uLnBhcnQuY2FsbFByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LmNhbGxQcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBpZiAocGFydC5hcHByb3ZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWFwcHJvdmFsLXJlcXVlc3RcIixcbiAgICAgICAgICAgICAgICAgICAgICBhcHByb3ZhbElkOiBwYXJ0LmFwcHJvdmFsLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgPT09IHRydWUgJiYgcGFydC5zdGF0ZSAhPT0gXCJhcHByb3ZhbC1yZXNwb25kZWRcIiAmJiAocGFydC5zdGF0ZSA9PT0gXCJvdXRwdXQtYXZhaWxhYmxlXCIgfHwgcGFydC5zdGF0ZSA9PT0gXCJvdXRwdXQtZXJyb3JcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogYXdhaXQgY3JlYXRlVG9vbE1vZGVsT3V0cHV0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBwYXJ0LmlucHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiBwYXJ0LnN0YXRlID09PSBcIm91dHB1dC1lcnJvclwiID8gcGFydC5lcnJvclRleHQgOiBwYXJ0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2w6IChfYiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudG9vbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYlt0b29sTmFtZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1vZGU6IHBhcnQuc3RhdGUgPT09IFwib3V0cHV0LWVycm9yXCIgPyBcImpzb25cIiA6IFwibm9uZVwiXG4gICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgLi4ucGFydC5jYWxsUHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck9wdGlvbnM6IHBhcnQuY2FsbFByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0RhdGFVSVBhcnQocGFydCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhUGFydCA9IChfYyA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuY29udmVydERhdGFQYXJ0KSA9PSBudWxsID8gdm9pZCAwIDogX2MuY2FsbChcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICBwYXJ0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVBhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgY29udGVudC5wdXNoKGRhdGFQYXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IHBhcnQ7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwYXJ0OiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vZGVsTWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgICAgIGNvbnRlbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdG9vbFBhcnRzID0gYmxvY2suZmlsdGVyKFxuICAgICAgICAgICAgICAocGFydCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTIyO1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1Rvb2xVSVBhcnQocGFydCkgJiYgKHBhcnQucHJvdmlkZXJFeGVjdXRlZCAhPT0gdHJ1ZSB8fCAoKF9hMjIgPSBwYXJ0LmFwcHJvdmFsKSA9PSBudWxsID8gdm9pZCAwIDogX2EyMi5hcHByb3ZlZCkgIT0gbnVsbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAodG9vbFBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQyID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0b29sUGFydCBvZiB0b29sUGFydHMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICgoKF9kID0gdG9vbFBhcnQuYXBwcm92YWwpID09IG51bGwgPyB2b2lkIDAgOiBfZC5hcHByb3ZlZCkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50Mi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtYXBwcm92YWwtcmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICBhcHByb3ZhbElkOiB0b29sUGFydC5hcHByb3ZhbC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICBhcHByb3ZlZDogdG9vbFBhcnQuYXBwcm92YWwuYXBwcm92ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgcmVhc29uOiB0b29sUGFydC5hcHByb3ZhbC5yZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogdG9vbFBhcnQucHJvdmlkZXJFeGVjdXRlZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICh0b29sUGFydC5wcm92aWRlckV4ZWN1dGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgc3dpdGNoICh0b29sUGFydC5zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwib3V0cHV0LWRlbmllZFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGVudDIucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiB0b29sUGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IGdldFRvb2xOYW1lKHRvb2xQYXJ0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yLXRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IChfZSA9IHRvb2xQYXJ0LmFwcHJvdmFsLnJlYXNvbikgIT0gbnVsbCA/IF9lIDogXCJUb29sIGV4ZWN1dGlvbiBkZW5pZWQuXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50b29sUGFydC5jYWxsUHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck9wdGlvbnM6IHRvb2xQYXJ0LmNhbGxQcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvdXRwdXQtZXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm91dHB1dC1hdmFpbGFibGVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xOYW1lID0gZ2V0VG9vbE5hbWUodG9vbFBhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQyLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbFBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiBhd2FpdCBjcmVhdGVUb29sTW9kZWxPdXRwdXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiB0b29sUGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogdG9vbFBhcnQuaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogdG9vbFBhcnQuc3RhdGUgPT09IFwib3V0cHV0LWVycm9yXCIgPyB0b29sUGFydC5lcnJvclRleHQgOiB0b29sUGFydC5vdXRwdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2w6IChfZiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudG9vbHMpID09IG51bGwgPyB2b2lkIDAgOiBfZlt0b29sTmFtZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTW9kZTogdG9vbFBhcnQuc3RhdGUgPT09IFwib3V0cHV0LWVycm9yXCIgPyBcInRleHRcIiA6IFwibm9uZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRvb2xQYXJ0LmNhbGxQcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyT3B0aW9uczogdG9vbFBhcnQuY2FsbFByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIG1vZGVsTWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHJvbGU6IFwidG9vbFwiLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBjb250ZW50MlxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9jayA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgbWVzc2FnZS5wYXJ0cykge1xuICAgICAgICAgICAgaWYgKGlzVGV4dFVJUGFydChwYXJ0KSB8fCBpc1JlYXNvbmluZ1VJUGFydChwYXJ0KSB8fCBpc0ZpbGVVSVBhcnQocGFydCkgfHwgaXNUb29sVUlQYXJ0KHBhcnQpIHx8IGlzRGF0YVVJUGFydChwYXJ0KSkge1xuICAgICAgICAgICAgICBibG9jay5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJ0LnR5cGUgPT09IFwic3RlcC1zdGFydFwiKSB7XG4gICAgICAgICAgICAgIGF3YWl0IHByb2Nlc3NCbG9jaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBwcm9jZXNzQmxvY2soKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IG1lc3NhZ2Uucm9sZTtcbiAgICAgICAgdGhyb3cgbmV3IE1lc3NhZ2VDb252ZXJzaW9uRXJyb3Ioe1xuICAgICAgICAgIG9yaWdpbmFsTWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICBtZXNzYWdlOiBgVW5zdXBwb3J0ZWQgcm9sZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtb2RlbE1lc3NhZ2VzO1xufVxuXG4vLyBzcmMvdWkvdmFsaWRhdGUtdWktbWVzc2FnZXMudHNcbmltcG9ydCB7IFR5cGVWYWxpZGF0aW9uRXJyb3IgYXMgVHlwZVZhbGlkYXRpb25FcnJvcjMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHtcbiAgbGF6eVNjaGVtYSBhcyBsYXp5U2NoZW1hMixcbiAgdmFsaWRhdGVUeXBlcyBhcyB2YWxpZGF0ZVR5cGVzMixcbiAgem9kU2NoZW1hIGFzIHpvZFNjaGVtYTJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IHogYXMgejggfSBmcm9tIFwiem9kL3Y0XCI7XG52YXIgdWlNZXNzYWdlc1NjaGVtYSA9IGxhenlTY2hlbWEyKFxuICAoKSA9PiB6b2RTY2hlbWEyKFxuICAgIHo4LmFycmF5KFxuICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgaWQ6IHo4LnN0cmluZygpLFxuICAgICAgICByb2xlOiB6OC5lbnVtKFtcInN5c3RlbVwiLCBcInVzZXJcIiwgXCJhc3Npc3RhbnRcIl0pLFxuICAgICAgICBtZXRhZGF0YTogejgudW5rbm93bigpLm9wdGlvbmFsKCksXG4gICAgICAgIHBhcnRzOiB6OC5hcnJheShcbiAgICAgICAgICB6OC51bmlvbihbXG4gICAgICAgICAgICB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICB0eXBlOiB6OC5saXRlcmFsKFwidGV4dFwiKSxcbiAgICAgICAgICAgICAgdGV4dDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHN0YXRlOiB6OC5lbnVtKFtcInN0cmVhbWluZ1wiLCBcImRvbmVcIl0pLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICB0eXBlOiB6OC5saXRlcmFsKFwicmVhc29uaW5nXCIpLFxuICAgICAgICAgICAgICB0ZXh0OiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgc3RhdGU6IHo4LmVudW0oW1wic3RyZWFtaW5nXCIsIFwiZG9uZVwiXSkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgIHR5cGU6IHo4LmxpdGVyYWwoXCJzb3VyY2UtdXJsXCIpLFxuICAgICAgICAgICAgICBzb3VyY2VJZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHVybDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHRpdGxlOiB6OC5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejgubGl0ZXJhbChcInNvdXJjZS1kb2N1bWVudFwiKSxcbiAgICAgICAgICAgICAgc291cmNlSWQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICBtZWRpYVR5cGU6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICB0aXRsZTogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIGZpbGVuYW1lOiB6OC5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejgubGl0ZXJhbChcImZpbGVcIiksXG4gICAgICAgICAgICAgIG1lZGlhVHlwZTogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIGZpbGVuYW1lOiB6OC5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICB1cmw6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejgubGl0ZXJhbChcInN0ZXAtc3RhcnRcIilcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejguc3RyaW5nKCkuc3RhcnRzV2l0aChcImRhdGEtXCIpLFxuICAgICAgICAgICAgICBpZDogejguc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgZGF0YTogejgudW5rbm93bigpXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgIHR5cGU6IHo4LmxpdGVyYWwoXCJkeW5hbWljLXRvb2xcIiksXG4gICAgICAgICAgICAgIHRvb2xOYW1lOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHN0YXRlOiB6OC5saXRlcmFsKFwiaW5wdXQtc3RyZWFtaW5nXCIpLFxuICAgICAgICAgICAgICBpbnB1dDogejgudW5rbm93bigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHo4LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBjYWxsUHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBvdXRwdXQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgZXJyb3JUZXh0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGFwcHJvdmFsOiB6OC5uZXZlcigpLm9wdGlvbmFsKClcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejgubGl0ZXJhbChcImR5bmFtaWMtdG9vbFwiKSxcbiAgICAgICAgICAgICAgdG9vbE5hbWU6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgc3RhdGU6IHo4LmxpdGVyYWwoXCJpbnB1dC1hdmFpbGFibGVcIiksXG4gICAgICAgICAgICAgIGlucHV0OiB6OC51bmtub3duKCksXG4gICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHo4LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBvdXRwdXQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgZXJyb3JUZXh0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGNhbGxQcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGFwcHJvdmFsOiB6OC5uZXZlcigpLm9wdGlvbmFsKClcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejgubGl0ZXJhbChcImR5bmFtaWMtdG9vbFwiKSxcbiAgICAgICAgICAgICAgdG9vbE5hbWU6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgc3RhdGU6IHo4LmxpdGVyYWwoXCJhcHByb3ZhbC1yZXF1ZXN0ZWRcIiksXG4gICAgICAgICAgICAgIGlucHV0OiB6OC51bmtub3duKCksXG4gICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHo4LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBvdXRwdXQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgZXJyb3JUZXh0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGNhbGxQcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGFwcHJvdmFsOiB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIGlkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBhcHByb3ZlZDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogejgubmV2ZXIoKS5vcHRpb25hbCgpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgIHR5cGU6IHo4LmxpdGVyYWwoXCJkeW5hbWljLXRvb2xcIiksXG4gICAgICAgICAgICAgIHRvb2xOYW1lOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHN0YXRlOiB6OC5saXRlcmFsKFwiYXBwcm92YWwtcmVzcG9uZGVkXCIpLFxuICAgICAgICAgICAgICBpbnB1dDogejgudW5rbm93bigpLFxuICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB6OC5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgb3V0cHV0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGVycm9yVGV4dDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBjYWxsUHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBhcHByb3ZhbDogejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgICBpZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgYXBwcm92ZWQ6IHo4LmJvb2xlYW4oKSxcbiAgICAgICAgICAgICAgICByZWFzb246IHo4LnN0cmluZygpLm9wdGlvbmFsKClcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejgubGl0ZXJhbChcImR5bmFtaWMtdG9vbFwiKSxcbiAgICAgICAgICAgICAgdG9vbE5hbWU6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgc3RhdGU6IHo4LmxpdGVyYWwoXCJvdXRwdXQtYXZhaWxhYmxlXCIpLFxuICAgICAgICAgICAgICBpbnB1dDogejgudW5rbm93bigpLFxuICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB6OC5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgb3V0cHV0OiB6OC51bmtub3duKCksXG4gICAgICAgICAgICAgIGVycm9yVGV4dDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBjYWxsUHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBwcmVsaW1pbmFyeTogejguYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGFwcHJvdmFsOiB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIGlkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBhcHByb3ZlZDogejgubGl0ZXJhbCh0cnVlKSxcbiAgICAgICAgICAgICAgICByZWFzb246IHo4LnN0cmluZygpLm9wdGlvbmFsKClcbiAgICAgICAgICAgICAgfSkub3B0aW9uYWwoKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICB0eXBlOiB6OC5saXRlcmFsKFwiZHluYW1pYy10b29sXCIpLFxuICAgICAgICAgICAgICB0b29sTmFtZTogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICBzdGF0ZTogejgubGl0ZXJhbChcIm91dHB1dC1lcnJvclwiKSxcbiAgICAgICAgICAgICAgaW5wdXQ6IHo4LnVua25vd24oKSxcbiAgICAgICAgICAgICAgcmF3SW5wdXQ6IHo4LnVua25vd24oKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB6OC5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgb3V0cHV0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGVycm9yVGV4dDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIGNhbGxQcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGFwcHJvdmFsOiB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIGlkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBhcHByb3ZlZDogejgubGl0ZXJhbCh0cnVlKSxcbiAgICAgICAgICAgICAgICByZWFzb246IHo4LnN0cmluZygpLm9wdGlvbmFsKClcbiAgICAgICAgICAgICAgfSkub3B0aW9uYWwoKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICB0eXBlOiB6OC5saXRlcmFsKFwiZHluYW1pYy10b29sXCIpLFxuICAgICAgICAgICAgICB0b29sTmFtZTogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICBzdGF0ZTogejgubGl0ZXJhbChcIm91dHB1dC1kZW5pZWRcIiksXG4gICAgICAgICAgICAgIGlucHV0OiB6OC51bmtub3duKCksXG4gICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHo4LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBvdXRwdXQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgZXJyb3JUZXh0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGNhbGxQcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGFwcHJvdmFsOiB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIGlkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBhcHByb3ZlZDogejgubGl0ZXJhbChmYWxzZSksXG4gICAgICAgICAgICAgICAgcmVhc29uOiB6OC5zdHJpbmcoKS5vcHRpb25hbCgpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgIHR5cGU6IHo4LnN0cmluZygpLnN0YXJ0c1dpdGgoXCJ0b29sLVwiKSxcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHN0YXRlOiB6OC5saXRlcmFsKFwiaW5wdXQtc3RyZWFtaW5nXCIpLFxuICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB6OC5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgY2FsbFByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgaW5wdXQ6IHo4LnVua25vd24oKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBvdXRwdXQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgZXJyb3JUZXh0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGFwcHJvdmFsOiB6OC5uZXZlcigpLm9wdGlvbmFsKClcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejguc3RyaW5nKCkuc3RhcnRzV2l0aChcInRvb2wtXCIpLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgc3RhdGU6IHo4LmxpdGVyYWwoXCJpbnB1dC1hdmFpbGFibGVcIiksXG4gICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHo4LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBpbnB1dDogejgudW5rbm93bigpLFxuICAgICAgICAgICAgICBvdXRwdXQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgZXJyb3JUZXh0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGNhbGxQcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGFwcHJvdmFsOiB6OC5uZXZlcigpLm9wdGlvbmFsKClcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejguc3RyaW5nKCkuc3RhcnRzV2l0aChcInRvb2wtXCIpLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgc3RhdGU6IHo4LmxpdGVyYWwoXCJhcHByb3ZhbC1yZXF1ZXN0ZWRcIiksXG4gICAgICAgICAgICAgIGlucHV0OiB6OC51bmtub3duKCksXG4gICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHo4LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBvdXRwdXQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgZXJyb3JUZXh0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGNhbGxQcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGFwcHJvdmFsOiB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIGlkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBhcHByb3ZlZDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogejgubmV2ZXIoKS5vcHRpb25hbCgpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgIHR5cGU6IHo4LnN0cmluZygpLnN0YXJ0c1dpdGgoXCJ0b29sLVwiKSxcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHN0YXRlOiB6OC5saXRlcmFsKFwiYXBwcm92YWwtcmVzcG9uZGVkXCIpLFxuICAgICAgICAgICAgICBpbnB1dDogejgudW5rbm93bigpLFxuICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB6OC5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgb3V0cHV0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGVycm9yVGV4dDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBjYWxsUHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBhcHByb3ZhbDogejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgICBpZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgYXBwcm92ZWQ6IHo4LmJvb2xlYW4oKSxcbiAgICAgICAgICAgICAgICByZWFzb246IHo4LnN0cmluZygpLm9wdGlvbmFsKClcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejguc3RyaW5nKCkuc3RhcnRzV2l0aChcInRvb2wtXCIpLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgc3RhdGU6IHo4LmxpdGVyYWwoXCJvdXRwdXQtYXZhaWxhYmxlXCIpLFxuICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB6OC5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgaW5wdXQ6IHo4LnVua25vd24oKSxcbiAgICAgICAgICAgICAgb3V0cHV0OiB6OC51bmtub3duKCksXG4gICAgICAgICAgICAgIGVycm9yVGV4dDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBjYWxsUHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBwcmVsaW1pbmFyeTogejguYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGFwcHJvdmFsOiB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIGlkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBhcHByb3ZlZDogejgubGl0ZXJhbCh0cnVlKSxcbiAgICAgICAgICAgICAgICByZWFzb246IHo4LnN0cmluZygpLm9wdGlvbmFsKClcbiAgICAgICAgICAgICAgfSkub3B0aW9uYWwoKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICB0eXBlOiB6OC5zdHJpbmcoKS5zdGFydHNXaXRoKFwidG9vbC1cIiksXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICBzdGF0ZTogejgubGl0ZXJhbChcIm91dHB1dC1lcnJvclwiKSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogejguYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGlucHV0OiB6OC51bmtub3duKCksXG4gICAgICAgICAgICAgIHJhd0lucHV0OiB6OC51bmtub3duKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgb3V0cHV0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGVycm9yVGV4dDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIGNhbGxQcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGFwcHJvdmFsOiB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIGlkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBhcHByb3ZlZDogejgubGl0ZXJhbCh0cnVlKSxcbiAgICAgICAgICAgICAgICByZWFzb246IHo4LnN0cmluZygpLm9wdGlvbmFsKClcbiAgICAgICAgICAgICAgfSkub3B0aW9uYWwoKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICB0eXBlOiB6OC5zdHJpbmcoKS5zdGFydHNXaXRoKFwidG9vbC1cIiksXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICBzdGF0ZTogejgubGl0ZXJhbChcIm91dHB1dC1kZW5pZWRcIiksXG4gICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHo4LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBpbnB1dDogejgudW5rbm93bigpLFxuICAgICAgICAgICAgICBvdXRwdXQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgZXJyb3JUZXh0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGNhbGxQcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGFwcHJvdmFsOiB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIGlkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBhcHByb3ZlZDogejgubGl0ZXJhbChmYWxzZSksXG4gICAgICAgICAgICAgICAgcmVhc29uOiB6OC5zdHJpbmcoKS5vcHRpb25hbCgpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIF0pXG4gICAgICAgICkubm9uZW1wdHkoXCJNZXNzYWdlIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgcGFydFwiKVxuICAgICAgfSlcbiAgICApLm5vbmVtcHR5KFwiTWVzc2FnZXMgYXJyYXkgbXVzdCBub3QgYmUgZW1wdHlcIilcbiAgKVxuKTtcbmFzeW5jIGZ1bmN0aW9uIHNhZmVWYWxpZGF0ZVVJTWVzc2FnZXMoe1xuICBtZXNzYWdlcyxcbiAgbWV0YWRhdGFTY2hlbWEsXG4gIGRhdGFTY2hlbWFzLFxuICB0b29sc1xufSkge1xuICB0cnkge1xuICAgIGlmIChtZXNzYWdlcyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgICAgcGFyYW1ldGVyOiBcIm1lc3NhZ2VzXCIsXG4gICAgICAgICAgdmFsdWU6IG1lc3NhZ2VzLFxuICAgICAgICAgIG1lc3NhZ2U6IFwibWVzc2FnZXMgcGFyYW1ldGVyIG11c3QgYmUgcHJvdmlkZWRcIlxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRhdGVkTWVzc2FnZXMgPSBhd2FpdCB2YWxpZGF0ZVR5cGVzMih7XG4gICAgICB2YWx1ZTogbWVzc2FnZXMsXG4gICAgICBzY2hlbWE6IHVpTWVzc2FnZXNTY2hlbWFcbiAgICB9KTtcbiAgICBpZiAobWV0YWRhdGFTY2hlbWEpIHtcbiAgICAgIGZvciAoY29uc3QgW21zZ0lkeCwgbWVzc2FnZV0gb2YgdmFsaWRhdGVkTWVzc2FnZXMuZW50cmllcygpKSB7XG4gICAgICAgIGF3YWl0IHZhbGlkYXRlVHlwZXMyKHtcbiAgICAgICAgICB2YWx1ZTogbWVzc2FnZS5tZXRhZGF0YSxcbiAgICAgICAgICBzY2hlbWE6IG1ldGFkYXRhU2NoZW1hLFxuICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgIGZpZWxkOiBgbWVzc2FnZXNbJHttc2dJZHh9XS5tZXRhZGF0YWAsXG4gICAgICAgICAgICBlbnRpdHlJZDogbWVzc2FnZS5pZFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRhU2NoZW1hcyB8fCB0b29scykge1xuICAgICAgZm9yIChjb25zdCBbbXNnSWR4LCBtZXNzYWdlXSBvZiB2YWxpZGF0ZWRNZXNzYWdlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCBbcGFydElkeCwgcGFydF0gb2YgbWVzc2FnZS5wYXJ0cy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICBpZiAoZGF0YVNjaGVtYXMgJiYgcGFydC50eXBlLnN0YXJ0c1dpdGgoXCJkYXRhLVwiKSkge1xuICAgICAgICAgICAgY29uc3QgZGF0YVBhcnQgPSBwYXJ0O1xuICAgICAgICAgICAgY29uc3QgZGF0YU5hbWUgPSBkYXRhUGFydC50eXBlLnNsaWNlKDUpO1xuICAgICAgICAgICAgY29uc3QgZGF0YVNjaGVtYSA9IGRhdGFTY2hlbWFzW2RhdGFOYW1lXTtcbiAgICAgICAgICAgIGlmICghZGF0YVNjaGVtYSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcjMoe1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IGRhdGFQYXJ0LmRhdGEsXG4gICAgICAgICAgICAgICAgICBjYXVzZTogYE5vIGRhdGEgc2NoZW1hIGZvdW5kIGZvciBkYXRhIHBhcnQgJHtkYXRhTmFtZX1gLFxuICAgICAgICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZDogYG1lc3NhZ2VzWyR7bXNnSWR4fV0ucGFydHNbJHtwYXJ0SWR4fV0uZGF0YWAsXG4gICAgICAgICAgICAgICAgICAgIGVudGl0eU5hbWU6IGRhdGFOYW1lLFxuICAgICAgICAgICAgICAgICAgICBlbnRpdHlJZDogZGF0YVBhcnQuaWRcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdmFsaWRhdGVUeXBlczIoe1xuICAgICAgICAgICAgICB2YWx1ZTogZGF0YVBhcnQuZGF0YSxcbiAgICAgICAgICAgICAgc2NoZW1hOiBkYXRhU2NoZW1hLFxuICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgZmllbGQ6IGBtZXNzYWdlc1ske21zZ0lkeH1dLnBhcnRzWyR7cGFydElkeH1dLmRhdGFgLFxuICAgICAgICAgICAgICAgIGVudGl0eU5hbWU6IGRhdGFOYW1lLFxuICAgICAgICAgICAgICAgIGVudGl0eUlkOiBkYXRhUGFydC5pZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRvb2xzICYmIHBhcnQudHlwZS5zdGFydHNXaXRoKFwidG9vbC1cIikpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xQYXJ0ID0gcGFydDtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xOYW1lID0gdG9vbFBhcnQudHlwZS5zbGljZSg1KTtcbiAgICAgICAgICAgIGNvbnN0IHRvb2wyID0gdG9vbHNbdG9vbE5hbWVdO1xuICAgICAgICAgICAgaWYgKCF0b29sMikge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcjMoe1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IHRvb2xQYXJ0LmlucHV0LFxuICAgICAgICAgICAgICAgICAgY2F1c2U6IGBObyB0b29sIHNjaGVtYSBmb3VuZCBmb3IgdG9vbCBwYXJ0ICR7dG9vbE5hbWV9YCxcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGBtZXNzYWdlc1ske21zZ0lkeH1dLnBhcnRzWyR7cGFydElkeH1dLmlucHV0YCxcbiAgICAgICAgICAgICAgICAgICAgZW50aXR5TmFtZTogdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGVudGl0eUlkOiB0b29sUGFydC50b29sQ2FsbElkXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b29sUGFydC5zdGF0ZSA9PT0gXCJpbnB1dC1hdmFpbGFibGVcIiB8fCB0b29sUGFydC5zdGF0ZSA9PT0gXCJvdXRwdXQtYXZhaWxhYmxlXCIgfHwgdG9vbFBhcnQuc3RhdGUgPT09IFwib3V0cHV0LWVycm9yXCIgJiYgdG9vbFBhcnQuaW5wdXQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBhd2FpdCB2YWxpZGF0ZVR5cGVzMih7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHRvb2xQYXJ0LmlucHV0LFxuICAgICAgICAgICAgICAgIHNjaGVtYTogdG9vbDIuaW5wdXRTY2hlbWEsXG4gICAgICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAgICAgZmllbGQ6IGBtZXNzYWdlc1ske21zZ0lkeH1dLnBhcnRzWyR7cGFydElkeH1dLmlucHV0YCxcbiAgICAgICAgICAgICAgICAgIGVudGl0eU5hbWU6IHRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgZW50aXR5SWQ6IHRvb2xQYXJ0LnRvb2xDYWxsSWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvb2xQYXJ0LnN0YXRlID09PSBcIm91dHB1dC1hdmFpbGFibGVcIiAmJiB0b29sMi5vdXRwdXRTY2hlbWEpIHtcbiAgICAgICAgICAgICAgYXdhaXQgdmFsaWRhdGVUeXBlczIoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0b29sUGFydC5vdXRwdXQsXG4gICAgICAgICAgICAgICAgc2NoZW1hOiB0b29sMi5vdXRwdXRTY2hlbWEsXG4gICAgICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAgICAgZmllbGQ6IGBtZXNzYWdlc1ske21zZ0lkeH1dLnBhcnRzWyR7cGFydElkeH1dLm91dHB1dGAsXG4gICAgICAgICAgICAgICAgICBlbnRpdHlOYW1lOiB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIGVudGl0eUlkOiB0b29sUGFydC50b29sQ2FsbElkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBkYXRhOiB2YWxpZGF0ZWRNZXNzYWdlc1xuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgZXJyID0gZXJyb3I7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IGVyclxuICAgIH07XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlVUlNZXNzYWdlcyh7XG4gIG1lc3NhZ2VzLFxuICBtZXRhZGF0YVNjaGVtYSxcbiAgZGF0YVNjaGVtYXMsXG4gIHRvb2xzXG59KSB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2FmZVZhbGlkYXRlVUlNZXNzYWdlcyh7XG4gICAgbWVzc2FnZXMsXG4gICAgbWV0YWRhdGFTY2hlbWEsXG4gICAgZGF0YVNjaGVtYXMsXG4gICAgdG9vbHNcbiAgfSk7XG4gIGlmICghcmVzcG9uc2Uuc3VjY2VzcylcbiAgICB0aHJvdyByZXNwb25zZS5lcnJvcjtcbiAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG59XG5cbi8vIHNyYy9hZ2VudC9jcmVhdGUtYWdlbnQtdWktc3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVBZ2VudFVJU3RyZWFtKHtcbiAgYWdlbnQsXG4gIHVpTWVzc2FnZXMsXG4gIG9wdGlvbnMsXG4gIGFib3J0U2lnbmFsLFxuICB0aW1lb3V0LFxuICBleHBlcmltZW50YWxfdHJhbnNmb3JtLFxuICBvblN0ZXBGaW5pc2gsXG4gIC4uLnVpTWVzc2FnZVN0cmVhbU9wdGlvbnNcbn0pIHtcbiAgdmFyIF9hMjE7XG4gIGNvbnN0IHZhbGlkYXRlZE1lc3NhZ2VzID0gYXdhaXQgdmFsaWRhdGVVSU1lc3NhZ2VzKHtcbiAgICBtZXNzYWdlczogdWlNZXNzYWdlcyxcbiAgICB0b29sczogYWdlbnQudG9vbHNcbiAgfSk7XG4gIGNvbnN0IG1vZGVsTWVzc2FnZXMgPSBhd2FpdCBjb252ZXJ0VG9Nb2RlbE1lc3NhZ2VzKHZhbGlkYXRlZE1lc3NhZ2VzLCB7XG4gICAgdG9vbHM6IGFnZW50LnRvb2xzXG4gIH0pO1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCBhZ2VudC5zdHJlYW0oe1xuICAgIHByb21wdDogbW9kZWxNZXNzYWdlcyxcbiAgICBvcHRpb25zLFxuICAgIGFib3J0U2lnbmFsLFxuICAgIHRpbWVvdXQsXG4gICAgZXhwZXJpbWVudGFsX3RyYW5zZm9ybSxcbiAgICBvblN0ZXBGaW5pc2hcbiAgfSk7XG4gIHJldHVybiByZXN1bHQudG9VSU1lc3NhZ2VTdHJlYW0oe1xuICAgIC4uLnVpTWVzc2FnZVN0cmVhbU9wdGlvbnMsXG4gICAgLy8gVE9ETyByZWFkaW5nIGBvcmlnaW5hbE1lc3NhZ2VzYCBpcyBoZXJlIGZvciBiYywgYWx3YXlzIHVzZSBgdmFsaWRhdGVkTWVzc2FnZXNgIGluIHY3XG4gICAgb3JpZ2luYWxNZXNzYWdlczogKF9hMjEgPSB1aU1lc3NhZ2VTdHJlYW1PcHRpb25zLm9yaWdpbmFsTWVzc2FnZXMpICE9IG51bGwgPyBfYTIxIDogdmFsaWRhdGVkTWVzc2FnZXNcbiAgfSk7XG59XG5cbi8vIHNyYy9hZ2VudC9jcmVhdGUtYWdlbnQtdWktc3RyZWFtLXJlc3BvbnNlLnRzXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVBZ2VudFVJU3RyZWFtUmVzcG9uc2Uoe1xuICBoZWFkZXJzLFxuICBzdGF0dXMsXG4gIHN0YXR1c1RleHQsXG4gIGNvbnN1bWVTc2VTdHJlYW0sXG4gIC4uLm9wdGlvbnNcbn0pIHtcbiAgcmV0dXJuIGNyZWF0ZVVJTWVzc2FnZVN0cmVhbVJlc3BvbnNlKHtcbiAgICBoZWFkZXJzLFxuICAgIHN0YXR1cyxcbiAgICBzdGF0dXNUZXh0LFxuICAgIGNvbnN1bWVTc2VTdHJlYW0sXG4gICAgc3RyZWFtOiBhd2FpdCBjcmVhdGVBZ2VudFVJU3RyZWFtKG9wdGlvbnMpXG4gIH0pO1xufVxuXG4vLyBzcmMvYWdlbnQvcGlwZS1hZ2VudC11aS1zdHJlYW0tdG8tcmVzcG9uc2UudHNcbmFzeW5jIGZ1bmN0aW9uIHBpcGVBZ2VudFVJU3RyZWFtVG9SZXNwb25zZSh7XG4gIHJlc3BvbnNlLFxuICBoZWFkZXJzLFxuICBzdGF0dXMsXG4gIHN0YXR1c1RleHQsXG4gIGNvbnN1bWVTc2VTdHJlYW0sXG4gIC4uLm9wdGlvbnNcbn0pIHtcbiAgcGlwZVVJTWVzc2FnZVN0cmVhbVRvUmVzcG9uc2Uoe1xuICAgIHJlc3BvbnNlLFxuICAgIGhlYWRlcnMsXG4gICAgc3RhdHVzLFxuICAgIHN0YXR1c1RleHQsXG4gICAgY29uc3VtZVNzZVN0cmVhbSxcbiAgICBzdHJlYW06IGF3YWl0IGNyZWF0ZUFnZW50VUlTdHJlYW0ob3B0aW9ucylcbiAgfSk7XG59XG5cbi8vIHNyYy9lbWJlZC9lbWJlZC50c1xuaW1wb3J0IHsgd2l0aFVzZXJBZ2VudFN1ZmZpeCBhcyB3aXRoVXNlckFnZW50U3VmZml4MyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5hc3luYyBmdW5jdGlvbiBlbWJlZCh7XG4gIG1vZGVsOiBtb2RlbEFyZyxcbiAgdmFsdWUsXG4gIHByb3ZpZGVyT3B0aW9ucyxcbiAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeVxufSkge1xuICBjb25zdCBtb2RlbCA9IHJlc29sdmVFbWJlZGRpbmdNb2RlbChtb2RlbEFyZyk7XG4gIGNvbnN0IHsgbWF4UmV0cmllcywgcmV0cnkgfSA9IHByZXBhcmVSZXRyaWVzKHtcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICAgIGFib3J0U2lnbmFsXG4gIH0pO1xuICBjb25zdCBoZWFkZXJzV2l0aFVzZXJBZ2VudCA9IHdpdGhVc2VyQWdlbnRTdWZmaXgzKFxuICAgIGhlYWRlcnMgIT0gbnVsbCA/IGhlYWRlcnMgOiB7fSxcbiAgICBgYWkvJHtWRVJTSU9OfWBcbiAgKTtcbiAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnM6IGhlYWRlcnNXaXRoVXNlckFnZW50LFxuICAgIHNldHRpbmdzOiB7IG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICBuYW1lOiBcImFpLmVtYmVkXCIsXG4gICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7IG9wZXJhdGlvbklkOiBcImFpLmVtYmVkXCIsIHRlbGVtZXRyeSB9KSxcbiAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgIFwiYWkudmFsdWVcIjogeyBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkodmFsdWUpIH1cbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICBjb25zdCB7IGVtYmVkZGluZywgdXNhZ2UsIHdhcm5pbmdzLCByZXNwb25zZSwgcHJvdmlkZXJNZXRhZGF0YSB9ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICgpID0+IChcbiAgICAgICAgICAvLyBuZXN0ZWQgc3BhbnMgdG8gYWxpZ24gd2l0aCB0aGUgZW1iZWRNYW55IHRlbGVtZXRyeSBkYXRhOlxuICAgICAgICAgIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgbmFtZTogXCJhaS5lbWJlZC5kb0VtYmVkXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmVtYmVkLmRvRW1iZWRcIixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgICAgICAgICBcImFpLnZhbHVlc1wiOiB7IGlucHV0OiAoKSA9PiBbSlNPTi5zdHJpbmdpZnkodmFsdWUpXSB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgZm46IGFzeW5jIChkb0VtYmVkU3BhbikgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2EyMTtcbiAgICAgICAgICAgICAgY29uc3QgbW9kZWxSZXNwb25zZSA9IGF3YWl0IG1vZGVsLmRvRW1iZWQoe1xuICAgICAgICAgICAgICAgIHZhbHVlczogW3ZhbHVlXSxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzV2l0aFVzZXJBZ2VudCxcbiAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IGVtYmVkZGluZzIgPSBtb2RlbFJlc3BvbnNlLmVtYmVkZGluZ3NbMF07XG4gICAgICAgICAgICAgIGNvbnN0IHVzYWdlMiA9IChfYTIxID0gbW9kZWxSZXNwb25zZS51c2FnZSkgIT0gbnVsbCA/IF9hMjEgOiB7IHRva2VuczogTmFOIH07XG4gICAgICAgICAgICAgIGRvRW1iZWRTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgYXdhaXQgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBtb2RlbFJlc3BvbnNlLmVtYmVkZGluZ3MubWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgKGVtYmVkZGluZzMpID0+IEpTT04uc3RyaW5naWZ5KGVtYmVkZGluZzMpXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB1c2FnZTIudG9rZW5zXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBlbWJlZGRpbmc6IGVtYmVkZGluZzIsXG4gICAgICAgICAgICAgICAgdXNhZ2U6IHVzYWdlMixcbiAgICAgICAgICAgICAgICB3YXJuaW5nczogbW9kZWxSZXNwb25zZS53YXJuaW5ncyxcbiAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBtb2RlbFJlc3BvbnNlLnByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IG1vZGVsUmVzcG9uc2UucmVzcG9uc2VcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICBhd2FpdCBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdcIjogeyBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KGVtYmVkZGluZykgfSxcbiAgICAgICAgICAgIFwiYWkudXNhZ2UudG9rZW5zXCI6IHVzYWdlLnRva2Vuc1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBsb2dXYXJuaW5ncyh7IHdhcm5pbmdzLCBwcm92aWRlcjogbW9kZWwucHJvdmlkZXIsIG1vZGVsOiBtb2RlbC5tb2RlbElkIH0pO1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0RW1iZWRSZXN1bHQoe1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZW1iZWRkaW5nLFxuICAgICAgICB1c2FnZSxcbiAgICAgICAgd2FybmluZ3MsXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgIHJlc3BvbnNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxudmFyIERlZmF1bHRFbWJlZFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMudmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHRoaXMuZW1iZWRkaW5nID0gb3B0aW9ucy5lbWJlZGRpbmc7XG4gICAgdGhpcy51c2FnZSA9IG9wdGlvbnMudXNhZ2U7XG4gICAgdGhpcy53YXJuaW5ncyA9IG9wdGlvbnMud2FybmluZ3M7XG4gICAgdGhpcy5wcm92aWRlck1ldGFkYXRhID0gb3B0aW9ucy5wcm92aWRlck1ldGFkYXRhO1xuICAgIHRoaXMucmVzcG9uc2UgPSBvcHRpb25zLnJlc3BvbnNlO1xuICB9XG59O1xuXG4vLyBzcmMvZW1iZWQvZW1iZWQtbWFueS50c1xuaW1wb3J0IHsgd2l0aFVzZXJBZ2VudFN1ZmZpeCBhcyB3aXRoVXNlckFnZW50U3VmZml4NCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy91dGlsL3NwbGl0LWFycmF5LnRzXG5mdW5jdGlvbiBzcGxpdEFycmF5KGFycmF5MiwgY2h1bmtTaXplKSB7XG4gIGlmIChjaHVua1NpemUgPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNodW5rU2l6ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCIpO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Mi5sZW5ndGg7IGkgKz0gY2h1bmtTaXplKSB7XG4gICAgcmVzdWx0LnB1c2goYXJyYXkyLnNsaWNlKGksIGkgKyBjaHVua1NpemUpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBzcmMvZW1iZWQvZW1iZWQtbWFueS50c1xuYXN5bmMgZnVuY3Rpb24gZW1iZWRNYW55KHtcbiAgbW9kZWw6IG1vZGVsQXJnLFxuICB2YWx1ZXMsXG4gIG1heFBhcmFsbGVsQ2FsbHMgPSBJbmZpbml0eSxcbiAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIHByb3ZpZGVyT3B0aW9ucyxcbiAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5XG59KSB7XG4gIGNvbnN0IG1vZGVsID0gcmVzb2x2ZUVtYmVkZGluZ01vZGVsKG1vZGVsQXJnKTtcbiAgY29uc3QgeyBtYXhSZXRyaWVzLCByZXRyeSB9ID0gcHJlcGFyZVJldHJpZXMoe1xuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gICAgYWJvcnRTaWduYWxcbiAgfSk7XG4gIGNvbnN0IGhlYWRlcnNXaXRoVXNlckFnZW50ID0gd2l0aFVzZXJBZ2VudFN1ZmZpeDQoXG4gICAgaGVhZGVycyAhPSBudWxsID8gaGVhZGVycyA6IHt9LFxuICAgIGBhaS8ke1ZFUlNJT059YFxuICApO1xuICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVyczogaGVhZGVyc1dpdGhVc2VyQWdlbnQsXG4gICAgc2V0dGluZ3M6IHsgbWF4UmV0cmllcyB9XG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIodGVsZW1ldHJ5KTtcbiAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgIG5hbWU6IFwiYWkuZW1iZWRNYW55XCIsXG4gICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7IG9wZXJhdGlvbklkOiBcImFpLmVtYmVkTWFueVwiLCB0ZWxlbWV0cnkgfSksXG4gICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgIFwiYWkudmFsdWVzXCI6IHtcbiAgICAgICAgICBpbnB1dDogKCkgPT4gdmFsdWVzLm1hcCgodmFsdWUpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLFxuICAgIHRyYWNlcixcbiAgICBmbjogYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgIHZhciBfYTIxO1xuICAgICAgY29uc3QgW21heEVtYmVkZGluZ3NQZXJDYWxsLCBzdXBwb3J0c1BhcmFsbGVsQ2FsbHNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBtb2RlbC5tYXhFbWJlZGRpbmdzUGVyQ2FsbCxcbiAgICAgICAgbW9kZWwuc3VwcG9ydHNQYXJhbGxlbENhbGxzXG4gICAgICBdKTtcbiAgICAgIGlmIChtYXhFbWJlZGRpbmdzUGVyQ2FsbCA9PSBudWxsIHx8IG1heEVtYmVkZGluZ3NQZXJDYWxsID09PSBJbmZpbml0eSkge1xuICAgICAgICBjb25zdCB7IGVtYmVkZGluZ3M6IGVtYmVkZGluZ3MyLCB1c2FnZSwgd2FybmluZ3M6IHdhcm5pbmdzMiwgcmVzcG9uc2UsIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGEyIH0gPSBhd2FpdCByZXRyeSgoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgbmFtZTogXCJhaS5lbWJlZE1hbnkuZG9FbWJlZFwiLFxuICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5lbWJlZE1hbnkuZG9FbWJlZFwiLFxuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICAgICAgICAgIFwiYWkudmFsdWVzXCI6IHtcbiAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiB2YWx1ZXMubWFwKCh2YWx1ZSkgPT4gSlNPTi5zdHJpbmdpZnkodmFsdWUpKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICBmbjogYXN5bmMgKGRvRW1iZWRTcGFuKSA9PiB7XG4gICAgICAgICAgICAgIHZhciBfYTIyO1xuICAgICAgICAgICAgICBjb25zdCBtb2RlbFJlc3BvbnNlID0gYXdhaXQgbW9kZWwuZG9FbWJlZCh7XG4gICAgICAgICAgICAgICAgdmFsdWVzLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnNXaXRoVXNlckFnZW50LFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3QgZW1iZWRkaW5nczMgPSBtb2RlbFJlc3BvbnNlLmVtYmVkZGluZ3M7XG4gICAgICAgICAgICAgIGNvbnN0IHVzYWdlMiA9IChfYTIyID0gbW9kZWxSZXNwb25zZS51c2FnZSkgIT0gbnVsbCA/IF9hMjIgOiB7IHRva2VuczogTmFOIH07XG4gICAgICAgICAgICAgIGRvRW1iZWRTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgYXdhaXQgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBlbWJlZGRpbmdzMy5tYXAoXG4gICAgICAgICAgICAgICAgICAgICAgICAoZW1iZWRkaW5nKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB1c2FnZTIudG9rZW5zXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBlbWJlZGRpbmdzOiBlbWJlZGRpbmdzMyxcbiAgICAgICAgICAgICAgICB1c2FnZTogdXNhZ2UyLFxuICAgICAgICAgICAgICAgIHdhcm5pbmdzOiBtb2RlbFJlc3BvbnNlLndhcm5pbmdzLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IG1vZGVsUmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICByZXNwb25zZTogbW9kZWxSZXNwb25zZS5yZXNwb25zZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgIGF3YWl0IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICBcImFpLmVtYmVkZGluZ3NcIjoge1xuICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gZW1iZWRkaW5nczIubWFwKChlbWJlZGRpbmcpID0+IEpTT04uc3RyaW5naWZ5KGVtYmVkZGluZykpXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiYWkudXNhZ2UudG9rZW5zXCI6IHVzYWdlLnRva2Vuc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGxvZ1dhcm5pbmdzKHtcbiAgICAgICAgICB3YXJuaW5nczogd2FybmluZ3MyLFxuICAgICAgICAgIHByb3ZpZGVyOiBtb2RlbC5wcm92aWRlcixcbiAgICAgICAgICBtb2RlbDogbW9kZWwubW9kZWxJZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0RW1iZWRNYW55UmVzdWx0KHtcbiAgICAgICAgICB2YWx1ZXMsXG4gICAgICAgICAgZW1iZWRkaW5nczogZW1iZWRkaW5nczIsXG4gICAgICAgICAgdXNhZ2UsXG4gICAgICAgICAgd2FybmluZ3M6IHdhcm5pbmdzMixcbiAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhMixcbiAgICAgICAgICByZXNwb25zZXM6IFtyZXNwb25zZV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZUNodW5rcyA9IHNwbGl0QXJyYXkodmFsdWVzLCBtYXhFbWJlZGRpbmdzUGVyQ2FsbCk7XG4gICAgICBjb25zdCBlbWJlZGRpbmdzID0gW107XG4gICAgICBjb25zdCB3YXJuaW5ncyA9IFtdO1xuICAgICAgY29uc3QgcmVzcG9uc2VzID0gW107XG4gICAgICBsZXQgdG9rZW5zID0gMDtcbiAgICAgIGxldCBwcm92aWRlck1ldGFkYXRhO1xuICAgICAgY29uc3QgcGFyYWxsZWxDaHVua3MgPSBzcGxpdEFycmF5KFxuICAgICAgICB2YWx1ZUNodW5rcyxcbiAgICAgICAgc3VwcG9ydHNQYXJhbGxlbENhbGxzID8gbWF4UGFyYWxsZWxDYWxscyA6IDFcbiAgICAgICk7XG4gICAgICBmb3IgKGNvbnN0IHBhcmFsbGVsQ2h1bmsgb2YgcGFyYWxsZWxDaHVua3MpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIHBhcmFsbGVsQ2h1bmsubWFwKChjaHVuaykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJldHJ5KCgpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiYWkuZW1iZWRNYW55LmRvRW1iZWRcIixcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5lbWJlZE1hbnkuZG9FbWJlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgICAgICAgICAgICAgXCJhaS52YWx1ZXNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBjaHVuay5tYXAoKHZhbHVlKSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICAgICAgZm46IGFzeW5jIChkb0VtYmVkU3BhbikgPT4ge1xuICAgICAgICAgICAgICAgICAgdmFyIF9hMjI7XG4gICAgICAgICAgICAgICAgICBjb25zdCBtb2RlbFJlc3BvbnNlID0gYXdhaXQgbW9kZWwuZG9FbWJlZCh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlczogY2h1bmssXG4gICAgICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzV2l0aFVzZXJBZ2VudCxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGVtYmVkZGluZ3MyID0gbW9kZWxSZXNwb25zZS5lbWJlZGRpbmdzO1xuICAgICAgICAgICAgICAgICAgY29uc3QgdXNhZ2UgPSAoX2EyMiA9IG1vZGVsUmVzcG9uc2UudXNhZ2UpICE9IG51bGwgPyBfYTIyIDogeyB0b2tlbnM6IE5hTiB9O1xuICAgICAgICAgICAgICAgICAgZG9FbWJlZFNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gZW1iZWRkaW5nczIubWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlbWJlZGRpbmcpID0+IEpTT04uc3RyaW5naWZ5KGVtYmVkZGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UudG9rZW5zXCI6IHVzYWdlLnRva2Vuc1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBlbWJlZGRpbmdzOiBlbWJlZGRpbmdzMixcbiAgICAgICAgICAgICAgICAgICAgdXNhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzOiBtb2RlbFJlc3BvbnNlLndhcm5pbmdzLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBtb2RlbFJlc3BvbnNlLnByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBtb2RlbFJlc3BvbnNlLnJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgZW1iZWRkaW5ncy5wdXNoKC4uLnJlc3VsdC5lbWJlZGRpbmdzKTtcbiAgICAgICAgICB3YXJuaW5ncy5wdXNoKC4uLnJlc3VsdC53YXJuaW5ncyk7XG4gICAgICAgICAgcmVzcG9uc2VzLnB1c2gocmVzdWx0LnJlc3BvbnNlKTtcbiAgICAgICAgICB0b2tlbnMgKz0gcmVzdWx0LnVzYWdlLnRva2VucztcbiAgICAgICAgICBpZiAocmVzdWx0LnByb3ZpZGVyTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGlmICghcHJvdmlkZXJNZXRhZGF0YSkge1xuICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhID0geyAuLi5yZXN1bHQucHJvdmlkZXJNZXRhZGF0YSB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBbcHJvdmlkZXJOYW1lLCBtZXRhZGF0YV0gb2YgT2JqZWN0LmVudHJpZXMoXG4gICAgICAgICAgICAgICAgcmVzdWx0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGFbcHJvdmlkZXJOYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgIC4uLihfYTIxID0gcHJvdmlkZXJNZXRhZGF0YVtwcm92aWRlck5hbWVdKSAhPSBudWxsID8gX2EyMSA6IHt9LFxuICAgICAgICAgICAgICAgICAgLi4ubWV0YWRhdGFcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgIGF3YWl0IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICBcImFpLmVtYmVkZGluZ3NcIjoge1xuICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGVtYmVkZGluZ3MubWFwKChlbWJlZGRpbmcpID0+IEpTT04uc3RyaW5naWZ5KGVtYmVkZGluZykpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdG9rZW5zXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIGxvZ1dhcm5pbmdzKHtcbiAgICAgICAgd2FybmluZ3MsXG4gICAgICAgIHByb3ZpZGVyOiBtb2RlbC5wcm92aWRlcixcbiAgICAgICAgbW9kZWw6IG1vZGVsLm1vZGVsSWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0RW1iZWRNYW55UmVzdWx0KHtcbiAgICAgICAgdmFsdWVzLFxuICAgICAgICBlbWJlZGRpbmdzLFxuICAgICAgICB1c2FnZTogeyB0b2tlbnMgfSxcbiAgICAgICAgd2FybmluZ3MsXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgIHJlc3BvbnNlc1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbnZhciBEZWZhdWx0RW1iZWRNYW55UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy52YWx1ZXMgPSBvcHRpb25zLnZhbHVlcztcbiAgICB0aGlzLmVtYmVkZGluZ3MgPSBvcHRpb25zLmVtYmVkZGluZ3M7XG4gICAgdGhpcy51c2FnZSA9IG9wdGlvbnMudXNhZ2U7XG4gICAgdGhpcy53YXJuaW5ncyA9IG9wdGlvbnMud2FybmluZ3M7XG4gICAgdGhpcy5wcm92aWRlck1ldGFkYXRhID0gb3B0aW9ucy5wcm92aWRlck1ldGFkYXRhO1xuICAgIHRoaXMucmVzcG9uc2VzID0gb3B0aW9ucy5yZXNwb25zZXM7XG4gIH1cbn07XG5cbi8vIHNyYy9nZW5lcmF0ZS1pbWFnZS9nZW5lcmF0ZS1pbWFnZS50c1xuaW1wb3J0IHtcbiAgY29udmVydEJhc2U2NFRvVWludDhBcnJheSBhcyBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5NCxcbiAgd2l0aFVzZXJBZ2VudFN1ZmZpeCBhcyB3aXRoVXNlckFnZW50U3VmZml4NVxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVJbWFnZSh7XG4gIG1vZGVsOiBtb2RlbEFyZyxcbiAgcHJvbXB0OiBwcm9tcHRBcmcsXG4gIG4gPSAxLFxuICBtYXhJbWFnZXNQZXJDYWxsLFxuICBzaXplLFxuICBhc3BlY3RSYXRpbyxcbiAgc2VlZCxcbiAgcHJvdmlkZXJPcHRpb25zLFxuICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVyc1xufSkge1xuICB2YXIgX2EyMSwgX2I7XG4gIGNvbnN0IG1vZGVsID0gcmVzb2x2ZUltYWdlTW9kZWwobW9kZWxBcmcpO1xuICBjb25zdCBoZWFkZXJzV2l0aFVzZXJBZ2VudCA9IHdpdGhVc2VyQWdlbnRTdWZmaXg1KFxuICAgIGhlYWRlcnMgIT0gbnVsbCA/IGhlYWRlcnMgOiB7fSxcbiAgICBgYWkvJHtWRVJTSU9OfWBcbiAgKTtcbiAgY29uc3QgeyByZXRyeSB9ID0gcHJlcGFyZVJldHJpZXMoe1xuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gICAgYWJvcnRTaWduYWxcbiAgfSk7XG4gIGNvbnN0IG1heEltYWdlc1BlckNhbGxXaXRoRGVmYXVsdCA9IChfYTIxID0gbWF4SW1hZ2VzUGVyQ2FsbCAhPSBudWxsID8gbWF4SW1hZ2VzUGVyQ2FsbCA6IGF3YWl0IGludm9rZU1vZGVsTWF4SW1hZ2VzUGVyQ2FsbChtb2RlbCkpICE9IG51bGwgPyBfYTIxIDogMTtcbiAgY29uc3QgY2FsbENvdW50ID0gTWF0aC5jZWlsKG4gLyBtYXhJbWFnZXNQZXJDYWxsV2l0aERlZmF1bHQpO1xuICBjb25zdCBjYWxsSW1hZ2VDb3VudHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBjYWxsQ291bnQgfSwgKF8sIGkpID0+IHtcbiAgICBpZiAoaSA8IGNhbGxDb3VudCAtIDEpIHtcbiAgICAgIHJldHVybiBtYXhJbWFnZXNQZXJDYWxsV2l0aERlZmF1bHQ7XG4gICAgfVxuICAgIGNvbnN0IHJlbWFpbmRlciA9IG4gJSBtYXhJbWFnZXNQZXJDYWxsV2l0aERlZmF1bHQ7XG4gICAgcmV0dXJuIHJlbWFpbmRlciA9PT0gMCA/IG1heEltYWdlc1BlckNhbGxXaXRoRGVmYXVsdCA6IHJlbWFpbmRlcjtcbiAgfSk7XG4gIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICBjYWxsSW1hZ2VDb3VudHMubWFwKFxuICAgICAgYXN5bmMgKGNhbGxJbWFnZUNvdW50KSA9PiByZXRyeSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcHJvbXB0LCBmaWxlcywgbWFzayB9ID0gbm9ybWFsaXplUHJvbXB0KHByb21wdEFyZyk7XG4gICAgICAgIHJldHVybiBtb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgICAgICBwcm9tcHQsXG4gICAgICAgICAgZmlsZXMsXG4gICAgICAgICAgbWFzayxcbiAgICAgICAgICBuOiBjYWxsSW1hZ2VDb3VudCxcbiAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzV2l0aFVzZXJBZ2VudCxcbiAgICAgICAgICBzaXplLFxuICAgICAgICAgIGFzcGVjdFJhdGlvLFxuICAgICAgICAgIHNlZWQsXG4gICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck9wdGlvbnMgIT0gbnVsbCA/IHByb3ZpZGVyT3B0aW9ucyA6IHt9XG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICApXG4gICk7XG4gIGNvbnN0IGltYWdlcyA9IFtdO1xuICBjb25zdCB3YXJuaW5ncyA9IFtdO1xuICBjb25zdCByZXNwb25zZXMgPSBbXTtcbiAgY29uc3QgcHJvdmlkZXJNZXRhZGF0YSA9IHt9O1xuICBsZXQgdG90YWxVc2FnZSA9IHtcbiAgICBpbnB1dFRva2Vuczogdm9pZCAwLFxuICAgIG91dHB1dFRva2Vuczogdm9pZCAwLFxuICAgIHRvdGFsVG9rZW5zOiB2b2lkIDBcbiAgfTtcbiAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgIGltYWdlcy5wdXNoKFxuICAgICAgLi4ucmVzdWx0LmltYWdlcy5tYXAoXG4gICAgICAgIChpbWFnZSkgPT4ge1xuICAgICAgICAgIHZhciBfYTIyO1xuICAgICAgICAgIHJldHVybiBuZXcgRGVmYXVsdEdlbmVyYXRlZEZpbGUoe1xuICAgICAgICAgICAgZGF0YTogaW1hZ2UsXG4gICAgICAgICAgICBtZWRpYVR5cGU6IChfYTIyID0gZGV0ZWN0TWVkaWFUeXBlKHtcbiAgICAgICAgICAgICAgZGF0YTogaW1hZ2UsXG4gICAgICAgICAgICAgIHNpZ25hdHVyZXM6IGltYWdlTWVkaWFUeXBlU2lnbmF0dXJlc1xuICAgICAgICAgICAgfSkpICE9IG51bGwgPyBfYTIyIDogXCJpbWFnZS9wbmdcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcbiAgICB3YXJuaW5ncy5wdXNoKC4uLnJlc3VsdC53YXJuaW5ncyk7XG4gICAgaWYgKHJlc3VsdC51c2FnZSAhPSBudWxsKSB7XG4gICAgICB0b3RhbFVzYWdlID0gYWRkSW1hZ2VNb2RlbFVzYWdlKHRvdGFsVXNhZ2UsIHJlc3VsdC51c2FnZSk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQucHJvdmlkZXJNZXRhZGF0YSkge1xuICAgICAgZm9yIChjb25zdCBbcHJvdmlkZXJOYW1lLCBtZXRhZGF0YV0gb2YgT2JqZWN0LmVudHJpZXMocmVzdWx0LnByb3ZpZGVyTWV0YWRhdGEpKSB7XG4gICAgICAgIGlmIChwcm92aWRlck5hbWUgPT09IFwiZ2F0ZXdheVwiKSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudEVudHJ5ID0gcHJvdmlkZXJNZXRhZGF0YVtwcm92aWRlck5hbWVdO1xuICAgICAgICAgIGlmIChjdXJyZW50RW50cnkgIT0gbnVsbCAmJiB0eXBlb2YgY3VycmVudEVudHJ5ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhW3Byb3ZpZGVyTmFtZV0gPSB7XG4gICAgICAgICAgICAgIC4uLmN1cnJlbnRFbnRyeSxcbiAgICAgICAgICAgICAgLi4ubWV0YWRhdGFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGFbcHJvdmlkZXJOYW1lXSA9IG1ldGFkYXRhO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpbWFnZXNWYWx1ZSA9IHByb3ZpZGVyTWV0YWRhdGFbcHJvdmlkZXJOYW1lXS5pbWFnZXM7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW1hZ2VzVmFsdWUpICYmIGltYWdlc1ZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIHByb3ZpZGVyTWV0YWRhdGFbcHJvdmlkZXJOYW1lXS5pbWFnZXM7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIChfYiA9IHByb3ZpZGVyTWV0YWRhdGFbcHJvdmlkZXJOYW1lXSkgIT0gbnVsbCA/IF9iIDogcHJvdmlkZXJNZXRhZGF0YVtwcm92aWRlck5hbWVdID0geyBpbWFnZXM6IFtdIH07XG4gICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YVtwcm92aWRlck5hbWVdLmltYWdlcy5wdXNoKFxuICAgICAgICAgICAgLi4ucmVzdWx0LnByb3ZpZGVyTWV0YWRhdGFbcHJvdmlkZXJOYW1lXS5pbWFnZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3BvbnNlcy5wdXNoKHJlc3VsdC5yZXNwb25zZSk7XG4gIH1cbiAgbG9nV2FybmluZ3MoeyB3YXJuaW5ncywgcHJvdmlkZXI6IG1vZGVsLnByb3ZpZGVyLCBtb2RlbDogbW9kZWwubW9kZWxJZCB9KTtcbiAgaWYgKCFpbWFnZXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IE5vSW1hZ2VHZW5lcmF0ZWRFcnJvcih7IHJlc3BvbnNlcyB9KTtcbiAgfVxuICByZXR1cm4gbmV3IERlZmF1bHRHZW5lcmF0ZUltYWdlUmVzdWx0KHtcbiAgICBpbWFnZXMsXG4gICAgd2FybmluZ3MsXG4gICAgcmVzcG9uc2VzLFxuICAgIHByb3ZpZGVyTWV0YWRhdGEsXG4gICAgdXNhZ2U6IHRvdGFsVXNhZ2VcbiAgfSk7XG59XG52YXIgRGVmYXVsdEdlbmVyYXRlSW1hZ2VSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLmltYWdlcyA9IG9wdGlvbnMuaW1hZ2VzO1xuICAgIHRoaXMud2FybmluZ3MgPSBvcHRpb25zLndhcm5pbmdzO1xuICAgIHRoaXMucmVzcG9uc2VzID0gb3B0aW9ucy5yZXNwb25zZXM7XG4gICAgdGhpcy5wcm92aWRlck1ldGFkYXRhID0gb3B0aW9ucy5wcm92aWRlck1ldGFkYXRhO1xuICAgIHRoaXMudXNhZ2UgPSBvcHRpb25zLnVzYWdlO1xuICB9XG4gIGdldCBpbWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbWFnZXNbMF07XG4gIH1cbn07XG5hc3luYyBmdW5jdGlvbiBpbnZva2VNb2RlbE1heEltYWdlc1BlckNhbGwobW9kZWwpIHtcbiAgY29uc3QgaXNGdW5jdGlvbiA9IG1vZGVsLm1heEltYWdlc1BlckNhbGwgaW5zdGFuY2VvZiBGdW5jdGlvbjtcbiAgaWYgKCFpc0Z1bmN0aW9uKSB7XG4gICAgcmV0dXJuIG1vZGVsLm1heEltYWdlc1BlckNhbGw7XG4gIH1cbiAgcmV0dXJuIG1vZGVsLm1heEltYWdlc1BlckNhbGwoe1xuICAgIG1vZGVsSWQ6IG1vZGVsLm1vZGVsSWRcbiAgfSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVQcm9tcHQocHJvbXB0KSB7XG4gIGlmICh0eXBlb2YgcHJvbXB0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHsgcHJvbXB0LCBmaWxlczogdm9pZCAwLCBtYXNrOiB2b2lkIDAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHByb21wdDogcHJvbXB0LnRleHQsXG4gICAgZmlsZXM6IHByb21wdC5pbWFnZXMubWFwKHRvSW1hZ2VNb2RlbFYzRmlsZSksXG4gICAgbWFzazogcHJvbXB0Lm1hc2sgPyB0b0ltYWdlTW9kZWxWM0ZpbGUocHJvbXB0Lm1hc2spIDogdm9pZCAwXG4gIH07XG59XG5mdW5jdGlvbiB0b0ltYWdlTW9kZWxWM0ZpbGUoZGF0YUNvbnRlbnQpIHtcbiAgaWYgKHR5cGVvZiBkYXRhQ29udGVudCA9PT0gXCJzdHJpbmdcIiAmJiBkYXRhQ29udGVudC5zdGFydHNXaXRoKFwiaHR0cFwiKSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInVybFwiLFxuICAgICAgdXJsOiBkYXRhQ29udGVudFxuICAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBkYXRhQ29udGVudCA9PT0gXCJzdHJpbmdcIiAmJiBkYXRhQ29udGVudC5zdGFydHNXaXRoKFwiZGF0YTpcIikpIHtcbiAgICBjb25zdCB7IG1lZGlhVHlwZTogZGF0YVVybE1lZGlhVHlwZSwgYmFzZTY0Q29udGVudCB9ID0gc3BsaXREYXRhVXJsKGRhdGFDb250ZW50KTtcbiAgICBpZiAoYmFzZTY0Q29udGVudCAhPSBudWxsKSB7XG4gICAgICBjb25zdCB1aW50OERhdGEyID0gY29udmVydEJhc2U2NFRvVWludDhBcnJheTQoYmFzZTY0Q29udGVudCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgZGF0YTogdWludDhEYXRhMixcbiAgICAgICAgbWVkaWFUeXBlOiBkYXRhVXJsTWVkaWFUeXBlIHx8IGRldGVjdE1lZGlhVHlwZSh7XG4gICAgICAgICAgZGF0YTogdWludDhEYXRhMixcbiAgICAgICAgICBzaWduYXR1cmVzOiBpbWFnZU1lZGlhVHlwZVNpZ25hdHVyZXNcbiAgICAgICAgfSkgfHwgXCJpbWFnZS9wbmdcIlxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdWludDhEYXRhID0gY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KGRhdGFDb250ZW50KTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImZpbGVcIixcbiAgICBkYXRhOiB1aW50OERhdGEsXG4gICAgbWVkaWFUeXBlOiBkZXRlY3RNZWRpYVR5cGUoe1xuICAgICAgZGF0YTogdWludDhEYXRhLFxuICAgICAgc2lnbmF0dXJlczogaW1hZ2VNZWRpYVR5cGVTaWduYXR1cmVzXG4gICAgfSkgfHwgXCJpbWFnZS9wbmdcIlxuICB9O1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtaW1hZ2UvaW5kZXgudHNcbnZhciBleHBlcmltZW50YWxfZ2VuZXJhdGVJbWFnZSA9IGdlbmVyYXRlSW1hZ2U7XG5cbi8vIHNyYy9nZW5lcmF0ZS1vYmplY3QvZ2VuZXJhdGUtb2JqZWN0LnRzXG5pbXBvcnQge1xuICBjcmVhdGVJZEdlbmVyYXRvciBhcyBjcmVhdGVJZEdlbmVyYXRvcjMsXG4gIHdpdGhVc2VyQWdlbnRTdWZmaXggYXMgd2l0aFVzZXJBZ2VudFN1ZmZpeDZcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL2dlbmVyYXRlLW9iamVjdC9vdXRwdXQtc3RyYXRlZ3kudHNcbmltcG9ydCB7XG4gIGlzSlNPTkFycmF5LFxuICBpc0pTT05PYmplY3QsXG4gIFR5cGVWYWxpZGF0aW9uRXJyb3IgYXMgVHlwZVZhbGlkYXRpb25FcnJvcjQsXG4gIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yIGFzIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yM1xufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHtcbiAgYXNTY2hlbWEgYXMgYXNTY2hlbWE0LFxuICBzYWZlVmFsaWRhdGVUeXBlcyBhcyBzYWZlVmFsaWRhdGVUeXBlczRcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbnZhciBub1NjaGVtYU91dHB1dFN0cmF0ZWd5ID0ge1xuICB0eXBlOiBcIm5vLXNjaGVtYVwiLFxuICBqc29uU2NoZW1hOiBhc3luYyAoKSA9PiB2b2lkIDAsXG4gIGFzeW5jIHZhbGlkYXRlUGFydGlhbFJlc3VsdCh7IHZhbHVlLCB0ZXh0RGVsdGEgfSkge1xuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlOiB7IHBhcnRpYWw6IHZhbHVlLCB0ZXh0RGVsdGEgfSB9O1xuICB9LFxuICBhc3luYyB2YWxpZGF0ZUZpbmFsUmVzdWx0KHZhbHVlLCBjb250ZXh0Mikge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBcIk5vIG9iamVjdCBnZW5lcmF0ZWQ6IHJlc3BvbnNlIGRpZCBub3QgbWF0Y2ggc2NoZW1hLlwiLFxuICAgICAgICB0ZXh0OiBjb250ZXh0Mi50ZXh0LFxuICAgICAgICByZXNwb25zZTogY29udGV4dDIucmVzcG9uc2UsXG4gICAgICAgIHVzYWdlOiBjb250ZXh0Mi51c2FnZSxcbiAgICAgICAgZmluaXNoUmVhc29uOiBjb250ZXh0Mi5maW5pc2hSZWFzb25cbiAgICAgIH0pXG4gICAgfSA6IHsgc3VjY2VzczogdHJ1ZSwgdmFsdWUgfTtcbiAgfSxcbiAgY3JlYXRlRWxlbWVudFN0cmVhbSgpIHtcbiAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IzKHtcbiAgICAgIGZ1bmN0aW9uYWxpdHk6IFwiZWxlbWVudCBzdHJlYW1zIGluIG5vLXNjaGVtYSBtb2RlXCJcbiAgICB9KTtcbiAgfVxufTtcbnZhciBvYmplY3RPdXRwdXRTdHJhdGVneSA9IChzY2hlbWEpID0+ICh7XG4gIHR5cGU6IFwib2JqZWN0XCIsXG4gIGpzb25TY2hlbWE6IGFzeW5jICgpID0+IGF3YWl0IHNjaGVtYS5qc29uU2NoZW1hLFxuICBhc3luYyB2YWxpZGF0ZVBhcnRpYWxSZXN1bHQoeyB2YWx1ZSwgdGV4dERlbHRhIH0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIC8vIE5vdGU6IGN1cnJlbnRseSBubyB2YWxpZGF0aW9uIG9mIHBhcnRpYWwgcmVzdWx0czpcbiAgICAgICAgcGFydGlhbDogdmFsdWUsXG4gICAgICAgIHRleHREZWx0YVxuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFzeW5jIHZhbGlkYXRlRmluYWxSZXN1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gc2FmZVZhbGlkYXRlVHlwZXM0KHsgdmFsdWUsIHNjaGVtYSB9KTtcbiAgfSxcbiAgY3JlYXRlRWxlbWVudFN0cmVhbSgpIHtcbiAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IzKHtcbiAgICAgIGZ1bmN0aW9uYWxpdHk6IFwiZWxlbWVudCBzdHJlYW1zIGluIG9iamVjdCBtb2RlXCJcbiAgICB9KTtcbiAgfVxufSk7XG52YXIgYXJyYXlPdXRwdXRTdHJhdGVneSA9IChzY2hlbWEpID0+IHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgLy8gd3JhcCBpbiBvYmplY3QgdGhhdCBjb250YWlucyBhcnJheSBvZiBlbGVtZW50cywgc2luY2UgbW9zdCBMTE1zIHdpbGwgbm90XG4gICAgLy8gYmUgYWJsZSB0byBnZW5lcmF0ZSBhbiBhcnJheSBkaXJlY3RseTpcbiAgICAvLyBwb3NzaWJsZSBmdXR1cmUgb3B0aW1pemF0aW9uOiB1c2UgYXJyYXlzIGRpcmVjdGx5IHdoZW4gbW9kZWwgc3VwcG9ydHMgZ3JhbW1hci1ndWlkZWQgZ2VuZXJhdGlvblxuICAgIGpzb25TY2hlbWE6IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgJHNjaGVtYSwgLi4uaXRlbVNjaGVtYSB9ID0gYXdhaXQgc2NoZW1hLmpzb25TY2hlbWE7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAkc2NoZW1hOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hI1wiLFxuICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgZWxlbWVudHM6IHsgdHlwZTogXCJhcnJheVwiLCBpdGVtczogaXRlbVNjaGVtYSB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVpcmVkOiBbXCJlbGVtZW50c1wiXSxcbiAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlXG4gICAgICB9O1xuICAgIH0sXG4gICAgYXN5bmMgdmFsaWRhdGVQYXJ0aWFsUmVzdWx0KHtcbiAgICAgIHZhbHVlLFxuICAgICAgbGF0ZXN0T2JqZWN0LFxuICAgICAgaXNGaXJzdERlbHRhLFxuICAgICAgaXNGaW5hbERlbHRhXG4gICAgfSkge1xuICAgICAgdmFyIF9hMjE7XG4gICAgICBpZiAoIWlzSlNPTk9iamVjdCh2YWx1ZSkgfHwgIWlzSlNPTkFycmF5KHZhbHVlLmVsZW1lbnRzKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcjQoe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogXCJ2YWx1ZSBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGFuIGFycmF5IG9mIGVsZW1lbnRzXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgaW5wdXRBcnJheSA9IHZhbHVlLmVsZW1lbnRzO1xuICAgICAgY29uc3QgcmVzdWx0QXJyYXkgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gaW5wdXRBcnJheVtpXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2FmZVZhbGlkYXRlVHlwZXM0KHsgdmFsdWU6IGVsZW1lbnQsIHNjaGVtYSB9KTtcbiAgICAgICAgaWYgKGkgPT09IGlucHV0QXJyYXkubGVuZ3RoIC0gMSAmJiAhaXNGaW5hbERlbHRhKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0QXJyYXkucHVzaChyZXN1bHQudmFsdWUpO1xuICAgICAgfVxuICAgICAgY29uc3QgcHVibGlzaGVkRWxlbWVudENvdW50ID0gKF9hMjEgPSBsYXRlc3RPYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IGxhdGVzdE9iamVjdC5sZW5ndGgpICE9IG51bGwgPyBfYTIxIDogMDtcbiAgICAgIGxldCB0ZXh0RGVsdGEgPSBcIlwiO1xuICAgICAgaWYgKGlzRmlyc3REZWx0YSkge1xuICAgICAgICB0ZXh0RGVsdGEgKz0gXCJbXCI7XG4gICAgICB9XG4gICAgICBpZiAocHVibGlzaGVkRWxlbWVudENvdW50ID4gMCkge1xuICAgICAgICB0ZXh0RGVsdGEgKz0gXCIsXCI7XG4gICAgICB9XG4gICAgICB0ZXh0RGVsdGEgKz0gcmVzdWx0QXJyYXkuc2xpY2UocHVibGlzaGVkRWxlbWVudENvdW50KS5tYXAoKGVsZW1lbnQpID0+IEpTT04uc3RyaW5naWZ5KGVsZW1lbnQpKS5qb2luKFwiLFwiKTtcbiAgICAgIGlmIChpc0ZpbmFsRGVsdGEpIHtcbiAgICAgICAgdGV4dERlbHRhICs9IFwiXVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBwYXJ0aWFsOiByZXN1bHRBcnJheSxcbiAgICAgICAgICB0ZXh0RGVsdGFcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIGFzeW5jIHZhbGlkYXRlRmluYWxSZXN1bHQodmFsdWUpIHtcbiAgICAgIGlmICghaXNKU09OT2JqZWN0KHZhbHVlKSB8fCAhaXNKU09OQXJyYXkodmFsdWUuZWxlbWVudHMpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yNCh7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGNhdXNlOiBcInZhbHVlIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYW4gYXJyYXkgb2YgZWxlbWVudHNcIlxuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBpbnB1dEFycmF5ID0gdmFsdWUuZWxlbWVudHM7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgaW5wdXRBcnJheSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzYWZlVmFsaWRhdGVUeXBlczQoeyB2YWx1ZTogZWxlbWVudCwgc2NoZW1hIH0pO1xuICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgdmFsdWU6IGlucHV0QXJyYXkgfTtcbiAgICB9LFxuICAgIGNyZWF0ZUVsZW1lbnRTdHJlYW0ob3JpZ2luYWxTdHJlYW0pIHtcbiAgICAgIGxldCBwdWJsaXNoZWRFbGVtZW50cyA9IDA7XG4gICAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShcbiAgICAgICAgb3JpZ2luYWxTdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhcnJheTIgPSBjaHVuay5vYmplY3Q7XG4gICAgICAgICAgICAgICAgICBmb3IgKDsgcHVibGlzaGVkRWxlbWVudHMgPCBhcnJheTIubGVuZ3RoOyBwdWJsaXNoZWRFbGVtZW50cysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShhcnJheTJbcHVibGlzaGVkRWxlbWVudHNdKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgYFVuc3VwcG9ydGVkIGNodW5rIHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICB9O1xufTtcbnZhciBlbnVtT3V0cHV0U3RyYXRlZ3kgPSAoZW51bVZhbHVlcykgPT4ge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIC8vIHdyYXAgaW4gb2JqZWN0IHRoYXQgY29udGFpbnMgcmVzdWx0LCBzaW5jZSBtb3N0IExMTXMgd2lsbCBub3RcbiAgICAvLyBiZSBhYmxlIHRvIGdlbmVyYXRlIGFuIGVudW0gdmFsdWUgZGlyZWN0bHk6XG4gICAgLy8gcG9zc2libGUgZnV0dXJlIG9wdGltaXphdGlvbjogdXNlIGVudW1zIGRpcmVjdGx5IHdoZW4gbW9kZWwgc3VwcG9ydHMgdG9wLWxldmVsIGVudW1zXG4gICAganNvblNjaGVtYTogYXN5bmMgKCkgPT4gKHtcbiAgICAgICRzY2hlbWE6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCIsXG4gICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICByZXN1bHQ6IHsgdHlwZTogXCJzdHJpbmdcIiwgZW51bTogZW51bVZhbHVlcyB9XG4gICAgICB9LFxuICAgICAgcmVxdWlyZWQ6IFtcInJlc3VsdFwiXSxcbiAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZVxuICAgIH0pLFxuICAgIGFzeW5jIHZhbGlkYXRlRmluYWxSZXN1bHQodmFsdWUpIHtcbiAgICAgIGlmICghaXNKU09OT2JqZWN0KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUucmVzdWx0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yNCh7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGNhdXNlOiAndmFsdWUgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIHN0cmluZyBpbiB0aGUgXCJyZXN1bHRcIiBwcm9wZXJ0eS4nXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlLnJlc3VsdDtcbiAgICAgIHJldHVybiBlbnVtVmFsdWVzLmluY2x1ZGVzKHJlc3VsdCkgPyB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlOiByZXN1bHQgfSA6IHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcjQoe1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGNhdXNlOiBcInZhbHVlIG11c3QgYmUgYSBzdHJpbmcgaW4gdGhlIGVudW1cIlxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9LFxuICAgIGFzeW5jIHZhbGlkYXRlUGFydGlhbFJlc3VsdCh7IHZhbHVlLCB0ZXh0RGVsdGEgfSkge1xuICAgICAgaWYgKCFpc0pTT05PYmplY3QodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5yZXN1bHQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3I0KHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgY2F1c2U6ICd2YWx1ZSBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgc3RyaW5nIGluIHRoZSBcInJlc3VsdFwiIHByb3BlcnR5LidcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUucmVzdWx0O1xuICAgICAgY29uc3QgcG9zc2libGVFbnVtVmFsdWVzID0gZW51bVZhbHVlcy5maWx0ZXIoXG4gICAgICAgIChlbnVtVmFsdWUpID0+IGVudW1WYWx1ZS5zdGFydHNXaXRoKHJlc3VsdClcbiAgICAgICk7XG4gICAgICBpZiAodmFsdWUucmVzdWx0Lmxlbmd0aCA9PT0gMCB8fCBwb3NzaWJsZUVudW1WYWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yNCh7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGNhdXNlOiBcInZhbHVlIG11c3QgYmUgYSBzdHJpbmcgaW4gdGhlIGVudW1cIlxuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHBhcnRpYWw6IHBvc3NpYmxlRW51bVZhbHVlcy5sZW5ndGggPiAxID8gcmVzdWx0IDogcG9zc2libGVFbnVtVmFsdWVzWzBdLFxuICAgICAgICAgIHRleHREZWx0YVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgY3JlYXRlRWxlbWVudFN0cmVhbSgpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcjMoe1xuICAgICAgICBmdW5jdGlvbmFsaXR5OiBcImVsZW1lbnQgc3RyZWFtcyBpbiBlbnVtIG1vZGVcIlxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufTtcbmZ1bmN0aW9uIGdldE91dHB1dFN0cmF0ZWd5KHtcbiAgb3V0cHV0LFxuICBzY2hlbWEsXG4gIGVudW1WYWx1ZXNcbn0pIHtcbiAgc3dpdGNoIChvdXRwdXQpIHtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICByZXR1cm4gb2JqZWN0T3V0cHV0U3RyYXRlZ3koYXNTY2hlbWE0KHNjaGVtYSkpO1xuICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgcmV0dXJuIGFycmF5T3V0cHV0U3RyYXRlZ3koYXNTY2hlbWE0KHNjaGVtYSkpO1xuICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICByZXR1cm4gZW51bU91dHB1dFN0cmF0ZWd5KGVudW1WYWx1ZXMpO1xuICAgIGNhc2UgXCJuby1zY2hlbWFcIjpcbiAgICAgIHJldHVybiBub1NjaGVtYU91dHB1dFN0cmF0ZWd5O1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBvdXRwdXQ7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG91dHB1dDogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvZ2VuZXJhdGUtb2JqZWN0L3BhcnNlLWFuZC12YWxpZGF0ZS1vYmplY3QtcmVzdWx0LnRzXG5pbXBvcnQgeyBKU09OUGFyc2VFcnJvciBhcyBKU09OUGFyc2VFcnJvcjIsIFR5cGVWYWxpZGF0aW9uRXJyb3IgYXMgVHlwZVZhbGlkYXRpb25FcnJvcjUgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHsgc2FmZVBhcnNlSlNPTiBhcyBzYWZlUGFyc2VKU09ONCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5hc3luYyBmdW5jdGlvbiBwYXJzZUFuZFZhbGlkYXRlT2JqZWN0UmVzdWx0KHJlc3VsdCwgb3V0cHV0U3RyYXRlZ3ksIGNvbnRleHQyKSB7XG4gIGNvbnN0IHBhcnNlUmVzdWx0ID0gYXdhaXQgc2FmZVBhcnNlSlNPTjQoeyB0ZXh0OiByZXN1bHQgfSk7XG4gIGlmICghcGFyc2VSZXN1bHQuc3VjY2Vzcykge1xuICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IFwiTm8gb2JqZWN0IGdlbmVyYXRlZDogY291bGQgbm90IHBhcnNlIHRoZSByZXNwb25zZS5cIixcbiAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvcixcbiAgICAgIHRleHQ6IHJlc3VsdCxcbiAgICAgIHJlc3BvbnNlOiBjb250ZXh0Mi5yZXNwb25zZSxcbiAgICAgIHVzYWdlOiBjb250ZXh0Mi51c2FnZSxcbiAgICAgIGZpbmlzaFJlYXNvbjogY29udGV4dDIuZmluaXNoUmVhc29uXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IGF3YWl0IG91dHB1dFN0cmF0ZWd5LnZhbGlkYXRlRmluYWxSZXN1bHQoXG4gICAgcGFyc2VSZXN1bHQudmFsdWUsXG4gICAge1xuICAgICAgdGV4dDogcmVzdWx0LFxuICAgICAgcmVzcG9uc2U6IGNvbnRleHQyLnJlc3BvbnNlLFxuICAgICAgdXNhZ2U6IGNvbnRleHQyLnVzYWdlXG4gICAgfVxuICApO1xuICBpZiAoIXZhbGlkYXRpb25SZXN1bHQuc3VjY2Vzcykge1xuICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IFwiTm8gb2JqZWN0IGdlbmVyYXRlZDogcmVzcG9uc2UgZGlkIG5vdCBtYXRjaCBzY2hlbWEuXCIsXG4gICAgICBjYXVzZTogdmFsaWRhdGlvblJlc3VsdC5lcnJvcixcbiAgICAgIHRleHQ6IHJlc3VsdCxcbiAgICAgIHJlc3BvbnNlOiBjb250ZXh0Mi5yZXNwb25zZSxcbiAgICAgIHVzYWdlOiBjb250ZXh0Mi51c2FnZSxcbiAgICAgIGZpbmlzaFJlYXNvbjogY29udGV4dDIuZmluaXNoUmVhc29uXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHZhbGlkYXRpb25SZXN1bHQudmFsdWU7XG59XG5hc3luYyBmdW5jdGlvbiBwYXJzZUFuZFZhbGlkYXRlT2JqZWN0UmVzdWx0V2l0aFJlcGFpcihyZXN1bHQsIG91dHB1dFN0cmF0ZWd5LCByZXBhaXJUZXh0LCBjb250ZXh0Mikge1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBwYXJzZUFuZFZhbGlkYXRlT2JqZWN0UmVzdWx0KHJlc3VsdCwgb3V0cHV0U3RyYXRlZ3ksIGNvbnRleHQyKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAocmVwYWlyVGV4dCAhPSBudWxsICYmIE5vT2JqZWN0R2VuZXJhdGVkRXJyb3IuaXNJbnN0YW5jZShlcnJvcikgJiYgKEpTT05QYXJzZUVycm9yMi5pc0luc3RhbmNlKGVycm9yLmNhdXNlKSB8fCBUeXBlVmFsaWRhdGlvbkVycm9yNS5pc0luc3RhbmNlKGVycm9yLmNhdXNlKSkpIHtcbiAgICAgIGNvbnN0IHJlcGFpcmVkVGV4dCA9IGF3YWl0IHJlcGFpclRleHQoe1xuICAgICAgICB0ZXh0OiByZXN1bHQsXG4gICAgICAgIGVycm9yOiBlcnJvci5jYXVzZVxuICAgICAgfSk7XG4gICAgICBpZiAocmVwYWlyZWRUZXh0ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF3YWl0IHBhcnNlQW5kVmFsaWRhdGVPYmplY3RSZXN1bHQoXG4gICAgICAgIHJlcGFpcmVkVGV4dCxcbiAgICAgICAgb3V0cHV0U3RyYXRlZ3ksXG4gICAgICAgIGNvbnRleHQyXG4gICAgICApO1xuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vLyBzcmMvZ2VuZXJhdGUtb2JqZWN0L3ZhbGlkYXRlLW9iamVjdC1nZW5lcmF0aW9uLWlucHV0LnRzXG5mdW5jdGlvbiB2YWxpZGF0ZU9iamVjdEdlbmVyYXRpb25JbnB1dCh7XG4gIG91dHB1dCxcbiAgc2NoZW1hLFxuICBzY2hlbWFOYW1lLFxuICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgZW51bVZhbHVlc1xufSkge1xuICBpZiAob3V0cHV0ICE9IG51bGwgJiYgb3V0cHV0ICE9PSBcIm9iamVjdFwiICYmIG91dHB1dCAhPT0gXCJhcnJheVwiICYmIG91dHB1dCAhPT0gXCJlbnVtXCIgJiYgb3V0cHV0ICE9PSBcIm5vLXNjaGVtYVwiKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgIHBhcmFtZXRlcjogXCJvdXRwdXRcIixcbiAgICAgIHZhbHVlOiBvdXRwdXQsXG4gICAgICBtZXNzYWdlOiBcIkludmFsaWQgb3V0cHV0IHR5cGUuXCJcbiAgICB9KTtcbiAgfVxuICBpZiAob3V0cHV0ID09PSBcIm5vLXNjaGVtYVwiKSB7XG4gICAgaWYgKHNjaGVtYSAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWEsXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIG5vLXNjaGVtYSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYURlc2NyaXB0aW9uXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICAgICAgbWVzc2FnZTogXCJTY2hlbWEgZGVzY3JpcHRpb24gaXMgbm90IHN1cHBvcnRlZCBmb3Igbm8tc2NoZW1hIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWFOYW1lICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFOYW1lXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWFOYW1lLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBuYW1lIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIG5vLXNjaGVtYSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZW51bVZhbHVlcyAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwiZW51bVZhbHVlc1wiLFxuICAgICAgICB2YWx1ZTogZW51bVZhbHVlcyxcbiAgICAgICAgbWVzc2FnZTogXCJFbnVtIHZhbHVlcyBhcmUgbm90IHN1cHBvcnRlZCBmb3Igbm8tc2NoZW1hIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChvdXRwdXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFcIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYSxcbiAgICAgICAgbWVzc2FnZTogXCJTY2hlbWEgaXMgcmVxdWlyZWQgZm9yIG9iamVjdCBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZW51bVZhbHVlcyAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwiZW51bVZhbHVlc1wiLFxuICAgICAgICB2YWx1ZTogZW51bVZhbHVlcyxcbiAgICAgICAgbWVzc2FnZTogXCJFbnVtIHZhbHVlcyBhcmUgbm90IHN1cHBvcnRlZCBmb3Igb2JqZWN0IG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChvdXRwdXQgPT09IFwiYXJyYXlcIikge1xuICAgIGlmIChzY2hlbWEgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYVwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hLFxuICAgICAgICBtZXNzYWdlOiBcIkVsZW1lbnQgc2NoZW1hIGlzIHJlcXVpcmVkIGZvciBhcnJheSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZW51bVZhbHVlcyAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwiZW51bVZhbHVlc1wiLFxuICAgICAgICB2YWx1ZTogZW51bVZhbHVlcyxcbiAgICAgICAgbWVzc2FnZTogXCJFbnVtIHZhbHVlcyBhcmUgbm90IHN1cHBvcnRlZCBmb3IgYXJyYXkgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKG91dHB1dCA9PT0gXCJlbnVtXCIpIHtcbiAgICBpZiAoc2NoZW1hICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFcIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYSxcbiAgICAgICAgbWVzc2FnZTogXCJTY2hlbWEgaXMgbm90IHN1cHBvcnRlZCBmb3IgZW51bSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYURlc2NyaXB0aW9uXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICAgICAgbWVzc2FnZTogXCJTY2hlbWEgZGVzY3JpcHRpb24gaXMgbm90IHN1cHBvcnRlZCBmb3IgZW51bSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hTmFtZSAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hTmFtZVwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hTmFtZSxcbiAgICAgICAgbWVzc2FnZTogXCJTY2hlbWEgbmFtZSBpcyBub3Qgc3VwcG9ydGVkIGZvciBlbnVtIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlbnVtVmFsdWVzID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJlbnVtVmFsdWVzXCIsXG4gICAgICAgIHZhbHVlOiBlbnVtVmFsdWVzLFxuICAgICAgICBtZXNzYWdlOiBcIkVudW0gdmFsdWVzIGFyZSByZXF1aXJlZCBmb3IgZW51bSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGVudW1WYWx1ZXMpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgICBwYXJhbWV0ZXI6IFwiZW51bVZhbHVlc1wiLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIG1lc3NhZ2U6IFwiRW51bSB2YWx1ZXMgbXVzdCBiZSBzdHJpbmdzLlwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvZ2VuZXJhdGUtb2JqZWN0L2dlbmVyYXRlLW9iamVjdC50c1xudmFyIG9yaWdpbmFsR2VuZXJhdGVJZDMgPSBjcmVhdGVJZEdlbmVyYXRvcjMoeyBwcmVmaXg6IFwiYWlvYmpcIiwgc2l6ZTogMjQgfSk7XG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZU9iamVjdChvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBtb2RlbDogbW9kZWxBcmcsXG4gICAgb3V0cHV0ID0gXCJvYmplY3RcIixcbiAgICBzeXN0ZW0sXG4gICAgcHJvbXB0LFxuICAgIG1lc3NhZ2VzLFxuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gICAgYWJvcnRTaWduYWwsXG4gICAgaGVhZGVycyxcbiAgICBleHBlcmltZW50YWxfcmVwYWlyVGV4dDogcmVwYWlyVGV4dCxcbiAgICBleHBlcmltZW50YWxfdGVsZW1ldHJ5OiB0ZWxlbWV0cnksXG4gICAgZXhwZXJpbWVudGFsX2Rvd25sb2FkOiBkb3dubG9hZDIsXG4gICAgcHJvdmlkZXJPcHRpb25zLFxuICAgIF9pbnRlcm5hbDoge1xuICAgICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDIgPSBvcmlnaW5hbEdlbmVyYXRlSWQzLFxuICAgICAgY3VycmVudERhdGUgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxuICAgIH0gPSB7fSxcbiAgICAuLi5zZXR0aW5nc1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgbW9kZWwgPSByZXNvbHZlTGFuZ3VhZ2VNb2RlbChtb2RlbEFyZyk7XG4gIGNvbnN0IGVudW1WYWx1ZXMgPSBcImVudW1cIiBpbiBvcHRpb25zID8gb3B0aW9ucy5lbnVtIDogdm9pZCAwO1xuICBjb25zdCB7XG4gICAgc2NoZW1hOiBpbnB1dFNjaGVtYSxcbiAgICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICBzY2hlbWFOYW1lXG4gIH0gPSBcInNjaGVtYVwiIGluIG9wdGlvbnMgPyBvcHRpb25zIDoge307XG4gIHZhbGlkYXRlT2JqZWN0R2VuZXJhdGlvbklucHV0KHtcbiAgICBvdXRwdXQsXG4gICAgc2NoZW1hOiBpbnB1dFNjaGVtYSxcbiAgICBzY2hlbWFOYW1lLFxuICAgIHNjaGVtYURlc2NyaXB0aW9uLFxuICAgIGVudW1WYWx1ZXNcbiAgfSk7XG4gIGNvbnN0IHsgbWF4UmV0cmllcywgcmV0cnkgfSA9IHByZXBhcmVSZXRyaWVzKHtcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICAgIGFib3J0U2lnbmFsXG4gIH0pO1xuICBjb25zdCBvdXRwdXRTdHJhdGVneSA9IGdldE91dHB1dFN0cmF0ZWd5KHtcbiAgICBvdXRwdXQsXG4gICAgc2NoZW1hOiBpbnB1dFNjaGVtYSxcbiAgICBlbnVtVmFsdWVzXG4gIH0pO1xuICBjb25zdCBjYWxsU2V0dGluZ3MgPSBwcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKTtcbiAgY29uc3QgaGVhZGVyc1dpdGhVc2VyQWdlbnQgPSB3aXRoVXNlckFnZW50U3VmZml4NihcbiAgICBoZWFkZXJzICE9IG51bGwgPyBoZWFkZXJzIDoge30sXG4gICAgYGFpLyR7VkVSU0lPTn1gXG4gICk7XG4gIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzOiBoZWFkZXJzV2l0aFVzZXJBZ2VudCxcbiAgICBzZXR0aW5nczogeyAuLi5jYWxsU2V0dGluZ3MsIG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gIGNvbnN0IGpzb25TY2hlbWEyID0gYXdhaXQgb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYSgpO1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCByZWNvcmRTcGFuKHtcbiAgICAgIG5hbWU6IFwiYWkuZ2VuZXJhdGVPYmplY3RcIixcbiAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZ2VuZXJhdGVPYmplY3RcIixcbiAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgICBcImFpLnByb21wdFwiOiB7XG4gICAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoeyBzeXN0ZW0sIHByb21wdCwgbWVzc2FnZXMgfSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiYWkuc2NoZW1hXCI6IGpzb25TY2hlbWEyICE9IG51bGwgPyB7IGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShqc29uU2NoZW1hMikgfSA6IHZvaWQgMCxcbiAgICAgICAgICBcImFpLnNjaGVtYS5uYW1lXCI6IHNjaGVtYU5hbWUsXG4gICAgICAgICAgXCJhaS5zY2hlbWEuZGVzY3JpcHRpb25cIjogc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgICAgICAgXCJhaS5zZXR0aW5ncy5vdXRwdXRcIjogb3V0cHV0U3RyYXRlZ3kudHlwZVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIHRyYWNlcixcbiAgICAgIGZuOiBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgICB2YXIgX2EyMTtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgbGV0IGZpbmlzaFJlYXNvbjtcbiAgICAgICAgbGV0IHVzYWdlO1xuICAgICAgICBsZXQgd2FybmluZ3M7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHJlcXVlc3Q7XG4gICAgICAgIGxldCByZXN1bHRQcm92aWRlck1ldGFkYXRhO1xuICAgICAgICBsZXQgcmVhc29uaW5nO1xuICAgICAgICBjb25zdCBzdGFuZGFyZGl6ZWRQcm9tcHQgPSBhd2FpdCBzdGFuZGFyZGl6ZVByb21wdCh7XG4gICAgICAgICAgc3lzdGVtLFxuICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICBtZXNzYWdlc1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcHJvbXB0TWVzc2FnZXMgPSBhd2FpdCBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgICAgICAgICBwcm9tcHQ6IHN0YW5kYXJkaXplZFByb21wdCxcbiAgICAgICAgICBzdXBwb3J0ZWRVcmxzOiBhd2FpdCBtb2RlbC5zdXBwb3J0ZWRVcmxzLFxuICAgICAgICAgIGRvd25sb2FkOiBkb3dubG9hZDJcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRlUmVzdWx0ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICAgKCkgPT4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICBuYW1lOiBcImFpLmdlbmVyYXRlT2JqZWN0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZ2VuZXJhdGVPYmplY3QuZG9HZW5lcmF0ZVwiLFxuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQubWVzc2FnZXNcIjoge1xuICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHN0cmluZ2lmeUZvclRlbGVtZXRyeShwcm9tcHRNZXNzYWdlcylcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICBcImdlbl9haS5zeXN0ZW1cIjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tb2RlbFwiOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QuZnJlcXVlbmN5X3BlbmFsdHlcIjogY2FsbFNldHRpbmdzLmZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tYXhfdG9rZW5zXCI6IGNhbGxTZXR0aW5ncy5tYXhPdXRwdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5wcmVzZW5jZV9wZW5hbHR5XCI6IGNhbGxTZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHksXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50ZW1wZXJhdHVyZVwiOiBjYWxsU2V0dGluZ3MudGVtcGVyYXR1cmUsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3Bfa1wiOiBjYWxsU2V0dGluZ3MudG9wSyxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9wXCI6IGNhbGxTZXR0aW5ncy50b3BQXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgZm46IGFzeW5jIChzcGFuMikgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2EyMiwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3VsdDIgPSBhd2FpdCBtb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgICAgICAgICAgICByZXNwb25zZUZvcm1hdDoge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJqc29uXCIsXG4gICAgICAgICAgICAgICAgICBzY2hlbWE6IGpzb25TY2hlbWEyLFxuICAgICAgICAgICAgICAgICAgbmFtZTogc2NoZW1hTmFtZSxcbiAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBzY2hlbWFEZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICAgICAgICAgICAgcHJvbXB0OiBwcm9tcHRNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyc1dpdGhVc2VyQWdlbnRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBpZDogKF9iID0gKF9hMjIgPSByZXN1bHQyLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyMi5pZCkgIT0gbnVsbCA/IF9iIDogZ2VuZXJhdGVJZDIoKSxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IChfZCA9IChfYyA9IHJlc3VsdDIucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYy50aW1lc3RhbXApICE9IG51bGwgPyBfZCA6IGN1cnJlbnREYXRlKCksXG4gICAgICAgICAgICAgICAgbW9kZWxJZDogKF9mID0gKF9lID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLm1vZGVsSWQpICE9IG51bGwgPyBfZiA6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogKF9nID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogKF9oID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9oLmJvZHlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgY29uc3QgdGV4dDIgPSBleHRyYWN0VGV4dENvbnRlbnQocmVzdWx0Mi5jb250ZW50KTtcbiAgICAgICAgICAgICAgY29uc3QgcmVhc29uaW5nMiA9IGV4dHJhY3RSZWFzb25pbmdDb250ZW50KHJlc3VsdDIuY29udGVudCk7XG4gICAgICAgICAgICAgIGlmICh0ZXh0MiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiB0aGUgbW9kZWwgZGlkIG5vdCByZXR1cm4gYSByZXNwb25zZS5cIixcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZURhdGEsXG4gICAgICAgICAgICAgICAgICB1c2FnZTogYXNMYW5ndWFnZU1vZGVsVXNhZ2UocmVzdWx0Mi51c2FnZSksXG4gICAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IHJlc3VsdDIuZmluaXNoUmVhc29uLnVuaWZpZWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzcGFuMi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgIGF3YWl0IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiByZXN1bHQyLmZpbmlzaFJlYXNvbi51bmlmaWVkLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm9iamVjdFwiOiB7IG91dHB1dDogKCkgPT4gdGV4dDIgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5pZFwiOiByZXNwb25zZURhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGltZXN0YW1wXCI6IHJlc3BvbnNlRGF0YS50aW1lc3RhbXAudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5wcm92aWRlck1ldGFkYXRhXCI6IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDIucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHJlbmFtZSB0ZWxlbWV0cnkgYXR0cmlidXRlcyB0byBpbnB1dFRva2VucyBhbmQgb3V0cHV0VG9rZW5zXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UuaW5wdXRUb2tlbnMudG90YWwsXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY29tcGxldGlvblRva2Vuc1wiOiByZXN1bHQyLnVzYWdlLm91dHB1dFRva2Vucy50b3RhbCxcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5maW5pc2hfcmVhc29uc1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Mi5maW5pc2hSZWFzb24udW5pZmllZFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5pZFwiOiByZXNwb25zZURhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLm1vZGVsXCI6IHJlc3BvbnNlRGF0YS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5pbnB1dF90b2tlbnNcIjogcmVzdWx0Mi51c2FnZS5pbnB1dFRva2Vucy50b3RhbCxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2Uub3V0cHV0X3Rva2Vuc1wiOiByZXN1bHQyLnVzYWdlLm91dHB1dFRva2Vucy50b3RhbFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4ucmVzdWx0MixcbiAgICAgICAgICAgICAgICBvYmplY3RUZXh0OiB0ZXh0MixcbiAgICAgICAgICAgICAgICByZWFzb25pbmc6IHJlYXNvbmluZzIsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VEYXRhXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgcmVzdWx0ID0gZ2VuZXJhdGVSZXN1bHQub2JqZWN0VGV4dDtcbiAgICAgICAgZmluaXNoUmVhc29uID0gZ2VuZXJhdGVSZXN1bHQuZmluaXNoUmVhc29uLnVuaWZpZWQ7XG4gICAgICAgIHVzYWdlID0gYXNMYW5ndWFnZU1vZGVsVXNhZ2UoZ2VuZXJhdGVSZXN1bHQudXNhZ2UpO1xuICAgICAgICB3YXJuaW5ncyA9IGdlbmVyYXRlUmVzdWx0Lndhcm5pbmdzO1xuICAgICAgICByZXN1bHRQcm92aWRlck1ldGFkYXRhID0gZ2VuZXJhdGVSZXN1bHQucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgcmVxdWVzdCA9IChfYTIxID0gZ2VuZXJhdGVSZXN1bHQucmVxdWVzdCkgIT0gbnVsbCA/IF9hMjEgOiB7fTtcbiAgICAgICAgcmVzcG9uc2UgPSBnZW5lcmF0ZVJlc3VsdC5yZXNwb25zZURhdGE7XG4gICAgICAgIHJlYXNvbmluZyA9IGdlbmVyYXRlUmVzdWx0LnJlYXNvbmluZztcbiAgICAgICAgbG9nV2FybmluZ3Moe1xuICAgICAgICAgIHdhcm5pbmdzLFxuICAgICAgICAgIHByb3ZpZGVyOiBtb2RlbC5wcm92aWRlcixcbiAgICAgICAgICBtb2RlbDogbW9kZWwubW9kZWxJZFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgb2JqZWN0MiA9IGF3YWl0IHBhcnNlQW5kVmFsaWRhdGVPYmplY3RSZXN1bHRXaXRoUmVwYWlyKFxuICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICBvdXRwdXRTdHJhdGVneSxcbiAgICAgICAgICByZXBhaXJUZXh0LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgdXNhZ2UsXG4gICAgICAgICAgICBmaW5pc2hSZWFzb25cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICBhd2FpdCBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShvYmplY3QyKVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnByb3ZpZGVyTWV0YWRhdGFcIjogSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgcmVzdWx0UHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAvLyBUT0RPIHJlbmFtZSB0ZWxlbWV0cnkgYXR0cmlidXRlcyB0byBpbnB1dFRva2VucyBhbmQgb3V0cHV0VG9rZW5zXG4gICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHVzYWdlLmlucHV0VG9rZW5zLFxuICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogdXNhZ2Uub3V0cHV0VG9rZW5zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0R2VuZXJhdGVPYmplY3RSZXN1bHQoe1xuICAgICAgICAgIG9iamVjdDogb2JqZWN0MixcbiAgICAgICAgICByZWFzb25pbmcsXG4gICAgICAgICAgZmluaXNoUmVhc29uLFxuICAgICAgICAgIHVzYWdlLFxuICAgICAgICAgIHdhcm5pbmdzLFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcmVzdWx0UHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyB3cmFwR2F0ZXdheUVycm9yKGVycm9yKTtcbiAgfVxufVxudmFyIERlZmF1bHRHZW5lcmF0ZU9iamVjdFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMub2JqZWN0ID0gb3B0aW9ucy5vYmplY3Q7XG4gICAgdGhpcy5maW5pc2hSZWFzb24gPSBvcHRpb25zLmZpbmlzaFJlYXNvbjtcbiAgICB0aGlzLnVzYWdlID0gb3B0aW9ucy51c2FnZTtcbiAgICB0aGlzLndhcm5pbmdzID0gb3B0aW9ucy53YXJuaW5ncztcbiAgICB0aGlzLnByb3ZpZGVyTWV0YWRhdGEgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgdGhpcy5yZXNwb25zZSA9IG9wdGlvbnMucmVzcG9uc2U7XG4gICAgdGhpcy5yZXF1ZXN0ID0gb3B0aW9ucy5yZXF1ZXN0O1xuICAgIHRoaXMucmVhc29uaW5nID0gb3B0aW9ucy5yZWFzb25pbmc7XG4gIH1cbiAgdG9Kc29uUmVzcG9uc2UoaW5pdCkge1xuICAgIHZhciBfYTIxO1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5vYmplY3QpLCB7XG4gICAgICBzdGF0dXM6IChfYTIxID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpICE9IG51bGwgPyBfYTIxIDogMjAwLFxuICAgICAgaGVhZGVyczogcHJlcGFyZUhlYWRlcnMoaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzLCB7XG4gICAgICAgIFwiY29udGVudC10eXBlXCI6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvZ2VuZXJhdGUtb2JqZWN0L3N0cmVhbS1vYmplY3QudHNcbmltcG9ydCB7XG4gIGNyZWF0ZUlkR2VuZXJhdG9yIGFzIGNyZWF0ZUlkR2VuZXJhdG9yNCxcbiAgRGVsYXllZFByb21pc2UgYXMgRGVsYXllZFByb21pc2UyXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy91dGlsL2Nvc2luZS1zaW1pbGFyaXR5LnRzXG5mdW5jdGlvbiBjb3NpbmVTaW1pbGFyaXR5KHZlY3RvcjEsIHZlY3RvcjIpIHtcbiAgaWYgKHZlY3RvcjEubGVuZ3RoICE9PSB2ZWN0b3IyLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICBwYXJhbWV0ZXI6IFwidmVjdG9yMSx2ZWN0b3IyXCIsXG4gICAgICB2YWx1ZTogeyB2ZWN0b3IxTGVuZ3RoOiB2ZWN0b3IxLmxlbmd0aCwgdmVjdG9yMkxlbmd0aDogdmVjdG9yMi5sZW5ndGggfSxcbiAgICAgIG1lc3NhZ2U6IGBWZWN0b3JzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhgXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbiA9IHZlY3RvcjEubGVuZ3RoO1xuICBpZiAobiA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGxldCBtYWduaXR1ZGVTcXVhcmVkMSA9IDA7XG4gIGxldCBtYWduaXR1ZGVTcXVhcmVkMiA9IDA7XG4gIGxldCBkb3RQcm9kdWN0ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBjb25zdCB2YWx1ZTEgPSB2ZWN0b3IxW2ldO1xuICAgIGNvbnN0IHZhbHVlMiA9IHZlY3RvcjJbaV07XG4gICAgbWFnbml0dWRlU3F1YXJlZDEgKz0gdmFsdWUxICogdmFsdWUxO1xuICAgIG1hZ25pdHVkZVNxdWFyZWQyICs9IHZhbHVlMiAqIHZhbHVlMjtcbiAgICBkb3RQcm9kdWN0ICs9IHZhbHVlMSAqIHZhbHVlMjtcbiAgfVxuICByZXR1cm4gbWFnbml0dWRlU3F1YXJlZDEgPT09IDAgfHwgbWFnbml0dWRlU3F1YXJlZDIgPT09IDAgPyAwIDogZG90UHJvZHVjdCAvIChNYXRoLnNxcnQobWFnbml0dWRlU3F1YXJlZDEpICogTWF0aC5zcXJ0KG1hZ25pdHVkZVNxdWFyZWQyKSk7XG59XG5cbi8vIHNyYy91dGlsL2Rvd25sb2FkL2NyZWF0ZS1kb3dubG9hZC50c1xuZnVuY3Rpb24gY3JlYXRlRG93bmxvYWQob3B0aW9ucykge1xuICByZXR1cm4gKHsgdXJsLCBhYm9ydFNpZ25hbCB9KSA9PiBkb3dubG9hZCh7IHVybCwgbWF4Qnl0ZXM6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubWF4Qnl0ZXMsIGFib3J0U2lnbmFsIH0pO1xufVxuXG4vLyBzcmMvdXRpbC9kYXRhLXVybC50c1xuZnVuY3Rpb24gZ2V0VGV4dEZyb21EYXRhVXJsKGRhdGFVcmwpIHtcbiAgY29uc3QgW2hlYWRlciwgYmFzZTY0Q29udGVudF0gPSBkYXRhVXJsLnNwbGl0KFwiLFwiKTtcbiAgY29uc3QgbWVkaWFUeXBlID0gaGVhZGVyLnNwbGl0KFwiO1wiKVswXS5zcGxpdChcIjpcIilbMV07XG4gIGlmIChtZWRpYVR5cGUgPT0gbnVsbCB8fCBiYXNlNjRDb250ZW50ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgVVJMIGZvcm1hdFwiKTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cuYXRvYihiYXNlNjRDb250ZW50KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGRlY29kaW5nIGRhdGEgVVJMYCk7XG4gIH1cbn1cblxuLy8gc3JjL3V0aWwvaXMtZGVlcC1lcXVhbC1kYXRhLnRzXG5mdW5jdGlvbiBpc0RlZXBFcXVhbERhdGEob2JqMSwgb2JqMikge1xuICBpZiAob2JqMSA9PT0gb2JqMilcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKG9iajEgPT0gbnVsbCB8fCBvYmoyID09IG51bGwpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIG9iajEgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iajIgIT09IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuIG9iajEgPT09IG9iajI7XG4gIGlmIChvYmoxLmNvbnN0cnVjdG9yICE9PSBvYmoyLmNvbnN0cnVjdG9yKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKG9iajEgaW5zdGFuY2VvZiBEYXRlICYmIG9iajIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIG9iajEuZ2V0VGltZSgpID09PSBvYmoyLmdldFRpbWUoKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShvYmoxKSkge1xuICAgIGlmIChvYmoxLmxlbmd0aCAhPT0gb2JqMi5sZW5ndGgpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmoxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWlzRGVlcEVxdWFsRGF0YShvYmoxW2ldLCBvYmoyW2ldKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBrZXlzMSA9IE9iamVjdC5rZXlzKG9iajEpO1xuICBjb25zdCBrZXlzMiA9IE9iamVjdC5rZXlzKG9iajIpO1xuICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzMSkge1xuICAgIGlmICgha2V5czIuaW5jbHVkZXMoa2V5KSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWlzRGVlcEVxdWFsRGF0YShvYmoxW2tleV0sIG9iajJba2V5XSkpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIHNyYy91dGlsL3NlcmlhbC1qb2ItZXhlY3V0b3IudHNcbnZhciBTZXJpYWxKb2JFeGVjdXRvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIHRoaXMuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc1F1ZXVlKCkge1xuICAgIGlmICh0aGlzLmlzUHJvY2Vzc2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzUHJvY2Vzc2luZyA9IHRydWU7XG4gICAgd2hpbGUgKHRoaXMucXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgYXdhaXQgdGhpcy5xdWV1ZVswXSgpO1xuICAgICAgdGhpcy5xdWV1ZS5zaGlmdCgpO1xuICAgIH1cbiAgICB0aGlzLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICB9XG4gIGFzeW5jIHJ1bihqb2IpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUzLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucXVldWUucHVzaChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgam9iKCk7XG4gICAgICAgICAgcmVzb2x2ZTMoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZvaWQgdGhpcy5wcm9jZXNzUXVldWUoKTtcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWwvc2ltdWxhdGUtcmVhZGFibGUtc3RyZWFtLnRzXG5pbXBvcnQgeyBkZWxheSBhcyBkZWxheUZ1bmN0aW9uIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmZ1bmN0aW9uIHNpbXVsYXRlUmVhZGFibGVTdHJlYW0oe1xuICBjaHVua3MsXG4gIGluaXRpYWxEZWxheUluTXMgPSAwLFxuICBjaHVua0RlbGF5SW5NcyA9IDAsXG4gIF9pbnRlcm5hbFxufSkge1xuICB2YXIgX2EyMTtcbiAgY29uc3QgZGVsYXkyID0gKF9hMjEgPSBfaW50ZXJuYWwgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnRlcm5hbC5kZWxheSkgIT0gbnVsbCA/IF9hMjEgOiBkZWxheUZ1bmN0aW9uO1xuICBsZXQgaW5kZXggPSAwO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIGlmIChpbmRleCA8IGNodW5rcy5sZW5ndGgpIHtcbiAgICAgICAgYXdhaXQgZGVsYXkyKGluZGV4ID09PSAwID8gaW5pdGlhbERlbGF5SW5NcyA6IGNodW5rRGVsYXlJbk1zKTtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rc1tpbmRleCsrXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2dlbmVyYXRlLW9iamVjdC9zdHJlYW0tb2JqZWN0LnRzXG52YXIgb3JpZ2luYWxHZW5lcmF0ZUlkNCA9IGNyZWF0ZUlkR2VuZXJhdG9yNCh7IHByZWZpeDogXCJhaW9ialwiLCBzaXplOiAyNCB9KTtcbmZ1bmN0aW9uIHN0cmVhbU9iamVjdChvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBtb2RlbCxcbiAgICBvdXRwdXQgPSBcIm9iamVjdFwiLFxuICAgIHN5c3RlbSxcbiAgICBwcm9tcHQsXG4gICAgbWVzc2FnZXMsXG4gICAgbWF4UmV0cmllcyxcbiAgICBhYm9ydFNpZ25hbCxcbiAgICBoZWFkZXJzLFxuICAgIGV4cGVyaW1lbnRhbF9yZXBhaXJUZXh0OiByZXBhaXJUZXh0LFxuICAgIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeSxcbiAgICBleHBlcmltZW50YWxfZG93bmxvYWQ6IGRvd25sb2FkMixcbiAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgb25FcnJvciA9ICh7IGVycm9yIH0pID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH0sXG4gICAgb25GaW5pc2gsXG4gICAgX2ludGVybmFsOiB7XG4gICAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMiA9IG9yaWdpbmFsR2VuZXJhdGVJZDQsXG4gICAgICBjdXJyZW50RGF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgbm93OiBub3cyID0gbm93XG4gICAgfSA9IHt9LFxuICAgIC4uLnNldHRpbmdzXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBlbnVtVmFsdWVzID0gXCJlbnVtXCIgaW4gb3B0aW9ucyAmJiBvcHRpb25zLmVudW0gPyBvcHRpb25zLmVudW0gOiB2b2lkIDA7XG4gIGNvbnN0IHtcbiAgICBzY2hlbWE6IGlucHV0U2NoZW1hLFxuICAgIHNjaGVtYURlc2NyaXB0aW9uLFxuICAgIHNjaGVtYU5hbWVcbiAgfSA9IFwic2NoZW1hXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcbiAgdmFsaWRhdGVPYmplY3RHZW5lcmF0aW9uSW5wdXQoe1xuICAgIG91dHB1dCxcbiAgICBzY2hlbWE6IGlucHV0U2NoZW1hLFxuICAgIHNjaGVtYU5hbWUsXG4gICAgc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgZW51bVZhbHVlc1xuICB9KTtcbiAgY29uc3Qgb3V0cHV0U3RyYXRlZ3kgPSBnZXRPdXRwdXRTdHJhdGVneSh7XG4gICAgb3V0cHV0LFxuICAgIHNjaGVtYTogaW5wdXRTY2hlbWEsXG4gICAgZW51bVZhbHVlc1xuICB9KTtcbiAgcmV0dXJuIG5ldyBEZWZhdWx0U3RyZWFtT2JqZWN0UmVzdWx0KHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVycyxcbiAgICBzZXR0aW5ncyxcbiAgICBtYXhSZXRyaWVzLFxuICAgIGFib3J0U2lnbmFsLFxuICAgIG91dHB1dFN0cmF0ZWd5LFxuICAgIHN5c3RlbSxcbiAgICBwcm9tcHQsXG4gICAgbWVzc2FnZXMsXG4gICAgc2NoZW1hTmFtZSxcbiAgICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgcmVwYWlyVGV4dCxcbiAgICBvbkVycm9yLFxuICAgIG9uRmluaXNoLFxuICAgIGRvd25sb2FkOiBkb3dubG9hZDIsXG4gICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDIsXG4gICAgY3VycmVudERhdGUsXG4gICAgbm93OiBub3cyXG4gIH0pO1xufVxudmFyIERlZmF1bHRTdHJlYW1PYmplY3RSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtb2RlbDogbW9kZWxBcmcsXG4gICAgaGVhZGVycyxcbiAgICB0ZWxlbWV0cnksXG4gICAgc2V0dGluZ3MsXG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICBhYm9ydFNpZ25hbCxcbiAgICBvdXRwdXRTdHJhdGVneSxcbiAgICBzeXN0ZW0sXG4gICAgcHJvbXB0LFxuICAgIG1lc3NhZ2VzLFxuICAgIHNjaGVtYU5hbWUsXG4gICAgc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgcHJvdmlkZXJPcHRpb25zLFxuICAgIHJlcGFpclRleHQsXG4gICAgb25FcnJvcixcbiAgICBvbkZpbmlzaCxcbiAgICBkb3dubG9hZDogZG93bmxvYWQyLFxuICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQyLFxuICAgIGN1cnJlbnREYXRlLFxuICAgIG5vdzogbm93MlxuICB9KSB7XG4gICAgdGhpcy5fb2JqZWN0ID0gbmV3IERlbGF5ZWRQcm9taXNlMigpO1xuICAgIHRoaXMuX3VzYWdlID0gbmV3IERlbGF5ZWRQcm9taXNlMigpO1xuICAgIHRoaXMuX3Byb3ZpZGVyTWV0YWRhdGEgPSBuZXcgRGVsYXllZFByb21pc2UyKCk7XG4gICAgdGhpcy5fd2FybmluZ3MgPSBuZXcgRGVsYXllZFByb21pc2UyKCk7XG4gICAgdGhpcy5fcmVxdWVzdCA9IG5ldyBEZWxheWVkUHJvbWlzZTIoKTtcbiAgICB0aGlzLl9yZXNwb25zZSA9IG5ldyBEZWxheWVkUHJvbWlzZTIoKTtcbiAgICB0aGlzLl9maW5pc2hSZWFzb24gPSBuZXcgRGVsYXllZFByb21pc2UyKCk7XG4gICAgY29uc3QgbW9kZWwgPSByZXNvbHZlTGFuZ3VhZ2VNb2RlbChtb2RlbEFyZyk7XG4gICAgY29uc3QgeyBtYXhSZXRyaWVzLCByZXRyeSB9ID0gcHJlcGFyZVJldHJpZXMoe1xuICAgICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICAgIGFib3J0U2lnbmFsXG4gICAgfSk7XG4gICAgY29uc3QgY2FsbFNldHRpbmdzID0gcHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICBtb2RlbCxcbiAgICAgIHRlbGVtZXRyeSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzZXR0aW5nczogeyAuLi5jYWxsU2V0dGluZ3MsIG1heFJldHJpZXMgfVxuICAgIH0pO1xuICAgIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcih0ZWxlbWV0cnkpO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IHN0aXRjaGFibGVTdHJlYW0gPSBjcmVhdGVTdGl0Y2hhYmxlU3RyZWFtKCk7XG4gICAgY29uc3QgZXZlbnRQcm9jZXNzb3IgPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgb25FcnJvcih7IGVycm9yOiB3cmFwR2F0ZXdheUVycm9yKGNodW5rLmVycm9yKSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYmFzZVN0cmVhbSA9IHN0aXRjaGFibGVTdHJlYW0uc3RyZWFtLnBpcGVUaHJvdWdoKGV2ZW50UHJvY2Vzc29yKTtcbiAgICByZWNvcmRTcGFuKHtcbiAgICAgIG5hbWU6IFwiYWkuc3RyZWFtT2JqZWN0XCIsXG4gICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLnN0cmVhbU9iamVjdFwiLFxuICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgfSksXG4gICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICAgIFwiYWkucHJvbXB0XCI6IHtcbiAgICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJhaS5zY2hlbWFcIjoge1xuICAgICAgICAgICAgaW5wdXQ6IGFzeW5jICgpID0+IEpTT04uc3RyaW5naWZ5KGF3YWl0IG91dHB1dFN0cmF0ZWd5Lmpzb25TY2hlbWEoKSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiYWkuc2NoZW1hLm5hbWVcIjogc2NoZW1hTmFtZSxcbiAgICAgICAgICBcImFpLnNjaGVtYS5kZXNjcmlwdGlvblwiOiBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICAgICAgICBcImFpLnNldHRpbmdzLm91dHB1dFwiOiBvdXRwdXRTdHJhdGVneS50eXBlXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgdHJhY2VyLFxuICAgICAgZW5kV2hlbkRvbmU6IGZhbHNlLFxuICAgICAgZm46IGFzeW5jIChyb290U3BhbikgPT4ge1xuICAgICAgICBjb25zdCBzdGFuZGFyZGl6ZWRQcm9tcHQgPSBhd2FpdCBzdGFuZGFyZGl6ZVByb21wdCh7XG4gICAgICAgICAgc3lzdGVtLFxuICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICBtZXNzYWdlc1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2FsbE9wdGlvbnMgPSB7XG4gICAgICAgICAgcmVzcG9uc2VGb3JtYXQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFwianNvblwiLFxuICAgICAgICAgICAgc2NoZW1hOiBhd2FpdCBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hKCksXG4gICAgICAgICAgICBuYW1lOiBzY2hlbWFOYW1lLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHNjaGVtYURlc2NyaXB0aW9uXG4gICAgICAgICAgfSxcbiAgICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgICBwcm9tcHQ6IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICAgICAgcHJvbXB0OiBzdGFuZGFyZGl6ZWRQcm9tcHQsXG4gICAgICAgICAgICBzdXBwb3J0ZWRVcmxzOiBhd2FpdCBtb2RlbC5zdXBwb3J0ZWRVcmxzLFxuICAgICAgICAgICAgZG93bmxvYWQ6IGRvd25sb2FkMlxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHByb3ZpZGVyT3B0aW9ucyxcbiAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIGluY2x1ZGVSYXdDaHVua3M6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVyID0ge1xuICAgICAgICAgIHRyYW5zZm9ybTogKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsuZGVsdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwicmVzcG9uc2UtbWV0YWRhdGFcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInN0cmVhbS1zdGFydFwiOlxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcmVzdWx0OiB7IHN0cmVhbSwgcmVzcG9uc2UsIHJlcXVlc3QgfSxcbiAgICAgICAgICBkb1N0cmVhbVNwYW4sXG4gICAgICAgICAgc3RhcnRUaW1lc3RhbXBNc1xuICAgICAgICB9ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICAgKCkgPT4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICBuYW1lOiBcImFpLnN0cmVhbU9iamVjdC5kb1N0cmVhbVwiLFxuICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5zdHJlYW1PYmplY3QuZG9TdHJlYW1cIixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0Lm1lc3NhZ2VzXCI6IHtcbiAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBzdHJpbmdpZnlGb3JUZWxlbWV0cnkoY2FsbE9wdGlvbnMucHJvbXB0KVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnN5c3RlbVwiOiBtb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1vZGVsXCI6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5mcmVxdWVuY3lfcGVuYWx0eVwiOiBjYWxsU2V0dGluZ3MuZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1heF90b2tlbnNcIjogY2FsbFNldHRpbmdzLm1heE91dHB1dFRva2VucyxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnByZXNlbmNlX3BlbmFsdHlcIjogY2FsbFNldHRpbmdzLnByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI6IGNhbGxTZXR0aW5ncy50ZW1wZXJhdHVyZSxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9rXCI6IGNhbGxTZXR0aW5ncy50b3BLLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX3BcIjogY2FsbFNldHRpbmdzLnRvcFBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICBlbmRXaGVuRG9uZTogZmFsc2UsXG4gICAgICAgICAgICBmbjogYXN5bmMgKGRvU3RyZWFtU3BhbjIpID0+ICh7XG4gICAgICAgICAgICAgIHN0YXJ0VGltZXN0YW1wTXM6IG5vdzIoKSxcbiAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuOiBkb1N0cmVhbVNwYW4yLFxuICAgICAgICAgICAgICByZXN1bHQ6IGF3YWl0IG1vZGVsLmRvU3RyZWFtKGNhbGxPcHRpb25zKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBzZWxmLl9yZXF1ZXN0LnJlc29sdmUocmVxdWVzdCAhPSBudWxsID8gcmVxdWVzdCA6IHt9KTtcbiAgICAgICAgbGV0IHdhcm5pbmdzO1xuICAgICAgICBsZXQgdXNhZ2UgPSBjcmVhdGVOdWxsTGFuZ3VhZ2VNb2RlbFVzYWdlKCk7XG4gICAgICAgIGxldCBmaW5pc2hSZWFzb247XG4gICAgICAgIGxldCBwcm92aWRlck1ldGFkYXRhO1xuICAgICAgICBsZXQgb2JqZWN0MjtcbiAgICAgICAgbGV0IGVycm9yO1xuICAgICAgICBsZXQgYWNjdW11bGF0ZWRUZXh0ID0gXCJcIjtcbiAgICAgICAgbGV0IHRleHREZWx0YSA9IFwiXCI7XG4gICAgICAgIGxldCBmdWxsUmVzcG9uc2UgPSB7XG4gICAgICAgICAgaWQ6IGdlbmVyYXRlSWQyKCksXG4gICAgICAgICAgdGltZXN0YW1wOiBjdXJyZW50RGF0ZSgpLFxuICAgICAgICAgIG1vZGVsSWQ6IG1vZGVsLm1vZGVsSWRcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGxhdGVzdE9iamVjdEpzb24gPSB2b2lkIDA7XG4gICAgICAgIGxldCBsYXRlc3RPYmplY3QgPSB2b2lkIDA7XG4gICAgICAgIGxldCBpc0ZpcnN0Q2h1bmsgPSB0cnVlO1xuICAgICAgICBsZXQgaXNGaXJzdERlbHRhID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRTdHJlYW0gPSBzdHJlYW0ucGlwZVRocm91Z2gobmV3IFRyYW5zZm9ybVN0cmVhbSh0cmFuc2Zvcm1lcikpLnBpcGVUaHJvdWdoKFxuICAgICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgIHZhciBfYTIxLCBfYiwgX2M7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09IFwib2JqZWN0XCIgJiYgY2h1bmsudHlwZSA9PT0gXCJzdHJlYW0tc3RhcnRcIikge1xuICAgICAgICAgICAgICAgIHdhcm5pbmdzID0gY2h1bmsud2FybmluZ3M7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc0ZpcnN0Q2h1bmspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtc1RvRmlyc3RDaHVuayA9IG5vdzIoKSAtIHN0YXJ0VGltZXN0YW1wTXM7XG4gICAgICAgICAgICAgICAgaXNGaXJzdENodW5rID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLmFkZEV2ZW50KFwiYWkuc3RyZWFtLmZpcnN0Q2h1bmtcIiwge1xuICAgICAgICAgICAgICAgICAgXCJhaS5zdHJlYW0ubXNUb0ZpcnN0Q2h1bmtcIjogbXNUb0ZpcnN0Q2h1bmtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICBcImFpLnN0cmVhbS5tc1RvRmlyc3RDaHVua1wiOiBtc1RvRmlyc3RDaHVua1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRlZFRleHQgKz0gY2h1bms7XG4gICAgICAgICAgICAgICAgdGV4dERlbHRhICs9IGNodW5rO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdmFsdWU6IGN1cnJlbnRPYmplY3RKc29uLCBzdGF0ZTogcGFyc2VTdGF0ZSB9ID0gYXdhaXQgcGFyc2VQYXJ0aWFsSnNvbihhY2N1bXVsYXRlZFRleHQpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50T2JqZWN0SnNvbiAhPT0gdm9pZCAwICYmICFpc0RlZXBFcXVhbERhdGEobGF0ZXN0T2JqZWN0SnNvbiwgY3VycmVudE9iamVjdEpzb24pKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gYXdhaXQgb3V0cHV0U3RyYXRlZ3kudmFsaWRhdGVQYXJ0aWFsUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGN1cnJlbnRPYmplY3RKc29uLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0RGVsdGEsXG4gICAgICAgICAgICAgICAgICAgIGxhdGVzdE9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgaXNGaXJzdERlbHRhLFxuICAgICAgICAgICAgICAgICAgICBpc0ZpbmFsRGVsdGE6IHBhcnNlU3RhdGUgPT09IFwic3VjY2Vzc2Z1bC1wYXJzZVwiXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MgJiYgIWlzRGVlcEVxdWFsRGF0YShcbiAgICAgICAgICAgICAgICAgICAgbGF0ZXN0T2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnZhbHVlLnBhcnRpYWxcbiAgICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF0ZXN0T2JqZWN0SnNvbiA9IGN1cnJlbnRPYmplY3RKc29uO1xuICAgICAgICAgICAgICAgICAgICBsYXRlc3RPYmplY3QgPSB2YWxpZGF0aW9uUmVzdWx0LnZhbHVlLnBhcnRpYWw7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IGxhdGVzdE9iamVjdFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHQtZGVsdGFcIixcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0RGVsdGE6IHZhbGlkYXRpb25SZXN1bHQudmFsdWUudGV4dERlbHRhXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0RGVsdGEgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBpc0ZpcnN0RGVsdGEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXNwb25zZS1tZXRhZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgICBmdWxsUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAoX2EyMSA9IGNodW5rLmlkKSAhPSBudWxsID8gX2EyMSA6IGZ1bGxSZXNwb25zZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiAoX2IgPSBjaHVuay50aW1lc3RhbXApICE9IG51bGwgPyBfYiA6IGZ1bGxSZXNwb25zZS50aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsSWQ6IChfYyA9IGNodW5rLm1vZGVsSWQpICE9IG51bGwgPyBfYyA6IGZ1bGxSZXNwb25zZS5tb2RlbElkXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjoge1xuICAgICAgICAgICAgICAgICAgaWYgKHRleHREZWx0YSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInRleHQtZGVsdGFcIiwgdGV4dERlbHRhIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uID0gY2h1bmsuZmluaXNoUmVhc29uLnVuaWZpZWQ7XG4gICAgICAgICAgICAgICAgICB1c2FnZSA9IGFzTGFuZ3VhZ2VNb2RlbFVzYWdlKGNodW5rLnVzYWdlKTtcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGEgPSBjaHVuay5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY2h1bmssXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogY2h1bmsuZmluaXNoUmVhc29uLnVuaWZpZWQsXG4gICAgICAgICAgICAgICAgICAgIHVzYWdlLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogZnVsbFJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGxvZ1dhcm5pbmdzKHtcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZ3M6IHdhcm5pbmdzICE9IG51bGwgPyB3YXJuaW5ncyA6IFtdLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsOiBtb2RlbC5tb2RlbElkXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHNlbGYuX3VzYWdlLnJlc29sdmUodXNhZ2UpO1xuICAgICAgICAgICAgICAgICAgc2VsZi5fcHJvdmlkZXJNZXRhZGF0YS5yZXNvbHZlKHByb3ZpZGVyTWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgICAgc2VsZi5fd2FybmluZ3MucmVzb2x2ZSh3YXJuaW5ncyk7XG4gICAgICAgICAgICAgICAgICBzZWxmLl9yZXNwb25zZS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZnVsbFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZSA9PSBudWxsID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBzZWxmLl9maW5pc2hSZWFzb24ucmVzb2x2ZShmaW5pc2hSZWFzb24gIT0gbnVsbCA/IGZpbmlzaFJlYXNvbiA6IFwib3RoZXJcIik7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3QyID0gYXdhaXQgcGFyc2VBbmRWYWxpZGF0ZU9iamVjdFJlc3VsdFdpdGhSZXBhaXIoXG4gICAgICAgICAgICAgICAgICAgICAgYWNjdW11bGF0ZWRUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFN0cmF0ZWd5LFxuICAgICAgICAgICAgICAgICAgICAgIHJlcGFpclRleHQsXG4gICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IGZ1bGxSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9vYmplY3QucmVzb2x2ZShvYmplY3QyKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9vYmplY3QucmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBpbnZva2Ugb25GaW5pc2ggY2FsbGJhY2sgYW5kIHJlc29sdmUgdG9vbFJlc3VsdHMgcHJvbWlzZSB3aGVuIHRoZSBzdHJlYW0gaXMgYWJvdXQgdG8gY2xvc2U6XG4gICAgICAgICAgICBhc3luYyBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmluYWxVc2FnZSA9IHVzYWdlICE9IG51bGwgPyB1c2FnZSA6IHtcbiAgICAgICAgICAgICAgICAgIHByb21wdFRva2VuczogTmFOLFxuICAgICAgICAgICAgICAgICAgY29tcGxldGlvblRva2VuczogTmFOLFxuICAgICAgICAgICAgICAgICAgdG90YWxUb2tlbnM6IE5hTlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICBhd2FpdCBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2Uub2JqZWN0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob2JqZWN0MilcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuaWRcIjogZnVsbFJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogZnVsbFJlc3BvbnNlLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50aW1lc3RhbXBcIjogZnVsbFJlc3BvbnNlLnRpbWVzdGFtcC50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YVwiOiBKU09OLnN0cmluZ2lmeShwcm92aWRlck1ldGFkYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmlucHV0VG9rZW5zXCI6IGZpbmFsVXNhZ2UuaW5wdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5vdXRwdXRUb2tlbnNcIjogZmluYWxVc2FnZS5vdXRwdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS50b3RhbFRva2Vuc1wiOiBmaW5hbFVzYWdlLnRvdGFsVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucmVhc29uaW5nVG9rZW5zXCI6IGZpbmFsVXNhZ2UucmVhc29uaW5nVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY2FjaGVkSW5wdXRUb2tlbnNcIjogZmluYWxVc2FnZS5jYWNoZWRJbnB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuZmluaXNoX3JlYXNvbnNcIjogW2ZpbmlzaFJlYXNvbl0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuaWRcIjogZnVsbFJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLm1vZGVsXCI6IGZ1bGxSZXNwb25zZS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmlucHV0X3Rva2Vuc1wiOiBmaW5hbFVzYWdlLmlucHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogZmluYWxVc2FnZS5vdXRwdXRUb2tlbnNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5lbmQoKTtcbiAgICAgICAgICAgICAgICByb290U3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgICAgYXdhaXQgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuaW5wdXRUb2tlbnNcIjogZmluYWxVc2FnZS5pbnB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLm91dHB1dFRva2Vuc1wiOiBmaW5hbFVzYWdlLm91dHB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnRvdGFsVG9rZW5zXCI6IGZpbmFsVXNhZ2UudG90YWxUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5yZWFzb25pbmdUb2tlbnNcIjogZmluYWxVc2FnZS5yZWFzb25pbmdUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jYWNoZWRJbnB1dFRva2Vuc1wiOiBmaW5hbFVzYWdlLmNhY2hlZElucHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2Uub2JqZWN0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob2JqZWN0MilcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YVwiOiBKU09OLnN0cmluZ2lmeShwcm92aWRlck1ldGFkYXRhKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYXdhaXQgKG9uRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvbkZpbmlzaCh7XG4gICAgICAgICAgICAgICAgICB1c2FnZTogZmluYWxVc2FnZSxcbiAgICAgICAgICAgICAgICAgIG9iamVjdDogb2JqZWN0MixcbiAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZnVsbFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZSA9PSBudWxsID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHdhcm5pbmdzLFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJlcnJvclwiLCBlcnJvcjogZXJyb3IyIH0pO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJvb3RTcGFuLmVuZCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgc3RpdGNoYWJsZVN0cmVhbS5hZGRTdHJlYW0odHJhbnNmb3JtZWRTdHJlYW0pO1xuICAgICAgfVxuICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgc3RpdGNoYWJsZVN0cmVhbS5hZGRTdHJlYW0oXG4gICAgICAgIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJlcnJvclwiLCBlcnJvciB9KTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgc3RpdGNoYWJsZVN0cmVhbS5jbG9zZSgpO1xuICAgIH0pO1xuICAgIHRoaXMub3V0cHV0U3RyYXRlZ3kgPSBvdXRwdXRTdHJhdGVneTtcbiAgfVxuICBnZXQgb2JqZWN0KCkge1xuICAgIHJldHVybiB0aGlzLl9vYmplY3QucHJvbWlzZTtcbiAgfVxuICBnZXQgdXNhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzYWdlLnByb21pc2U7XG4gIH1cbiAgZ2V0IHByb3ZpZGVyTWV0YWRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb3ZpZGVyTWV0YWRhdGEucHJvbWlzZTtcbiAgfVxuICBnZXQgd2FybmluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dhcm5pbmdzLnByb21pc2U7XG4gIH1cbiAgZ2V0IHJlcXVlc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QucHJvbWlzZTtcbiAgfVxuICBnZXQgcmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc3BvbnNlLnByb21pc2U7XG4gIH1cbiAgZ2V0IGZpbmlzaFJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZmluaXNoUmVhc29uLnByb21pc2U7XG4gIH1cbiAgZ2V0IHBhcnRpYWxPYmplY3RTdHJlYW0oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oXG4gICAgICB0aGlzLmJhc2VTdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsub2JqZWN0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBjaHVuaztcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNodW5rIHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGdldCBlbGVtZW50U3RyZWFtKCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dFN0cmF0ZWd5LmNyZWF0ZUVsZW1lbnRTdHJlYW0odGhpcy5iYXNlU3RyZWFtKTtcbiAgfVxuICBnZXQgdGV4dFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShcbiAgICAgIHRoaXMuYmFzZVN0cmVhbS5waXBlVGhyb3VnaChcbiAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsudGV4dERlbHRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IGNodW5rO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY2h1bmsgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgZ2V0IGZ1bGxTdHJlYW0oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0odGhpcy5iYXNlU3RyZWFtKTtcbiAgfVxuICBwaXBlVGV4dFN0cmVhbVRvUmVzcG9uc2UocmVzcG9uc2UsIGluaXQpIHtcbiAgICBwaXBlVGV4dFN0cmVhbVRvUmVzcG9uc2Uoe1xuICAgICAgcmVzcG9uc2UsXG4gICAgICB0ZXh0U3RyZWFtOiB0aGlzLnRleHRTdHJlYW0sXG4gICAgICAuLi5pbml0XG4gICAgfSk7XG4gIH1cbiAgdG9UZXh0U3RyZWFtUmVzcG9uc2UoaW5pdCkge1xuICAgIHJldHVybiBjcmVhdGVUZXh0U3RyZWFtUmVzcG9uc2Uoe1xuICAgICAgdGV4dFN0cmVhbTogdGhpcy50ZXh0U3RyZWFtLFxuICAgICAgLi4uaW5pdFxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvZ2VuZXJhdGUtc3BlZWNoL2dlbmVyYXRlLXNwZWVjaC50c1xuaW1wb3J0IHsgd2l0aFVzZXJBZ2VudFN1ZmZpeCBhcyB3aXRoVXNlckFnZW50U3VmZml4NyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy9nZW5lcmF0ZS1zcGVlY2gvZ2VuZXJhdGVkLWF1ZGlvLWZpbGUudHNcbnZhciBEZWZhdWx0R2VuZXJhdGVkQXVkaW9GaWxlID0gY2xhc3MgZXh0ZW5kcyBEZWZhdWx0R2VuZXJhdGVkRmlsZSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkYXRhLFxuICAgIG1lZGlhVHlwZVxuICB9KSB7XG4gICAgc3VwZXIoeyBkYXRhLCBtZWRpYVR5cGUgfSk7XG4gICAgbGV0IGZvcm1hdCA9IFwibXAzXCI7XG4gICAgaWYgKG1lZGlhVHlwZSkge1xuICAgICAgY29uc3QgbWVkaWFUeXBlUGFydHMgPSBtZWRpYVR5cGUuc3BsaXQoXCIvXCIpO1xuICAgICAgaWYgKG1lZGlhVHlwZVBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBpZiAobWVkaWFUeXBlICE9PSBcImF1ZGlvL21wZWdcIikge1xuICAgICAgICAgIGZvcm1hdCA9IG1lZGlhVHlwZVBhcnRzWzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZm9ybWF0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQXVkaW8gZm9ybWF0IG11c3QgYmUgcHJvdmlkZWQgb3IgZGV0ZXJtaW5hYmxlIGZyb20gbWVkaWEgdHlwZVwiXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcbiAgfVxufTtcblxuLy8gc3JjL2dlbmVyYXRlLXNwZWVjaC9nZW5lcmF0ZS1zcGVlY2gudHNcbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlU3BlZWNoKHtcbiAgbW9kZWwsXG4gIHRleHQ6IHRleHQyLFxuICB2b2ljZSxcbiAgb3V0cHV0Rm9ybWF0LFxuICBpbnN0cnVjdGlvbnMsXG4gIHNwZWVkLFxuICBsYW5ndWFnZSxcbiAgcHJvdmlkZXJPcHRpb25zID0ge30sXG4gIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzXG59KSB7XG4gIHZhciBfYTIxO1xuICBjb25zdCByZXNvbHZlZE1vZGVsID0gcmVzb2x2ZVNwZWVjaE1vZGVsKG1vZGVsKTtcbiAgaWYgKCFyZXNvbHZlZE1vZGVsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTW9kZWwgY291bGQgbm90IGJlIHJlc29sdmVkXCIpO1xuICB9XG4gIGNvbnN0IGhlYWRlcnNXaXRoVXNlckFnZW50ID0gd2l0aFVzZXJBZ2VudFN1ZmZpeDcoXG4gICAgaGVhZGVycyAhPSBudWxsID8gaGVhZGVycyA6IHt9LFxuICAgIGBhaS8ke1ZFUlNJT059YFxuICApO1xuICBjb25zdCB7IHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7XG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICBhYm9ydFNpZ25hbFxuICB9KTtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmV0cnkoXG4gICAgKCkgPT4gcmVzb2x2ZWRNb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgIHRleHQ6IHRleHQyLFxuICAgICAgdm9pY2UsXG4gICAgICBvdXRwdXRGb3JtYXQsXG4gICAgICBpbnN0cnVjdGlvbnMsXG4gICAgICBzcGVlZCxcbiAgICAgIGxhbmd1YWdlLFxuICAgICAgYWJvcnRTaWduYWwsXG4gICAgICBoZWFkZXJzOiBoZWFkZXJzV2l0aFVzZXJBZ2VudCxcbiAgICAgIHByb3ZpZGVyT3B0aW9uc1xuICAgIH0pXG4gICk7XG4gIGlmICghcmVzdWx0LmF1ZGlvIHx8IHJlc3VsdC5hdWRpby5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgTm9TcGVlY2hHZW5lcmF0ZWRFcnJvcih7IHJlc3BvbnNlczogW3Jlc3VsdC5yZXNwb25zZV0gfSk7XG4gIH1cbiAgbG9nV2FybmluZ3Moe1xuICAgIHdhcm5pbmdzOiByZXN1bHQud2FybmluZ3MsXG4gICAgcHJvdmlkZXI6IHJlc29sdmVkTW9kZWwucHJvdmlkZXIsXG4gICAgbW9kZWw6IHJlc29sdmVkTW9kZWwubW9kZWxJZFxuICB9KTtcbiAgcmV0dXJuIG5ldyBEZWZhdWx0U3BlZWNoUmVzdWx0KHtcbiAgICBhdWRpbzogbmV3IERlZmF1bHRHZW5lcmF0ZWRBdWRpb0ZpbGUoe1xuICAgICAgZGF0YTogcmVzdWx0LmF1ZGlvLFxuICAgICAgbWVkaWFUeXBlOiAoX2EyMSA9IGRldGVjdE1lZGlhVHlwZSh7XG4gICAgICAgIGRhdGE6IHJlc3VsdC5hdWRpbyxcbiAgICAgICAgc2lnbmF0dXJlczogYXVkaW9NZWRpYVR5cGVTaWduYXR1cmVzXG4gICAgICB9KSkgIT0gbnVsbCA/IF9hMjEgOiBcImF1ZGlvL21wM1wiXG4gICAgfSksXG4gICAgd2FybmluZ3M6IHJlc3VsdC53YXJuaW5ncyxcbiAgICByZXNwb25zZXM6IFtyZXN1bHQucmVzcG9uc2VdLFxuICAgIHByb3ZpZGVyTWV0YWRhdGE6IHJlc3VsdC5wcm92aWRlck1ldGFkYXRhXG4gIH0pO1xufVxudmFyIERlZmF1bHRTcGVlY2hSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EyMTtcbiAgICB0aGlzLmF1ZGlvID0gb3B0aW9ucy5hdWRpbztcbiAgICB0aGlzLndhcm5pbmdzID0gb3B0aW9ucy53YXJuaW5ncztcbiAgICB0aGlzLnJlc3BvbnNlcyA9IG9wdGlvbnMucmVzcG9uc2VzO1xuICAgIHRoaXMucHJvdmlkZXJNZXRhZGF0YSA9IChfYTIxID0gb3B0aW9ucy5wcm92aWRlck1ldGFkYXRhKSAhPSBudWxsID8gX2EyMSA6IHt9O1xuICB9XG59O1xuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9wcnVuZS1tZXNzYWdlcy50c1xuZnVuY3Rpb24gcHJ1bmVNZXNzYWdlcyh7XG4gIG1lc3NhZ2VzLFxuICByZWFzb25pbmcgPSBcIm5vbmVcIixcbiAgdG9vbENhbGxzID0gW10sXG4gIGVtcHR5TWVzc2FnZXMgPSBcInJlbW92ZVwiXG59KSB7XG4gIGlmIChyZWFzb25pbmcgPT09IFwiYWxsXCIgfHwgcmVhc29uaW5nID09PSBcImJlZm9yZS1sYXN0LW1lc3NhZ2VcIikge1xuICAgIG1lc3NhZ2VzID0gbWVzc2FnZXMubWFwKChtZXNzYWdlLCBtZXNzYWdlSW5kZXgpID0+IHtcbiAgICAgIGlmIChtZXNzYWdlLnJvbGUgIT09IFwiYXNzaXN0YW50XCIgfHwgdHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gXCJzdHJpbmdcIiB8fCByZWFzb25pbmcgPT09IFwiYmVmb3JlLWxhc3QtbWVzc2FnZVwiICYmIG1lc3NhZ2VJbmRleCA9PT0gbWVzc2FnZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1lc3NhZ2UsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5maWx0ZXIoKHBhcnQpID0+IHBhcnQudHlwZSAhPT0gXCJyZWFzb25pbmdcIilcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgaWYgKHRvb2xDYWxscyA9PT0gXCJub25lXCIpIHtcbiAgICB0b29sQ2FsbHMgPSBbXTtcbiAgfSBlbHNlIGlmICh0b29sQ2FsbHMgPT09IFwiYWxsXCIpIHtcbiAgICB0b29sQ2FsbHMgPSBbeyB0eXBlOiBcImFsbFwiIH1dO1xuICB9IGVsc2UgaWYgKHRvb2xDYWxscyA9PT0gXCJiZWZvcmUtbGFzdC1tZXNzYWdlXCIpIHtcbiAgICB0b29sQ2FsbHMgPSBbeyB0eXBlOiBcImJlZm9yZS1sYXN0LW1lc3NhZ2VcIiB9XTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdG9vbENhbGxzID09PSBcInN0cmluZ1wiKSB7XG4gICAgdG9vbENhbGxzID0gW3sgdHlwZTogdG9vbENhbGxzIH1dO1xuICB9XG4gIGZvciAoY29uc3QgdG9vbENhbGwgb2YgdG9vbENhbGxzKSB7XG4gICAgY29uc3Qga2VlcExhc3RNZXNzYWdlc0NvdW50ID0gdG9vbENhbGwudHlwZSA9PT0gXCJhbGxcIiA/IHZvaWQgMCA6IHRvb2xDYWxsLnR5cGUgPT09IFwiYmVmb3JlLWxhc3QtbWVzc2FnZVwiID8gMSA6IE51bWJlcihcbiAgICAgIHRvb2xDYWxsLnR5cGUuc2xpY2UoXCJiZWZvcmUtbGFzdC1cIi5sZW5ndGgpLnNsaWNlKDAsIC1cIi1tZXNzYWdlc1wiLmxlbmd0aClcbiAgICApO1xuICAgIGNvbnN0IGtlcHRUb29sQ2FsbElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3Qga2VwdEFwcHJvdmFsSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBpZiAoa2VlcExhc3RNZXNzYWdlc0NvdW50ICE9IG51bGwpIHtcbiAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcy5zbGljZSgta2VlcExhc3RNZXNzYWdlc0NvdW50KSkge1xuICAgICAgICBpZiAoKG1lc3NhZ2Uucm9sZSA9PT0gXCJhc3Npc3RhbnRcIiB8fCBtZXNzYWdlLnJvbGUgPT09IFwidG9vbFwiKSAmJiB0eXBlb2YgbWVzc2FnZS5jb250ZW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIG1lc3NhZ2UuY29udGVudCkge1xuICAgICAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0b29sLWNhbGxcIiB8fCBwYXJ0LnR5cGUgPT09IFwidG9vbC1yZXN1bHRcIikge1xuICAgICAgICAgICAgICBrZXB0VG9vbENhbGxJZHMuYWRkKHBhcnQudG9vbENhbGxJZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnQudHlwZSA9PT0gXCJ0b29sLWFwcHJvdmFsLXJlcXVlc3RcIiB8fCBwYXJ0LnR5cGUgPT09IFwidG9vbC1hcHByb3ZhbC1yZXNwb25zZVwiKSB7XG4gICAgICAgICAgICAgIGtlcHRBcHByb3ZhbElkcy5hZGQocGFydC5hcHByb3ZhbElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbWVzc2FnZXMgPSBtZXNzYWdlcy5tYXAoKG1lc3NhZ2UsIG1lc3NhZ2VJbmRleCkgPT4ge1xuICAgICAgaWYgKG1lc3NhZ2Uucm9sZSAhPT0gXCJhc3Npc3RhbnRcIiAmJiBtZXNzYWdlLnJvbGUgIT09IFwidG9vbFwiIHx8IHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIgfHwga2VlcExhc3RNZXNzYWdlc0NvdW50ICYmIG1lc3NhZ2VJbmRleCA+PSBtZXNzYWdlcy5sZW5ndGggLSBrZWVwTGFzdE1lc3NhZ2VzQ291bnQpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICB9XG4gICAgICBjb25zdCB0b29sQ2FsbElkVG9Ub29sTmFtZSA9IHt9O1xuICAgICAgY29uc3QgYXBwcm92YWxJZFRvVG9vbE5hbWUgPSB7fTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1lc3NhZ2UsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5maWx0ZXIoKHBhcnQpID0+IHtcbiAgICAgICAgICBpZiAocGFydC50eXBlICE9PSBcInRvb2wtY2FsbFwiICYmIHBhcnQudHlwZSAhPT0gXCJ0b29sLXJlc3VsdFwiICYmIHBhcnQudHlwZSAhPT0gXCJ0b29sLWFwcHJvdmFsLXJlcXVlc3RcIiAmJiBwYXJ0LnR5cGUgIT09IFwidG9vbC1hcHByb3ZhbC1yZXNwb25zZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0b29sLWNhbGxcIikge1xuICAgICAgICAgICAgdG9vbENhbGxJZFRvVG9vbE5hbWVbcGFydC50b29sQ2FsbElkXSA9IHBhcnQudG9vbE5hbWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwYXJ0LnR5cGUgPT09IFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCIpIHtcbiAgICAgICAgICAgIGFwcHJvdmFsSWRUb1Rvb2xOYW1lW3BhcnQuYXBwcm92YWxJZF0gPSB0b29sQ2FsbElkVG9Ub29sTmFtZVtwYXJ0LnRvb2xDYWxsSWRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKHBhcnQudHlwZSA9PT0gXCJ0b29sLWNhbGxcIiB8fCBwYXJ0LnR5cGUgPT09IFwidG9vbC1yZXN1bHRcIikgJiYga2VwdFRvb2xDYWxsSWRzLmhhcyhwYXJ0LnRvb2xDYWxsSWQpIHx8IChwYXJ0LnR5cGUgPT09IFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCIgfHwgcGFydC50eXBlID09PSBcInRvb2wtYXBwcm92YWwtcmVzcG9uc2VcIikgJiYga2VwdEFwcHJvdmFsSWRzLmhhcyhwYXJ0LmFwcHJvdmFsSWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRvb2xDYWxsLnRvb2xzICE9IG51bGwgJiYgIXRvb2xDYWxsLnRvb2xzLmluY2x1ZGVzKFxuICAgICAgICAgICAgcGFydC50eXBlID09PSBcInRvb2wtY2FsbFwiIHx8IHBhcnQudHlwZSA9PT0gXCJ0b29sLXJlc3VsdFwiID8gcGFydC50b29sTmFtZSA6IGFwcHJvdmFsSWRUb1Rvb2xOYW1lW3BhcnQuYXBwcm92YWxJZF1cbiAgICAgICAgICApO1xuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBpZiAoZW1wdHlNZXNzYWdlcyA9PT0gXCJyZW1vdmVcIikge1xuICAgIG1lc3NhZ2VzID0gbWVzc2FnZXMuZmlsdGVyKChtZXNzYWdlKSA9PiBtZXNzYWdlLmNvbnRlbnQubGVuZ3RoID4gMCk7XG4gIH1cbiAgcmV0dXJuIG1lc3NhZ2VzO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9zbW9vdGgtc3RyZWFtLnRzXG5pbXBvcnQgeyBkZWxheSBhcyBvcmlnaW5hbERlbGF5IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yIGFzIEludmFsaWRBcmd1bWVudEVycm9yMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgQ0hVTktJTkdfUkVHRVhQUyA9IHtcbiAgd29yZDogL1xcUytcXHMrL20sXG4gIGxpbmU6IC9cXG4rL21cbn07XG5mdW5jdGlvbiBzbW9vdGhTdHJlYW0oe1xuICBkZWxheUluTXMgPSAxMCxcbiAgY2h1bmtpbmcgPSBcIndvcmRcIixcbiAgX2ludGVybmFsOiB7IGRlbGF5OiBkZWxheTIgPSBvcmlnaW5hbERlbGF5IH0gPSB7fVxufSA9IHt9KSB7XG4gIGxldCBkZXRlY3RDaHVuaztcbiAgaWYgKGNodW5raW5nICE9IG51bGwgJiYgdHlwZW9mIGNodW5raW5nID09PSBcIm9iamVjdFwiICYmIFwic2VnbWVudFwiIGluIGNodW5raW5nICYmIHR5cGVvZiBjaHVua2luZy5zZWdtZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zdCBzZWdtZW50ZXIgPSBjaHVua2luZztcbiAgICBkZXRlY3RDaHVuayA9IChidWZmZXIpID0+IHtcbiAgICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNvbnN0IGl0ZXJhdG9yID0gc2VnbWVudGVyLnNlZ21lbnQoYnVmZmVyKVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICBjb25zdCBmaXJzdCA9IGl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICAgIHJldHVybiAoZmlyc3QgPT0gbnVsbCA/IHZvaWQgMCA6IGZpcnN0LnNlZ21lbnQpIHx8IG51bGw7XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmtpbmcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGRldGVjdENodW5rID0gKGJ1ZmZlcikgPT4ge1xuICAgICAgY29uc3QgbWF0Y2ggPSBjaHVua2luZyhidWZmZXIpO1xuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoIW1hdGNoLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENodW5raW5nIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGEgbm9uLWVtcHR5IHN0cmluZy5gKTtcbiAgICAgIH1cbiAgICAgIGlmICghYnVmZmVyLnN0YXJ0c1dpdGgobWF0Y2gpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQ2h1bmtpbmcgZnVuY3Rpb24gbXVzdCByZXR1cm4gYSBtYXRjaCB0aGF0IGlzIGEgcHJlZml4IG9mIHRoZSBidWZmZXIuIFJlY2VpdmVkOiBcIiR7bWF0Y2h9XCIgZXhwZWN0ZWQgdG8gc3RhcnQgd2l0aCBcIiR7YnVmZmVyfVwiYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY2h1bmtpbmdSZWdleCA9IHR5cGVvZiBjaHVua2luZyA9PT0gXCJzdHJpbmdcIiA/IENIVU5LSU5HX1JFR0VYUFNbY2h1bmtpbmddIDogY2h1bmtpbmcgaW5zdGFuY2VvZiBSZWdFeHAgPyBjaHVua2luZyA6IHZvaWQgMDtcbiAgICBpZiAoY2h1bmtpbmdSZWdleCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IyKHtcbiAgICAgICAgYXJndW1lbnQ6IFwiY2h1bmtpbmdcIixcbiAgICAgICAgbWVzc2FnZTogYENodW5raW5nIG11c3QgYmUgXCJ3b3JkXCIsIFwibGluZVwiLCBhIFJlZ0V4cCwgYW4gSW50bC5TZWdtZW50ZXIsIG9yIGEgQ2h1bmtEZXRlY3RvciBmdW5jdGlvbi4gUmVjZWl2ZWQ6ICR7Y2h1bmtpbmd9YFxuICAgICAgfSk7XG4gICAgfVxuICAgIGRldGVjdENodW5rID0gKGJ1ZmZlcikgPT4ge1xuICAgICAgY29uc3QgbWF0Y2ggPSBjaHVua2luZ1JlZ2V4LmV4ZWMoYnVmZmVyKTtcbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArIChtYXRjaCA9PSBudWxsID8gdm9pZCAwIDogbWF0Y2hbMF0pO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuICgpID0+IHtcbiAgICBsZXQgYnVmZmVyID0gXCJcIjtcbiAgICBsZXQgaWQgPSBcIlwiO1xuICAgIGxldCB0eXBlID0gdm9pZCAwO1xuICAgIGxldCBwcm92aWRlck1ldGFkYXRhID0gdm9pZCAwO1xuICAgIGZ1bmN0aW9uIGZsdXNoQnVmZmVyKGNvbnRyb2xsZXIpIHtcbiAgICAgIGlmIChidWZmZXIubGVuZ3RoID4gMCAmJiB0eXBlICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIHRleHQ6IGJ1ZmZlcixcbiAgICAgICAgICBpZCxcbiAgICAgICAgICAuLi5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBidWZmZXIgPSBcIlwiO1xuICAgICAgICBwcm92aWRlck1ldGFkYXRhID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgaWYgKGNodW5rLnR5cGUgIT09IFwidGV4dC1kZWx0YVwiICYmIGNodW5rLnR5cGUgIT09IFwicmVhc29uaW5nLWRlbHRhXCIpIHtcbiAgICAgICAgICBmbHVzaEJ1ZmZlcihjb250cm9sbGVyKTtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGNodW5rLnR5cGUgIT09IHR5cGUgfHwgY2h1bmsuaWQgIT09IGlkKSAmJiBidWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGZsdXNoQnVmZmVyKGNvbnRyb2xsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlciArPSBjaHVuay50ZXh0O1xuICAgICAgICBpZCA9IGNodW5rLmlkO1xuICAgICAgICB0eXBlID0gY2h1bmsudHlwZTtcbiAgICAgICAgaWYgKGNodW5rLnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGEgPSBjaHVuay5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtYXRjaDtcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IGRldGVjdENodW5rKGJ1ZmZlcikpICE9IG51bGwpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlLCB0ZXh0OiBtYXRjaCwgaWQgfSk7XG4gICAgICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKG1hdGNoLmxlbmd0aCk7XG4gICAgICAgICAgYXdhaXQgZGVsYXkyKGRlbGF5SW5Ncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn1cblxuLy8gc3JjL2dlbmVyYXRlLXZpZGVvL2dlbmVyYXRlLXZpZGVvLnRzXG5pbXBvcnQge1xuICBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5IGFzIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXk1LFxuICB3aXRoVXNlckFnZW50U3VmZml4IGFzIHdpdGhVc2VyQWdlbnRTdWZmaXg4XG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG52YXIgZGVmYXVsdERvd25sb2FkID0gY3JlYXRlRG93bmxvYWQoKTtcbmFzeW5jIGZ1bmN0aW9uIGV4cGVyaW1lbnRhbF9nZW5lcmF0ZVZpZGVvKHtcbiAgbW9kZWw6IG1vZGVsQXJnLFxuICBwcm9tcHQ6IHByb21wdEFyZyxcbiAgbiA9IDEsXG4gIG1heFZpZGVvc1BlckNhbGwsXG4gIGFzcGVjdFJhdGlvLFxuICByZXNvbHV0aW9uLFxuICBkdXJhdGlvbixcbiAgZnBzLFxuICBzZWVkLFxuICBwcm92aWRlck9wdGlvbnMsXG4gIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzLFxuICBkb3dubG9hZDogZG93bmxvYWRGbiA9IGRlZmF1bHREb3dubG9hZFxufSkge1xuICB2YXIgX2EyMTtcbiAgY29uc3QgbW9kZWwgPSByZXNvbHZlVmlkZW9Nb2RlbChtb2RlbEFyZyk7XG4gIGNvbnN0IGhlYWRlcnNXaXRoVXNlckFnZW50ID0gd2l0aFVzZXJBZ2VudFN1ZmZpeDgoXG4gICAgaGVhZGVycyAhPSBudWxsID8gaGVhZGVycyA6IHt9LFxuICAgIGBhaS8ke1ZFUlNJT059YFxuICApO1xuICBjb25zdCB7IHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7XG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICBhYm9ydFNpZ25hbFxuICB9KTtcbiAgY29uc3QgeyBwcm9tcHQsIGltYWdlIH0gPSBub3JtYWxpemVQcm9tcHQyKHByb21wdEFyZyk7XG4gIGNvbnN0IG1heFZpZGVvc1BlckNhbGxXaXRoRGVmYXVsdCA9IChfYTIxID0gbWF4VmlkZW9zUGVyQ2FsbCAhPSBudWxsID8gbWF4VmlkZW9zUGVyQ2FsbCA6IGF3YWl0IGludm9rZU1vZGVsTWF4VmlkZW9zUGVyQ2FsbChtb2RlbCkpICE9IG51bGwgPyBfYTIxIDogMTtcbiAgY29uc3QgY2FsbENvdW50ID0gTWF0aC5jZWlsKG4gLyBtYXhWaWRlb3NQZXJDYWxsV2l0aERlZmF1bHQpO1xuICBjb25zdCBjYWxsVmlkZW9Db3VudHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBjYWxsQ291bnQgfSwgKF8sIGluZGV4KSA9PiB7XG4gICAgY29uc3QgcmVtYWluaW5nID0gbiAtIGluZGV4ICogbWF4VmlkZW9zUGVyQ2FsbFdpdGhEZWZhdWx0O1xuICAgIHJldHVybiBNYXRoLm1pbihyZW1haW5pbmcsIG1heFZpZGVvc1BlckNhbGxXaXRoRGVmYXVsdCk7XG4gIH0pO1xuICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgY2FsbFZpZGVvQ291bnRzLm1hcChcbiAgICAgIGFzeW5jIChjYWxsVmlkZW9Db3VudCkgPT4gcmV0cnkoXG4gICAgICAgICgpID0+IG1vZGVsLmRvR2VuZXJhdGUoe1xuICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICBuOiBjYWxsVmlkZW9Db3VudCxcbiAgICAgICAgICBhc3BlY3RSYXRpbyxcbiAgICAgICAgICByZXNvbHV0aW9uLFxuICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICAgIGZwcyxcbiAgICAgICAgICBzZWVkLFxuICAgICAgICAgIGltYWdlLFxuICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJPcHRpb25zICE9IG51bGwgPyBwcm92aWRlck9wdGlvbnMgOiB7fSxcbiAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzV2l0aFVzZXJBZ2VudCxcbiAgICAgICAgICBhYm9ydFNpZ25hbFxuICAgICAgICB9KVxuICAgICAgKVxuICAgIClcbiAgKTtcbiAgY29uc3QgdmlkZW9zID0gW107XG4gIGNvbnN0IHdhcm5pbmdzID0gW107XG4gIGNvbnN0IHJlc3BvbnNlcyA9IFtdO1xuICBjb25zdCBwcm92aWRlck1ldGFkYXRhID0ge307XG4gIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICBmb3IgKGNvbnN0IHZpZGVvRGF0YSBvZiByZXN1bHQudmlkZW9zKSB7XG4gICAgICBzd2l0Y2ggKHZpZGVvRGF0YS50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJ1cmxcIjoge1xuICAgICAgICAgIGNvbnN0IHsgZGF0YSwgbWVkaWFUeXBlOiBkb3dubG9hZGVkTWVkaWFUeXBlIH0gPSBhd2FpdCBkb3dubG9hZEZuKHtcbiAgICAgICAgICAgIHVybDogbmV3IFVSTCh2aWRlb0RhdGEudXJsKSxcbiAgICAgICAgICAgIGFib3J0U2lnbmFsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgaXNVc2FibGVNZWRpYVR5cGUgPSAodHlwZSkgPT4gISF0eXBlICYmIHR5cGUgIT09IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCI7XG4gICAgICAgICAgY29uc3QgbWVkaWFUeXBlID0gaXNVc2FibGVNZWRpYVR5cGUodmlkZW9EYXRhLm1lZGlhVHlwZSkgJiYgdmlkZW9EYXRhLm1lZGlhVHlwZSB8fCBpc1VzYWJsZU1lZGlhVHlwZShkb3dubG9hZGVkTWVkaWFUeXBlKSAmJiBkb3dubG9hZGVkTWVkaWFUeXBlIHx8IGRldGVjdE1lZGlhVHlwZSh7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgc2lnbmF0dXJlczogdmlkZW9NZWRpYVR5cGVTaWduYXR1cmVzXG4gICAgICAgICAgfSkgfHwgXCJ2aWRlby9tcDRcIjtcbiAgICAgICAgICB2aWRlb3MucHVzaChcbiAgICAgICAgICAgIG5ldyBEZWZhdWx0R2VuZXJhdGVkRmlsZSh7XG4gICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgIG1lZGlhVHlwZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJiYXNlNjRcIjoge1xuICAgICAgICAgIHZpZGVvcy5wdXNoKFxuICAgICAgICAgICAgbmV3IERlZmF1bHRHZW5lcmF0ZWRGaWxlKHtcbiAgICAgICAgICAgICAgZGF0YTogdmlkZW9EYXRhLmRhdGEsXG4gICAgICAgICAgICAgIG1lZGlhVHlwZTogdmlkZW9EYXRhLm1lZGlhVHlwZSB8fCBcInZpZGVvL21wNFwiXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImJpbmFyeVwiOiB7XG4gICAgICAgICAgY29uc3QgbWVkaWFUeXBlID0gdmlkZW9EYXRhLm1lZGlhVHlwZSB8fCBkZXRlY3RNZWRpYVR5cGUoe1xuICAgICAgICAgICAgZGF0YTogdmlkZW9EYXRhLmRhdGEsXG4gICAgICAgICAgICBzaWduYXR1cmVzOiB2aWRlb01lZGlhVHlwZVNpZ25hdHVyZXNcbiAgICAgICAgICB9KSB8fCBcInZpZGVvL21wNFwiO1xuICAgICAgICAgIHZpZGVvcy5wdXNoKFxuICAgICAgICAgICAgbmV3IERlZmF1bHRHZW5lcmF0ZWRGaWxlKHtcbiAgICAgICAgICAgICAgZGF0YTogdmlkZW9EYXRhLmRhdGEsXG4gICAgICAgICAgICAgIG1lZGlhVHlwZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHdhcm5pbmdzLnB1c2goLi4ucmVzdWx0Lndhcm5pbmdzKTtcbiAgICByZXNwb25zZXMucHVzaCh7XG4gICAgICB0aW1lc3RhbXA6IHJlc3VsdC5yZXNwb25zZS50aW1lc3RhbXAsXG4gICAgICBtb2RlbElkOiByZXN1bHQucmVzcG9uc2UubW9kZWxJZCxcbiAgICAgIGhlYWRlcnM6IHJlc3VsdC5yZXNwb25zZS5oZWFkZXJzLFxuICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcmVzdWx0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgZm9yIChjb25zdCBbcHJvdmlkZXJOYW1lLCBtZXRhZGF0YV0gb2YgT2JqZWN0LmVudHJpZXMoXG4gICAgICAgIHJlc3VsdC5wcm92aWRlck1ldGFkYXRhXG4gICAgICApKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nTWV0YWRhdGEgPSBwcm92aWRlck1ldGFkYXRhW3Byb3ZpZGVyTmFtZV07XG4gICAgICAgIGlmIChleGlzdGluZ01ldGFkYXRhICE9IG51bGwgJiYgdHlwZW9mIGV4aXN0aW5nTWV0YWRhdGEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBwcm92aWRlck1ldGFkYXRhW3Byb3ZpZGVyTmFtZV0gPSB7XG4gICAgICAgICAgICAuLi5leGlzdGluZ01ldGFkYXRhLFxuICAgICAgICAgICAgLi4ubWV0YWRhdGFcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChcInZpZGVvc1wiIGluIGV4aXN0aW5nTWV0YWRhdGEgJiYgQXJyYXkuaXNBcnJheShleGlzdGluZ01ldGFkYXRhLnZpZGVvcykgJiYgXCJ2aWRlb3NcIiBpbiBtZXRhZGF0YSAmJiBBcnJheS5pc0FycmF5KG1ldGFkYXRhLnZpZGVvcykpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGFbcHJvdmlkZXJOYW1lXS52aWRlb3MgPSBbXG4gICAgICAgICAgICAgIC4uLmV4aXN0aW5nTWV0YWRhdGEudmlkZW9zLFxuICAgICAgICAgICAgICAuLi5tZXRhZGF0YS52aWRlb3NcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGFbcHJvdmlkZXJOYW1lXSA9IG1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2aWRlb3MubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IE5vVmlkZW9HZW5lcmF0ZWRFcnJvcih7IHJlc3BvbnNlcyB9KTtcbiAgfVxuICBpZiAod2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgIGxvZ1dhcm5pbmdzKHtcbiAgICAgIHdhcm5pbmdzLFxuICAgICAgcHJvdmlkZXI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgbW9kZWw6IG1vZGVsLm1vZGVsSWRcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZpZGVvOiB2aWRlb3NbMF0sXG4gICAgdmlkZW9zLFxuICAgIHdhcm5pbmdzLFxuICAgIHJlc3BvbnNlcyxcbiAgICBwcm92aWRlck1ldGFkYXRhXG4gIH07XG59XG5mdW5jdGlvbiBub3JtYWxpemVQcm9tcHQyKHByb21wdEFyZykge1xuICB2YXIgX2EyMSwgX2I7XG4gIGlmICh0eXBlb2YgcHJvbXB0QXJnID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb21wdDogcHJvbXB0QXJnLFxuICAgICAgaW1hZ2U6IHZvaWQgMFxuICAgIH07XG4gIH1cbiAgbGV0IGltYWdlO1xuICBpZiAocHJvbXB0QXJnLmltYWdlICE9IG51bGwpIHtcbiAgICBjb25zdCBkYXRhQ29udGVudCA9IHByb21wdEFyZy5pbWFnZTtcbiAgICBpZiAodHlwZW9mIGRhdGFDb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoZGF0YUNvbnRlbnQuc3RhcnRzV2l0aChcImh0dHA6Ly9cIikgfHwgZGF0YUNvbnRlbnQuc3RhcnRzV2l0aChcImh0dHBzOi8vXCIpKSB7XG4gICAgICAgIGltYWdlID0ge1xuICAgICAgICAgIHR5cGU6IFwidXJsXCIsXG4gICAgICAgICAgdXJsOiBkYXRhQ29udGVudFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChkYXRhQ29udGVudC5zdGFydHNXaXRoKFwiZGF0YTpcIikpIHtcbiAgICAgICAgY29uc3QgeyBtZWRpYVR5cGUsIGJhc2U2NENvbnRlbnQgfSA9IHNwbGl0RGF0YVVybChkYXRhQ29udGVudCk7XG4gICAgICAgIGltYWdlID0ge1xuICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAgIG1lZGlhVHlwZTogbWVkaWFUeXBlICE9IG51bGwgPyBtZWRpYVR5cGUgOiBcImltYWdlL3BuZ1wiLFxuICAgICAgICAgIGRhdGE6IGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXk1KGJhc2U2NENvbnRlbnQgIT0gbnVsbCA/IGJhc2U2NENvbnRlbnQgOiBcIlwiKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5NShkYXRhQ29udGVudCk7XG4gICAgICAgIGNvbnN0IG1lZGlhVHlwZSA9IChfYTIxID0gZGV0ZWN0TWVkaWFUeXBlKHtcbiAgICAgICAgICBkYXRhOiBieXRlcyxcbiAgICAgICAgICBzaWduYXR1cmVzOiBpbWFnZU1lZGlhVHlwZVNpZ25hdHVyZXNcbiAgICAgICAgfSkpICE9IG51bGwgPyBfYTIxIDogXCJpbWFnZS9wbmdcIjtcbiAgICAgICAgaW1hZ2UgPSB7XG4gICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgbWVkaWFUeXBlLFxuICAgICAgICAgIGRhdGE6IGJ5dGVzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkYXRhQ29udGVudCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIGNvbnN0IG1lZGlhVHlwZSA9IChfYiA9IGRldGVjdE1lZGlhVHlwZSh7XG4gICAgICAgIGRhdGE6IGRhdGFDb250ZW50LFxuICAgICAgICBzaWduYXR1cmVzOiBpbWFnZU1lZGlhVHlwZVNpZ25hdHVyZXNcbiAgICAgIH0pKSAhPSBudWxsID8gX2IgOiBcImltYWdlL3BuZ1wiO1xuICAgICAgaW1hZ2UgPSB7XG4gICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICBtZWRpYVR5cGUsXG4gICAgICAgIGRhdGE6IGRhdGFDb250ZW50XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHByb21wdDogcHJvbXB0QXJnLnRleHQsXG4gICAgaW1hZ2VcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGludm9rZU1vZGVsTWF4VmlkZW9zUGVyQ2FsbChtb2RlbCkge1xuICBpZiAodHlwZW9mIG1vZGVsLm1heFZpZGVvc1BlckNhbGwgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBhd2FpdCBtb2RlbC5tYXhWaWRlb3NQZXJDYWxsKHsgbW9kZWxJZDogbW9kZWwubW9kZWxJZCB9KTtcbiAgfVxuICByZXR1cm4gbW9kZWwubWF4VmlkZW9zUGVyQ2FsbDtcbn1cblxuLy8gc3JjL21pZGRsZXdhcmUvZGVmYXVsdC1lbWJlZGRpbmctc2V0dGluZ3MtbWlkZGxld2FyZS50c1xuZnVuY3Rpb24gZGVmYXVsdEVtYmVkZGluZ1NldHRpbmdzTWlkZGxld2FyZSh7XG4gIHNldHRpbmdzXG59KSB7XG4gIHJldHVybiB7XG4gICAgc3BlY2lmaWNhdGlvblZlcnNpb246IFwidjNcIixcbiAgICB0cmFuc2Zvcm1QYXJhbXM6IGFzeW5jICh7IHBhcmFtcyB9KSA9PiB7XG4gICAgICByZXR1cm4gbWVyZ2VPYmplY3RzKHNldHRpbmdzLCBwYXJhbXMpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21pZGRsZXdhcmUvZGVmYXVsdC1zZXR0aW5ncy1taWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBkZWZhdWx0U2V0dGluZ3NNaWRkbGV3YXJlKHtcbiAgc2V0dGluZ3Ncbn0pIHtcbiAgcmV0dXJuIHtcbiAgICBzcGVjaWZpY2F0aW9uVmVyc2lvbjogXCJ2M1wiLFxuICAgIHRyYW5zZm9ybVBhcmFtczogYXN5bmMgKHsgcGFyYW1zIH0pID0+IHtcbiAgICAgIHJldHVybiBtZXJnZU9iamVjdHMoc2V0dGluZ3MsIHBhcmFtcyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWlkZGxld2FyZS9leHRyYWN0LWpzb24tbWlkZGxld2FyZS50c1xuZnVuY3Rpb24gZGVmYXVsdFRyYW5zZm9ybSh0ZXh0Mikge1xuICByZXR1cm4gdGV4dDIucmVwbGFjZSgvXmBgYCg/Ompzb24pP1xccypcXG4/LywgXCJcIikucmVwbGFjZSgvXFxuP2BgYFxccyokLywgXCJcIikudHJpbSgpO1xufVxuZnVuY3Rpb24gZXh0cmFjdEpzb25NaWRkbGV3YXJlKG9wdGlvbnMpIHtcbiAgdmFyIF9hMjE7XG4gIGNvbnN0IHRyYW5zZm9ybSA9IChfYTIxID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy50cmFuc2Zvcm0pICE9IG51bGwgPyBfYTIxIDogZGVmYXVsdFRyYW5zZm9ybTtcbiAgY29uc3QgaGFzQ3VzdG9tVHJhbnNmb3JtID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSAhPT0gdm9pZCAwO1xuICByZXR1cm4ge1xuICAgIHNwZWNpZmljYXRpb25WZXJzaW9uOiBcInYzXCIsXG4gICAgd3JhcEdlbmVyYXRlOiBhc3luYyAoeyBkb0dlbmVyYXRlIH0pID0+IHtcbiAgICAgIGNvbnN0IHsgY29udGVudCwgLi4ucmVzdCB9ID0gYXdhaXQgZG9HZW5lcmF0ZSgpO1xuICAgICAgY29uc3QgdHJhbnNmb3JtZWRDb250ZW50ID0gW107XG4gICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgY29udGVudCkge1xuICAgICAgICBpZiAocGFydC50eXBlICE9PSBcInRleHRcIikge1xuICAgICAgICAgIHRyYW5zZm9ybWVkQ29udGVudC5wdXNoKHBhcnQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zZm9ybWVkQ29udGVudC5wdXNoKHtcbiAgICAgICAgICAuLi5wYXJ0LFxuICAgICAgICAgIHRleHQ6IHRyYW5zZm9ybShwYXJ0LnRleHQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgY29udGVudDogdHJhbnNmb3JtZWRDb250ZW50LCAuLi5yZXN0IH07XG4gICAgfSxcbiAgICB3cmFwU3RyZWFtOiBhc3luYyAoeyBkb1N0cmVhbSB9KSA9PiB7XG4gICAgICBjb25zdCB7IHN0cmVhbSwgLi4ucmVzdCB9ID0gYXdhaXQgZG9TdHJlYW0oKTtcbiAgICAgIGNvbnN0IHRleHRCbG9ja3MgPSB7fTtcbiAgICAgIGNvbnN0IFNVRkZJWF9CVUZGRVJfU0laRSA9IDEyO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RyZWFtOiBzdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LXN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICB0ZXh0QmxvY2tzW2NodW5rLmlkXSA9IHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0RXZlbnQ6IGNodW5rLFxuICAgICAgICAgICAgICAgICAgLy8gQ3VzdG9tIHRyYW5zZm9ybXMgbmVlZCB0byBidWZmZXIgYWxsIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgIHBoYXNlOiBoYXNDdXN0b21UcmFuc2Zvcm0gPyBcImJ1ZmZlcmluZ1wiIDogXCJwcmVmaXhcIixcbiAgICAgICAgICAgICAgICAgIGJ1ZmZlcjogXCJcIixcbiAgICAgICAgICAgICAgICAgIHByZWZpeFN0cmlwcGVkOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjaHVuay50eXBlID09PSBcInRleHQtZGVsdGFcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gdGV4dEJsb2Nrc1tjaHVuay5pZF07XG4gICAgICAgICAgICAgICAgaWYgKCFibG9jaykge1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmxvY2suYnVmZmVyICs9IGNodW5rLmRlbHRhO1xuICAgICAgICAgICAgICAgIGlmIChibG9jay5waGFzZSA9PT0gXCJidWZmZXJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmxvY2sucGhhc2UgPT09IFwicHJlZml4XCIpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChibG9jay5idWZmZXIubGVuZ3RoID4gMCAmJiAhYmxvY2suYnVmZmVyLnN0YXJ0c1dpdGgoXCJgXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLnBoYXNlID0gXCJzdHJlYW1pbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGJsb2NrLnN0YXJ0RXZlbnQpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChibG9jay5idWZmZXIuc3RhcnRzV2l0aChcImBgYFwiKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2suYnVmZmVyLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZml4TWF0Y2ggPSBibG9jay5idWZmZXIubWF0Y2goL15gYGAoPzpqc29uKT9cXHMqXFxuLyk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZpeE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9jay5idWZmZXIgPSBibG9jay5idWZmZXIuc2xpY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeE1hdGNoWzBdLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrLnByZWZpeFN0cmlwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrLnBoYXNlID0gXCJzdHJlYW1pbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShibG9jay5zdGFydEV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2sucGhhc2UgPSBcInN0cmVhbWluZ1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGJsb2NrLnN0YXJ0RXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChibG9jay5idWZmZXIubGVuZ3RoID49IDMgJiYgIWJsb2NrLmJ1ZmZlci5zdGFydHNXaXRoKFwiYGBgXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLnBoYXNlID0gXCJzdHJlYW1pbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGJsb2NrLnN0YXJ0RXZlbnQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmxvY2sucGhhc2UgPT09IFwic3RyZWFtaW5nXCIgJiYgYmxvY2suYnVmZmVyLmxlbmd0aCA+IFNVRkZJWF9CVUZGRVJfU0laRSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdG9TdHJlYW0gPSBibG9jay5idWZmZXIuc2xpY2UoMCwgLVNVRkZJWF9CVUZGRVJfU0laRSk7XG4gICAgICAgICAgICAgICAgICBibG9jay5idWZmZXIgPSBibG9jay5idWZmZXIuc2xpY2UoLVNVRkZJWF9CVUZGRVJfU0laRSk7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHQtZGVsdGFcIixcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGNodW5rLmlkLFxuICAgICAgICAgICAgICAgICAgICBkZWx0YTogdG9TdHJlYW1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwidGV4dC1lbmRcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gdGV4dEJsb2Nrc1tjaHVuay5pZF07XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoYmxvY2sucGhhc2UgPT09IFwicHJlZml4XCIgfHwgYmxvY2sucGhhc2UgPT09IFwiYnVmZmVyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGJsb2NrLnN0YXJ0RXZlbnQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbGV0IHJlbWFpbmluZyA9IGJsb2NrLmJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAgIGlmIChibG9jay5waGFzZSA9PT0gXCJidWZmZXJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmcgPSB0cmFuc2Zvcm0ocmVtYWluaW5nKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYmxvY2sucHJlZml4U3RyaXBwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nID0gcmVtYWluaW5nLnJlcGxhY2UoL1xcbj9gYGBcXHMqJC8sIFwiXCIpLnRyaW1FbmQoKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZyA9IHRyYW5zZm9ybShyZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHJlbWFpbmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgaWQ6IGNodW5rLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIGRlbHRhOiByZW1haW5pbmdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIHRleHRCbG9ja3NbY2h1bmsuaWRdO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICksXG4gICAgICAgIC4uLnJlc3RcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdXRpbC9nZXQtcG90ZW50aWFsLXN0YXJ0LWluZGV4LnRzXG5mdW5jdGlvbiBnZXRQb3RlbnRpYWxTdGFydEluZGV4KHRleHQyLCBzZWFyY2hlZFRleHQpIHtcbiAgaWYgKHNlYXJjaGVkVGV4dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBkaXJlY3RJbmRleCA9IHRleHQyLmluZGV4T2Yoc2VhcmNoZWRUZXh0KTtcbiAgaWYgKGRpcmVjdEluZGV4ICE9PSAtMSkge1xuICAgIHJldHVybiBkaXJlY3RJbmRleDtcbiAgfVxuICBmb3IgKGxldCBpID0gdGV4dDIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBzdWZmaXggPSB0ZXh0Mi5zdWJzdHJpbmcoaSk7XG4gICAgaWYgKHNlYXJjaGVkVGV4dC5zdGFydHNXaXRoKHN1ZmZpeCkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gc3JjL21pZGRsZXdhcmUvZXh0cmFjdC1yZWFzb25pbmctbWlkZGxld2FyZS50c1xuZnVuY3Rpb24gZXh0cmFjdFJlYXNvbmluZ01pZGRsZXdhcmUoe1xuICB0YWdOYW1lLFxuICBzZXBhcmF0b3IgPSBcIlxcblwiLFxuICBzdGFydFdpdGhSZWFzb25pbmcgPSBmYWxzZVxufSkge1xuICBjb25zdCBvcGVuaW5nVGFnID0gYDwke3RhZ05hbWV9PmA7XG4gIGNvbnN0IGNsb3NpbmdUYWcgPSBgPC8ke3RhZ05hbWV9PmA7XG4gIHJldHVybiB7XG4gICAgc3BlY2lmaWNhdGlvblZlcnNpb246IFwidjNcIixcbiAgICB3cmFwR2VuZXJhdGU6IGFzeW5jICh7IGRvR2VuZXJhdGUgfSkgPT4ge1xuICAgICAgY29uc3QgeyBjb250ZW50LCAuLi5yZXN0IH0gPSBhd2FpdCBkb0dlbmVyYXRlKCk7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1lZENvbnRlbnQgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgcGFydCBvZiBjb250ZW50KSB7XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgIT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgdHJhbnNmb3JtZWRDb250ZW50LnB1c2gocGFydCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGV4dDIgPSBzdGFydFdpdGhSZWFzb25pbmcgPyBvcGVuaW5nVGFnICsgcGFydC50ZXh0IDogcGFydC50ZXh0O1xuICAgICAgICBjb25zdCByZWdleHAgPSBuZXcgUmVnRXhwKGAke29wZW5pbmdUYWd9KC4qPykke2Nsb3NpbmdUYWd9YCwgXCJnc1wiKTtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IEFycmF5LmZyb20odGV4dDIubWF0Y2hBbGwocmVnZXhwKSk7XG4gICAgICAgIGlmICghbWF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICB0cmFuc2Zvcm1lZENvbnRlbnQucHVzaChwYXJ0KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWFzb25pbmdUZXh0ID0gbWF0Y2hlcy5tYXAoKG1hdGNoKSA9PiBtYXRjaFsxXSkuam9pbihzZXBhcmF0b3IpO1xuICAgICAgICBsZXQgdGV4dFdpdGhvdXRSZWFzb25pbmcgPSB0ZXh0MjtcbiAgICAgICAgZm9yIChsZXQgaSA9IG1hdGNoZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBtYXRjaCA9IG1hdGNoZXNbaV07XG4gICAgICAgICAgY29uc3QgYmVmb3JlTWF0Y2ggPSB0ZXh0V2l0aG91dFJlYXNvbmluZy5zbGljZSgwLCBtYXRjaC5pbmRleCk7XG4gICAgICAgICAgY29uc3QgYWZ0ZXJNYXRjaCA9IHRleHRXaXRob3V0UmVhc29uaW5nLnNsaWNlKFxuICAgICAgICAgICAgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGhcbiAgICAgICAgICApO1xuICAgICAgICAgIHRleHRXaXRob3V0UmVhc29uaW5nID0gYmVmb3JlTWF0Y2ggKyAoYmVmb3JlTWF0Y2gubGVuZ3RoID4gMCAmJiBhZnRlck1hdGNoLmxlbmd0aCA+IDAgPyBzZXBhcmF0b3IgOiBcIlwiKSArIGFmdGVyTWF0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNmb3JtZWRDb250ZW50LnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nXCIsXG4gICAgICAgICAgdGV4dDogcmVhc29uaW5nVGV4dFxuICAgICAgICB9KTtcbiAgICAgICAgdHJhbnNmb3JtZWRDb250ZW50LnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgIHRleHQ6IHRleHRXaXRob3V0UmVhc29uaW5nXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgY29udGVudDogdHJhbnNmb3JtZWRDb250ZW50LCAuLi5yZXN0IH07XG4gICAgfSxcbiAgICB3cmFwU3RyZWFtOiBhc3luYyAoeyBkb1N0cmVhbSB9KSA9PiB7XG4gICAgICBjb25zdCB7IHN0cmVhbSwgLi4ucmVzdCB9ID0gYXdhaXQgZG9TdHJlYW0oKTtcbiAgICAgIGNvbnN0IHJlYXNvbmluZ0V4dHJhY3Rpb25zID0ge307XG4gICAgICBsZXQgZGVsYXllZFRleHRTdGFydDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0cmVhbTogc3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwidGV4dC1zdGFydFwiKSB7XG4gICAgICAgICAgICAgICAgZGVsYXllZFRleHRTdGFydCA9IGNodW5rO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LWVuZFwiICYmIGRlbGF5ZWRUZXh0U3RhcnQpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZGVsYXllZFRleHRTdGFydCk7XG4gICAgICAgICAgICAgICAgZGVsYXllZFRleHRTdGFydCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY2h1bmsudHlwZSAhPT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVhc29uaW5nRXh0cmFjdGlvbnNbY2h1bmsuaWRdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZWFzb25pbmdFeHRyYWN0aW9uc1tjaHVuay5pZF0gPSB7XG4gICAgICAgICAgICAgICAgICBpc0ZpcnN0UmVhc29uaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgaXNGaXJzdFRleHQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICBhZnRlclN3aXRjaDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICBpc1JlYXNvbmluZzogc3RhcnRXaXRoUmVhc29uaW5nLFxuICAgICAgICAgICAgICAgICAgYnVmZmVyOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgaWRDb3VudGVyOiAwLFxuICAgICAgICAgICAgICAgICAgdGV4dElkOiBjaHVuay5pZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgYWN0aXZlRXh0cmFjdGlvbiA9IHJlYXNvbmluZ0V4dHJhY3Rpb25zW2NodW5rLmlkXTtcbiAgICAgICAgICAgICAgYWN0aXZlRXh0cmFjdGlvbi5idWZmZXIgKz0gY2h1bmsuZGVsdGE7XG4gICAgICAgICAgICAgIGZ1bmN0aW9uIHB1Ymxpc2godGV4dDIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGV4dDIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gYWN0aXZlRXh0cmFjdGlvbi5hZnRlclN3aXRjaCAmJiAoYWN0aXZlRXh0cmFjdGlvbi5pc1JlYXNvbmluZyA/ICFhY3RpdmVFeHRyYWN0aW9uLmlzRmlyc3RSZWFzb25pbmcgOiAhYWN0aXZlRXh0cmFjdGlvbi5pc0ZpcnN0VGV4dCkgPyBzZXBhcmF0b3IgOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUV4dHJhY3Rpb24uaXNSZWFzb25pbmcgJiYgKGFjdGl2ZUV4dHJhY3Rpb24uYWZ0ZXJTd2l0Y2ggfHwgYWN0aXZlRXh0cmFjdGlvbi5pc0ZpcnN0UmVhc29uaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nLXN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgaWQ6IGByZWFzb25pbmctJHthY3RpdmVFeHRyYWN0aW9uLmlkQ291bnRlcn1gXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUV4dHJhY3Rpb24uaXNSZWFzb25pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZy1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgICAgIGRlbHRhOiBwcmVmaXggKyB0ZXh0MixcbiAgICAgICAgICAgICAgICAgICAgICBpZDogYHJlYXNvbmluZy0ke2FjdGl2ZUV4dHJhY3Rpb24uaWRDb3VudGVyfWBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVsYXllZFRleHRTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShkZWxheWVkVGV4dFN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxheWVkVGV4dFN0YXJ0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgZGVsdGE6IHByZWZpeCArIHRleHQyLFxuICAgICAgICAgICAgICAgICAgICAgIGlkOiBhY3RpdmVFeHRyYWN0aW9uLnRleHRJZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGFjdGl2ZUV4dHJhY3Rpb24uYWZ0ZXJTd2l0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmVFeHRyYWN0aW9uLmlzUmVhc29uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUV4dHJhY3Rpb24uaXNGaXJzdFJlYXNvbmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlRXh0cmFjdGlvbi5pc0ZpcnN0VGV4dCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFRhZyA9IGFjdGl2ZUV4dHJhY3Rpb24uaXNSZWFzb25pbmcgPyBjbG9zaW5nVGFnIDogb3BlbmluZ1RhZztcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gZ2V0UG90ZW50aWFsU3RhcnRJbmRleChcbiAgICAgICAgICAgICAgICAgIGFjdGl2ZUV4dHJhY3Rpb24uYnVmZmVyLFxuICAgICAgICAgICAgICAgICAgbmV4dFRhZ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0SW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcHVibGlzaChhY3RpdmVFeHRyYWN0aW9uLmJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICBhY3RpdmVFeHRyYWN0aW9uLmJ1ZmZlciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHVibGlzaChhY3RpdmVFeHRyYWN0aW9uLmJ1ZmZlci5zbGljZSgwLCBzdGFydEluZGV4KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZm91bmRGdWxsTWF0Y2ggPSBzdGFydEluZGV4ICsgbmV4dFRhZy5sZW5ndGggPD0gYWN0aXZlRXh0cmFjdGlvbi5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZEZ1bGxNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgYWN0aXZlRXh0cmFjdGlvbi5idWZmZXIgPSBhY3RpdmVFeHRyYWN0aW9uLmJ1ZmZlci5zbGljZShcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleCArIG5leHRUYWcubGVuZ3RoXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUV4dHJhY3Rpb24uaXNSZWFzb25pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUV4dHJhY3Rpb24uaXNGaXJzdFJlYXNvbmluZykge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZy1zdGFydFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGByZWFzb25pbmctJHthY3RpdmVFeHRyYWN0aW9uLmlkQ291bnRlcn1gXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZy1lbmRcIixcbiAgICAgICAgICAgICAgICAgICAgICBpZDogYHJlYXNvbmluZy0ke2FjdGl2ZUV4dHJhY3Rpb24uaWRDb3VudGVyKyt9YFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGFjdGl2ZUV4dHJhY3Rpb24uaXNSZWFzb25pbmcgPSAhYWN0aXZlRXh0cmFjdGlvbi5pc1JlYXNvbmluZztcbiAgICAgICAgICAgICAgICAgIGFjdGl2ZUV4dHJhY3Rpb24uYWZ0ZXJTd2l0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBhY3RpdmVFeHRyYWN0aW9uLmJ1ZmZlciA9IGFjdGl2ZUV4dHJhY3Rpb24uYnVmZmVyLnNsaWNlKHN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApLFxuICAgICAgICAuLi5yZXN0XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21pZGRsZXdhcmUvc2ltdWxhdGUtc3RyZWFtaW5nLW1pZGRsZXdhcmUudHNcbmZ1bmN0aW9uIHNpbXVsYXRlU3RyZWFtaW5nTWlkZGxld2FyZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBzcGVjaWZpY2F0aW9uVmVyc2lvbjogXCJ2M1wiLFxuICAgIHdyYXBTdHJlYW06IGFzeW5jICh7IGRvR2VuZXJhdGUgfSkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZG9HZW5lcmF0ZSgpO1xuICAgICAgbGV0IGlkID0gMDtcbiAgICAgIGNvbnN0IHNpbXVsYXRlZFN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgdHlwZTogXCJzdHJlYW0tc3RhcnRcIixcbiAgICAgICAgICAgIHdhcm5pbmdzOiByZXN1bHQud2FybmluZ3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInJlc3BvbnNlLW1ldGFkYXRhXCIsIC4uLnJlc3VsdC5yZXNwb25zZSB9KTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcmVzdWx0LmNvbnRlbnQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgICAgICBpZiAocGFydC50ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwidGV4dC1zdGFydFwiLCBpZDogU3RyaW5nKGlkKSB9KTtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgICBpZDogU3RyaW5nKGlkKSxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGE6IHBhcnQudGV4dFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInRleHQtZW5kXCIsIGlkOiBTdHJpbmcoaWQpIH0pO1xuICAgICAgICAgICAgICAgICAgaWQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZ1wiOiB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nLXN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICBpZDogU3RyaW5nKGlkKSxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZy1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgaWQ6IFN0cmluZyhpZCksXG4gICAgICAgICAgICAgICAgICBkZWx0YTogcGFydC50ZXh0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJyZWFzb25pbmctZW5kXCIsIGlkOiBTdHJpbmcoaWQpIH0pO1xuICAgICAgICAgICAgICAgIGlkKys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShwYXJ0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgdHlwZTogXCJmaW5pc2hcIixcbiAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogcmVzdWx0LmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIHVzYWdlOiByZXN1bHQudXNhZ2UsXG4gICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiByZXN1bHQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdHJlYW06IHNpbXVsYXRlZFN0cmVhbSxcbiAgICAgICAgcmVxdWVzdDogcmVzdWx0LnJlcXVlc3QsXG4gICAgICAgIHJlc3BvbnNlOiByZXN1bHQucmVzcG9uc2VcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWlkZGxld2FyZS9hZGQtdG9vbC1pbnB1dC1leGFtcGxlcy1taWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBkZWZhdWx0Rm9ybWF0RXhhbXBsZShleGFtcGxlKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShleGFtcGxlLmlucHV0KTtcbn1cbmZ1bmN0aW9uIGFkZFRvb2xJbnB1dEV4YW1wbGVzTWlkZGxld2FyZSh7XG4gIHByZWZpeCA9IFwiSW5wdXQgRXhhbXBsZXM6XCIsXG4gIGZvcm1hdCA9IGRlZmF1bHRGb3JtYXRFeGFtcGxlLFxuICByZW1vdmUgPSB0cnVlXG59ID0ge30pIHtcbiAgcmV0dXJuIHtcbiAgICBzcGVjaWZpY2F0aW9uVmVyc2lvbjogXCJ2M1wiLFxuICAgIHRyYW5zZm9ybVBhcmFtczogYXN5bmMgKHsgcGFyYW1zIH0pID0+IHtcbiAgICAgIHZhciBfYTIxO1xuICAgICAgaWYgKCEoKF9hMjEgPSBwYXJhbXMudG9vbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIxLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkVG9vbHMgPSBwYXJhbXMudG9vbHMubWFwKCh0b29sMikgPT4ge1xuICAgICAgICB2YXIgX2EyMjtcbiAgICAgICAgaWYgKHRvb2wyLnR5cGUgIT09IFwiZnVuY3Rpb25cIiB8fCAhKChfYTIyID0gdG9vbDIuaW5wdXRFeGFtcGxlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMjIubGVuZ3RoKSkge1xuICAgICAgICAgIHJldHVybiB0b29sMjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3JtYXR0ZWRFeGFtcGxlcyA9IHRvb2wyLmlucHV0RXhhbXBsZXMubWFwKChleGFtcGxlLCBpbmRleCkgPT4gZm9ybWF0KGV4YW1wbGUsIGluZGV4KSkuam9pbihcIlxcblwiKTtcbiAgICAgICAgY29uc3QgZXhhbXBsZXNTZWN0aW9uID0gYCR7cHJlZml4fVxuJHtmb3JtYXR0ZWRFeGFtcGxlc31gO1xuICAgICAgICBjb25zdCB0b29sRGVzY3JpcHRpb24gPSB0b29sMi5kZXNjcmlwdGlvbiA/IGAke3Rvb2wyLmRlc2NyaXB0aW9ufVxuXG4ke2V4YW1wbGVzU2VjdGlvbn1gIDogZXhhbXBsZXNTZWN0aW9uO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnRvb2wyLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiB0b29sRGVzY3JpcHRpb24sXG4gICAgICAgICAgaW5wdXRFeGFtcGxlczogcmVtb3ZlID8gdm9pZCAwIDogdG9vbDIuaW5wdXRFeGFtcGxlc1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIHRvb2xzOiB0cmFuc2Zvcm1lZFRvb2xzXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21pZGRsZXdhcmUvd3JhcC1sYW5ndWFnZS1tb2RlbC50c1xudmFyIHdyYXBMYW5ndWFnZU1vZGVsID0gKHtcbiAgbW9kZWwsXG4gIG1pZGRsZXdhcmU6IG1pZGRsZXdhcmVBcmcsXG4gIG1vZGVsSWQsXG4gIHByb3ZpZGVySWRcbn0pID0+IHtcbiAgcmV0dXJuIFsuLi5hc0FycmF5KG1pZGRsZXdhcmVBcmcpXS5yZXZlcnNlKCkucmVkdWNlKCh3cmFwcGVkTW9kZWwsIG1pZGRsZXdhcmUpID0+IHtcbiAgICByZXR1cm4gZG9XcmFwKHsgbW9kZWw6IHdyYXBwZWRNb2RlbCwgbWlkZGxld2FyZSwgbW9kZWxJZCwgcHJvdmlkZXJJZCB9KTtcbiAgfSwgbW9kZWwpO1xufTtcbnZhciBkb1dyYXAgPSAoe1xuICBtb2RlbCxcbiAgbWlkZGxld2FyZToge1xuICAgIHRyYW5zZm9ybVBhcmFtcyxcbiAgICB3cmFwR2VuZXJhdGUsXG4gICAgd3JhcFN0cmVhbSxcbiAgICBvdmVycmlkZVByb3ZpZGVyLFxuICAgIG92ZXJyaWRlTW9kZWxJZCxcbiAgICBvdmVycmlkZVN1cHBvcnRlZFVybHNcbiAgfSxcbiAgbW9kZWxJZCxcbiAgcHJvdmlkZXJJZFxufSkgPT4ge1xuICB2YXIgX2EyMSwgX2IsIF9jO1xuICBhc3luYyBmdW5jdGlvbiBkb1RyYW5zZm9ybSh7XG4gICAgcGFyYW1zLFxuICAgIHR5cGVcbiAgfSkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1QYXJhbXMgPyBhd2FpdCB0cmFuc2Zvcm1QYXJhbXMoeyBwYXJhbXMsIHR5cGUsIG1vZGVsIH0pIDogcGFyYW1zO1xuICB9XG4gIHJldHVybiB7XG4gICAgc3BlY2lmaWNhdGlvblZlcnNpb246IFwidjNcIixcbiAgICBwcm92aWRlcjogKF9hMjEgPSBwcm92aWRlcklkICE9IG51bGwgPyBwcm92aWRlcklkIDogb3ZlcnJpZGVQcm92aWRlciA9PSBudWxsID8gdm9pZCAwIDogb3ZlcnJpZGVQcm92aWRlcih7IG1vZGVsIH0pKSAhPSBudWxsID8gX2EyMSA6IG1vZGVsLnByb3ZpZGVyLFxuICAgIG1vZGVsSWQ6IChfYiA9IG1vZGVsSWQgIT0gbnVsbCA/IG1vZGVsSWQgOiBvdmVycmlkZU1vZGVsSWQgPT0gbnVsbCA/IHZvaWQgMCA6IG92ZXJyaWRlTW9kZWxJZCh7IG1vZGVsIH0pKSAhPSBudWxsID8gX2IgOiBtb2RlbC5tb2RlbElkLFxuICAgIHN1cHBvcnRlZFVybHM6IChfYyA9IG92ZXJyaWRlU3VwcG9ydGVkVXJscyA9PSBudWxsID8gdm9pZCAwIDogb3ZlcnJpZGVTdXBwb3J0ZWRVcmxzKHsgbW9kZWwgfSkpICE9IG51bGwgPyBfYyA6IG1vZGVsLnN1cHBvcnRlZFVybHMsXG4gICAgYXN5bmMgZG9HZW5lcmF0ZShwYXJhbXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUGFyYW1zID0gYXdhaXQgZG9UcmFuc2Zvcm0oeyBwYXJhbXMsIHR5cGU6IFwiZ2VuZXJhdGVcIiB9KTtcbiAgICAgIGNvbnN0IGRvR2VuZXJhdGUgPSBhc3luYyAoKSA9PiBtb2RlbC5kb0dlbmVyYXRlKHRyYW5zZm9ybWVkUGFyYW1zKTtcbiAgICAgIGNvbnN0IGRvU3RyZWFtID0gYXN5bmMgKCkgPT4gbW9kZWwuZG9TdHJlYW0odHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgcmV0dXJuIHdyYXBHZW5lcmF0ZSA/IHdyYXBHZW5lcmF0ZSh7XG4gICAgICAgIGRvR2VuZXJhdGUsXG4gICAgICAgIGRvU3RyZWFtLFxuICAgICAgICBwYXJhbXM6IHRyYW5zZm9ybWVkUGFyYW1zLFxuICAgICAgICBtb2RlbFxuICAgICAgfSkgOiBkb0dlbmVyYXRlKCk7XG4gICAgfSxcbiAgICBhc3luYyBkb1N0cmVhbShwYXJhbXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUGFyYW1zID0gYXdhaXQgZG9UcmFuc2Zvcm0oeyBwYXJhbXMsIHR5cGU6IFwic3RyZWFtXCIgfSk7XG4gICAgICBjb25zdCBkb0dlbmVyYXRlID0gYXN5bmMgKCkgPT4gbW9kZWwuZG9HZW5lcmF0ZSh0cmFuc2Zvcm1lZFBhcmFtcyk7XG4gICAgICBjb25zdCBkb1N0cmVhbSA9IGFzeW5jICgpID0+IG1vZGVsLmRvU3RyZWFtKHRyYW5zZm9ybWVkUGFyYW1zKTtcbiAgICAgIHJldHVybiB3cmFwU3RyZWFtID8gd3JhcFN0cmVhbSh7IGRvR2VuZXJhdGUsIGRvU3RyZWFtLCBwYXJhbXM6IHRyYW5zZm9ybWVkUGFyYW1zLCBtb2RlbCB9KSA6IGRvU3RyZWFtKCk7XG4gICAgfVxuICB9O1xufTtcblxuLy8gc3JjL21pZGRsZXdhcmUvd3JhcC1lbWJlZGRpbmctbW9kZWwudHNcbnZhciB3cmFwRW1iZWRkaW5nTW9kZWwgPSAoe1xuICBtb2RlbCxcbiAgbWlkZGxld2FyZTogbWlkZGxld2FyZUFyZyxcbiAgbW9kZWxJZCxcbiAgcHJvdmlkZXJJZFxufSkgPT4ge1xuICByZXR1cm4gWy4uLmFzQXJyYXkobWlkZGxld2FyZUFyZyldLnJldmVyc2UoKS5yZWR1Y2UoKHdyYXBwZWRNb2RlbCwgbWlkZGxld2FyZSkgPT4ge1xuICAgIHJldHVybiBkb1dyYXAyKHsgbW9kZWw6IHdyYXBwZWRNb2RlbCwgbWlkZGxld2FyZSwgbW9kZWxJZCwgcHJvdmlkZXJJZCB9KTtcbiAgfSwgbW9kZWwpO1xufTtcbnZhciBkb1dyYXAyID0gKHtcbiAgbW9kZWwsXG4gIG1pZGRsZXdhcmU6IHtcbiAgICB0cmFuc2Zvcm1QYXJhbXMsXG4gICAgd3JhcEVtYmVkLFxuICAgIG92ZXJyaWRlUHJvdmlkZXIsXG4gICAgb3ZlcnJpZGVNb2RlbElkLFxuICAgIG92ZXJyaWRlTWF4RW1iZWRkaW5nc1BlckNhbGwsXG4gICAgb3ZlcnJpZGVTdXBwb3J0c1BhcmFsbGVsQ2FsbHNcbiAgfSxcbiAgbW9kZWxJZCxcbiAgcHJvdmlkZXJJZFxufSkgPT4ge1xuICB2YXIgX2EyMSwgX2IsIF9jLCBfZDtcbiAgYXN5bmMgZnVuY3Rpb24gZG9UcmFuc2Zvcm0oe1xuICAgIHBhcmFtc1xuICB9KSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVBhcmFtcyA/IGF3YWl0IHRyYW5zZm9ybVBhcmFtcyh7IHBhcmFtcywgbW9kZWwgfSkgOiBwYXJhbXM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzcGVjaWZpY2F0aW9uVmVyc2lvbjogXCJ2M1wiLFxuICAgIHByb3ZpZGVyOiAoX2EyMSA9IHByb3ZpZGVySWQgIT0gbnVsbCA/IHByb3ZpZGVySWQgOiBvdmVycmlkZVByb3ZpZGVyID09IG51bGwgPyB2b2lkIDAgOiBvdmVycmlkZVByb3ZpZGVyKHsgbW9kZWwgfSkpICE9IG51bGwgPyBfYTIxIDogbW9kZWwucHJvdmlkZXIsXG4gICAgbW9kZWxJZDogKF9iID0gbW9kZWxJZCAhPSBudWxsID8gbW9kZWxJZCA6IG92ZXJyaWRlTW9kZWxJZCA9PSBudWxsID8gdm9pZCAwIDogb3ZlcnJpZGVNb2RlbElkKHsgbW9kZWwgfSkpICE9IG51bGwgPyBfYiA6IG1vZGVsLm1vZGVsSWQsXG4gICAgbWF4RW1iZWRkaW5nc1BlckNhbGw6IChfYyA9IG92ZXJyaWRlTWF4RW1iZWRkaW5nc1BlckNhbGwgPT0gbnVsbCA/IHZvaWQgMCA6IG92ZXJyaWRlTWF4RW1iZWRkaW5nc1BlckNhbGwoeyBtb2RlbCB9KSkgIT0gbnVsbCA/IF9jIDogbW9kZWwubWF4RW1iZWRkaW5nc1BlckNhbGwsXG4gICAgc3VwcG9ydHNQYXJhbGxlbENhbGxzOiAoX2QgPSBvdmVycmlkZVN1cHBvcnRzUGFyYWxsZWxDYWxscyA9PSBudWxsID8gdm9pZCAwIDogb3ZlcnJpZGVTdXBwb3J0c1BhcmFsbGVsQ2FsbHMoeyBtb2RlbCB9KSkgIT0gbnVsbCA/IF9kIDogbW9kZWwuc3VwcG9ydHNQYXJhbGxlbENhbGxzLFxuICAgIGFzeW5jIGRvRW1iZWQocGFyYW1zKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1lZFBhcmFtcyA9IGF3YWl0IGRvVHJhbnNmb3JtKHsgcGFyYW1zIH0pO1xuICAgICAgY29uc3QgZG9FbWJlZCA9IGFzeW5jICgpID0+IG1vZGVsLmRvRW1iZWQodHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgcmV0dXJuIHdyYXBFbWJlZCA/IHdyYXBFbWJlZCh7XG4gICAgICAgIGRvRW1iZWQsXG4gICAgICAgIHBhcmFtczogdHJhbnNmb3JtZWRQYXJhbXMsXG4gICAgICAgIG1vZGVsXG4gICAgICB9KSA6IGRvRW1iZWQoKTtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBzcmMvbWlkZGxld2FyZS93cmFwLWltYWdlLW1vZGVsLnRzXG52YXIgd3JhcEltYWdlTW9kZWwgPSAoe1xuICBtb2RlbCxcbiAgbWlkZGxld2FyZTogbWlkZGxld2FyZUFyZyxcbiAgbW9kZWxJZCxcbiAgcHJvdmlkZXJJZFxufSkgPT4ge1xuICByZXR1cm4gWy4uLmFzQXJyYXkobWlkZGxld2FyZUFyZyldLnJldmVyc2UoKS5yZWR1Y2UoKHdyYXBwZWRNb2RlbCwgbWlkZGxld2FyZSkgPT4ge1xuICAgIHJldHVybiBkb1dyYXAzKHsgbW9kZWw6IHdyYXBwZWRNb2RlbCwgbWlkZGxld2FyZSwgbW9kZWxJZCwgcHJvdmlkZXJJZCB9KTtcbiAgfSwgbW9kZWwpO1xufTtcbnZhciBkb1dyYXAzID0gKHtcbiAgbW9kZWwsXG4gIG1pZGRsZXdhcmU6IHtcbiAgICB0cmFuc2Zvcm1QYXJhbXMsXG4gICAgd3JhcEdlbmVyYXRlLFxuICAgIG92ZXJyaWRlUHJvdmlkZXIsXG4gICAgb3ZlcnJpZGVNb2RlbElkLFxuICAgIG92ZXJyaWRlTWF4SW1hZ2VzUGVyQ2FsbFxuICB9LFxuICBtb2RlbElkLFxuICBwcm92aWRlcklkXG59KSA9PiB7XG4gIHZhciBfYTIxLCBfYiwgX2M7XG4gIGFzeW5jIGZ1bmN0aW9uIGRvVHJhbnNmb3JtKHsgcGFyYW1zIH0pIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtUGFyYW1zID8gYXdhaXQgdHJhbnNmb3JtUGFyYW1zKHsgcGFyYW1zLCBtb2RlbCB9KSA6IHBhcmFtcztcbiAgfVxuICBjb25zdCBtYXhJbWFnZXNQZXJDYWxsUmF3ID0gKF9hMjEgPSBvdmVycmlkZU1heEltYWdlc1BlckNhbGwgPT0gbnVsbCA/IHZvaWQgMCA6IG92ZXJyaWRlTWF4SW1hZ2VzUGVyQ2FsbCh7IG1vZGVsIH0pKSAhPSBudWxsID8gX2EyMSA6IG1vZGVsLm1heEltYWdlc1BlckNhbGw7XG4gIGNvbnN0IG1heEltYWdlc1BlckNhbGwgPSBtYXhJbWFnZXNQZXJDYWxsUmF3IGluc3RhbmNlb2YgRnVuY3Rpb24gPyBtYXhJbWFnZXNQZXJDYWxsUmF3LmJpbmQobW9kZWwpIDogbWF4SW1hZ2VzUGVyQ2FsbFJhdztcbiAgcmV0dXJuIHtcbiAgICBzcGVjaWZpY2F0aW9uVmVyc2lvbjogXCJ2M1wiLFxuICAgIHByb3ZpZGVyOiAoX2IgPSBwcm92aWRlcklkICE9IG51bGwgPyBwcm92aWRlcklkIDogb3ZlcnJpZGVQcm92aWRlciA9PSBudWxsID8gdm9pZCAwIDogb3ZlcnJpZGVQcm92aWRlcih7IG1vZGVsIH0pKSAhPSBudWxsID8gX2IgOiBtb2RlbC5wcm92aWRlcixcbiAgICBtb2RlbElkOiAoX2MgPSBtb2RlbElkICE9IG51bGwgPyBtb2RlbElkIDogb3ZlcnJpZGVNb2RlbElkID09IG51bGwgPyB2b2lkIDAgOiBvdmVycmlkZU1vZGVsSWQoeyBtb2RlbCB9KSkgIT0gbnVsbCA/IF9jIDogbW9kZWwubW9kZWxJZCxcbiAgICBtYXhJbWFnZXNQZXJDYWxsLFxuICAgIGFzeW5jIGRvR2VuZXJhdGUocGFyYW1zKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1lZFBhcmFtcyA9IGF3YWl0IGRvVHJhbnNmb3JtKHsgcGFyYW1zIH0pO1xuICAgICAgY29uc3QgZG9HZW5lcmF0ZSA9IGFzeW5jICgpID0+IG1vZGVsLmRvR2VuZXJhdGUodHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgcmV0dXJuIHdyYXBHZW5lcmF0ZSA/IHdyYXBHZW5lcmF0ZSh7XG4gICAgICAgIGRvR2VuZXJhdGUsXG4gICAgICAgIHBhcmFtczogdHJhbnNmb3JtZWRQYXJhbXMsXG4gICAgICAgIG1vZGVsXG4gICAgICB9KSA6IGRvR2VuZXJhdGUoKTtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBzcmMvbW9kZWwvYXMtcHJvdmlkZXItdjMudHNcbmZ1bmN0aW9uIGFzUHJvdmlkZXJWMyhwcm92aWRlcikge1xuICBpZiAoXCJzcGVjaWZpY2F0aW9uVmVyc2lvblwiIGluIHByb3ZpZGVyICYmIHByb3ZpZGVyLnNwZWNpZmljYXRpb25WZXJzaW9uID09PSBcInYzXCIpIHtcbiAgICByZXR1cm4gcHJvdmlkZXI7XG4gIH1cbiAgY29uc3QgdjJQcm92aWRlciA9IHByb3ZpZGVyO1xuICByZXR1cm4ge1xuICAgIHNwZWNpZmljYXRpb25WZXJzaW9uOiBcInYzXCIsXG4gICAgbGFuZ3VhZ2VNb2RlbDogKG1vZGVsSWQpID0+IGFzTGFuZ3VhZ2VNb2RlbFYzKHYyUHJvdmlkZXIubGFuZ3VhZ2VNb2RlbChtb2RlbElkKSksXG4gICAgZW1iZWRkaW5nTW9kZWw6IChtb2RlbElkKSA9PiBhc0VtYmVkZGluZ01vZGVsVjModjJQcm92aWRlci50ZXh0RW1iZWRkaW5nTW9kZWwobW9kZWxJZCkpLFxuICAgIGltYWdlTW9kZWw6IChtb2RlbElkKSA9PiBhc0ltYWdlTW9kZWxWMyh2MlByb3ZpZGVyLmltYWdlTW9kZWwobW9kZWxJZCkpLFxuICAgIHRyYW5zY3JpcHRpb25Nb2RlbDogdjJQcm92aWRlci50cmFuc2NyaXB0aW9uTW9kZWwgPyAobW9kZWxJZCkgPT4gYXNUcmFuc2NyaXB0aW9uTW9kZWxWMyh2MlByb3ZpZGVyLnRyYW5zY3JpcHRpb25Nb2RlbChtb2RlbElkKSkgOiB2b2lkIDAsXG4gICAgc3BlZWNoTW9kZWw6IHYyUHJvdmlkZXIuc3BlZWNoTW9kZWwgPyAobW9kZWxJZCkgPT4gYXNTcGVlY2hNb2RlbFYzKHYyUHJvdmlkZXIuc3BlZWNoTW9kZWwobW9kZWxJZCkpIDogdm9pZCAwLFxuICAgIHJlcmFua2luZ01vZGVsOiB2b2lkIDBcbiAgICAvLyB2MiBwcm92aWRlcnMgZG9uJ3QgaGF2ZSByZXJhbmtpbmcgbW9kZWxzXG4gIH07XG59XG5cbi8vIHNyYy9taWRkbGV3YXJlL3dyYXAtcHJvdmlkZXIudHNcbmZ1bmN0aW9uIHdyYXBQcm92aWRlcih7XG4gIHByb3ZpZGVyLFxuICBsYW5ndWFnZU1vZGVsTWlkZGxld2FyZSxcbiAgaW1hZ2VNb2RlbE1pZGRsZXdhcmVcbn0pIHtcbiAgY29uc3QgcHJvdmlkZXJWMyA9IGFzUHJvdmlkZXJWMyhwcm92aWRlcik7XG4gIHJldHVybiB7XG4gICAgc3BlY2lmaWNhdGlvblZlcnNpb246IFwidjNcIixcbiAgICBsYW5ndWFnZU1vZGVsOiAobW9kZWxJZCkgPT4gd3JhcExhbmd1YWdlTW9kZWwoe1xuICAgICAgbW9kZWw6IHByb3ZpZGVyVjMubGFuZ3VhZ2VNb2RlbChtb2RlbElkKSxcbiAgICAgIG1pZGRsZXdhcmU6IGxhbmd1YWdlTW9kZWxNaWRkbGV3YXJlXG4gICAgfSksXG4gICAgZW1iZWRkaW5nTW9kZWw6IHByb3ZpZGVyVjMuZW1iZWRkaW5nTW9kZWwsXG4gICAgaW1hZ2VNb2RlbDogKG1vZGVsSWQpID0+IHtcbiAgICAgIGxldCBtb2RlbCA9IHByb3ZpZGVyVjMuaW1hZ2VNb2RlbChtb2RlbElkKTtcbiAgICAgIGlmIChpbWFnZU1vZGVsTWlkZGxld2FyZSAhPSBudWxsKSB7XG4gICAgICAgIG1vZGVsID0gd3JhcEltYWdlTW9kZWwoeyBtb2RlbCwgbWlkZGxld2FyZTogaW1hZ2VNb2RlbE1pZGRsZXdhcmUgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbW9kZWw7XG4gICAgfSxcbiAgICB0cmFuc2NyaXB0aW9uTW9kZWw6IHByb3ZpZGVyVjMudHJhbnNjcmlwdGlvbk1vZGVsLFxuICAgIHNwZWVjaE1vZGVsOiBwcm92aWRlclYzLnNwZWVjaE1vZGVsLFxuICAgIHJlcmFua2luZ01vZGVsOiBwcm92aWRlclYzLnJlcmFua2luZ01vZGVsXG4gIH07XG59XG5cbi8vIHNyYy9yZWdpc3RyeS9jdXN0b20tcHJvdmlkZXIudHNcbmltcG9ydCB7XG4gIE5vU3VjaE1vZGVsRXJyb3IgYXMgTm9TdWNoTW9kZWxFcnJvcjJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmZ1bmN0aW9uIGN1c3RvbVByb3ZpZGVyKHtcbiAgbGFuZ3VhZ2VNb2RlbHMsXG4gIGVtYmVkZGluZ01vZGVscyxcbiAgaW1hZ2VNb2RlbHMsXG4gIHRyYW5zY3JpcHRpb25Nb2RlbHMsXG4gIHNwZWVjaE1vZGVscyxcbiAgcmVyYW5raW5nTW9kZWxzLFxuICB2aWRlb01vZGVscyxcbiAgZmFsbGJhY2tQcm92aWRlcjogZmFsbGJhY2tQcm92aWRlckFyZ1xufSkge1xuICBjb25zdCBmYWxsYmFja1Byb3ZpZGVyID0gZmFsbGJhY2tQcm92aWRlckFyZyA/IGFzUHJvdmlkZXJWMyhmYWxsYmFja1Byb3ZpZGVyQXJnKSA6IHZvaWQgMDtcbiAgcmV0dXJuIHtcbiAgICBzcGVjaWZpY2F0aW9uVmVyc2lvbjogXCJ2M1wiLFxuICAgIGxhbmd1YWdlTW9kZWwobW9kZWxJZCkge1xuICAgICAgaWYgKGxhbmd1YWdlTW9kZWxzICE9IG51bGwgJiYgbW9kZWxJZCBpbiBsYW5ndWFnZU1vZGVscykge1xuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VNb2RlbHNbbW9kZWxJZF07XG4gICAgICB9XG4gICAgICBpZiAoZmFsbGJhY2tQcm92aWRlcikge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tQcm92aWRlci5sYW5ndWFnZU1vZGVsKG1vZGVsSWQpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3IyKHsgbW9kZWxJZCwgbW9kZWxUeXBlOiBcImxhbmd1YWdlTW9kZWxcIiB9KTtcbiAgICB9LFxuICAgIGVtYmVkZGluZ01vZGVsKG1vZGVsSWQpIHtcbiAgICAgIGlmIChlbWJlZGRpbmdNb2RlbHMgIT0gbnVsbCAmJiBtb2RlbElkIGluIGVtYmVkZGluZ01vZGVscykge1xuICAgICAgICByZXR1cm4gZW1iZWRkaW5nTW9kZWxzW21vZGVsSWRdO1xuICAgICAgfVxuICAgICAgaWYgKGZhbGxiYWNrUHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrUHJvdmlkZXIuZW1iZWRkaW5nTW9kZWwobW9kZWxJZCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjIoeyBtb2RlbElkLCBtb2RlbFR5cGU6IFwiZW1iZWRkaW5nTW9kZWxcIiB9KTtcbiAgICB9LFxuICAgIGltYWdlTW9kZWwobW9kZWxJZCkge1xuICAgICAgaWYgKGltYWdlTW9kZWxzICE9IG51bGwgJiYgbW9kZWxJZCBpbiBpbWFnZU1vZGVscykge1xuICAgICAgICByZXR1cm4gaW1hZ2VNb2RlbHNbbW9kZWxJZF07XG4gICAgICB9XG4gICAgICBpZiAoZmFsbGJhY2tQcm92aWRlciA9PSBudWxsID8gdm9pZCAwIDogZmFsbGJhY2tQcm92aWRlci5pbWFnZU1vZGVsKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFja1Byb3ZpZGVyLmltYWdlTW9kZWwobW9kZWxJZCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjIoeyBtb2RlbElkLCBtb2RlbFR5cGU6IFwiaW1hZ2VNb2RlbFwiIH0pO1xuICAgIH0sXG4gICAgdHJhbnNjcmlwdGlvbk1vZGVsKG1vZGVsSWQpIHtcbiAgICAgIGlmICh0cmFuc2NyaXB0aW9uTW9kZWxzICE9IG51bGwgJiYgbW9kZWxJZCBpbiB0cmFuc2NyaXB0aW9uTW9kZWxzKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2NyaXB0aW9uTW9kZWxzW21vZGVsSWRdO1xuICAgICAgfVxuICAgICAgaWYgKGZhbGxiYWNrUHJvdmlkZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGZhbGxiYWNrUHJvdmlkZXIudHJhbnNjcmlwdGlvbk1vZGVsKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFja1Byb3ZpZGVyLnRyYW5zY3JpcHRpb25Nb2RlbChtb2RlbElkKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yMih7IG1vZGVsSWQsIG1vZGVsVHlwZTogXCJ0cmFuc2NyaXB0aW9uTW9kZWxcIiB9KTtcbiAgICB9LFxuICAgIHNwZWVjaE1vZGVsKG1vZGVsSWQpIHtcbiAgICAgIGlmIChzcGVlY2hNb2RlbHMgIT0gbnVsbCAmJiBtb2RlbElkIGluIHNwZWVjaE1vZGVscykge1xuICAgICAgICByZXR1cm4gc3BlZWNoTW9kZWxzW21vZGVsSWRdO1xuICAgICAgfVxuICAgICAgaWYgKGZhbGxiYWNrUHJvdmlkZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGZhbGxiYWNrUHJvdmlkZXIuc3BlZWNoTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrUHJvdmlkZXIuc3BlZWNoTW9kZWwobW9kZWxJZCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjIoeyBtb2RlbElkLCBtb2RlbFR5cGU6IFwic3BlZWNoTW9kZWxcIiB9KTtcbiAgICB9LFxuICAgIHJlcmFua2luZ01vZGVsKG1vZGVsSWQpIHtcbiAgICAgIGlmIChyZXJhbmtpbmdNb2RlbHMgIT0gbnVsbCAmJiBtb2RlbElkIGluIHJlcmFua2luZ01vZGVscykge1xuICAgICAgICByZXR1cm4gcmVyYW5raW5nTW9kZWxzW21vZGVsSWRdO1xuICAgICAgfVxuICAgICAgaWYgKGZhbGxiYWNrUHJvdmlkZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGZhbGxiYWNrUHJvdmlkZXIucmVyYW5raW5nTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrUHJvdmlkZXIucmVyYW5raW5nTW9kZWwobW9kZWxJZCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjIoeyBtb2RlbElkLCBtb2RlbFR5cGU6IFwicmVyYW5raW5nTW9kZWxcIiB9KTtcbiAgICB9LFxuICAgIHZpZGVvTW9kZWwobW9kZWxJZCkge1xuICAgICAgaWYgKHZpZGVvTW9kZWxzICE9IG51bGwgJiYgbW9kZWxJZCBpbiB2aWRlb01vZGVscykge1xuICAgICAgICByZXR1cm4gdmlkZW9Nb2RlbHNbbW9kZWxJZF07XG4gICAgICB9XG4gICAgICBjb25zdCB2aWRlb01vZGVsID0gZmFsbGJhY2tQcm92aWRlciA9PSBudWxsID8gdm9pZCAwIDogZmFsbGJhY2tQcm92aWRlci52aWRlb01vZGVsO1xuICAgICAgaWYgKHZpZGVvTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHZpZGVvTW9kZWwobW9kZWxJZCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjIoeyBtb2RlbElkLCBtb2RlbFR5cGU6IFwidmlkZW9Nb2RlbFwiIH0pO1xuICAgIH1cbiAgfTtcbn1cbnZhciBleHBlcmltZW50YWxfY3VzdG9tUHJvdmlkZXIgPSBjdXN0b21Qcm92aWRlcjtcblxuLy8gc3JjL3JlZ2lzdHJ5L25vLXN1Y2gtcHJvdmlkZXItZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjI0LCBOb1N1Y2hNb2RlbEVycm9yIGFzIE5vU3VjaE1vZGVsRXJyb3IzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMjAgPSBcIkFJX05vU3VjaFByb3ZpZGVyRXJyb3JcIjtcbnZhciBtYXJrZXIyMCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMjB9YDtcbnZhciBzeW1ib2wyMCA9IFN5bWJvbC5mb3IobWFya2VyMjApO1xudmFyIF9hMjA7XG52YXIgTm9TdWNoUHJvdmlkZXJFcnJvciA9IGNsYXNzIGV4dGVuZHMgTm9TdWNoTW9kZWxFcnJvcjMge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbW9kZWxJZCxcbiAgICBtb2RlbFR5cGUsXG4gICAgcHJvdmlkZXJJZCxcbiAgICBhdmFpbGFibGVQcm92aWRlcnMsXG4gICAgbWVzc2FnZSA9IGBObyBzdWNoIHByb3ZpZGVyOiAke3Byb3ZpZGVySWR9IChhdmFpbGFibGUgcHJvdmlkZXJzOiAke2F2YWlsYWJsZVByb3ZpZGVycy5qb2luKCl9KWBcbiAgfSkge1xuICAgIHN1cGVyKHsgZXJyb3JOYW1lOiBuYW1lMjAsIG1vZGVsSWQsIG1vZGVsVHlwZSwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hMjBdID0gdHJ1ZTtcbiAgICB0aGlzLnByb3ZpZGVySWQgPSBwcm92aWRlcklkO1xuICAgIHRoaXMuYXZhaWxhYmxlUHJvdmlkZXJzID0gYXZhaWxhYmxlUHJvdmlkZXJzO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IyNC5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjIwKTtcbiAgfVxufTtcbl9hMjAgPSBzeW1ib2wyMDtcblxuLy8gc3JjL3JlZ2lzdHJ5L3Byb3ZpZGVyLXJlZ2lzdHJ5LnRzXG5pbXBvcnQge1xuICBOb1N1Y2hNb2RlbEVycm9yIGFzIE5vU3VjaE1vZGVsRXJyb3I0XG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5mdW5jdGlvbiBjcmVhdGVQcm92aWRlclJlZ2lzdHJ5KHByb3ZpZGVycywge1xuICBzZXBhcmF0b3IgPSBcIjpcIixcbiAgbGFuZ3VhZ2VNb2RlbE1pZGRsZXdhcmUsXG4gIGltYWdlTW9kZWxNaWRkbGV3YXJlXG59ID0ge30pIHtcbiAgY29uc3QgcmVnaXN0cnkgPSBuZXcgRGVmYXVsdFByb3ZpZGVyUmVnaXN0cnkoe1xuICAgIHNlcGFyYXRvcixcbiAgICBsYW5ndWFnZU1vZGVsTWlkZGxld2FyZSxcbiAgICBpbWFnZU1vZGVsTWlkZGxld2FyZVxuICB9KTtcbiAgZm9yIChjb25zdCBbaWQsIHByb3ZpZGVyXSBvZiBPYmplY3QuZW50cmllcyhwcm92aWRlcnMpKSB7XG4gICAgcmVnaXN0cnkucmVnaXN0ZXJQcm92aWRlcih7IGlkLCBwcm92aWRlciB9KTtcbiAgfVxuICByZXR1cm4gcmVnaXN0cnk7XG59XG52YXIgZXhwZXJpbWVudGFsX2NyZWF0ZVByb3ZpZGVyUmVnaXN0cnkgPSBjcmVhdGVQcm92aWRlclJlZ2lzdHJ5O1xudmFyIERlZmF1bHRQcm92aWRlclJlZ2lzdHJ5ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgc2VwYXJhdG9yLFxuICAgIGxhbmd1YWdlTW9kZWxNaWRkbGV3YXJlLFxuICAgIGltYWdlTW9kZWxNaWRkbGV3YXJlXG4gIH0pIHtcbiAgICB0aGlzLnByb3ZpZGVycyA9IHt9O1xuICAgIHRoaXMuc2VwYXJhdG9yID0gc2VwYXJhdG9yO1xuICAgIHRoaXMubGFuZ3VhZ2VNb2RlbE1pZGRsZXdhcmUgPSBsYW5ndWFnZU1vZGVsTWlkZGxld2FyZTtcbiAgICB0aGlzLmltYWdlTW9kZWxNaWRkbGV3YXJlID0gaW1hZ2VNb2RlbE1pZGRsZXdhcmU7XG4gIH1cbiAgcmVnaXN0ZXJQcm92aWRlcih7XG4gICAgaWQsXG4gICAgcHJvdmlkZXJcbiAgfSkge1xuICAgIHRoaXMucHJvdmlkZXJzW2lkXSA9IHByb3ZpZGVyO1xuICB9XG4gIGdldFByb3ZpZGVyKGlkLCBtb2RlbFR5cGUpIHtcbiAgICBjb25zdCBwcm92aWRlciA9IHRoaXMucHJvdmlkZXJzW2lkXTtcbiAgICBpZiAocHJvdmlkZXIgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vU3VjaFByb3ZpZGVyRXJyb3Ioe1xuICAgICAgICBtb2RlbElkOiBpZCxcbiAgICAgICAgbW9kZWxUeXBlLFxuICAgICAgICBwcm92aWRlcklkOiBpZCxcbiAgICAgICAgYXZhaWxhYmxlUHJvdmlkZXJzOiBPYmplY3Qua2V5cyh0aGlzLnByb3ZpZGVycylcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJvdmlkZXI7XG4gIH1cbiAgc3BsaXRJZChpZCwgbW9kZWxUeXBlKSB7XG4gICAgY29uc3QgaW5kZXggPSBpZC5pbmRleE9mKHRoaXMuc2VwYXJhdG9yKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjQoe1xuICAgICAgICBtb2RlbElkOiBpZCxcbiAgICAgICAgbW9kZWxUeXBlLFxuICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCAke21vZGVsVHlwZX0gaWQgZm9yIHJlZ2lzdHJ5OiAke2lkfSAobXVzdCBiZSBpbiB0aGUgZm9ybWF0IFwicHJvdmlkZXJJZCR7dGhpcy5zZXBhcmF0b3J9bW9kZWxJZFwiKWBcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gW2lkLnNsaWNlKDAsIGluZGV4KSwgaWQuc2xpY2UoaW5kZXggKyB0aGlzLnNlcGFyYXRvci5sZW5ndGgpXTtcbiAgfVxuICBsYW5ndWFnZU1vZGVsKGlkKSB7XG4gICAgdmFyIF9hMjEsIF9iO1xuICAgIGNvbnN0IFtwcm92aWRlcklkLCBtb2RlbElkXSA9IHRoaXMuc3BsaXRJZChpZCwgXCJsYW5ndWFnZU1vZGVsXCIpO1xuICAgIGxldCBtb2RlbCA9IChfYiA9IChfYTIxID0gdGhpcy5nZXRQcm92aWRlcihwcm92aWRlcklkLCBcImxhbmd1YWdlTW9kZWxcIikpLmxhbmd1YWdlTW9kZWwpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKFxuICAgICAgX2EyMSxcbiAgICAgIG1vZGVsSWRcbiAgICApO1xuICAgIGlmIChtb2RlbCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjQoeyBtb2RlbElkOiBpZCwgbW9kZWxUeXBlOiBcImxhbmd1YWdlTW9kZWxcIiB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMubGFuZ3VhZ2VNb2RlbE1pZGRsZXdhcmUgIT0gbnVsbCkge1xuICAgICAgbW9kZWwgPSB3cmFwTGFuZ3VhZ2VNb2RlbCh7XG4gICAgICAgIG1vZGVsLFxuICAgICAgICBtaWRkbGV3YXJlOiB0aGlzLmxhbmd1YWdlTW9kZWxNaWRkbGV3YXJlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIGVtYmVkZGluZ01vZGVsKGlkKSB7XG4gICAgdmFyIF9hMjE7XG4gICAgY29uc3QgW3Byb3ZpZGVySWQsIG1vZGVsSWRdID0gdGhpcy5zcGxpdElkKGlkLCBcImVtYmVkZGluZ01vZGVsXCIpO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcm92aWRlcklkLCBcImVtYmVkZGluZ01vZGVsXCIpO1xuICAgIGNvbnN0IG1vZGVsID0gKF9hMjEgPSBwcm92aWRlci5lbWJlZGRpbmdNb2RlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMjEuY2FsbChwcm92aWRlciwgbW9kZWxJZCk7XG4gICAgaWYgKG1vZGVsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yNCh7XG4gICAgICAgIG1vZGVsSWQ6IGlkLFxuICAgICAgICBtb2RlbFR5cGU6IFwiZW1iZWRkaW5nTW9kZWxcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuICBpbWFnZU1vZGVsKGlkKSB7XG4gICAgdmFyIF9hMjE7XG4gICAgY29uc3QgW3Byb3ZpZGVySWQsIG1vZGVsSWRdID0gdGhpcy5zcGxpdElkKGlkLCBcImltYWdlTW9kZWxcIik7XG4gICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByb3ZpZGVySWQsIFwiaW1hZ2VNb2RlbFwiKTtcbiAgICBsZXQgbW9kZWwgPSAoX2EyMSA9IHByb3ZpZGVyLmltYWdlTW9kZWwpID09IG51bGwgPyB2b2lkIDAgOiBfYTIxLmNhbGwocHJvdmlkZXIsIG1vZGVsSWQpO1xuICAgIGlmIChtb2RlbCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjQoeyBtb2RlbElkOiBpZCwgbW9kZWxUeXBlOiBcImltYWdlTW9kZWxcIiB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW1hZ2VNb2RlbE1pZGRsZXdhcmUgIT0gbnVsbCkge1xuICAgICAgbW9kZWwgPSB3cmFwSW1hZ2VNb2RlbCh7XG4gICAgICAgIG1vZGVsLFxuICAgICAgICBtaWRkbGV3YXJlOiB0aGlzLmltYWdlTW9kZWxNaWRkbGV3YXJlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIHRyYW5zY3JpcHRpb25Nb2RlbChpZCkge1xuICAgIHZhciBfYTIxO1xuICAgIGNvbnN0IFtwcm92aWRlcklkLCBtb2RlbElkXSA9IHRoaXMuc3BsaXRJZChpZCwgXCJ0cmFuc2NyaXB0aW9uTW9kZWxcIik7XG4gICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByb3ZpZGVySWQsIFwidHJhbnNjcmlwdGlvbk1vZGVsXCIpO1xuICAgIGNvbnN0IG1vZGVsID0gKF9hMjEgPSBwcm92aWRlci50cmFuc2NyaXB0aW9uTW9kZWwpID09IG51bGwgPyB2b2lkIDAgOiBfYTIxLmNhbGwocHJvdmlkZXIsIG1vZGVsSWQpO1xuICAgIGlmIChtb2RlbCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjQoe1xuICAgICAgICBtb2RlbElkOiBpZCxcbiAgICAgICAgbW9kZWxUeXBlOiBcInRyYW5zY3JpcHRpb25Nb2RlbFwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIHNwZWVjaE1vZGVsKGlkKSB7XG4gICAgdmFyIF9hMjE7XG4gICAgY29uc3QgW3Byb3ZpZGVySWQsIG1vZGVsSWRdID0gdGhpcy5zcGxpdElkKGlkLCBcInNwZWVjaE1vZGVsXCIpO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcm92aWRlcklkLCBcInNwZWVjaE1vZGVsXCIpO1xuICAgIGNvbnN0IG1vZGVsID0gKF9hMjEgPSBwcm92aWRlci5zcGVlY2hNb2RlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMjEuY2FsbChwcm92aWRlciwgbW9kZWxJZCk7XG4gICAgaWYgKG1vZGVsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yNCh7IG1vZGVsSWQ6IGlkLCBtb2RlbFR5cGU6IFwic3BlZWNoTW9kZWxcIiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIHJlcmFua2luZ01vZGVsKGlkKSB7XG4gICAgdmFyIF9hMjE7XG4gICAgY29uc3QgW3Byb3ZpZGVySWQsIG1vZGVsSWRdID0gdGhpcy5zcGxpdElkKGlkLCBcInJlcmFua2luZ01vZGVsXCIpO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcm92aWRlcklkLCBcInJlcmFua2luZ01vZGVsXCIpO1xuICAgIGNvbnN0IG1vZGVsID0gKF9hMjEgPSBwcm92aWRlci5yZXJhbmtpbmdNb2RlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMjEuY2FsbChwcm92aWRlciwgbW9kZWxJZCk7XG4gICAgaWYgKG1vZGVsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yNCh7IG1vZGVsSWQ6IGlkLCBtb2RlbFR5cGU6IFwicmVyYW5raW5nTW9kZWxcIiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG59O1xuXG4vLyBzcmMvcmVyYW5rL3JlcmFuay50c1xuYXN5bmMgZnVuY3Rpb24gcmVyYW5rKHtcbiAgbW9kZWwsXG4gIGRvY3VtZW50cyxcbiAgcXVlcnksXG4gIHRvcE4sXG4gIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzLFxuICBwcm92aWRlck9wdGlvbnMsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeVxufSkge1xuICBpZiAoZG9jdW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgRGVmYXVsdFJlcmFua1Jlc3VsdCh7XG4gICAgICBvcmlnaW5hbERvY3VtZW50czogW10sXG4gICAgICByYW5raW5nOiBbXSxcbiAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHZvaWQgMCxcbiAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgIHRpbWVzdGFtcDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICAgIG1vZGVsSWQ6IG1vZGVsLm1vZGVsSWRcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb25zdCB7IG1heFJldHJpZXMsIHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7XG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICBhYm9ydFNpZ25hbFxuICB9KTtcbiAgY29uc3QgZG9jdW1lbnRzVG9TZW5kID0gdHlwZW9mIGRvY3VtZW50c1swXSA9PT0gXCJzdHJpbmdcIiA/IHsgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlczogZG9jdW1lbnRzIH0gOiB7IHR5cGU6IFwib2JqZWN0XCIsIHZhbHVlczogZG9jdW1lbnRzIH07XG4gIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzOiB7IG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICBuYW1lOiBcImFpLnJlcmFua1wiLFxuICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoeyBvcGVyYXRpb25JZDogXCJhaS5yZXJhbmtcIiwgdGVsZW1ldHJ5IH0pLFxuICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgXCJhaS5kb2N1bWVudHNcIjoge1xuICAgICAgICAgIGlucHV0OiAoKSA9PiBkb2N1bWVudHMubWFwKChkb2N1bWVudCkgPT4gSlNPTi5zdHJpbmdpZnkoZG9jdW1lbnQpKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSksXG4gICAgdHJhY2VyLFxuICAgIGZuOiBhc3luYyAoKSA9PiB7XG4gICAgICB2YXIgX2EyMSwgX2I7XG4gICAgICBjb25zdCB7IHJhbmtpbmcsIHJlc3BvbnNlLCBwcm92aWRlck1ldGFkYXRhLCB3YXJuaW5ncyB9ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICgpID0+IHJlY29yZFNwYW4oe1xuICAgICAgICAgIG5hbWU6IFwiYWkucmVyYW5rLmRvUmVyYW5rXCIsXG4gICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkucmVyYW5rLmRvUmVyYW5rXCIsXG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICAgICAgICBcImFpLmRvY3VtZW50c1wiOiB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IGRvY3VtZW50cy5tYXAoKGRvY3VtZW50KSA9PiBKU09OLnN0cmluZ2lmeShkb2N1bWVudCkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgZm46IGFzeW5jIChkb1JlcmFua1NwYW4pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsUmVzcG9uc2UgPSBhd2FpdCBtb2RlbC5kb1JlcmFuayh7XG4gICAgICAgICAgICAgIGRvY3VtZW50czogZG9jdW1lbnRzVG9TZW5kLFxuICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgdG9wTixcbiAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zLFxuICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByYW5raW5nMiA9IG1vZGVsUmVzcG9uc2UucmFua2luZztcbiAgICAgICAgICAgIGRvUmVyYW5rU3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICBhd2FpdCBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgXCJhaS5yYW5raW5nLnR5cGVcIjogZG9jdW1lbnRzVG9TZW5kLnR5cGUsXG4gICAgICAgICAgICAgICAgICBcImFpLnJhbmtpbmdcIjoge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IHJhbmtpbmcyLm1hcCgocmFua2luZzMpID0+IEpTT04uc3RyaW5naWZ5KHJhbmtpbmczKSlcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcmFua2luZzogcmFua2luZzIsXG4gICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IG1vZGVsUmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgcmVzcG9uc2U6IG1vZGVsUmVzcG9uc2UucmVzcG9uc2UsXG4gICAgICAgICAgICAgIHdhcm5pbmdzOiBtb2RlbFJlc3BvbnNlLndhcm5pbmdzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBsb2dXYXJuaW5ncyh7XG4gICAgICAgIHdhcm5pbmdzOiB3YXJuaW5ncyAhPSBudWxsID8gd2FybmluZ3MgOiBbXSxcbiAgICAgICAgcHJvdmlkZXI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICBtb2RlbDogbW9kZWwubW9kZWxJZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IERlZmF1bHRSZXJhbmtSZXN1bHQoe1xuICAgICAgICBvcmlnaW5hbERvY3VtZW50czogZG9jdW1lbnRzLFxuICAgICAgICByYW5raW5nOiByYW5raW5nLm1hcCgocmFua2luZzIpID0+ICh7XG4gICAgICAgICAgb3JpZ2luYWxJbmRleDogcmFua2luZzIuaW5kZXgsXG4gICAgICAgICAgc2NvcmU6IHJhbmtpbmcyLnJlbGV2YW5jZVNjb3JlLFxuICAgICAgICAgIGRvY3VtZW50OiBkb2N1bWVudHNbcmFua2luZzIuaW5kZXhdXG4gICAgICAgIH0pKSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICBpZDogcmVzcG9uc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc3BvbnNlLmlkLFxuICAgICAgICAgIHRpbWVzdGFtcDogKF9hMjEgPSByZXNwb25zZSA9PSBudWxsID8gdm9pZCAwIDogcmVzcG9uc2UudGltZXN0YW1wKSAhPSBudWxsID8gX2EyMSA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgICAgIG1vZGVsSWQ6IChfYiA9IHJlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByZXNwb25zZS5tb2RlbElkKSAhPSBudWxsID8gX2IgOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IHJlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByZXNwb25zZS5ib2R5XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG52YXIgRGVmYXVsdFJlcmFua1Jlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMub3JpZ2luYWxEb2N1bWVudHMgPSBvcHRpb25zLm9yaWdpbmFsRG9jdW1lbnRzO1xuICAgIHRoaXMucmFua2luZyA9IG9wdGlvbnMucmFua2luZztcbiAgICB0aGlzLnJlc3BvbnNlID0gb3B0aW9ucy5yZXNwb25zZTtcbiAgICB0aGlzLnByb3ZpZGVyTWV0YWRhdGEgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGE7XG4gIH1cbiAgZ2V0IHJlcmFua2VkRG9jdW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLnJhbmtpbmcubWFwKChyYW5raW5nKSA9PiByYW5raW5nLmRvY3VtZW50KTtcbiAgfVxufTtcblxuLy8gc3JjL3RyYW5zY3JpYmUvdHJhbnNjcmliZS50c1xuaW1wb3J0IHsgd2l0aFVzZXJBZ2VudFN1ZmZpeCBhcyB3aXRoVXNlckFnZW50U3VmZml4OSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG52YXIgZGVmYXVsdERvd25sb2FkMiA9IGNyZWF0ZURvd25sb2FkKCk7XG5hc3luYyBmdW5jdGlvbiB0cmFuc2NyaWJlKHtcbiAgbW9kZWwsXG4gIGF1ZGlvLFxuICBwcm92aWRlck9wdGlvbnMgPSB7fSxcbiAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIGRvd25sb2FkOiBkb3dubG9hZEZuID0gZGVmYXVsdERvd25sb2FkMlxufSkge1xuICBjb25zdCByZXNvbHZlZE1vZGVsID0gcmVzb2x2ZVRyYW5zY3JpcHRpb25Nb2RlbChtb2RlbCk7XG4gIGlmICghcmVzb2x2ZWRNb2RlbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1vZGVsIGNvdWxkIG5vdCBiZSByZXNvbHZlZFwiKTtcbiAgfVxuICBjb25zdCB7IHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7XG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICBhYm9ydFNpZ25hbFxuICB9KTtcbiAgY29uc3QgaGVhZGVyc1dpdGhVc2VyQWdlbnQgPSB3aXRoVXNlckFnZW50U3VmZml4OShcbiAgICBoZWFkZXJzICE9IG51bGwgPyBoZWFkZXJzIDoge30sXG4gICAgYGFpLyR7VkVSU0lPTn1gXG4gICk7XG4gIGNvbnN0IGF1ZGlvRGF0YSA9IGF1ZGlvIGluc3RhbmNlb2YgVVJMID8gKGF3YWl0IGRvd25sb2FkRm4oeyB1cmw6IGF1ZGlvLCBhYm9ydFNpZ25hbCB9KSkuZGF0YSA6IGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShhdWRpbyk7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJldHJ5KFxuICAgICgpID0+IHtcbiAgICAgIHZhciBfYTIxO1xuICAgICAgcmV0dXJuIHJlc29sdmVkTW9kZWwuZG9HZW5lcmF0ZSh7XG4gICAgICAgIGF1ZGlvOiBhdWRpb0RhdGEsXG4gICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICBoZWFkZXJzOiBoZWFkZXJzV2l0aFVzZXJBZ2VudCxcbiAgICAgICAgcHJvdmlkZXJPcHRpb25zLFxuICAgICAgICBtZWRpYVR5cGU6IChfYTIxID0gZGV0ZWN0TWVkaWFUeXBlKHtcbiAgICAgICAgICBkYXRhOiBhdWRpb0RhdGEsXG4gICAgICAgICAgc2lnbmF0dXJlczogYXVkaW9NZWRpYVR5cGVTaWduYXR1cmVzXG4gICAgICAgIH0pKSAhPSBudWxsID8gX2EyMSA6IFwiYXVkaW8vd2F2XCJcbiAgICAgIH0pO1xuICAgIH1cbiAgKTtcbiAgbG9nV2FybmluZ3Moe1xuICAgIHdhcm5pbmdzOiByZXN1bHQud2FybmluZ3MsXG4gICAgcHJvdmlkZXI6IHJlc29sdmVkTW9kZWwucHJvdmlkZXIsXG4gICAgbW9kZWw6IHJlc29sdmVkTW9kZWwubW9kZWxJZFxuICB9KTtcbiAgaWYgKCFyZXN1bHQudGV4dCkge1xuICAgIHRocm93IG5ldyBOb1RyYW5zY3JpcHRHZW5lcmF0ZWRFcnJvcih7IHJlc3BvbnNlczogW3Jlc3VsdC5yZXNwb25zZV0gfSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBEZWZhdWx0VHJhbnNjcmlwdGlvblJlc3VsdCh7XG4gICAgdGV4dDogcmVzdWx0LnRleHQsXG4gICAgc2VnbWVudHM6IHJlc3VsdC5zZWdtZW50cyxcbiAgICBsYW5ndWFnZTogcmVzdWx0Lmxhbmd1YWdlLFxuICAgIGR1cmF0aW9uSW5TZWNvbmRzOiByZXN1bHQuZHVyYXRpb25JblNlY29uZHMsXG4gICAgd2FybmluZ3M6IHJlc3VsdC53YXJuaW5ncyxcbiAgICByZXNwb25zZXM6IFtyZXN1bHQucmVzcG9uc2VdLFxuICAgIHByb3ZpZGVyTWV0YWRhdGE6IHJlc3VsdC5wcm92aWRlck1ldGFkYXRhXG4gIH0pO1xufVxudmFyIERlZmF1bHRUcmFuc2NyaXB0aW9uUmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF9hMjE7XG4gICAgdGhpcy50ZXh0ID0gb3B0aW9ucy50ZXh0O1xuICAgIHRoaXMuc2VnbWVudHMgPSBvcHRpb25zLnNlZ21lbnRzO1xuICAgIHRoaXMubGFuZ3VhZ2UgPSBvcHRpb25zLmxhbmd1YWdlO1xuICAgIHRoaXMuZHVyYXRpb25JblNlY29uZHMgPSBvcHRpb25zLmR1cmF0aW9uSW5TZWNvbmRzO1xuICAgIHRoaXMud2FybmluZ3MgPSBvcHRpb25zLndhcm5pbmdzO1xuICAgIHRoaXMucmVzcG9uc2VzID0gb3B0aW9ucy5yZXNwb25zZXM7XG4gICAgdGhpcy5wcm92aWRlck1ldGFkYXRhID0gKF9hMjEgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGEpICE9IG51bGwgPyBfYTIxIDoge307XG4gIH1cbn07XG5cbi8vIHNyYy91aS9jYWxsLWNvbXBsZXRpb24tYXBpLnRzXG5pbXBvcnQge1xuICBwYXJzZUpzb25FdmVudFN0cmVhbSxcbiAgd2l0aFVzZXJBZ2VudFN1ZmZpeCBhcyB3aXRoVXNlckFnZW50U3VmZml4MTAsXG4gIGdldFJ1bnRpbWVFbnZpcm9ubWVudFVzZXJBZ2VudCBhcyBnZXRSdW50aW1lRW52aXJvbm1lbnRVc2VyQWdlbnQyXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy91aS9wcm9jZXNzLXRleHQtc3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzVGV4dFN0cmVhbSh7XG4gIHN0cmVhbSxcbiAgb25UZXh0UGFydFxufSkge1xuICBjb25zdCByZWFkZXIgPSBzdHJlYW0ucGlwZVRocm91Z2gobmV3IFRleHREZWNvZGVyU3RyZWFtKCkpLmdldFJlYWRlcigpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBhd2FpdCBvblRleHRQYXJ0KHZhbHVlKTtcbiAgfVxufVxuXG4vLyBzcmMvdWkvY2FsbC1jb21wbGV0aW9uLWFwaS50c1xudmFyIGdldE9yaWdpbmFsRmV0Y2ggPSAoKSA9PiBmZXRjaDtcbmFzeW5jIGZ1bmN0aW9uIGNhbGxDb21wbGV0aW9uQXBpKHtcbiAgYXBpLFxuICBwcm9tcHQsXG4gIGNyZWRlbnRpYWxzLFxuICBoZWFkZXJzLFxuICBib2R5LFxuICBzdHJlYW1Qcm90b2NvbCA9IFwiZGF0YVwiLFxuICBzZXRDb21wbGV0aW9uLFxuICBzZXRMb2FkaW5nLFxuICBzZXRFcnJvcixcbiAgc2V0QWJvcnRDb250cm9sbGVyLFxuICBvbkZpbmlzaCxcbiAgb25FcnJvcixcbiAgZmV0Y2g6IGZldGNoMiA9IGdldE9yaWdpbmFsRmV0Y2goKVxufSkge1xuICB2YXIgX2EyMTtcbiAgdHJ5IHtcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKHZvaWQgMCk7XG4gICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHNldEFib3J0Q29udHJvbGxlcihhYm9ydENvbnRyb2xsZXIpO1xuICAgIHNldENvbXBsZXRpb24oXCJcIik7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaDIoYXBpLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBwcm9tcHQsXG4gICAgICAgIC4uLmJvZHlcbiAgICAgIH0pLFxuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICBoZWFkZXJzOiB3aXRoVXNlckFnZW50U3VmZml4MTAoXG4gICAgICAgIHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5oZWFkZXJzXG4gICAgICAgIH0sXG4gICAgICAgIGBhaS1zZGsvJHtWRVJTSU9OfWAsXG4gICAgICAgIGdldFJ1bnRpbWVFbnZpcm9ubWVudFVzZXJBZ2VudDIoKVxuICAgICAgKSxcbiAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbFxuICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIChfYTIxID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpKSAhPSBudWxsID8gX2EyMSA6IFwiRmFpbGVkIHRvIGZldGNoIHRoZSBjaGF0IHJlc3BvbnNlLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByZXNwb25zZSBib2R5IGlzIGVtcHR5LlwiKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgc3dpdGNoIChzdHJlYW1Qcm90b2NvbCkge1xuICAgICAgY2FzZSBcInRleHRcIjoge1xuICAgICAgICBhd2FpdCBwcm9jZXNzVGV4dFN0cmVhbSh7XG4gICAgICAgICAgc3RyZWFtOiByZXNwb25zZS5ib2R5LFxuICAgICAgICAgIG9uVGV4dFBhcnQ6IChjaHVuaykgPT4ge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGNodW5rO1xuICAgICAgICAgICAgc2V0Q29tcGxldGlvbihyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImRhdGFcIjoge1xuICAgICAgICBhd2FpdCBjb25zdW1lU3RyZWFtKHtcbiAgICAgICAgICBzdHJlYW06IHBhcnNlSnNvbkV2ZW50U3RyZWFtKHtcbiAgICAgICAgICAgIHN0cmVhbTogcmVzcG9uc2UuYm9keSxcbiAgICAgICAgICAgIHNjaGVtYTogdWlNZXNzYWdlQ2h1bmtTY2hlbWFcbiAgICAgICAgICB9KS5waXBlVGhyb3VnaChcbiAgICAgICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgICAgICBhc3luYyB0cmFuc2Zvcm0ocGFydCkge1xuICAgICAgICAgICAgICAgIGlmICghcGFydC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBwYXJ0LmVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzdHJlYW1QYXJ0ID0gcGFydC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyZWFtUGFydC50eXBlID09PSBcInRleHQtZGVsdGFcIikge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0cmVhbVBhcnQuZGVsdGE7XG4gICAgICAgICAgICAgICAgICBzZXRDb21wbGV0aW9uKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW1QYXJ0LnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cmVhbVBhcnQuZXJyb3JUZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKSxcbiAgICAgICAgICBvbkVycm9yOiAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2sgPSBzdHJlYW1Qcm90b2NvbDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHN0cmVhbSBwcm90b2NvbDogJHtleGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbkZpbmlzaCkge1xuICAgICAgb25GaW5pc2gocHJvbXB0LCByZXN1bHQpO1xuICAgIH1cbiAgICBzZXRBYm9ydENvbnRyb2xsZXIobnVsbCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyci5uYW1lID09PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXRFcnJvcihlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICB9XG59XG5cbi8vIHNyYy91aS9jaGF0LnRzXG5pbXBvcnQge1xuICBnZW5lcmF0ZUlkIGFzIGdlbmVyYXRlSWRGdW5jMlxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdWkvY29udmVydC1maWxlLWxpc3QtdG8tZmlsZS11aS1wYXJ0cy50c1xuYXN5bmMgZnVuY3Rpb24gY29udmVydEZpbGVMaXN0VG9GaWxlVUlQYXJ0cyhmaWxlcykge1xuICBpZiAoZmlsZXMgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoIWdsb2JhbFRoaXMuRmlsZUxpc3QgfHwgIShmaWxlcyBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuRmlsZUxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmlsZUxpc3QgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudFwiKTtcbiAgfVxuICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgQXJyYXkuZnJvbShmaWxlcykubWFwKGFzeW5jIChmaWxlKSA9PiB7XG4gICAgICBjb25zdCB7IG5hbWU6IG5hbWUyMSwgdHlwZSB9ID0gZmlsZTtcbiAgICAgIGNvbnN0IGRhdGFVcmwgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZTMsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25sb2FkID0gKHJlYWRlckV2ZW50KSA9PiB7XG4gICAgICAgICAgdmFyIF9hMjE7XG4gICAgICAgICAgcmVzb2x2ZTMoKF9hMjEgPSByZWFkZXJFdmVudC50YXJnZXQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIxLnJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5vbmVycm9yID0gKGVycm9yKSA9PiByZWplY3QoZXJyb3IpO1xuICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgIG1lZGlhVHlwZTogdHlwZSxcbiAgICAgICAgZmlsZW5hbWU6IG5hbWUyMSxcbiAgICAgICAgdXJsOiBkYXRhVXJsXG4gICAgICB9O1xuICAgIH0pXG4gICk7XG59XG5cbi8vIHNyYy91aS9kZWZhdWx0LWNoYXQtdHJhbnNwb3J0LnRzXG5pbXBvcnQgeyBwYXJzZUpzb25FdmVudFN0cmVhbSBhcyBwYXJzZUpzb25FdmVudFN0cmVhbTIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdWkvaHR0cC1jaGF0LXRyYW5zcG9ydC50c1xuaW1wb3J0IHtcbiAgbm9ybWFsaXplSGVhZGVycyxcbiAgcmVzb2x2ZSBhcyByZXNvbHZlMixcbiAgd2l0aFVzZXJBZ2VudFN1ZmZpeCBhcyB3aXRoVXNlckFnZW50U3VmZml4MTEsXG4gIGdldFJ1bnRpbWVFbnZpcm9ubWVudFVzZXJBZ2VudCBhcyBnZXRSdW50aW1lRW52aXJvbm1lbnRVc2VyQWdlbnQzXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG52YXIgSHR0cENoYXRUcmFuc3BvcnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBhcGkgPSBcIi9hcGkvY2hhdFwiLFxuICAgIGNyZWRlbnRpYWxzLFxuICAgIGhlYWRlcnMsXG4gICAgYm9keSxcbiAgICBmZXRjaDogZmV0Y2gyLFxuICAgIHByZXBhcmVTZW5kTWVzc2FnZXNSZXF1ZXN0LFxuICAgIHByZXBhcmVSZWNvbm5lY3RUb1N0cmVhbVJlcXVlc3RcbiAgfSkge1xuICAgIHRoaXMuYXBpID0gYXBpO1xuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBjcmVkZW50aWFscztcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5mZXRjaCA9IGZldGNoMjtcbiAgICB0aGlzLnByZXBhcmVTZW5kTWVzc2FnZXNSZXF1ZXN0ID0gcHJlcGFyZVNlbmRNZXNzYWdlc1JlcXVlc3Q7XG4gICAgdGhpcy5wcmVwYXJlUmVjb25uZWN0VG9TdHJlYW1SZXF1ZXN0ID0gcHJlcGFyZVJlY29ubmVjdFRvU3RyZWFtUmVxdWVzdDtcbiAgfVxuICBhc3luYyBzZW5kTWVzc2FnZXMoe1xuICAgIGFib3J0U2lnbmFsLFxuICAgIC4uLm9wdGlvbnNcbiAgfSkge1xuICAgIHZhciBfYTIxLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBjb25zdCByZXNvbHZlZEJvZHkgPSBhd2FpdCByZXNvbHZlMih0aGlzLmJvZHkpO1xuICAgIGNvbnN0IHJlc29sdmVkSGVhZGVycyA9IGF3YWl0IHJlc29sdmUyKHRoaXMuaGVhZGVycyk7XG4gICAgY29uc3QgcmVzb2x2ZWRDcmVkZW50aWFscyA9IGF3YWl0IHJlc29sdmUyKHRoaXMuY3JlZGVudGlhbHMpO1xuICAgIGNvbnN0IGJhc2VIZWFkZXJzID0ge1xuICAgICAgLi4ubm9ybWFsaXplSGVhZGVycyhyZXNvbHZlZEhlYWRlcnMpLFxuICAgICAgLi4ubm9ybWFsaXplSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgfTtcbiAgICBjb25zdCBwcmVwYXJlZFJlcXVlc3QgPSBhd2FpdCAoKF9hMjEgPSB0aGlzLnByZXBhcmVTZW5kTWVzc2FnZXNSZXF1ZXN0KSA9PSBudWxsID8gdm9pZCAwIDogX2EyMS5jYWxsKHRoaXMsIHtcbiAgICAgIGFwaTogdGhpcy5hcGksXG4gICAgICBpZDogb3B0aW9ucy5jaGF0SWQsXG4gICAgICBtZXNzYWdlczogb3B0aW9ucy5tZXNzYWdlcyxcbiAgICAgIGJvZHk6IHsgLi4ucmVzb2x2ZWRCb2R5LCAuLi5vcHRpb25zLmJvZHkgfSxcbiAgICAgIGhlYWRlcnM6IGJhc2VIZWFkZXJzLFxuICAgICAgY3JlZGVudGlhbHM6IHJlc29sdmVkQ3JlZGVudGlhbHMsXG4gICAgICByZXF1ZXN0TWV0YWRhdGE6IG9wdGlvbnMubWV0YWRhdGEsXG4gICAgICB0cmlnZ2VyOiBvcHRpb25zLnRyaWdnZXIsXG4gICAgICBtZXNzYWdlSWQ6IG9wdGlvbnMubWVzc2FnZUlkXG4gICAgfSkpO1xuICAgIGNvbnN0IGFwaSA9IChfYiA9IHByZXBhcmVkUmVxdWVzdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZWRSZXF1ZXN0LmFwaSkgIT0gbnVsbCA/IF9iIDogdGhpcy5hcGk7XG4gICAgY29uc3QgaGVhZGVycyA9IChwcmVwYXJlZFJlcXVlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVkUmVxdWVzdC5oZWFkZXJzKSAhPT0gdm9pZCAwID8gbm9ybWFsaXplSGVhZGVycyhwcmVwYXJlZFJlcXVlc3QuaGVhZGVycykgOiBiYXNlSGVhZGVycztcbiAgICBjb25zdCBib2R5ID0gKHByZXBhcmVkUmVxdWVzdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZWRSZXF1ZXN0LmJvZHkpICE9PSB2b2lkIDAgPyBwcmVwYXJlZFJlcXVlc3QuYm9keSA6IHtcbiAgICAgIC4uLnJlc29sdmVkQm9keSxcbiAgICAgIC4uLm9wdGlvbnMuYm9keSxcbiAgICAgIGlkOiBvcHRpb25zLmNoYXRJZCxcbiAgICAgIG1lc3NhZ2VzOiBvcHRpb25zLm1lc3NhZ2VzLFxuICAgICAgdHJpZ2dlcjogb3B0aW9ucy50cmlnZ2VyLFxuICAgICAgbWVzc2FnZUlkOiBvcHRpb25zLm1lc3NhZ2VJZFxuICAgIH07XG4gICAgY29uc3QgY3JlZGVudGlhbHMgPSAoX2MgPSBwcmVwYXJlZFJlcXVlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVkUmVxdWVzdC5jcmVkZW50aWFscykgIT0gbnVsbCA/IF9jIDogcmVzb2x2ZWRDcmVkZW50aWFscztcbiAgICBjb25zdCBmZXRjaDIgPSAoX2QgPSB0aGlzLmZldGNoKSAhPSBudWxsID8gX2QgOiBnbG9iYWxUaGlzLmZldGNoO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gyKGFwaSwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHdpdGhVc2VyQWdlbnRTdWZmaXgxMShcbiAgICAgICAge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmhlYWRlcnNcbiAgICAgICAgfSxcbiAgICAgICAgYGFpLXNkay8ke1ZFUlNJT059YCxcbiAgICAgICAgZ2V0UnVudGltZUVudmlyb25tZW50VXNlckFnZW50MygpXG4gICAgICApLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICBjcmVkZW50aWFscyxcbiAgICAgIHNpZ25hbDogYWJvcnRTaWduYWxcbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIChfZSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKSkgIT0gbnVsbCA/IF9lIDogXCJGYWlsZWQgdG8gZmV0Y2ggdGhlIGNoYXQgcmVzcG9uc2UuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVzcG9uc2VTdHJlYW0ocmVzcG9uc2UuYm9keSk7XG4gIH1cbiAgYXN5bmMgcmVjb25uZWN0VG9TdHJlYW0ob3B0aW9ucykge1xuICAgIHZhciBfYTIxLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBjb25zdCByZXNvbHZlZEJvZHkgPSBhd2FpdCByZXNvbHZlMih0aGlzLmJvZHkpO1xuICAgIGNvbnN0IHJlc29sdmVkSGVhZGVycyA9IGF3YWl0IHJlc29sdmUyKHRoaXMuaGVhZGVycyk7XG4gICAgY29uc3QgcmVzb2x2ZWRDcmVkZW50aWFscyA9IGF3YWl0IHJlc29sdmUyKHRoaXMuY3JlZGVudGlhbHMpO1xuICAgIGNvbnN0IGJhc2VIZWFkZXJzID0ge1xuICAgICAgLi4ubm9ybWFsaXplSGVhZGVycyhyZXNvbHZlZEhlYWRlcnMpLFxuICAgICAgLi4ubm9ybWFsaXplSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgfTtcbiAgICBjb25zdCBwcmVwYXJlZFJlcXVlc3QgPSBhd2FpdCAoKF9hMjEgPSB0aGlzLnByZXBhcmVSZWNvbm5lY3RUb1N0cmVhbVJlcXVlc3QpID09IG51bGwgPyB2b2lkIDAgOiBfYTIxLmNhbGwodGhpcywge1xuICAgICAgYXBpOiB0aGlzLmFwaSxcbiAgICAgIGlkOiBvcHRpb25zLmNoYXRJZCxcbiAgICAgIGJvZHk6IHsgLi4ucmVzb2x2ZWRCb2R5LCAuLi5vcHRpb25zLmJvZHkgfSxcbiAgICAgIGhlYWRlcnM6IGJhc2VIZWFkZXJzLFxuICAgICAgY3JlZGVudGlhbHM6IHJlc29sdmVkQ3JlZGVudGlhbHMsXG4gICAgICByZXF1ZXN0TWV0YWRhdGE6IG9wdGlvbnMubWV0YWRhdGFcbiAgICB9KSk7XG4gICAgY29uc3QgYXBpID0gKF9iID0gcHJlcGFyZWRSZXF1ZXN0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlZFJlcXVlc3QuYXBpKSAhPSBudWxsID8gX2IgOiBgJHt0aGlzLmFwaX0vJHtvcHRpb25zLmNoYXRJZH0vc3RyZWFtYDtcbiAgICBjb25zdCBoZWFkZXJzID0gKHByZXBhcmVkUmVxdWVzdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZWRSZXF1ZXN0LmhlYWRlcnMpICE9PSB2b2lkIDAgPyBub3JtYWxpemVIZWFkZXJzKHByZXBhcmVkUmVxdWVzdC5oZWFkZXJzKSA6IGJhc2VIZWFkZXJzO1xuICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gKF9jID0gcHJlcGFyZWRSZXF1ZXN0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlZFJlcXVlc3QuY3JlZGVudGlhbHMpICE9IG51bGwgPyBfYyA6IHJlc29sdmVkQ3JlZGVudGlhbHM7XG4gICAgY29uc3QgZmV0Y2gyID0gKF9kID0gdGhpcy5mZXRjaCkgIT0gbnVsbCA/IF9kIDogZ2xvYmFsVGhpcy5mZXRjaDtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoMihhcGksIHtcbiAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgIGhlYWRlcnM6IHdpdGhVc2VyQWdlbnRTdWZmaXgxMShcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgYGFpLXNkay8ke1ZFUlNJT059YCxcbiAgICAgICAgZ2V0UnVudGltZUVudmlyb25tZW50VXNlckFnZW50MygpXG4gICAgICApLFxuICAgICAgY3JlZGVudGlhbHNcbiAgICB9KTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIChfZSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKSkgIT0gbnVsbCA/IF9lIDogXCJGYWlsZWQgdG8gZmV0Y2ggdGhlIGNoYXQgcmVzcG9uc2UuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVzcG9uc2VTdHJlYW0ocmVzcG9uc2UuYm9keSk7XG4gIH1cbn07XG5cbi8vIHNyYy91aS9kZWZhdWx0LWNoYXQtdHJhbnNwb3J0LnRzXG52YXIgRGVmYXVsdENoYXRUcmFuc3BvcnQgPSBjbGFzcyBleHRlbmRzIEh0dHBDaGF0VHJhbnNwb3J0IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gIH1cbiAgcHJvY2Vzc1Jlc3BvbnNlU3RyZWFtKHN0cmVhbSkge1xuICAgIHJldHVybiBwYXJzZUpzb25FdmVudFN0cmVhbTIoe1xuICAgICAgc3RyZWFtLFxuICAgICAgc2NoZW1hOiB1aU1lc3NhZ2VDaHVua1NjaGVtYVxuICAgIH0pLnBpcGVUaHJvdWdoKFxuICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgIGlmICghY2h1bmsuc3VjY2Vzcykge1xuICAgICAgICAgICAgdGhyb3cgY2h1bmsuZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL3VpL2NoYXQudHNcbnZhciBBYnN0cmFjdENoYXQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMiA9IGdlbmVyYXRlSWRGdW5jMixcbiAgICBpZCA9IGdlbmVyYXRlSWQyKCksXG4gICAgdHJhbnNwb3J0ID0gbmV3IERlZmF1bHRDaGF0VHJhbnNwb3J0KCksXG4gICAgbWVzc2FnZU1ldGFkYXRhU2NoZW1hLFxuICAgIGRhdGFQYXJ0U2NoZW1hcyxcbiAgICBzdGF0ZSxcbiAgICBvbkVycm9yLFxuICAgIG9uVG9vbENhbGwsXG4gICAgb25GaW5pc2gsXG4gICAgb25EYXRhLFxuICAgIHNlbmRBdXRvbWF0aWNhbGx5V2hlblxuICB9KSB7XG4gICAgdGhpcy5hY3RpdmVSZXNwb25zZSA9IHZvaWQgMDtcbiAgICB0aGlzLmpvYkV4ZWN1dG9yID0gbmV3IFNlcmlhbEpvYkV4ZWN1dG9yKCk7XG4gICAgLyoqXG4gICAgICogQXBwZW5kcyBvciByZXBsYWNlcyBhIHVzZXIgbWVzc2FnZSB0byB0aGUgY2hhdCBsaXN0LiBUaGlzIHRyaWdnZXJzIHRoZSBBUEkgY2FsbCB0byBmZXRjaFxuICAgICAqIHRoZSBhc3Npc3RhbnQncyByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIElmIGEgbWVzc2FnZUlkIGlzIHByb3ZpZGVkLCB0aGUgbWVzc2FnZSB3aWxsIGJlIHJlcGxhY2VkLlxuICAgICAqL1xuICAgIHRoaXMuc2VuZE1lc3NhZ2UgPSBhc3luYyAobWVzc2FnZSwgb3B0aW9ucykgPT4ge1xuICAgICAgdmFyIF9hMjEsIF9iLCBfYywgX2Q7XG4gICAgICBpZiAobWVzc2FnZSA9PSBudWxsKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubWFrZVJlcXVlc3Qoe1xuICAgICAgICAgIHRyaWdnZXI6IFwic3VibWl0LW1lc3NhZ2VcIixcbiAgICAgICAgICBtZXNzYWdlSWQ6IChfYTIxID0gdGhpcy5sYXN0TWVzc2FnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMjEuaWQsXG4gICAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHVpTWVzc2FnZTtcbiAgICAgIGlmIChcInRleHRcIiBpbiBtZXNzYWdlIHx8IFwiZmlsZXNcIiBpbiBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGZpbGVQYXJ0cyA9IEFycmF5LmlzQXJyYXkobWVzc2FnZS5maWxlcykgPyBtZXNzYWdlLmZpbGVzIDogYXdhaXQgY29udmVydEZpbGVMaXN0VG9GaWxlVUlQYXJ0cyhtZXNzYWdlLmZpbGVzKTtcbiAgICAgICAgdWlNZXNzYWdlID0ge1xuICAgICAgICAgIHBhcnRzOiBbXG4gICAgICAgICAgICAuLi5maWxlUGFydHMsXG4gICAgICAgICAgICAuLi5cInRleHRcIiBpbiBtZXNzYWdlICYmIG1lc3NhZ2UudGV4dCAhPSBudWxsID8gW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IG1lc3NhZ2UudGV4dCB9XSA6IFtdXG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdWlNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLm1lc3NhZ2VJZCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VJbmRleCA9IHRoaXMuc3RhdGUubWVzc2FnZXMuZmluZEluZGV4KFxuICAgICAgICAgIChtKSA9PiBtLmlkID09PSBtZXNzYWdlLm1lc3NhZ2VJZFxuICAgICAgICApO1xuICAgICAgICBpZiAobWVzc2FnZUluZGV4ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbWVzc2FnZSB3aXRoIGlkICR7bWVzc2FnZS5tZXNzYWdlSWR9IG5vdCBmb3VuZGApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLm1lc3NhZ2VzW21lc3NhZ2VJbmRleF0ucm9sZSAhPT0gXCJ1c2VyXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgbWVzc2FnZSB3aXRoIGlkICR7bWVzc2FnZS5tZXNzYWdlSWR9IGlzIG5vdCBhIHVzZXIgbWVzc2FnZWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUubWVzc2FnZXMgPSB0aGlzLnN0YXRlLm1lc3NhZ2VzLnNsaWNlKDAsIG1lc3NhZ2VJbmRleCArIDEpO1xuICAgICAgICB0aGlzLnN0YXRlLnJlcGxhY2VNZXNzYWdlKG1lc3NhZ2VJbmRleCwge1xuICAgICAgICAgIC4uLnVpTWVzc2FnZSxcbiAgICAgICAgICBpZDogbWVzc2FnZS5tZXNzYWdlSWQsXG4gICAgICAgICAgcm9sZTogKF9iID0gdWlNZXNzYWdlLnJvbGUpICE9IG51bGwgPyBfYiA6IFwidXNlclwiLFxuICAgICAgICAgIG1ldGFkYXRhOiBtZXNzYWdlLm1ldGFkYXRhXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5wdXNoTWVzc2FnZSh7XG4gICAgICAgICAgLi4udWlNZXNzYWdlLFxuICAgICAgICAgIGlkOiAoX2MgPSB1aU1lc3NhZ2UuaWQpICE9IG51bGwgPyBfYyA6IHRoaXMuZ2VuZXJhdGVJZCgpLFxuICAgICAgICAgIHJvbGU6IChfZCA9IHVpTWVzc2FnZS5yb2xlKSAhPSBudWxsID8gX2QgOiBcInVzZXJcIixcbiAgICAgICAgICBtZXRhZGF0YTogbWVzc2FnZS5tZXRhZGF0YVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMubWFrZVJlcXVlc3Qoe1xuICAgICAgICB0cmlnZ2VyOiBcInN1Ym1pdC1tZXNzYWdlXCIsXG4gICAgICAgIG1lc3NhZ2VJZDogbWVzc2FnZS5tZXNzYWdlSWQsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnZW5lcmF0ZSB0aGUgYXNzaXN0YW50IG1lc3NhZ2Ugd2l0aCB0aGUgcHJvdmlkZWQgbWVzc2FnZSBpZC5cbiAgICAgKiBJZiBubyBtZXNzYWdlIGlkIGlzIHByb3ZpZGVkLCB0aGUgbGFzdCBhc3Npc3RhbnQgbWVzc2FnZSB3aWxsIGJlIHJlZ2VuZXJhdGVkLlxuICAgICAqL1xuICAgIHRoaXMucmVnZW5lcmF0ZSA9IGFzeW5jICh7XG4gICAgICBtZXNzYWdlSWQsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSA9IHt9KSA9PiB7XG4gICAgICBjb25zdCBtZXNzYWdlSW5kZXggPSBtZXNzYWdlSWQgPT0gbnVsbCA/IHRoaXMuc3RhdGUubWVzc2FnZXMubGVuZ3RoIC0gMSA6IHRoaXMuc3RhdGUubWVzc2FnZXMuZmluZEluZGV4KChtZXNzYWdlKSA9PiBtZXNzYWdlLmlkID09PSBtZXNzYWdlSWQpO1xuICAgICAgaWYgKG1lc3NhZ2VJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtZXNzYWdlICR7bWVzc2FnZUlkfSBub3QgZm91bmRgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGUubWVzc2FnZXMgPSB0aGlzLnN0YXRlLm1lc3NhZ2VzLnNsaWNlKFxuICAgICAgICAwLFxuICAgICAgICAvLyBpZiB0aGUgbWVzc2FnZSBpcyBhIHVzZXIgbWVzc2FnZSwgd2UgbmVlZCB0byBpbmNsdWRlIGl0IGluIHRoZSByZXF1ZXN0OlxuICAgICAgICB0aGlzLm1lc3NhZ2VzW21lc3NhZ2VJbmRleF0ucm9sZSA9PT0gXCJhc3Npc3RhbnRcIiA/IG1lc3NhZ2VJbmRleCA6IG1lc3NhZ2VJbmRleCArIDFcbiAgICAgICk7XG4gICAgICBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KHtcbiAgICAgICAgdHJpZ2dlcjogXCJyZWdlbmVyYXRlLW1lc3NhZ2VcIixcbiAgICAgICAgbWVzc2FnZUlkLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGVtcHQgdG8gcmVzdW1lIGFuIG9uZ29pbmcgc3RyZWFtaW5nIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIHRoaXMucmVzdW1lU3RyZWFtID0gYXN5bmMgKG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5tYWtlUmVxdWVzdCh7IHRyaWdnZXI6IFwicmVzdW1lLXN0cmVhbVwiLCAuLi5vcHRpb25zIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIGVycm9yIHN0YXRlIGFuZCBzZXQgdGhlIHN0YXR1cyB0byByZWFkeSBpZiB0aGUgY2hhdCBpcyBpbiBhbiBlcnJvciBzdGF0ZS5cbiAgICAgKi9cbiAgICB0aGlzLmNsZWFyRXJyb3IgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFwiZXJyb3JcIikge1xuICAgICAgICB0aGlzLnN0YXRlLmVycm9yID0gdm9pZCAwO1xuICAgICAgICB0aGlzLnNldFN0YXR1cyh7IHN0YXR1czogXCJyZWFkeVwiIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hZGRUb29sQXBwcm92YWxSZXNwb25zZSA9IGFzeW5jICh7XG4gICAgICBpZCxcbiAgICAgIGFwcHJvdmVkLFxuICAgICAgcmVhc29uXG4gICAgfSkgPT4gdGhpcy5qb2JFeGVjdXRvci5ydW4oYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbWVzc2FnZXMgPSB0aGlzLnN0YXRlLm1lc3NhZ2VzO1xuICAgICAgY29uc3QgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IHVwZGF0ZVBhcnQgPSAocGFydCkgPT4gaXNUb29sVUlQYXJ0KHBhcnQpICYmIHBhcnQuc3RhdGUgPT09IFwiYXBwcm92YWwtcmVxdWVzdGVkXCIgJiYgcGFydC5hcHByb3ZhbC5pZCA9PT0gaWQgPyB7XG4gICAgICAgIC4uLnBhcnQsXG4gICAgICAgIHN0YXRlOiBcImFwcHJvdmFsLXJlc3BvbmRlZFwiLFxuICAgICAgICBhcHByb3ZhbDogeyBpZCwgYXBwcm92ZWQsIHJlYXNvbiB9XG4gICAgICB9IDogcGFydDtcbiAgICAgIHRoaXMuc3RhdGUucmVwbGFjZU1lc3NhZ2UobWVzc2FnZXMubGVuZ3RoIC0gMSwge1xuICAgICAgICAuLi5sYXN0TWVzc2FnZSxcbiAgICAgICAgcGFydHM6IGxhc3RNZXNzYWdlLnBhcnRzLm1hcCh1cGRhdGVQYXJ0KVxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5hY3RpdmVSZXNwb25zZSkge1xuICAgICAgICB0aGlzLmFjdGl2ZVJlc3BvbnNlLnN0YXRlLm1lc3NhZ2UucGFydHMgPSB0aGlzLmFjdGl2ZVJlc3BvbnNlLnN0YXRlLm1lc3NhZ2UucGFydHMubWFwKHVwZGF0ZVBhcnQpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RhdHVzICE9PSBcInN0cmVhbWluZ1wiICYmIHRoaXMuc3RhdHVzICE9PSBcInN1Ym1pdHRlZFwiICYmIHRoaXMuc2VuZEF1dG9tYXRpY2FsbHlXaGVuKSB7XG4gICAgICAgIHRoaXMuc2hvdWxkU2VuZEF1dG9tYXRpY2FsbHkoKS50aGVuKChzaG91bGRTZW5kKSA9PiB7XG4gICAgICAgICAgdmFyIF9hMjE7XG4gICAgICAgICAgaWYgKHNob3VsZFNlbmQpIHtcbiAgICAgICAgICAgIHRoaXMubWFrZVJlcXVlc3Qoe1xuICAgICAgICAgICAgICB0cmlnZ2VyOiBcInN1Ym1pdC1tZXNzYWdlXCIsXG4gICAgICAgICAgICAgIG1lc3NhZ2VJZDogKF9hMjEgPSB0aGlzLmxhc3RNZXNzYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyMS5pZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmFkZFRvb2xPdXRwdXQgPSBhc3luYyAoe1xuICAgICAgc3RhdGUgPSBcIm91dHB1dC1hdmFpbGFibGVcIixcbiAgICAgIHRvb2w6IHRvb2wyLFxuICAgICAgdG9vbENhbGxJZCxcbiAgICAgIG91dHB1dCxcbiAgICAgIGVycm9yVGV4dFxuICAgIH0pID0+IHRoaXMuam9iRXhlY3V0b3IucnVuKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VzID0gdGhpcy5zdGF0ZS5tZXNzYWdlcztcbiAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCB1cGRhdGVQYXJ0ID0gKHBhcnQpID0+IGlzVG9vbFVJUGFydChwYXJ0KSAmJiBwYXJ0LnRvb2xDYWxsSWQgPT09IHRvb2xDYWxsSWQgPyB7IC4uLnBhcnQsIHN0YXRlLCBvdXRwdXQsIGVycm9yVGV4dCB9IDogcGFydDtcbiAgICAgIHRoaXMuc3RhdGUucmVwbGFjZU1lc3NhZ2UobWVzc2FnZXMubGVuZ3RoIC0gMSwge1xuICAgICAgICAuLi5sYXN0TWVzc2FnZSxcbiAgICAgICAgcGFydHM6IGxhc3RNZXNzYWdlLnBhcnRzLm1hcCh1cGRhdGVQYXJ0KVxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5hY3RpdmVSZXNwb25zZSkge1xuICAgICAgICB0aGlzLmFjdGl2ZVJlc3BvbnNlLnN0YXRlLm1lc3NhZ2UucGFydHMgPSB0aGlzLmFjdGl2ZVJlc3BvbnNlLnN0YXRlLm1lc3NhZ2UucGFydHMubWFwKHVwZGF0ZVBhcnQpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RhdHVzICE9PSBcInN0cmVhbWluZ1wiICYmIHRoaXMuc3RhdHVzICE9PSBcInN1Ym1pdHRlZFwiICYmIHRoaXMuc2VuZEF1dG9tYXRpY2FsbHlXaGVuKSB7XG4gICAgICAgIHRoaXMuc2hvdWxkU2VuZEF1dG9tYXRpY2FsbHkoKS50aGVuKChzaG91bGRTZW5kKSA9PiB7XG4gICAgICAgICAgdmFyIF9hMjE7XG4gICAgICAgICAgaWYgKHNob3VsZFNlbmQpIHtcbiAgICAgICAgICAgIHRoaXMubWFrZVJlcXVlc3Qoe1xuICAgICAgICAgICAgICB0cmlnZ2VyOiBcInN1Ym1pdC1tZXNzYWdlXCIsXG4gICAgICAgICAgICAgIG1lc3NhZ2VJZDogKF9hMjEgPSB0aGlzLmxhc3RNZXNzYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyMS5pZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKiogQGRlcHJlY2F0ZWQgVXNlIGFkZFRvb2xPdXRwdXQgKi9cbiAgICB0aGlzLmFkZFRvb2xSZXN1bHQgPSB0aGlzLmFkZFRvb2xPdXRwdXQ7XG4gICAgLyoqXG4gICAgICogQWJvcnQgdGhlIGN1cnJlbnQgcmVxdWVzdCBpbW1lZGlhdGVseSwga2VlcCB0aGUgZ2VuZXJhdGVkIHRva2VucyBpZiBhbnkuXG4gICAgICovXG4gICAgdGhpcy5zdG9wID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdmFyIF9hMjE7XG4gICAgICBpZiAodGhpcy5zdGF0dXMgIT09IFwic3RyZWFtaW5nXCIgJiYgdGhpcy5zdGF0dXMgIT09IFwic3VibWl0dGVkXCIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICgoX2EyMSA9IHRoaXMuYWN0aXZlUmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTIxLmFib3J0Q29udHJvbGxlcikge1xuICAgICAgICB0aGlzLmFjdGl2ZVJlc3BvbnNlLmFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIHRoaXMuZ2VuZXJhdGVJZCA9IGdlbmVyYXRlSWQyO1xuICAgIHRoaXMubWVzc2FnZU1ldGFkYXRhU2NoZW1hID0gbWVzc2FnZU1ldGFkYXRhU2NoZW1hO1xuICAgIHRoaXMuZGF0YVBhcnRTY2hlbWFzID0gZGF0YVBhcnRTY2hlbWFzO1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLm9uRXJyb3IgPSBvbkVycm9yO1xuICAgIHRoaXMub25Ub29sQ2FsbCA9IG9uVG9vbENhbGw7XG4gICAgdGhpcy5vbkZpbmlzaCA9IG9uRmluaXNoO1xuICAgIHRoaXMub25EYXRhID0gb25EYXRhO1xuICAgIHRoaXMuc2VuZEF1dG9tYXRpY2FsbHlXaGVuID0gc2VuZEF1dG9tYXRpY2FsbHlXaGVuO1xuICB9XG4gIC8qKlxuICAgKiBIb29rIHN0YXR1czpcbiAgICpcbiAgICogLSBgc3VibWl0dGVkYDogVGhlIG1lc3NhZ2UgaGFzIGJlZW4gc2VudCB0byB0aGUgQVBJIGFuZCB3ZSdyZSBhd2FpdGluZyB0aGUgc3RhcnQgb2YgdGhlIHJlc3BvbnNlIHN0cmVhbS5cbiAgICogLSBgc3RyZWFtaW5nYDogVGhlIHJlc3BvbnNlIGlzIGFjdGl2ZWx5IHN0cmVhbWluZyBpbiBmcm9tIHRoZSBBUEksIHJlY2VpdmluZyBjaHVua3Mgb2YgZGF0YS5cbiAgICogLSBgcmVhZHlgOiBUaGUgZnVsbCByZXNwb25zZSBoYXMgYmVlbiByZWNlaXZlZCBhbmQgcHJvY2Vzc2VkOyBhIG5ldyB1c2VyIG1lc3NhZ2UgY2FuIGJlIHN1Ym1pdHRlZC5cbiAgICogLSBgZXJyb3JgOiBBbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgdGhlIEFQSSByZXF1ZXN0LCBwcmV2ZW50aW5nIHN1Y2Nlc3NmdWwgY29tcGxldGlvbi5cbiAgICovXG4gIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuc3RhdHVzO1xuICB9XG4gIHNldFN0YXR1cyh7XG4gICAgc3RhdHVzLFxuICAgIGVycm9yXG4gIH0pIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IHN0YXR1cylcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnN0YXRlLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLnN0YXRlLmVycm9yID0gZXJyb3I7XG4gIH1cbiAgZ2V0IGVycm9yKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmVycm9yO1xuICB9XG4gIGdldCBtZXNzYWdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5tZXNzYWdlcztcbiAgfVxuICBnZXQgbGFzdE1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUubWVzc2FnZXNbdGhpcy5zdGF0ZS5tZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgfVxuICBzZXQgbWVzc2FnZXMobWVzc2FnZXMpIHtcbiAgICB0aGlzLnN0YXRlLm1lc3NhZ2VzID0gbWVzc2FnZXM7XG4gIH1cbiAgYXN5bmMgc2hvdWxkU2VuZEF1dG9tYXRpY2FsbHkoKSB7XG4gICAgaWYgKCF0aGlzLnNlbmRBdXRvbWF0aWNhbGx5V2hlbilcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnNlbmRBdXRvbWF0aWNhbGx5V2hlbih7XG4gICAgICBtZXNzYWdlczogdGhpcy5zdGF0ZS5tZXNzYWdlc1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdCA9PT0gXCJvYmplY3RcIiAmJiBcInRoZW5cIiBpbiByZXN1bHQpIHtcbiAgICAgIHJldHVybiBhd2FpdCByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgbWFrZVJlcXVlc3Qoe1xuICAgIHRyaWdnZXIsXG4gICAgbWV0YWRhdGEsXG4gICAgaGVhZGVycyxcbiAgICBib2R5LFxuICAgIG1lc3NhZ2VJZFxuICB9KSB7XG4gICAgdmFyIF9hMjEsIF9iLCBfYztcbiAgICBsZXQgcmVzdW1lU3RyZWFtO1xuICAgIGlmICh0cmlnZ2VyID09PSBcInJlc3VtZS1zdHJlYW1cIikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVjb25uZWN0ID0gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVjb25uZWN0VG9TdHJlYW0oe1xuICAgICAgICAgIGNoYXRJZDogdGhpcy5pZCxcbiAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIGJvZHlcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZWNvbm5lY3QgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bWVTdHJlYW0gPSByZWNvbm5lY3Q7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKHRoaXMub25FcnJvciAmJiBlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHRoaXMub25FcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKHsgc3RhdHVzOiBcImVycm9yXCIsIGVycm9yOiBlcnIgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zZXRTdGF0dXMoeyBzdGF0dXM6IFwic3VibWl0dGVkXCIsIGVycm9yOiB2b2lkIDAgfSk7XG4gICAgY29uc3QgbGFzdE1lc3NhZ2UgPSB0aGlzLmxhc3RNZXNzYWdlO1xuICAgIGxldCBpc0Fib3J0ID0gZmFsc2U7XG4gICAgbGV0IGlzRGlzY29ubmVjdCA9IGZhbHNlO1xuICAgIGxldCBpc0Vycm9yID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFjdGl2ZVJlc3BvbnNlID0ge1xuICAgICAgICBzdGF0ZTogY3JlYXRlU3RyZWFtaW5nVUlNZXNzYWdlU3RhdGUoe1xuICAgICAgICAgIGxhc3RNZXNzYWdlOiB0aGlzLnN0YXRlLnNuYXBzaG90KGxhc3RNZXNzYWdlKSxcbiAgICAgICAgICBtZXNzYWdlSWQ6IHRoaXMuZ2VuZXJhdGVJZCgpXG4gICAgICAgIH0pLFxuICAgICAgICBhYm9ydENvbnRyb2xsZXI6IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgICAgfTtcbiAgICAgIGFjdGl2ZVJlc3BvbnNlLmFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgICAgaXNBYm9ydCA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYWN0aXZlUmVzcG9uc2UgPSBhY3RpdmVSZXNwb25zZTtcbiAgICAgIGxldCBzdHJlYW07XG4gICAgICBpZiAodHJpZ2dlciA9PT0gXCJyZXN1bWUtc3RyZWFtXCIpIHtcbiAgICAgICAgc3RyZWFtID0gcmVzdW1lU3RyZWFtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyZWFtID0gYXdhaXQgdGhpcy50cmFuc3BvcnQuc2VuZE1lc3NhZ2VzKHtcbiAgICAgICAgICBjaGF0SWQ6IHRoaXMuaWQsXG4gICAgICAgICAgbWVzc2FnZXM6IHRoaXMuc3RhdGUubWVzc2FnZXMsXG4gICAgICAgICAgYWJvcnRTaWduYWw6IGFjdGl2ZVJlc3BvbnNlLmFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBib2R5LFxuICAgICAgICAgIHRyaWdnZXIsXG4gICAgICAgICAgbWVzc2FnZUlkXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgcnVuVXBkYXRlTWVzc2FnZUpvYiA9IChqb2IpID0+IChcbiAgICAgICAgLy8gc2VyaWFsaXplIHRoZSBqb2IgZXhlY3V0aW9uIHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uczpcbiAgICAgICAgdGhpcy5qb2JFeGVjdXRvci5ydW4oXG4gICAgICAgICAgKCkgPT4gam9iKHtcbiAgICAgICAgICAgIHN0YXRlOiBhY3RpdmVSZXNwb25zZS5zdGF0ZSxcbiAgICAgICAgICAgIHdyaXRlOiAoKSA9PiB7XG4gICAgICAgICAgICAgIHZhciBfYTIyO1xuICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyh7IHN0YXR1czogXCJzdHJlYW1pbmdcIiB9KTtcbiAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZUxhc3RNZXNzYWdlID0gYWN0aXZlUmVzcG9uc2Uuc3RhdGUubWVzc2FnZS5pZCA9PT0gKChfYTIyID0gdGhpcy5sYXN0TWVzc2FnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMjIuaWQpO1xuICAgICAgICAgICAgICBpZiAocmVwbGFjZUxhc3RNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5yZXBsYWNlTWVzc2FnZShcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUubWVzc2FnZXMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICAgIGFjdGl2ZVJlc3BvbnNlLnN0YXRlLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucHVzaE1lc3NhZ2UoYWN0aXZlUmVzcG9uc2Uuc3RhdGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgYXdhaXQgY29uc3VtZVN0cmVhbSh7XG4gICAgICAgIHN0cmVhbTogcHJvY2Vzc1VJTWVzc2FnZVN0cmVhbSh7XG4gICAgICAgICAgc3RyZWFtLFxuICAgICAgICAgIG9uVG9vbENhbGw6IHRoaXMub25Ub29sQ2FsbCxcbiAgICAgICAgICBvbkRhdGE6IHRoaXMub25EYXRhLFxuICAgICAgICAgIG1lc3NhZ2VNZXRhZGF0YVNjaGVtYTogdGhpcy5tZXNzYWdlTWV0YWRhdGFTY2hlbWEsXG4gICAgICAgICAgZGF0YVBhcnRTY2hlbWFzOiB0aGlzLmRhdGFQYXJ0U2NoZW1hcyxcbiAgICAgICAgICBydW5VcGRhdGVNZXNzYWdlSm9iLFxuICAgICAgICAgIG9uRXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgb25FcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZXRTdGF0dXMoeyBzdGF0dXM6IFwicmVhZHlcIiB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChpc0Fib3J0IHx8IGVyci5uYW1lID09PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgICBpc0Fib3J0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoeyBzdGF0dXM6IFwicmVhZHlcIiB9KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpc0Vycm9yID0gdHJ1ZTtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiYgKGVyci5tZXNzYWdlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJmZXRjaFwiKSB8fCBlcnIubWVzc2FnZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwibmV0d29ya1wiKSkpIHtcbiAgICAgICAgaXNEaXNjb25uZWN0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9uRXJyb3IgJiYgZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhpcy5vbkVycm9yKGVycik7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFN0YXR1cyh7IHN0YXR1czogXCJlcnJvclwiLCBlcnJvcjogZXJyIH0pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICAoX2IgPSB0aGlzLm9uRmluaXNoKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgbWVzc2FnZTogdGhpcy5hY3RpdmVSZXNwb25zZS5zdGF0ZS5tZXNzYWdlLFxuICAgICAgICAgIG1lc3NhZ2VzOiB0aGlzLnN0YXRlLm1lc3NhZ2VzLFxuICAgICAgICAgIGlzQWJvcnQsXG4gICAgICAgICAgaXNEaXNjb25uZWN0LFxuICAgICAgICAgIGlzRXJyb3IsXG4gICAgICAgICAgZmluaXNoUmVhc29uOiAoX2EyMSA9IHRoaXMuYWN0aXZlUmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTIxLnN0YXRlLmZpbmlzaFJlYXNvblxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICB9XG4gICAgICB0aGlzLmFjdGl2ZVJlc3BvbnNlID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAoIWlzRXJyb3IgJiYgYXdhaXQgdGhpcy5zaG91bGRTZW5kQXV0b21hdGljYWxseSgpKSB7XG4gICAgICBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KHtcbiAgICAgICAgdHJpZ2dlcjogXCJzdWJtaXQtbWVzc2FnZVwiLFxuICAgICAgICBtZXNzYWdlSWQ6IChfYyA9IHRoaXMubGFzdE1lc3NhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYy5pZCxcbiAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGJvZHlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3VpL2RpcmVjdC1jaGF0LXRyYW5zcG9ydC50c1xudmFyIERpcmVjdENoYXRUcmFuc3BvcnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBhZ2VudCxcbiAgICBvcHRpb25zLFxuICAgIC4uLnVpTWVzc2FnZVN0cmVhbU9wdGlvbnNcbiAgfSkge1xuICAgIHRoaXMuYWdlbnQgPSBhZ2VudDtcbiAgICB0aGlzLmFnZW50T3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy51aU1lc3NhZ2VTdHJlYW1PcHRpb25zID0gdWlNZXNzYWdlU3RyZWFtT3B0aW9ucztcbiAgfVxuICBhc3luYyBzZW5kTWVzc2FnZXMoe1xuICAgIG1lc3NhZ2VzLFxuICAgIGFib3J0U2lnbmFsXG4gIH0pIHtcbiAgICBjb25zdCB2YWxpZGF0ZWRNZXNzYWdlcyA9IGF3YWl0IHZhbGlkYXRlVUlNZXNzYWdlcyh7XG4gICAgICBtZXNzYWdlcyxcbiAgICAgIHRvb2xzOiB0aGlzLmFnZW50LnRvb2xzXG4gICAgfSk7XG4gICAgY29uc3QgbW9kZWxNZXNzYWdlcyA9IGF3YWl0IGNvbnZlcnRUb01vZGVsTWVzc2FnZXModmFsaWRhdGVkTWVzc2FnZXMsIHtcbiAgICAgIHRvb2xzOiB0aGlzLmFnZW50LnRvb2xzXG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5hZ2VudC5zdHJlYW0oe1xuICAgICAgcHJvbXB0OiBtb2RlbE1lc3NhZ2VzLFxuICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAuLi50aGlzLmFnZW50T3B0aW9ucyAhPT0gdm9pZCAwID8geyBvcHRpb25zOiB0aGlzLmFnZW50T3B0aW9ucyB9IDoge31cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0LnRvVUlNZXNzYWdlU3RyZWFtKHRoaXMudWlNZXNzYWdlU3RyZWFtT3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIERpcmVjdCB0cmFuc3BvcnQgZG9lcyBub3Qgc3VwcG9ydCByZWNvbm5lY3Rpb24gc2luY2UgdGhlcmUgaXMgbm9cbiAgICogcGVyc2lzdGVudCBzZXJ2ZXItc2lkZSBzdHJlYW0gdG8gcmVjb25uZWN0IHRvLlxuICAgKlxuICAgKiBAcmV0dXJucyBBbHdheXMgcmV0dXJucyBgbnVsbGBcbiAgICovXG4gIGFzeW5jIHJlY29ubmVjdFRvU3RyZWFtKF9vcHRpb25zKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8vIHNyYy91aS9sYXN0LWFzc2lzdGFudC1tZXNzYWdlLWlzLWNvbXBsZXRlLXdpdGgtYXBwcm92YWwtcmVzcG9uc2VzLnRzXG5mdW5jdGlvbiBsYXN0QXNzaXN0YW50TWVzc2FnZUlzQ29tcGxldGVXaXRoQXBwcm92YWxSZXNwb25zZXMoe1xuICBtZXNzYWdlc1xufSkge1xuICBjb25zdCBtZXNzYWdlID0gbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gIGlmICghbWVzc2FnZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobWVzc2FnZS5yb2xlICE9PSBcImFzc2lzdGFudFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGxhc3RTdGVwU3RhcnRJbmRleCA9IG1lc3NhZ2UucGFydHMucmVkdWNlKChsYXN0SW5kZXgsIHBhcnQsIGluZGV4KSA9PiB7XG4gICAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJzdGVwLXN0YXJ0XCIgPyBpbmRleCA6IGxhc3RJbmRleDtcbiAgfSwgLTEpO1xuICBjb25zdCBsYXN0U3RlcFRvb2xJbnZvY2F0aW9ucyA9IG1lc3NhZ2UucGFydHMuc2xpY2UobGFzdFN0ZXBTdGFydEluZGV4ICsgMSkuZmlsdGVyKGlzVG9vbFVJUGFydCkuZmlsdGVyKChwYXJ0KSA9PiAhcGFydC5wcm92aWRlckV4ZWN1dGVkKTtcbiAgcmV0dXJuIChcbiAgICAvLyBoYXMgYXQgbGVhc3Qgb25lIHRvb2wgYXBwcm92YWwgcmVzcG9uc2VcbiAgICBsYXN0U3RlcFRvb2xJbnZvY2F0aW9ucy5maWx0ZXIoKHBhcnQpID0+IHBhcnQuc3RhdGUgPT09IFwiYXBwcm92YWwtcmVzcG9uZGVkXCIpLmxlbmd0aCA+IDAgJiYgLy8gYWxsIHRvb2wgYXBwcm92YWxzIG11c3QgaGF2ZSBhIHJlc3BvbnNlXG4gICAgbGFzdFN0ZXBUb29sSW52b2NhdGlvbnMuZXZlcnkoXG4gICAgICAocGFydCkgPT4gcGFydC5zdGF0ZSA9PT0gXCJvdXRwdXQtYXZhaWxhYmxlXCIgfHwgcGFydC5zdGF0ZSA9PT0gXCJvdXRwdXQtZXJyb3JcIiB8fCBwYXJ0LnN0YXRlID09PSBcImFwcHJvdmFsLXJlc3BvbmRlZFwiXG4gICAgKVxuICApO1xufVxuXG4vLyBzcmMvdWkvbGFzdC1hc3Npc3RhbnQtbWVzc2FnZS1pcy1jb21wbGV0ZS13aXRoLXRvb2wtY2FsbHMudHNcbmZ1bmN0aW9uIGxhc3RBc3Npc3RhbnRNZXNzYWdlSXNDb21wbGV0ZVdpdGhUb29sQ2FsbHMoe1xuICBtZXNzYWdlc1xufSkge1xuICBjb25zdCBtZXNzYWdlID0gbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gIGlmICghbWVzc2FnZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobWVzc2FnZS5yb2xlICE9PSBcImFzc2lzdGFudFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGxhc3RTdGVwU3RhcnRJbmRleCA9IG1lc3NhZ2UucGFydHMucmVkdWNlKChsYXN0SW5kZXgsIHBhcnQsIGluZGV4KSA9PiB7XG4gICAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJzdGVwLXN0YXJ0XCIgPyBpbmRleCA6IGxhc3RJbmRleDtcbiAgfSwgLTEpO1xuICBjb25zdCBsYXN0U3RlcFRvb2xJbnZvY2F0aW9ucyA9IG1lc3NhZ2UucGFydHMuc2xpY2UobGFzdFN0ZXBTdGFydEluZGV4ICsgMSkuZmlsdGVyKGlzVG9vbFVJUGFydCkuZmlsdGVyKChwYXJ0KSA9PiAhcGFydC5wcm92aWRlckV4ZWN1dGVkKTtcbiAgcmV0dXJuIGxhc3RTdGVwVG9vbEludm9jYXRpb25zLmxlbmd0aCA+IDAgJiYgbGFzdFN0ZXBUb29sSW52b2NhdGlvbnMuZXZlcnkoXG4gICAgKHBhcnQpID0+IHBhcnQuc3RhdGUgPT09IFwib3V0cHV0LWF2YWlsYWJsZVwiIHx8IHBhcnQuc3RhdGUgPT09IFwib3V0cHV0LWVycm9yXCJcbiAgKTtcbn1cblxuLy8gc3JjL3VpL3RyYW5zZm9ybS10ZXh0LXRvLXVpLW1lc3NhZ2Utc3RyZWFtLnRzXG5mdW5jdGlvbiB0cmFuc2Zvcm1UZXh0VG9VaU1lc3NhZ2VTdHJlYW0oe1xuICBzdHJlYW1cbn0pIHtcbiAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChcbiAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJzdGFydFwiIH0pO1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInN0YXJ0LXN0ZXBcIiB9KTtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJ0ZXh0LXN0YXJ0XCIsIGlkOiBcInRleHQtMVwiIH0pO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIHRyYW5zZm9ybShwYXJ0LCBjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwidGV4dC1kZWx0YVwiLCBpZDogXCJ0ZXh0LTFcIiwgZGVsdGE6IHBhcnQgfSk7XG4gICAgICB9LFxuICAgICAgYXN5bmMgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInRleHQtZW5kXCIsIGlkOiBcInRleHQtMVwiIH0pO1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcImZpbmlzaC1zdGVwXCIgfSk7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwiZmluaXNoXCIgfSk7XG4gICAgICB9XG4gICAgfSlcbiAgKTtcbn1cblxuLy8gc3JjL3VpL3RleHQtc3RyZWFtLWNoYXQtdHJhbnNwb3J0LnRzXG52YXIgVGV4dFN0cmVhbUNoYXRUcmFuc3BvcnQgPSBjbGFzcyBleHRlbmRzIEh0dHBDaGF0VHJhbnNwb3J0IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gIH1cbiAgcHJvY2Vzc1Jlc3BvbnNlU3RyZWFtKHN0cmVhbSkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1UZXh0VG9VaU1lc3NhZ2VTdHJlYW0oe1xuICAgICAgc3RyZWFtOiBzdHJlYW0ucGlwZVRocm91Z2gobmV3IFRleHREZWNvZGVyU3RyZWFtKCkpXG4gICAgfSk7XG4gIH1cbn07XG5leHBvcnQge1xuICBBSVNES0Vycm9yMjEgYXMgQUlTREtFcnJvcixcbiAgQVBJQ2FsbEVycm9yLFxuICBBYnN0cmFjdENoYXQsXG4gIERlZmF1bHRDaGF0VHJhbnNwb3J0LFxuICBEZWZhdWx0R2VuZXJhdGVkRmlsZSxcbiAgRGlyZWN0Q2hhdFRyYW5zcG9ydCxcbiAgRG93bmxvYWRFcnJvcixcbiAgRW1wdHlSZXNwb25zZUJvZHlFcnJvcixcbiAgVG9vbExvb3BBZ2VudCBhcyBFeHBlcmltZW50YWxfQWdlbnQsXG4gIEh0dHBDaGF0VHJhbnNwb3J0LFxuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgSW52YWxpZERhdGFDb250ZW50RXJyb3IsXG4gIEludmFsaWRNZXNzYWdlUm9sZUVycm9yLFxuICBJbnZhbGlkUHJvbXB0RXJyb3IsXG4gIEludmFsaWRSZXNwb25zZURhdGFFcnJvcixcbiAgSW52YWxpZFN0cmVhbVBhcnRFcnJvcixcbiAgSW52YWxpZFRvb2xBcHByb3ZhbEVycm9yLFxuICBJbnZhbGlkVG9vbElucHV0RXJyb3IsXG4gIEpTT05QYXJzZUVycm9yLFxuICBKc29uVG9Tc2VUcmFuc2Zvcm1TdHJlYW0sXG4gIExvYWRBUElLZXlFcnJvcixcbiAgTG9hZFNldHRpbmdFcnJvcixcbiAgTWVzc2FnZUNvbnZlcnNpb25FcnJvcixcbiAgTWlzc2luZ1Rvb2xSZXN1bHRzRXJyb3IsXG4gIE5vQ29udGVudEdlbmVyYXRlZEVycm9yLFxuICBOb0ltYWdlR2VuZXJhdGVkRXJyb3IsXG4gIE5vT2JqZWN0R2VuZXJhdGVkRXJyb3IsXG4gIE5vT3V0cHV0R2VuZXJhdGVkRXJyb3IsXG4gIE5vU3BlZWNoR2VuZXJhdGVkRXJyb3IsXG4gIE5vU3VjaE1vZGVsRXJyb3IsXG4gIE5vU3VjaFByb3ZpZGVyRXJyb3IsXG4gIE5vU3VjaFRvb2xFcnJvcixcbiAgTm9UcmFuc2NyaXB0R2VuZXJhdGVkRXJyb3IsXG4gIE5vVmlkZW9HZW5lcmF0ZWRFcnJvcixcbiAgb3V0cHV0X2V4cG9ydHMgYXMgT3V0cHV0LFxuICBSZXRyeUVycm9yLFxuICBTZXJpYWxKb2JFeGVjdXRvcixcbiAgVGV4dFN0cmVhbUNoYXRUcmFuc3BvcnQsXG4gIFRvb01hbnlFbWJlZGRpbmdWYWx1ZXNGb3JDYWxsRXJyb3IsXG4gIFRvb2xDYWxsTm90Rm91bmRGb3JBcHByb3ZhbEVycm9yLFxuICBUb29sQ2FsbFJlcGFpckVycm9yLFxuICBUb29sTG9vcEFnZW50LFxuICBUeXBlVmFsaWRhdGlvbkVycm9yLFxuICBVSU1lc3NhZ2VTdHJlYW1FcnJvcixcbiAgVUlfTUVTU0FHRV9TVFJFQU1fSEVBREVSUyxcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IsXG4gIFVuc3VwcG9ydGVkTW9kZWxWZXJzaW9uRXJyb3IsXG4gIGFkZFRvb2xJbnB1dEV4YW1wbGVzTWlkZGxld2FyZSxcbiAgYXNTY2hlbWE1IGFzIGFzU2NoZW1hLFxuICBhc3Npc3RhbnRNb2RlbE1lc3NhZ2VTY2hlbWEsXG4gIGNhbGxDb21wbGV0aW9uQXBpLFxuICBjb25zdW1lU3RyZWFtLFxuICBjb252ZXJ0RmlsZUxpc3RUb0ZpbGVVSVBhcnRzLFxuICBjb252ZXJ0VG9Nb2RlbE1lc3NhZ2VzLFxuICBjb3NpbmVTaW1pbGFyaXR5LFxuICBjcmVhdGVBZ2VudFVJU3RyZWFtLFxuICBjcmVhdGVBZ2VudFVJU3RyZWFtUmVzcG9uc2UsXG4gIGNyZWF0ZURvd25sb2FkLFxuICBjcmVhdGVHYXRld2F5LFxuICBjcmVhdGVJZEdlbmVyYXRvcjUgYXMgY3JlYXRlSWRHZW5lcmF0b3IsXG4gIGNyZWF0ZVByb3ZpZGVyUmVnaXN0cnksXG4gIGNyZWF0ZVRleHRTdHJlYW1SZXNwb25zZSxcbiAgY3JlYXRlVUlNZXNzYWdlU3RyZWFtLFxuICBjcmVhdGVVSU1lc3NhZ2VTdHJlYW1SZXNwb25zZSxcbiAgY3VzdG9tUHJvdmlkZXIsXG4gIGRlZmF1bHRFbWJlZGRpbmdTZXR0aW5nc01pZGRsZXdhcmUsXG4gIGRlZmF1bHRTZXR0aW5nc01pZGRsZXdhcmUsXG4gIGR5bmFtaWNUb29sLFxuICBlbWJlZCxcbiAgZW1iZWRNYW55LFxuICBleHBlcmltZW50YWxfY3JlYXRlUHJvdmlkZXJSZWdpc3RyeSxcbiAgZXhwZXJpbWVudGFsX2N1c3RvbVByb3ZpZGVyLFxuICBleHBlcmltZW50YWxfZ2VuZXJhdGVJbWFnZSxcbiAgZ2VuZXJhdGVTcGVlY2ggYXMgZXhwZXJpbWVudGFsX2dlbmVyYXRlU3BlZWNoLFxuICBleHBlcmltZW50YWxfZ2VuZXJhdGVWaWRlbyxcbiAgdHJhbnNjcmliZSBhcyBleHBlcmltZW50YWxfdHJhbnNjcmliZSxcbiAgZXh0cmFjdEpzb25NaWRkbGV3YXJlLFxuICBleHRyYWN0UmVhc29uaW5nTWlkZGxld2FyZSxcbiAgZ2F0ZXdheTIgYXMgZ2F0ZXdheSxcbiAgZ2VuZXJhdGVJZCxcbiAgZ2VuZXJhdGVJbWFnZSxcbiAgZ2VuZXJhdGVPYmplY3QsXG4gIGdlbmVyYXRlVGV4dCxcbiAgZ2V0U3RhdGljVG9vbE5hbWUsXG4gIGdldFRleHRGcm9tRGF0YVVybCxcbiAgZ2V0VG9vbE5hbWUsXG4gIGdldFRvb2xPckR5bmFtaWNUb29sTmFtZSxcbiAgaGFzVG9vbENhbGwsXG4gIGlzRGF0YVVJUGFydCxcbiAgaXNEZWVwRXF1YWxEYXRhLFxuICBpc0ZpbGVVSVBhcnQsXG4gIGlzUmVhc29uaW5nVUlQYXJ0LFxuICBpc1N0YXRpY1Rvb2xVSVBhcnQsXG4gIGlzVGV4dFVJUGFydCxcbiAgaXNUb29sT3JEeW5hbWljVG9vbFVJUGFydCxcbiAgaXNUb29sVUlQYXJ0LFxuICBqc29uU2NoZW1hLFxuICBsYXN0QXNzaXN0YW50TWVzc2FnZUlzQ29tcGxldGVXaXRoQXBwcm92YWxSZXNwb25zZXMsXG4gIGxhc3RBc3Npc3RhbnRNZXNzYWdlSXNDb21wbGV0ZVdpdGhUb29sQ2FsbHMsXG4gIG1vZGVsTWVzc2FnZVNjaGVtYSxcbiAgcGFyc2VKc29uRXZlbnRTdHJlYW0zIGFzIHBhcnNlSnNvbkV2ZW50U3RyZWFtLFxuICBwYXJzZVBhcnRpYWxKc29uLFxuICBwaXBlQWdlbnRVSVN0cmVhbVRvUmVzcG9uc2UsXG4gIHBpcGVUZXh0U3RyZWFtVG9SZXNwb25zZSxcbiAgcGlwZVVJTWVzc2FnZVN0cmVhbVRvUmVzcG9uc2UsXG4gIHBydW5lTWVzc2FnZXMsXG4gIHJlYWRVSU1lc3NhZ2VTdHJlYW0sXG4gIHJlcmFuayxcbiAgc2FmZVZhbGlkYXRlVUlNZXNzYWdlcyxcbiAgc2ltdWxhdGVSZWFkYWJsZVN0cmVhbSxcbiAgc2ltdWxhdGVTdHJlYW1pbmdNaWRkbGV3YXJlLFxuICBzbW9vdGhTdHJlYW0sXG4gIHN0ZXBDb3VudElzLFxuICBzdHJlYW1PYmplY3QsXG4gIHN0cmVhbVRleHQsXG4gIHN5c3RlbU1vZGVsTWVzc2FnZVNjaGVtYSxcbiAgdG9vbCxcbiAgdG9vbE1vZGVsTWVzc2FnZVNjaGVtYSxcbiAgdWlNZXNzYWdlQ2h1bmtTY2hlbWEsXG4gIHVzZXJNb2RlbE1lc3NhZ2VTY2hlbWEsXG4gIHZhbGlkYXRlVUlNZXNzYWdlcyxcbiAgd3JhcEVtYmVkZGluZ01vZGVsLFxuICB3cmFwSW1hZ2VNb2RlbCxcbiAgd3JhcExhbmd1YWdlTW9kZWwsXG4gIHdyYXBQcm92aWRlcixcbiAgem9kU2NoZW1hMyBhcyB6b2RTY2hlbWFcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ai-sdk/react/node_modules/ai/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ai-sdk/google/dist/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@ai-sdk/google/dist/index.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createGoogleGenerativeAI: () => (/* binding */ createGoogleGenerativeAI),\n/* harmony export */   google: () => (/* binding */ google)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/v3/types.js\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/provider/dist/index.mjs\");\n// src/google-provider.ts\n\n\n// src/google-generative-ai-language-model.ts\n\n\n\n// src/convert-json-schema-to-openapi-schema.ts\nfunction convertJSONSchemaToOpenAPISchema(jsonSchema) {\n  if (isEmptyObjectSchema(jsonSchema)) {\n    return void 0;\n  }\n  if (typeof jsonSchema === \"boolean\") {\n    return { type: \"boolean\", properties: {} };\n  }\n  const {\n    type,\n    description,\n    required,\n    properties,\n    items,\n    allOf,\n    anyOf,\n    oneOf,\n    format,\n    const: constValue,\n    minLength,\n    enum: enumValues\n  } = jsonSchema;\n  const result = {};\n  if (description)\n    result.description = description;\n  if (required)\n    result.required = required;\n  if (format)\n    result.format = format;\n  if (constValue !== void 0) {\n    result.enum = [constValue];\n  }\n  if (type) {\n    if (Array.isArray(type)) {\n      if (type.includes(\"null\")) {\n        result.type = type.filter((t) => t !== \"null\")[0];\n        result.nullable = true;\n      } else {\n        result.type = type;\n      }\n    } else if (type === \"null\") {\n      result.type = \"null\";\n    } else {\n      result.type = type;\n    }\n  }\n  if (enumValues !== void 0) {\n    result.enum = enumValues;\n  }\n  if (properties != null) {\n    result.properties = Object.entries(properties).reduce(\n      (acc, [key, value]) => {\n        acc[key] = convertJSONSchemaToOpenAPISchema(value);\n        return acc;\n      },\n      {}\n    );\n  }\n  if (items) {\n    result.items = Array.isArray(items) ? items.map(convertJSONSchemaToOpenAPISchema) : convertJSONSchemaToOpenAPISchema(items);\n  }\n  if (allOf) {\n    result.allOf = allOf.map(convertJSONSchemaToOpenAPISchema);\n  }\n  if (anyOf) {\n    if (anyOf.some(\n      (schema) => typeof schema === \"object\" && (schema == null ? void 0 : schema.type) === \"null\"\n    )) {\n      const nonNullSchemas = anyOf.filter(\n        (schema) => !(typeof schema === \"object\" && (schema == null ? void 0 : schema.type) === \"null\")\n      );\n      if (nonNullSchemas.length === 1) {\n        const converted = convertJSONSchemaToOpenAPISchema(nonNullSchemas[0]);\n        if (typeof converted === \"object\") {\n          result.nullable = true;\n          Object.assign(result, converted);\n        }\n      } else {\n        result.anyOf = nonNullSchemas.map(convertJSONSchemaToOpenAPISchema);\n        result.nullable = true;\n      }\n    } else {\n      result.anyOf = anyOf.map(convertJSONSchemaToOpenAPISchema);\n    }\n  }\n  if (oneOf) {\n    result.oneOf = oneOf.map(convertJSONSchemaToOpenAPISchema);\n  }\n  if (minLength !== void 0) {\n    result.minLength = minLength;\n  }\n  return result;\n}\nfunction isEmptyObjectSchema(jsonSchema) {\n  return jsonSchema != null && typeof jsonSchema === \"object\" && jsonSchema.type === \"object\" && (jsonSchema.properties == null || Object.keys(jsonSchema.properties).length === 0) && !jsonSchema.additionalProperties;\n}\n\n// src/convert-to-google-generative-ai-messages.ts\n\n\nfunction convertToGoogleGenerativeAIMessages(prompt) {\n  var _a, _b;\n  const systemInstructionParts = [];\n  const contents = [];\n  let systemMessagesAllowed = true;\n  for (const { role, content } of prompt) {\n    switch (role) {\n      case \"system\": {\n        if (!systemMessagesAllowed) {\n          throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n            functionality: \"system messages are only supported at the beginning of the conversation\"\n          });\n        }\n        systemInstructionParts.push({ text: content });\n        break;\n      }\n      case \"user\": {\n        systemMessagesAllowed = false;\n        const parts = [];\n        for (const part of content) {\n          switch (part.type) {\n            case \"text\": {\n              parts.push({ text: part.text });\n              break;\n            }\n            case \"image\": {\n              parts.push(\n                part.image instanceof URL ? {\n                  fileData: {\n                    mimeType: (_a = part.mimeType) != null ? _a : \"image/jpeg\",\n                    fileUri: part.image.toString()\n                  }\n                } : {\n                  inlineData: {\n                    mimeType: (_b = part.mimeType) != null ? _b : \"image/jpeg\",\n                    data: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.convertUint8ArrayToBase64)(part.image)\n                  }\n                }\n              );\n              break;\n            }\n            case \"file\": {\n              parts.push(\n                part.data instanceof URL ? {\n                  fileData: {\n                    mimeType: part.mimeType,\n                    fileUri: part.data.toString()\n                  }\n                } : {\n                  inlineData: {\n                    mimeType: part.mimeType,\n                    data: part.data\n                  }\n                }\n              );\n              break;\n            }\n          }\n        }\n        contents.push({ role: \"user\", parts });\n        break;\n      }\n      case \"assistant\": {\n        systemMessagesAllowed = false;\n        contents.push({\n          role: \"model\",\n          parts: content.map((part) => {\n            switch (part.type) {\n              case \"text\": {\n                return part.text.length === 0 ? void 0 : { text: part.text };\n              }\n              case \"file\": {\n                if (part.mimeType !== \"image/png\") {\n                  throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n                    functionality: \"Only PNG images are supported in assistant messages\"\n                  });\n                }\n                if (part.data instanceof URL) {\n                  throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n                    functionality: \"File data URLs in assistant messages are not supported\"\n                  });\n                }\n                return {\n                  inlineData: {\n                    mimeType: part.mimeType,\n                    data: part.data\n                  }\n                };\n              }\n              case \"tool-call\": {\n                return {\n                  functionCall: {\n                    name: part.toolName,\n                    args: part.args\n                  }\n                };\n              }\n            }\n          }).filter((part) => part !== void 0)\n        });\n        break;\n      }\n      case \"tool\": {\n        systemMessagesAllowed = false;\n        contents.push({\n          role: \"user\",\n          parts: content.map((part) => ({\n            functionResponse: {\n              name: part.toolName,\n              response: {\n                name: part.toolName,\n                content: part.result\n              }\n            }\n          }))\n        });\n        break;\n      }\n    }\n  }\n  return {\n    systemInstruction: systemInstructionParts.length > 0 ? { parts: systemInstructionParts } : void 0,\n    contents\n  };\n}\n\n// src/get-model-path.ts\nfunction getModelPath(modelId) {\n  return modelId.includes(\"/\") ? modelId : `models/${modelId}`;\n}\n\n// src/google-error.ts\n\n\nvar googleErrorDataSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({\n  error: zod__WEBPACK_IMPORTED_MODULE_2__.object({\n    code: zod__WEBPACK_IMPORTED_MODULE_2__.number().nullable(),\n    message: zod__WEBPACK_IMPORTED_MODULE_2__.string(),\n    status: zod__WEBPACK_IMPORTED_MODULE_2__.string()\n  })\n});\nvar googleFailedResponseHandler = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.createJsonErrorResponseHandler)({\n  errorSchema: googleErrorDataSchema,\n  errorToMessage: (data) => data.error.message\n});\n\n// src/google-prepare-tools.ts\n\nfunction prepareTools(mode, useSearchGrounding, dynamicRetrievalConfig, modelId) {\n  var _a, _b;\n  const tools = ((_a = mode.tools) == null ? void 0 : _a.length) ? mode.tools : void 0;\n  const toolWarnings = [];\n  const isGemini2 = modelId.includes(\"gemini-2\");\n  const supportsDynamicRetrieval = modelId.includes(\"gemini-1.5-flash\") && !modelId.includes(\"-8b\");\n  if (useSearchGrounding) {\n    return {\n      tools: isGemini2 ? { googleSearch: {} } : {\n        googleSearchRetrieval: !supportsDynamicRetrieval || !dynamicRetrievalConfig ? {} : { dynamicRetrievalConfig }\n      },\n      toolConfig: void 0,\n      toolWarnings\n    };\n  }\n  if (tools == null) {\n    return { tools: void 0, toolConfig: void 0, toolWarnings };\n  }\n  const functionDeclarations = [];\n  for (const tool of tools) {\n    if (tool.type === \"provider-defined\") {\n      toolWarnings.push({ type: \"unsupported-tool\", tool });\n    } else {\n      functionDeclarations.push({\n        name: tool.name,\n        description: (_b = tool.description) != null ? _b : \"\",\n        parameters: convertJSONSchemaToOpenAPISchema(tool.parameters)\n      });\n    }\n  }\n  const toolChoice = mode.toolChoice;\n  if (toolChoice == null) {\n    return {\n      tools: { functionDeclarations },\n      toolConfig: void 0,\n      toolWarnings\n    };\n  }\n  const type = toolChoice.type;\n  switch (type) {\n    case \"auto\":\n      return {\n        tools: { functionDeclarations },\n        toolConfig: { functionCallingConfig: { mode: \"AUTO\" } },\n        toolWarnings\n      };\n    case \"none\":\n      return {\n        tools: { functionDeclarations },\n        toolConfig: { functionCallingConfig: { mode: \"NONE\" } },\n        toolWarnings\n      };\n    case \"required\":\n      return {\n        tools: { functionDeclarations },\n        toolConfig: { functionCallingConfig: { mode: \"ANY\" } },\n        toolWarnings\n      };\n    case \"tool\":\n      return {\n        tools: { functionDeclarations },\n        toolConfig: {\n          functionCallingConfig: {\n            mode: \"ANY\",\n            allowedFunctionNames: [toolChoice.toolName]\n          }\n        },\n        toolWarnings\n      };\n    default: {\n      const _exhaustiveCheck = type;\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n        functionality: `Unsupported tool choice type: ${_exhaustiveCheck}`\n      });\n    }\n  }\n}\n\n// src/map-google-generative-ai-finish-reason.ts\nfunction mapGoogleGenerativeAIFinishReason({\n  finishReason,\n  hasToolCalls\n}) {\n  switch (finishReason) {\n    case \"STOP\":\n      return hasToolCalls ? \"tool-calls\" : \"stop\";\n    case \"MAX_TOKENS\":\n      return \"length\";\n    case \"IMAGE_SAFETY\":\n    case \"RECITATION\":\n    case \"SAFETY\":\n    case \"BLOCKLIST\":\n    case \"PROHIBITED_CONTENT\":\n    case \"SPII\":\n      return \"content-filter\";\n    case \"FINISH_REASON_UNSPECIFIED\":\n    case \"OTHER\":\n      return \"other\";\n    case \"MALFORMED_FUNCTION_CALL\":\n      return \"error\";\n    default:\n      return \"unknown\";\n  }\n}\n\n// src/google-generative-ai-language-model.ts\nvar GoogleGenerativeAILanguageModel = class {\n  constructor(modelId, settings, config) {\n    this.specificationVersion = \"v1\";\n    this.defaultObjectGenerationMode = \"json\";\n    this.supportsImageUrls = false;\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n  get supportsStructuredOutputs() {\n    var _a;\n    return (_a = this.settings.structuredOutputs) != null ? _a : true;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async getArgs({\n    mode,\n    prompt,\n    maxTokens,\n    temperature,\n    topP,\n    topK,\n    frequencyPenalty,\n    presencePenalty,\n    stopSequences,\n    responseFormat,\n    seed,\n    providerMetadata\n  }) {\n    var _a, _b, _c;\n    const type = mode.type;\n    const warnings = [];\n    const googleOptions = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.parseProviderOptions)({\n      provider: \"google\",\n      providerOptions: providerMetadata,\n      schema: googleGenerativeAIProviderOptionsSchema\n    });\n    if (((_a = googleOptions == null ? void 0 : googleOptions.thinkingConfig) == null ? void 0 : _a.includeThoughts) === true && !this.config.provider.startsWith(\"google.vertex.\")) {\n      warnings.push({\n        type: \"other\",\n        message: `The 'includeThoughts' option is only supported with the Google Vertex provider and might not be supported or could behave unexpectedly with the current Google provider (${this.config.provider}).`\n      });\n    }\n    const generationConfig = {\n      // standardized settings:\n      maxOutputTokens: maxTokens,\n      temperature,\n      topK,\n      topP,\n      frequencyPenalty,\n      presencePenalty,\n      stopSequences,\n      seed,\n      // response format:\n      responseMimeType: (responseFormat == null ? void 0 : responseFormat.type) === \"json\" ? \"application/json\" : void 0,\n      responseSchema: (responseFormat == null ? void 0 : responseFormat.type) === \"json\" && responseFormat.schema != null && // Google GenAI does not support all OpenAPI Schema features,\n      // so this is needed as an escape hatch:\n      this.supportsStructuredOutputs ? convertJSONSchemaToOpenAPISchema(responseFormat.schema) : void 0,\n      ...this.settings.audioTimestamp && {\n        audioTimestamp: this.settings.audioTimestamp\n      },\n      // provider options:\n      responseModalities: googleOptions == null ? void 0 : googleOptions.responseModalities,\n      thinkingConfig: googleOptions == null ? void 0 : googleOptions.thinkingConfig\n    };\n    const { contents, systemInstruction } = convertToGoogleGenerativeAIMessages(prompt);\n    switch (type) {\n      case \"regular\": {\n        const { tools, toolConfig, toolWarnings } = prepareTools(\n          mode,\n          (_b = this.settings.useSearchGrounding) != null ? _b : false,\n          this.settings.dynamicRetrievalConfig,\n          this.modelId\n        );\n        return {\n          args: {\n            generationConfig,\n            contents,\n            systemInstruction,\n            safetySettings: this.settings.safetySettings,\n            tools,\n            toolConfig,\n            cachedContent: this.settings.cachedContent\n          },\n          warnings: [...warnings, ...toolWarnings]\n        };\n      }\n      case \"object-json\": {\n        return {\n          args: {\n            generationConfig: {\n              ...generationConfig,\n              responseMimeType: \"application/json\",\n              responseSchema: mode.schema != null && // Google GenAI does not support all OpenAPI Schema features,\n              // so this is needed as an escape hatch:\n              this.supportsStructuredOutputs ? convertJSONSchemaToOpenAPISchema(mode.schema) : void 0\n            },\n            contents,\n            systemInstruction,\n            safetySettings: this.settings.safetySettings,\n            cachedContent: this.settings.cachedContent\n          },\n          warnings\n        };\n      }\n      case \"object-tool\": {\n        return {\n          args: {\n            generationConfig,\n            contents,\n            systemInstruction,\n            tools: {\n              functionDeclarations: [\n                {\n                  name: mode.tool.name,\n                  description: (_c = mode.tool.description) != null ? _c : \"\",\n                  parameters: convertJSONSchemaToOpenAPISchema(\n                    mode.tool.parameters\n                  )\n                }\n              ]\n            },\n            toolConfig: { functionCallingConfig: { mode: \"ANY\" } },\n            safetySettings: this.settings.safetySettings,\n            cachedContent: this.settings.cachedContent\n          },\n          warnings\n        };\n      }\n      default: {\n        const _exhaustiveCheck = type;\n        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n  supportsUrl(url) {\n    return this.config.isSupportedUrl(url);\n  }\n  async doGenerate(options) {\n    var _a, _b, _c, _d, _e;\n    const { args, warnings } = await this.getArgs(options);\n    const body = JSON.stringify(args);\n    const mergedHeaders = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.combineHeaders)(\n      await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.resolve)(this.config.headers),\n      options.headers\n    );\n    const {\n      responseHeaders,\n      value: response,\n      rawValue: rawResponse\n    } = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.postJsonToApi)({\n      url: `${this.config.baseURL}/${getModelPath(\n        this.modelId\n      )}:generateContent`,\n      headers: mergedHeaders,\n      body: args,\n      failedResponseHandler: googleFailedResponseHandler,\n      successfulResponseHandler: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.createJsonResponseHandler)(responseSchema),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const { contents: rawPrompt, ...rawSettings } = args;\n    const candidate = response.candidates[0];\n    const parts = candidate.content == null || typeof candidate.content !== \"object\" || !(\"parts\" in candidate.content) ? [] : candidate.content.parts;\n    const toolCalls = getToolCallsFromParts({\n      parts,\n      // Use candidateParts\n      generateId: this.config.generateId\n    });\n    const usageMetadata = response.usageMetadata;\n    return {\n      text: getTextFromParts(parts),\n      reasoning: getReasoningDetailsFromParts(parts),\n      files: (_a = getInlineDataParts(parts)) == null ? void 0 : _a.map((part) => ({\n        data: part.inlineData.data,\n        mimeType: part.inlineData.mimeType\n      })),\n      toolCalls,\n      finishReason: mapGoogleGenerativeAIFinishReason({\n        finishReason: candidate.finishReason,\n        hasToolCalls: toolCalls != null && toolCalls.length > 0\n      }),\n      usage: {\n        promptTokens: (_b = usageMetadata == null ? void 0 : usageMetadata.promptTokenCount) != null ? _b : NaN,\n        completionTokens: (_c = usageMetadata == null ? void 0 : usageMetadata.candidatesTokenCount) != null ? _c : NaN\n      },\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders, body: rawResponse },\n      warnings,\n      providerMetadata: {\n        google: {\n          groundingMetadata: (_d = candidate.groundingMetadata) != null ? _d : null,\n          safetyRatings: (_e = candidate.safetyRatings) != null ? _e : null\n        }\n      },\n      sources: extractSources({\n        groundingMetadata: candidate.groundingMetadata,\n        generateId: this.config.generateId\n      }),\n      request: { body }\n    };\n  }\n  async doStream(options) {\n    const { args, warnings } = await this.getArgs(options);\n    const body = JSON.stringify(args);\n    const headers = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.combineHeaders)(\n      await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.resolve)(this.config.headers),\n      options.headers\n    );\n    const { responseHeaders, value: response } = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.postJsonToApi)({\n      url: `${this.config.baseURL}/${getModelPath(\n        this.modelId\n      )}:streamGenerateContent?alt=sse`,\n      headers,\n      body: args,\n      failedResponseHandler: googleFailedResponseHandler,\n      successfulResponseHandler: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.createEventSourceResponseHandler)(chunkSchema),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const { contents: rawPrompt, ...rawSettings } = args;\n    let finishReason = \"unknown\";\n    let usage = {\n      promptTokens: Number.NaN,\n      completionTokens: Number.NaN\n    };\n    let providerMetadata = void 0;\n    const generateId2 = this.config.generateId;\n    let hasToolCalls = false;\n    return {\n      stream: response.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            var _a, _b, _c, _d, _e, _f;\n            if (!chunk.success) {\n              controller.enqueue({ type: \"error\", error: chunk.error });\n              return;\n            }\n            const value = chunk.value;\n            const usageMetadata = value.usageMetadata;\n            if (usageMetadata != null) {\n              usage = {\n                promptTokens: (_a = usageMetadata.promptTokenCount) != null ? _a : NaN,\n                completionTokens: (_b = usageMetadata.candidatesTokenCount) != null ? _b : NaN\n              };\n            }\n            const candidate = (_c = value.candidates) == null ? void 0 : _c[0];\n            if (candidate == null) {\n              return;\n            }\n            const content = candidate.content;\n            if (content != null) {\n              const deltaText = getTextFromParts(content.parts);\n              if (deltaText != null) {\n                controller.enqueue({\n                  type: \"text-delta\",\n                  textDelta: deltaText\n                });\n              }\n              const reasoningDeltaText = getReasoningDetailsFromParts(\n                content.parts\n              );\n              if (reasoningDeltaText != null) {\n                for (const part of reasoningDeltaText) {\n                  controller.enqueue({\n                    type: \"reasoning\",\n                    textDelta: part.text\n                  });\n                }\n              }\n              const inlineDataParts = getInlineDataParts(content.parts);\n              if (inlineDataParts != null) {\n                for (const part of inlineDataParts) {\n                  controller.enqueue({\n                    type: \"file\",\n                    mimeType: part.inlineData.mimeType,\n                    data: part.inlineData.data\n                  });\n                }\n              }\n              const toolCallDeltas = getToolCallsFromParts({\n                parts: content.parts,\n                generateId: generateId2\n              });\n              if (toolCallDeltas != null) {\n                for (const toolCall of toolCallDeltas) {\n                  controller.enqueue({\n                    type: \"tool-call-delta\",\n                    toolCallType: \"function\",\n                    toolCallId: toolCall.toolCallId,\n                    toolName: toolCall.toolName,\n                    argsTextDelta: toolCall.args\n                  });\n                  controller.enqueue({\n                    type: \"tool-call\",\n                    toolCallType: \"function\",\n                    toolCallId: toolCall.toolCallId,\n                    toolName: toolCall.toolName,\n                    args: toolCall.args\n                  });\n                  hasToolCalls = true;\n                }\n              }\n            }\n            if (candidate.finishReason != null) {\n              finishReason = mapGoogleGenerativeAIFinishReason({\n                finishReason: candidate.finishReason,\n                hasToolCalls\n              });\n              const sources = (_d = extractSources({\n                groundingMetadata: candidate.groundingMetadata,\n                generateId: generateId2\n              })) != null ? _d : [];\n              for (const source of sources) {\n                controller.enqueue({ type: \"source\", source });\n              }\n              providerMetadata = {\n                google: {\n                  groundingMetadata: (_e = candidate.groundingMetadata) != null ? _e : null,\n                  safetyRatings: (_f = candidate.safetyRatings) != null ? _f : null\n                }\n              };\n            }\n          },\n          flush(controller) {\n            controller.enqueue({\n              type: \"finish\",\n              finishReason,\n              usage,\n              providerMetadata\n            });\n          }\n        })\n      ),\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders },\n      warnings,\n      request: { body }\n    };\n  }\n};\nfunction getToolCallsFromParts({\n  parts,\n  generateId: generateId2\n}) {\n  const functionCallParts = parts == null ? void 0 : parts.filter(\n    (part) => \"functionCall\" in part\n  );\n  return functionCallParts == null || functionCallParts.length === 0 ? void 0 : functionCallParts.map((part) => ({\n    toolCallType: \"function\",\n    toolCallId: generateId2(),\n    toolName: part.functionCall.name,\n    args: JSON.stringify(part.functionCall.args)\n  }));\n}\nfunction getTextFromParts(parts) {\n  const textParts = parts == null ? void 0 : parts.filter(\n    (part) => \"text\" in part && part.thought !== true\n  );\n  return textParts == null || textParts.length === 0 ? void 0 : textParts.map((part) => part.text).join(\"\");\n}\nfunction getReasoningDetailsFromParts(parts) {\n  const reasoningParts = parts == null ? void 0 : parts.filter(\n    (part) => \"text\" in part && part.thought === true && part.text != null\n  );\n  return reasoningParts == null || reasoningParts.length === 0 ? void 0 : reasoningParts.map((part) => ({ type: \"text\", text: part.text }));\n}\nfunction getInlineDataParts(parts) {\n  return parts == null ? void 0 : parts.filter(\n    (part) => \"inlineData\" in part\n  );\n}\nfunction extractSources({\n  groundingMetadata,\n  generateId: generateId2\n}) {\n  var _a;\n  return (_a = groundingMetadata == null ? void 0 : groundingMetadata.groundingChunks) == null ? void 0 : _a.filter(\n    (chunk) => chunk.web != null\n  ).map((chunk) => ({\n    sourceType: \"url\",\n    id: generateId2(),\n    url: chunk.web.uri,\n    title: chunk.web.title\n  }));\n}\nvar contentSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({\n  parts: zod__WEBPACK_IMPORTED_MODULE_2__.array(\n    zod__WEBPACK_IMPORTED_MODULE_2__.union([\n      // note: order matters since text can be fully empty\n      zod__WEBPACK_IMPORTED_MODULE_2__.object({\n        functionCall: zod__WEBPACK_IMPORTED_MODULE_2__.object({\n          name: zod__WEBPACK_IMPORTED_MODULE_2__.string(),\n          args: zod__WEBPACK_IMPORTED_MODULE_2__.unknown()\n        })\n      }),\n      zod__WEBPACK_IMPORTED_MODULE_2__.object({\n        inlineData: zod__WEBPACK_IMPORTED_MODULE_2__.object({\n          mimeType: zod__WEBPACK_IMPORTED_MODULE_2__.string(),\n          data: zod__WEBPACK_IMPORTED_MODULE_2__.string()\n        })\n      }),\n      zod__WEBPACK_IMPORTED_MODULE_2__.object({\n        text: zod__WEBPACK_IMPORTED_MODULE_2__.string().nullish(),\n        thought: zod__WEBPACK_IMPORTED_MODULE_2__.boolean().nullish()\n      })\n    ])\n  ).nullish()\n});\nvar groundingChunkSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({\n  web: zod__WEBPACK_IMPORTED_MODULE_2__.object({ uri: zod__WEBPACK_IMPORTED_MODULE_2__.string(), title: zod__WEBPACK_IMPORTED_MODULE_2__.string() }).nullish(),\n  retrievedContext: zod__WEBPACK_IMPORTED_MODULE_2__.object({ uri: zod__WEBPACK_IMPORTED_MODULE_2__.string(), title: zod__WEBPACK_IMPORTED_MODULE_2__.string() }).nullish()\n});\nvar groundingMetadataSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({\n  webSearchQueries: zod__WEBPACK_IMPORTED_MODULE_2__.array(zod__WEBPACK_IMPORTED_MODULE_2__.string()).nullish(),\n  retrievalQueries: zod__WEBPACK_IMPORTED_MODULE_2__.array(zod__WEBPACK_IMPORTED_MODULE_2__.string()).nullish(),\n  searchEntryPoint: zod__WEBPACK_IMPORTED_MODULE_2__.object({ renderedContent: zod__WEBPACK_IMPORTED_MODULE_2__.string() }).nullish(),\n  groundingChunks: zod__WEBPACK_IMPORTED_MODULE_2__.array(groundingChunkSchema).nullish(),\n  groundingSupports: zod__WEBPACK_IMPORTED_MODULE_2__.array(\n    zod__WEBPACK_IMPORTED_MODULE_2__.object({\n      segment: zod__WEBPACK_IMPORTED_MODULE_2__.object({\n        startIndex: zod__WEBPACK_IMPORTED_MODULE_2__.number().nullish(),\n        endIndex: zod__WEBPACK_IMPORTED_MODULE_2__.number().nullish(),\n        text: zod__WEBPACK_IMPORTED_MODULE_2__.string().nullish()\n      }),\n      segment_text: zod__WEBPACK_IMPORTED_MODULE_2__.string().nullish(),\n      groundingChunkIndices: zod__WEBPACK_IMPORTED_MODULE_2__.array(zod__WEBPACK_IMPORTED_MODULE_2__.number()).nullish(),\n      supportChunkIndices: zod__WEBPACK_IMPORTED_MODULE_2__.array(zod__WEBPACK_IMPORTED_MODULE_2__.number()).nullish(),\n      confidenceScores: zod__WEBPACK_IMPORTED_MODULE_2__.array(zod__WEBPACK_IMPORTED_MODULE_2__.number()).nullish(),\n      confidenceScore: zod__WEBPACK_IMPORTED_MODULE_2__.array(zod__WEBPACK_IMPORTED_MODULE_2__.number()).nullish()\n    })\n  ).nullish(),\n  retrievalMetadata: zod__WEBPACK_IMPORTED_MODULE_2__.union([\n    zod__WEBPACK_IMPORTED_MODULE_2__.object({\n      webDynamicRetrievalScore: zod__WEBPACK_IMPORTED_MODULE_2__.number()\n    }),\n    zod__WEBPACK_IMPORTED_MODULE_2__.object({})\n  ]).nullish()\n});\nvar safetyRatingSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({\n  category: zod__WEBPACK_IMPORTED_MODULE_2__.string().nullish(),\n  probability: zod__WEBPACK_IMPORTED_MODULE_2__.string().nullish(),\n  probabilityScore: zod__WEBPACK_IMPORTED_MODULE_2__.number().nullish(),\n  severity: zod__WEBPACK_IMPORTED_MODULE_2__.string().nullish(),\n  severityScore: zod__WEBPACK_IMPORTED_MODULE_2__.number().nullish(),\n  blocked: zod__WEBPACK_IMPORTED_MODULE_2__.boolean().nullish()\n});\nvar responseSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({\n  candidates: zod__WEBPACK_IMPORTED_MODULE_2__.array(\n    zod__WEBPACK_IMPORTED_MODULE_2__.object({\n      content: contentSchema.nullish().or(zod__WEBPACK_IMPORTED_MODULE_2__.object({}).strict()),\n      finishReason: zod__WEBPACK_IMPORTED_MODULE_2__.string().nullish(),\n      safetyRatings: zod__WEBPACK_IMPORTED_MODULE_2__.array(safetyRatingSchema).nullish(),\n      groundingMetadata: groundingMetadataSchema.nullish()\n    })\n  ),\n  usageMetadata: zod__WEBPACK_IMPORTED_MODULE_2__.object({\n    promptTokenCount: zod__WEBPACK_IMPORTED_MODULE_2__.number().nullish(),\n    candidatesTokenCount: zod__WEBPACK_IMPORTED_MODULE_2__.number().nullish(),\n    totalTokenCount: zod__WEBPACK_IMPORTED_MODULE_2__.number().nullish()\n  }).nullish()\n});\nvar chunkSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({\n  candidates: zod__WEBPACK_IMPORTED_MODULE_2__.array(\n    zod__WEBPACK_IMPORTED_MODULE_2__.object({\n      content: contentSchema.nullish(),\n      finishReason: zod__WEBPACK_IMPORTED_MODULE_2__.string().nullish(),\n      safetyRatings: zod__WEBPACK_IMPORTED_MODULE_2__.array(safetyRatingSchema).nullish(),\n      groundingMetadata: groundingMetadataSchema.nullish()\n    })\n  ).nullish(),\n  usageMetadata: zod__WEBPACK_IMPORTED_MODULE_2__.object({\n    promptTokenCount: zod__WEBPACK_IMPORTED_MODULE_2__.number().nullish(),\n    candidatesTokenCount: zod__WEBPACK_IMPORTED_MODULE_2__.number().nullish(),\n    totalTokenCount: zod__WEBPACK_IMPORTED_MODULE_2__.number().nullish()\n  }).nullish()\n});\nvar googleGenerativeAIProviderOptionsSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({\n  responseModalities: zod__WEBPACK_IMPORTED_MODULE_2__.array(zod__WEBPACK_IMPORTED_MODULE_2__[\"enum\"]([\"TEXT\", \"IMAGE\"])).nullish(),\n  thinkingConfig: zod__WEBPACK_IMPORTED_MODULE_2__.object({\n    thinkingBudget: zod__WEBPACK_IMPORTED_MODULE_2__.number().nullish(),\n    includeThoughts: zod__WEBPACK_IMPORTED_MODULE_2__.boolean().nullish()\n  }).nullish()\n});\n\n// src/google-generative-ai-embedding-model.ts\n\n\n\nvar GoogleGenerativeAIEmbeddingModel = class {\n  constructor(modelId, settings, config) {\n    this.specificationVersion = \"v1\";\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  get maxEmbeddingsPerCall() {\n    return 2048;\n  }\n  get supportsParallelCalls() {\n    return true;\n  }\n  async doEmbed({\n    values,\n    headers,\n    abortSignal\n  }) {\n    if (values.length > this.maxEmbeddingsPerCall) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TooManyEmbeddingValuesForCallError({\n        provider: this.provider,\n        modelId: this.modelId,\n        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,\n        values\n      });\n    }\n    const mergedHeaders = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.combineHeaders)(\n      await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.resolve)(this.config.headers),\n      headers\n    );\n    const { responseHeaders, value: response } = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.postJsonToApi)({\n      url: `${this.config.baseURL}/models/${this.modelId}:batchEmbedContents`,\n      headers: mergedHeaders,\n      body: {\n        requests: values.map((value) => ({\n          model: `models/${this.modelId}`,\n          content: { role: \"user\", parts: [{ text: value }] },\n          outputDimensionality: this.settings.outputDimensionality,\n          taskType: this.settings.taskType\n        }))\n      },\n      failedResponseHandler: googleFailedResponseHandler,\n      successfulResponseHandler: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.createJsonResponseHandler)(\n        googleGenerativeAITextEmbeddingResponseSchema\n      ),\n      abortSignal,\n      fetch: this.config.fetch\n    });\n    return {\n      embeddings: response.embeddings.map((item) => item.values),\n      usage: void 0,\n      rawResponse: { headers: responseHeaders }\n    };\n  }\n};\nvar googleGenerativeAITextEmbeddingResponseSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({\n  embeddings: zod__WEBPACK_IMPORTED_MODULE_2__.array(zod__WEBPACK_IMPORTED_MODULE_2__.object({ values: zod__WEBPACK_IMPORTED_MODULE_2__.array(zod__WEBPACK_IMPORTED_MODULE_2__.number()) }))\n});\n\n// src/google-supported-file-url.ts\nfunction isSupportedFileUrl(url) {\n  return url.toString().startsWith(\"https://generativelanguage.googleapis.com/v1beta/files/\");\n}\n\n// src/google-provider.ts\nfunction createGoogleGenerativeAI(options = {}) {\n  var _a;\n  const baseURL = (_a = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.withoutTrailingSlash)(options.baseURL)) != null ? _a : \"https://generativelanguage.googleapis.com/v1beta\";\n  const getHeaders = () => ({\n    \"x-goog-api-key\": (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.loadApiKey)({\n      apiKey: options.apiKey,\n      environmentVariableName: \"GOOGLE_GENERATIVE_AI_API_KEY\",\n      description: \"Google Generative AI\"\n    }),\n    ...options.headers\n  });\n  const createChatModel = (modelId, settings = {}) => {\n    var _a2;\n    return new GoogleGenerativeAILanguageModel(modelId, settings, {\n      provider: \"google.generative-ai\",\n      baseURL,\n      headers: getHeaders,\n      generateId: (_a2 = options.generateId) != null ? _a2 : _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.generateId,\n      isSupportedUrl: isSupportedFileUrl,\n      fetch: options.fetch\n    });\n  };\n  const createEmbeddingModel = (modelId, settings = {}) => new GoogleGenerativeAIEmbeddingModel(modelId, settings, {\n    provider: \"google.generative-ai\",\n    baseURL,\n    headers: getHeaders,\n    fetch: options.fetch\n  });\n  const provider = function(modelId, settings) {\n    if (new.target) {\n      throw new Error(\n        \"The Google Generative AI model function cannot be called with the new keyword.\"\n      );\n    }\n    return createChatModel(modelId, settings);\n  };\n  provider.languageModel = createChatModel;\n  provider.chat = createChatModel;\n  provider.generativeAI = createChatModel;\n  provider.embedding = createEmbeddingModel;\n  provider.textEmbedding = createEmbeddingModel;\n  provider.textEmbeddingModel = createEmbeddingModel;\n  return provider;\n}\nvar google = createGoogleGenerativeAI();\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9nb29nbGUvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUtnQzs7QUFFaEM7QUFRZ0M7QUFDRjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUcwQjtBQUN5QztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJFQUE2QjtBQUNqRDtBQUNBLFdBQVc7QUFDWDtBQUNBLHNDQUFzQyxlQUFlO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNs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QUFDLHVDQUFTLEdBQUcsUUFBUSxzQ0FBUSxDQUFDLHVDQUFTLEtBQUs7QUFDbEUsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLHdCQUF3Qiw0RUFBb0I7QUFDNUM7QUFDQSxzQkFBc0Isa0VBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNILGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDhEQUFVO0FBQ3ZFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbGVldGZsb3cvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9nb29nbGUvZGlzdC9pbmRleC5tanM/Yzc2MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvZ29vZ2xlLXByb3ZpZGVyLnRzXG5pbXBvcnQge1xuICBnZW5lcmF0ZUlkLFxuICBsb2FkQXBpS2V5LFxuICB3aXRob3V0VHJhaWxpbmdTbGFzaFxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvZ29vZ2xlLWdlbmVyYXRpdmUtYWktbGFuZ3VhZ2UtbW9kZWwudHNcbmltcG9ydCB7XG4gIGNvbWJpbmVIZWFkZXJzLFxuICBjcmVhdGVFdmVudFNvdXJjZVJlc3BvbnNlSGFuZGxlcixcbiAgY3JlYXRlSnNvblJlc3BvbnNlSGFuZGxlcixcbiAgcGFyc2VQcm92aWRlck9wdGlvbnMsXG4gIHBvc3RKc29uVG9BcGksXG4gIHJlc29sdmVcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IHogYXMgejIgfSBmcm9tIFwiem9kXCI7XG5cbi8vIHNyYy9jb252ZXJ0LWpzb24tc2NoZW1hLXRvLW9wZW5hcGktc2NoZW1hLnRzXG5mdW5jdGlvbiBjb252ZXJ0SlNPTlNjaGVtYVRvT3BlbkFQSVNjaGVtYShqc29uU2NoZW1hKSB7XG4gIGlmIChpc0VtcHR5T2JqZWN0U2NoZW1hKGpzb25TY2hlbWEpKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBpZiAodHlwZW9mIGpzb25TY2hlbWEgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJib29sZWFuXCIsIHByb3BlcnRpZXM6IHt9IH07XG4gIH1cbiAgY29uc3Qge1xuICAgIHR5cGUsXG4gICAgZGVzY3JpcHRpb24sXG4gICAgcmVxdWlyZWQsXG4gICAgcHJvcGVydGllcyxcbiAgICBpdGVtcyxcbiAgICBhbGxPZixcbiAgICBhbnlPZixcbiAgICBvbmVPZixcbiAgICBmb3JtYXQsXG4gICAgY29uc3Q6IGNvbnN0VmFsdWUsXG4gICAgbWluTGVuZ3RoLFxuICAgIGVudW06IGVudW1WYWx1ZXNcbiAgfSA9IGpzb25TY2hlbWE7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBpZiAoZGVzY3JpcHRpb24pXG4gICAgcmVzdWx0LmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gIGlmIChyZXF1aXJlZClcbiAgICByZXN1bHQucmVxdWlyZWQgPSByZXF1aXJlZDtcbiAgaWYgKGZvcm1hdClcbiAgICByZXN1bHQuZm9ybWF0ID0gZm9ybWF0O1xuICBpZiAoY29uc3RWYWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgcmVzdWx0LmVudW0gPSBbY29uc3RWYWx1ZV07XG4gIH1cbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgaWYgKHR5cGUuaW5jbHVkZXMoXCJudWxsXCIpKSB7XG4gICAgICAgIHJlc3VsdC50eXBlID0gdHlwZS5maWx0ZXIoKHQpID0+IHQgIT09IFwibnVsbFwiKVswXTtcbiAgICAgICAgcmVzdWx0Lm51bGxhYmxlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC50eXBlID0gdHlwZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibnVsbFwiKSB7XG4gICAgICByZXN1bHQudHlwZSA9IFwibnVsbFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQudHlwZSA9IHR5cGU7XG4gICAgfVxuICB9XG4gIGlmIChlbnVtVmFsdWVzICE9PSB2b2lkIDApIHtcbiAgICByZXN1bHQuZW51bSA9IGVudW1WYWx1ZXM7XG4gIH1cbiAgaWYgKHByb3BlcnRpZXMgIT0gbnVsbCkge1xuICAgIHJlc3VsdC5wcm9wZXJ0aWVzID0gT2JqZWN0LmVudHJpZXMocHJvcGVydGllcykucmVkdWNlKFxuICAgICAgKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGFjY1trZXldID0gY29udmVydEpTT05TY2hlbWFUb09wZW5BUElTY2hlbWEodmFsdWUpO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSxcbiAgICAgIHt9XG4gICAgKTtcbiAgfVxuICBpZiAoaXRlbXMpIHtcbiAgICByZXN1bHQuaXRlbXMgPSBBcnJheS5pc0FycmF5KGl0ZW1zKSA/IGl0ZW1zLm1hcChjb252ZXJ0SlNPTlNjaGVtYVRvT3BlbkFQSVNjaGVtYSkgOiBjb252ZXJ0SlNPTlNjaGVtYVRvT3BlbkFQSVNjaGVtYShpdGVtcyk7XG4gIH1cbiAgaWYgKGFsbE9mKSB7XG4gICAgcmVzdWx0LmFsbE9mID0gYWxsT2YubWFwKGNvbnZlcnRKU09OU2NoZW1hVG9PcGVuQVBJU2NoZW1hKTtcbiAgfVxuICBpZiAoYW55T2YpIHtcbiAgICBpZiAoYW55T2Yuc29tZShcbiAgICAgIChzY2hlbWEpID0+IHR5cGVvZiBzY2hlbWEgPT09IFwib2JqZWN0XCIgJiYgKHNjaGVtYSA9PSBudWxsID8gdm9pZCAwIDogc2NoZW1hLnR5cGUpID09PSBcIm51bGxcIlxuICAgICkpIHtcbiAgICAgIGNvbnN0IG5vbk51bGxTY2hlbWFzID0gYW55T2YuZmlsdGVyKFxuICAgICAgICAoc2NoZW1hKSA9PiAhKHR5cGVvZiBzY2hlbWEgPT09IFwib2JqZWN0XCIgJiYgKHNjaGVtYSA9PSBudWxsID8gdm9pZCAwIDogc2NoZW1hLnR5cGUpID09PSBcIm51bGxcIilcbiAgICAgICk7XG4gICAgICBpZiAobm9uTnVsbFNjaGVtYXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IGNvbnZlcnRlZCA9IGNvbnZlcnRKU09OU2NoZW1hVG9PcGVuQVBJU2NoZW1hKG5vbk51bGxTY2hlbWFzWzBdKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb252ZXJ0ZWQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICByZXN1bHQubnVsbGFibGUgPSB0cnVlO1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCBjb252ZXJ0ZWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQuYW55T2YgPSBub25OdWxsU2NoZW1hcy5tYXAoY29udmVydEpTT05TY2hlbWFUb09wZW5BUElTY2hlbWEpO1xuICAgICAgICByZXN1bHQubnVsbGFibGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQuYW55T2YgPSBhbnlPZi5tYXAoY29udmVydEpTT05TY2hlbWFUb09wZW5BUElTY2hlbWEpO1xuICAgIH1cbiAgfVxuICBpZiAob25lT2YpIHtcbiAgICByZXN1bHQub25lT2YgPSBvbmVPZi5tYXAoY29udmVydEpTT05TY2hlbWFUb09wZW5BUElTY2hlbWEpO1xuICB9XG4gIGlmIChtaW5MZW5ndGggIT09IHZvaWQgMCkge1xuICAgIHJlc3VsdC5taW5MZW5ndGggPSBtaW5MZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGlzRW1wdHlPYmplY3RTY2hlbWEoanNvblNjaGVtYSkge1xuICByZXR1cm4ganNvblNjaGVtYSAhPSBudWxsICYmIHR5cGVvZiBqc29uU2NoZW1hID09PSBcIm9iamVjdFwiICYmIGpzb25TY2hlbWEudHlwZSA9PT0gXCJvYmplY3RcIiAmJiAoanNvblNjaGVtYS5wcm9wZXJ0aWVzID09IG51bGwgfHwgT2JqZWN0LmtleXMoanNvblNjaGVtYS5wcm9wZXJ0aWVzKS5sZW5ndGggPT09IDApICYmICFqc29uU2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzO1xufVxuXG4vLyBzcmMvY29udmVydC10by1nb29nbGUtZ2VuZXJhdGl2ZS1haS1tZXNzYWdlcy50c1xuaW1wb3J0IHtcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3Jcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuZnVuY3Rpb24gY29udmVydFRvR29vZ2xlR2VuZXJhdGl2ZUFJTWVzc2FnZXMocHJvbXB0KSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHN5c3RlbUluc3RydWN0aW9uUGFydHMgPSBbXTtcbiAgY29uc3QgY29udGVudHMgPSBbXTtcbiAgbGV0IHN5c3RlbU1lc3NhZ2VzQWxsb3dlZCA9IHRydWU7XG4gIGZvciAoY29uc3QgeyByb2xlLCBjb250ZW50IH0gb2YgcHJvbXB0KSB7XG4gICAgc3dpdGNoIChyb2xlKSB7XG4gICAgICBjYXNlIFwic3lzdGVtXCI6IHtcbiAgICAgICAgaWYgKCFzeXN0ZW1NZXNzYWdlc0FsbG93ZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3Ioe1xuICAgICAgICAgICAgZnVuY3Rpb25hbGl0eTogXCJzeXN0ZW0gbWVzc2FnZXMgYXJlIG9ubHkgc3VwcG9ydGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGNvbnZlcnNhdGlvblwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3lzdGVtSW5zdHJ1Y3Rpb25QYXJ0cy5wdXNoKHsgdGV4dDogY29udGVudCB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwidXNlclwiOiB7XG4gICAgICAgIHN5c3RlbU1lc3NhZ2VzQWxsb3dlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgY29udGVudCkge1xuICAgICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidGV4dFwiOiB7XG4gICAgICAgICAgICAgIHBhcnRzLnB1c2goeyB0ZXh0OiBwYXJ0LnRleHQgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImltYWdlXCI6IHtcbiAgICAgICAgICAgICAgcGFydHMucHVzaChcbiAgICAgICAgICAgICAgICBwYXJ0LmltYWdlIGluc3RhbmNlb2YgVVJMID8ge1xuICAgICAgICAgICAgICAgICAgZmlsZURhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IChfYSA9IHBhcnQubWltZVR5cGUpICE9IG51bGwgPyBfYSA6IFwiaW1hZ2UvanBlZ1wiLFxuICAgICAgICAgICAgICAgICAgICBmaWxlVXJpOiBwYXJ0LmltYWdlLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgICAgaW5saW5lRGF0YToge1xuICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogKF9iID0gcGFydC5taW1lVHlwZSkgIT0gbnVsbCA/IF9iIDogXCJpbWFnZS9qcGVnXCIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQocGFydC5pbWFnZSlcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImZpbGVcIjoge1xuICAgICAgICAgICAgICBwYXJ0cy5wdXNoKFxuICAgICAgICAgICAgICAgIHBhcnQuZGF0YSBpbnN0YW5jZW9mIFVSTCA/IHtcbiAgICAgICAgICAgICAgICAgIGZpbGVEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBwYXJ0Lm1pbWVUeXBlLFxuICAgICAgICAgICAgICAgICAgICBmaWxlVXJpOiBwYXJ0LmRhdGEudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgICBpbmxpbmVEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBwYXJ0Lm1pbWVUeXBlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBwYXJ0LmRhdGFcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250ZW50cy5wdXNoKHsgcm9sZTogXCJ1c2VyXCIsIHBhcnRzIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJhc3Npc3RhbnRcIjoge1xuICAgICAgICBzeXN0ZW1NZXNzYWdlc0FsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgY29udGVudHMucHVzaCh7XG4gICAgICAgICAgcm9sZTogXCJtb2RlbFwiLFxuICAgICAgICAgIHBhcnRzOiBjb250ZW50Lm1hcCgocGFydCkgPT4ge1xuICAgICAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInRleHRcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0LnRleHQubGVuZ3RoID09PSAwID8gdm9pZCAwIDogeyB0ZXh0OiBwYXJ0LnRleHQgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwiZmlsZVwiOiB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQubWltZVR5cGUgIT09IFwiaW1hZ2UvcG5nXCIpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uYWxpdHk6IFwiT25seSBQTkcgaW1hZ2VzIGFyZSBzdXBwb3J0ZWQgaW4gYXNzaXN0YW50IG1lc3NhZ2VzXCJcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFydC5kYXRhIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbmFsaXR5OiBcIkZpbGUgZGF0YSBVUkxzIGluIGFzc2lzdGFudCBtZXNzYWdlcyBhcmUgbm90IHN1cHBvcnRlZFwiXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIGlubGluZURhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IHBhcnQubWltZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHBhcnQuZGF0YVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uQ2FsbDoge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBwYXJ0LmFyZ3NcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0ICE9PSB2b2lkIDApXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ0b29sXCI6IHtcbiAgICAgICAgc3lzdGVtTWVzc2FnZXNBbGxvd2VkID0gZmFsc2U7XG4gICAgICAgIGNvbnRlbnRzLnB1c2goe1xuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIHBhcnRzOiBjb250ZW50Lm1hcCgocGFydCkgPT4gKHtcbiAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgbmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHBhcnQucmVzdWx0XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSlcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHN5c3RlbUluc3RydWN0aW9uOiBzeXN0ZW1JbnN0cnVjdGlvblBhcnRzLmxlbmd0aCA+IDAgPyB7IHBhcnRzOiBzeXN0ZW1JbnN0cnVjdGlvblBhcnRzIH0gOiB2b2lkIDAsXG4gICAgY29udGVudHNcbiAgfTtcbn1cblxuLy8gc3JjL2dldC1tb2RlbC1wYXRoLnRzXG5mdW5jdGlvbiBnZXRNb2RlbFBhdGgobW9kZWxJZCkge1xuICByZXR1cm4gbW9kZWxJZC5pbmNsdWRlcyhcIi9cIikgPyBtb2RlbElkIDogYG1vZGVscy8ke21vZGVsSWR9YDtcbn1cblxuLy8gc3JjL2dvb2dsZS1lcnJvci50c1xuaW1wb3J0IHsgY3JlYXRlSnNvbkVycm9yUmVzcG9uc2VIYW5kbGVyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IHogfSBmcm9tIFwiem9kXCI7XG52YXIgZ29vZ2xlRXJyb3JEYXRhU2NoZW1hID0gei5vYmplY3Qoe1xuICBlcnJvcjogei5vYmplY3Qoe1xuICAgIGNvZGU6IHoubnVtYmVyKCkubnVsbGFibGUoKSxcbiAgICBtZXNzYWdlOiB6LnN0cmluZygpLFxuICAgIHN0YXR1czogei5zdHJpbmcoKVxuICB9KVxufSk7XG52YXIgZ29vZ2xlRmFpbGVkUmVzcG9uc2VIYW5kbGVyID0gY3JlYXRlSnNvbkVycm9yUmVzcG9uc2VIYW5kbGVyKHtcbiAgZXJyb3JTY2hlbWE6IGdvb2dsZUVycm9yRGF0YVNjaGVtYSxcbiAgZXJyb3JUb01lc3NhZ2U6IChkYXRhKSA9PiBkYXRhLmVycm9yLm1lc3NhZ2Vcbn0pO1xuXG4vLyBzcmMvZ29vZ2xlLXByZXBhcmUtdG9vbHMudHNcbmltcG9ydCB7XG4gIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yIGFzIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yMlxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuZnVuY3Rpb24gcHJlcGFyZVRvb2xzKG1vZGUsIHVzZVNlYXJjaEdyb3VuZGluZywgZHluYW1pY1JldHJpZXZhbENvbmZpZywgbW9kZWxJZCkge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCB0b29scyA9ICgoX2EgPSBtb2RlLnRvb2xzKSA9PSBudWxsID8gdm9pZCAwIDogX2EubGVuZ3RoKSA/IG1vZGUudG9vbHMgOiB2b2lkIDA7XG4gIGNvbnN0IHRvb2xXYXJuaW5ncyA9IFtdO1xuICBjb25zdCBpc0dlbWluaTIgPSBtb2RlbElkLmluY2x1ZGVzKFwiZ2VtaW5pLTJcIik7XG4gIGNvbnN0IHN1cHBvcnRzRHluYW1pY1JldHJpZXZhbCA9IG1vZGVsSWQuaW5jbHVkZXMoXCJnZW1pbmktMS41LWZsYXNoXCIpICYmICFtb2RlbElkLmluY2x1ZGVzKFwiLThiXCIpO1xuICBpZiAodXNlU2VhcmNoR3JvdW5kaW5nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvb2xzOiBpc0dlbWluaTIgPyB7IGdvb2dsZVNlYXJjaDoge30gfSA6IHtcbiAgICAgICAgZ29vZ2xlU2VhcmNoUmV0cmlldmFsOiAhc3VwcG9ydHNEeW5hbWljUmV0cmlldmFsIHx8ICFkeW5hbWljUmV0cmlldmFsQ29uZmlnID8ge30gOiB7IGR5bmFtaWNSZXRyaWV2YWxDb25maWcgfVxuICAgICAgfSxcbiAgICAgIHRvb2xDb25maWc6IHZvaWQgMCxcbiAgICAgIHRvb2xXYXJuaW5nc1xuICAgIH07XG4gIH1cbiAgaWYgKHRvb2xzID09IG51bGwpIHtcbiAgICByZXR1cm4geyB0b29sczogdm9pZCAwLCB0b29sQ29uZmlnOiB2b2lkIDAsIHRvb2xXYXJuaW5ncyB9O1xuICB9XG4gIGNvbnN0IGZ1bmN0aW9uRGVjbGFyYXRpb25zID0gW107XG4gIGZvciAoY29uc3QgdG9vbCBvZiB0b29scykge1xuICAgIGlmICh0b29sLnR5cGUgPT09IFwicHJvdmlkZXItZGVmaW5lZFwiKSB7XG4gICAgICB0b29sV2FybmluZ3MucHVzaCh7IHR5cGU6IFwidW5zdXBwb3J0ZWQtdG9vbFwiLCB0b29sIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmdW5jdGlvbkRlY2xhcmF0aW9ucy5wdXNoKHtcbiAgICAgICAgbmFtZTogdG9vbC5uYW1lLFxuICAgICAgICBkZXNjcmlwdGlvbjogKF9iID0gdG9vbC5kZXNjcmlwdGlvbikgIT0gbnVsbCA/IF9iIDogXCJcIixcbiAgICAgICAgcGFyYW1ldGVyczogY29udmVydEpTT05TY2hlbWFUb09wZW5BUElTY2hlbWEodG9vbC5wYXJhbWV0ZXJzKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHRvb2xDaG9pY2UgPSBtb2RlLnRvb2xDaG9pY2U7XG4gIGlmICh0b29sQ2hvaWNlID09IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9vbHM6IHsgZnVuY3Rpb25EZWNsYXJhdGlvbnMgfSxcbiAgICAgIHRvb2xDb25maWc6IHZvaWQgMCxcbiAgICAgIHRvb2xXYXJuaW5nc1xuICAgIH07XG4gIH1cbiAgY29uc3QgdHlwZSA9IHRvb2xDaG9pY2UudHlwZTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcImF1dG9cIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvb2xzOiB7IGZ1bmN0aW9uRGVjbGFyYXRpb25zIH0sXG4gICAgICAgIHRvb2xDb25maWc6IHsgZnVuY3Rpb25DYWxsaW5nQ29uZmlnOiB7IG1vZGU6IFwiQVVUT1wiIH0gfSxcbiAgICAgICAgdG9vbFdhcm5pbmdzXG4gICAgICB9O1xuICAgIGNhc2UgXCJub25lXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b29sczogeyBmdW5jdGlvbkRlY2xhcmF0aW9ucyB9LFxuICAgICAgICB0b29sQ29uZmlnOiB7IGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZzogeyBtb2RlOiBcIk5PTkVcIiB9IH0sXG4gICAgICAgIHRvb2xXYXJuaW5nc1xuICAgICAgfTtcbiAgICBjYXNlIFwicmVxdWlyZWRcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvb2xzOiB7IGZ1bmN0aW9uRGVjbGFyYXRpb25zIH0sXG4gICAgICAgIHRvb2xDb25maWc6IHsgZnVuY3Rpb25DYWxsaW5nQ29uZmlnOiB7IG1vZGU6IFwiQU5ZXCIgfSB9LFxuICAgICAgICB0b29sV2FybmluZ3NcbiAgICAgIH07XG4gICAgY2FzZSBcInRvb2xcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvb2xzOiB7IGZ1bmN0aW9uRGVjbGFyYXRpb25zIH0sXG4gICAgICAgIHRvb2xDb25maWc6IHtcbiAgICAgICAgICBmdW5jdGlvbkNhbGxpbmdDb25maWc6IHtcbiAgICAgICAgICAgIG1vZGU6IFwiQU5ZXCIsXG4gICAgICAgICAgICBhbGxvd2VkRnVuY3Rpb25OYW1lczogW3Rvb2xDaG9pY2UudG9vbE5hbWVdXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0b29sV2FybmluZ3NcbiAgICAgIH07XG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IHR5cGU7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IyKHtcbiAgICAgICAgZnVuY3Rpb25hbGl0eTogYFVuc3VwcG9ydGVkIHRvb2wgY2hvaWNlIHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuLy8gc3JjL21hcC1nb29nbGUtZ2VuZXJhdGl2ZS1haS1maW5pc2gtcmVhc29uLnRzXG5mdW5jdGlvbiBtYXBHb29nbGVHZW5lcmF0aXZlQUlGaW5pc2hSZWFzb24oe1xuICBmaW5pc2hSZWFzb24sXG4gIGhhc1Rvb2xDYWxsc1xufSkge1xuICBzd2l0Y2ggKGZpbmlzaFJlYXNvbikge1xuICAgIGNhc2UgXCJTVE9QXCI6XG4gICAgICByZXR1cm4gaGFzVG9vbENhbGxzID8gXCJ0b29sLWNhbGxzXCIgOiBcInN0b3BcIjtcbiAgICBjYXNlIFwiTUFYX1RPS0VOU1wiOlxuICAgICAgcmV0dXJuIFwibGVuZ3RoXCI7XG4gICAgY2FzZSBcIklNQUdFX1NBRkVUWVwiOlxuICAgIGNhc2UgXCJSRUNJVEFUSU9OXCI6XG4gICAgY2FzZSBcIlNBRkVUWVwiOlxuICAgIGNhc2UgXCJCTE9DS0xJU1RcIjpcbiAgICBjYXNlIFwiUFJPSElCSVRFRF9DT05URU5UXCI6XG4gICAgY2FzZSBcIlNQSUlcIjpcbiAgICAgIHJldHVybiBcImNvbnRlbnQtZmlsdGVyXCI7XG4gICAgY2FzZSBcIkZJTklTSF9SRUFTT05fVU5TUEVDSUZJRURcIjpcbiAgICBjYXNlIFwiT1RIRVJcIjpcbiAgICAgIHJldHVybiBcIm90aGVyXCI7XG4gICAgY2FzZSBcIk1BTEZPUk1FRF9GVU5DVElPTl9DQUxMXCI6XG4gICAgICByZXR1cm4gXCJlcnJvclwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCJ1bmtub3duXCI7XG4gIH1cbn1cblxuLy8gc3JjL2dvb2dsZS1nZW5lcmF0aXZlLWFpLWxhbmd1YWdlLW1vZGVsLnRzXG52YXIgR29vZ2xlR2VuZXJhdGl2ZUFJTGFuZ3VhZ2VNb2RlbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobW9kZWxJZCwgc2V0dGluZ3MsIGNvbmZpZykge1xuICAgIHRoaXMuc3BlY2lmaWNhdGlvblZlcnNpb24gPSBcInYxXCI7XG4gICAgdGhpcy5kZWZhdWx0T2JqZWN0R2VuZXJhdGlvbk1vZGUgPSBcImpzb25cIjtcbiAgICB0aGlzLnN1cHBvcnRzSW1hZ2VVcmxzID0gZmFsc2U7XG4gICAgdGhpcy5tb2RlbElkID0gbW9kZWxJZDtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cbiAgZ2V0IHN1cHBvcnRzU3RydWN0dXJlZE91dHB1dHMoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLnNldHRpbmdzLnN0cnVjdHVyZWRPdXRwdXRzKSAhPSBudWxsID8gX2EgOiB0cnVlO1xuICB9XG4gIGdldCBwcm92aWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcucHJvdmlkZXI7XG4gIH1cbiAgYXN5bmMgZ2V0QXJncyh7XG4gICAgbW9kZSxcbiAgICBwcm9tcHQsXG4gICAgbWF4VG9rZW5zLFxuICAgIHRlbXBlcmF0dXJlLFxuICAgIHRvcFAsXG4gICAgdG9wSyxcbiAgICBmcmVxdWVuY3lQZW5hbHR5LFxuICAgIHByZXNlbmNlUGVuYWx0eSxcbiAgICBzdG9wU2VxdWVuY2VzLFxuICAgIHJlc3BvbnNlRm9ybWF0LFxuICAgIHNlZWQsXG4gICAgcHJvdmlkZXJNZXRhZGF0YVxuICB9KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgdHlwZSA9IG1vZGUudHlwZTtcbiAgICBjb25zdCB3YXJuaW5ncyA9IFtdO1xuICAgIGNvbnN0IGdvb2dsZU9wdGlvbnMgPSBwYXJzZVByb3ZpZGVyT3B0aW9ucyh7XG4gICAgICBwcm92aWRlcjogXCJnb29nbGVcIixcbiAgICAgIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgIHNjaGVtYTogZ29vZ2xlR2VuZXJhdGl2ZUFJUHJvdmlkZXJPcHRpb25zU2NoZW1hXG4gICAgfSk7XG4gICAgaWYgKCgoX2EgPSBnb29nbGVPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBnb29nbGVPcHRpb25zLnRoaW5raW5nQ29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaW5jbHVkZVRob3VnaHRzKSA9PT0gdHJ1ZSAmJiAhdGhpcy5jb25maWcucHJvdmlkZXIuc3RhcnRzV2l0aChcImdvb2dsZS52ZXJ0ZXguXCIpKSB7XG4gICAgICB3YXJuaW5ncy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJvdGhlclwiLFxuICAgICAgICBtZXNzYWdlOiBgVGhlICdpbmNsdWRlVGhvdWdodHMnIG9wdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCB3aXRoIHRoZSBHb29nbGUgVmVydGV4IHByb3ZpZGVyIGFuZCBtaWdodCBub3QgYmUgc3VwcG9ydGVkIG9yIGNvdWxkIGJlaGF2ZSB1bmV4cGVjdGVkbHkgd2l0aCB0aGUgY3VycmVudCBHb29nbGUgcHJvdmlkZXIgKCR7dGhpcy5jb25maWcucHJvdmlkZXJ9KS5gXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgZ2VuZXJhdGlvbkNvbmZpZyA9IHtcbiAgICAgIC8vIHN0YW5kYXJkaXplZCBzZXR0aW5nczpcbiAgICAgIG1heE91dHB1dFRva2VuczogbWF4VG9rZW5zLFxuICAgICAgdGVtcGVyYXR1cmUsXG4gICAgICB0b3BLLFxuICAgICAgdG9wUCxcbiAgICAgIGZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICBwcmVzZW5jZVBlbmFsdHksXG4gICAgICBzdG9wU2VxdWVuY2VzLFxuICAgICAgc2VlZCxcbiAgICAgIC8vIHJlc3BvbnNlIGZvcm1hdDpcbiAgICAgIHJlc3BvbnNlTWltZVR5cGU6IChyZXNwb25zZUZvcm1hdCA9PSBudWxsID8gdm9pZCAwIDogcmVzcG9uc2VGb3JtYXQudHlwZSkgPT09IFwianNvblwiID8gXCJhcHBsaWNhdGlvbi9qc29uXCIgOiB2b2lkIDAsXG4gICAgICByZXNwb25zZVNjaGVtYTogKHJlc3BvbnNlRm9ybWF0ID09IG51bGwgPyB2b2lkIDAgOiByZXNwb25zZUZvcm1hdC50eXBlKSA9PT0gXCJqc29uXCIgJiYgcmVzcG9uc2VGb3JtYXQuc2NoZW1hICE9IG51bGwgJiYgLy8gR29vZ2xlIEdlbkFJIGRvZXMgbm90IHN1cHBvcnQgYWxsIE9wZW5BUEkgU2NoZW1hIGZlYXR1cmVzLFxuICAgICAgLy8gc28gdGhpcyBpcyBuZWVkZWQgYXMgYW4gZXNjYXBlIGhhdGNoOlxuICAgICAgdGhpcy5zdXBwb3J0c1N0cnVjdHVyZWRPdXRwdXRzID8gY29udmVydEpTT05TY2hlbWFUb09wZW5BUElTY2hlbWEocmVzcG9uc2VGb3JtYXQuc2NoZW1hKSA6IHZvaWQgMCxcbiAgICAgIC4uLnRoaXMuc2V0dGluZ3MuYXVkaW9UaW1lc3RhbXAgJiYge1xuICAgICAgICBhdWRpb1RpbWVzdGFtcDogdGhpcy5zZXR0aW5ncy5hdWRpb1RpbWVzdGFtcFxuICAgICAgfSxcbiAgICAgIC8vIHByb3ZpZGVyIG9wdGlvbnM6XG4gICAgICByZXNwb25zZU1vZGFsaXRpZXM6IGdvb2dsZU9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGdvb2dsZU9wdGlvbnMucmVzcG9uc2VNb2RhbGl0aWVzLFxuICAgICAgdGhpbmtpbmdDb25maWc6IGdvb2dsZU9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGdvb2dsZU9wdGlvbnMudGhpbmtpbmdDb25maWdcbiAgICB9O1xuICAgIGNvbnN0IHsgY29udGVudHMsIHN5c3RlbUluc3RydWN0aW9uIH0gPSBjb252ZXJ0VG9Hb29nbGVHZW5lcmF0aXZlQUlNZXNzYWdlcyhwcm9tcHQpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcInJlZ3VsYXJcIjoge1xuICAgICAgICBjb25zdCB7IHRvb2xzLCB0b29sQ29uZmlnLCB0b29sV2FybmluZ3MgfSA9IHByZXBhcmVUb29scyhcbiAgICAgICAgICBtb2RlLFxuICAgICAgICAgIChfYiA9IHRoaXMuc2V0dGluZ3MudXNlU2VhcmNoR3JvdW5kaW5nKSAhPSBudWxsID8gX2IgOiBmYWxzZSxcbiAgICAgICAgICB0aGlzLnNldHRpbmdzLmR5bmFtaWNSZXRyaWV2YWxDb25maWcsXG4gICAgICAgICAgdGhpcy5tb2RlbElkXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYXJnczoge1xuICAgICAgICAgICAgZ2VuZXJhdGlvbkNvbmZpZyxcbiAgICAgICAgICAgIGNvbnRlbnRzLFxuICAgICAgICAgICAgc3lzdGVtSW5zdHJ1Y3Rpb24sXG4gICAgICAgICAgICBzYWZldHlTZXR0aW5nczogdGhpcy5zZXR0aW5ncy5zYWZldHlTZXR0aW5ncyxcbiAgICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgICAgdG9vbENvbmZpZyxcbiAgICAgICAgICAgIGNhY2hlZENvbnRlbnQ6IHRoaXMuc2V0dGluZ3MuY2FjaGVkQ29udGVudFxuICAgICAgICAgIH0sXG4gICAgICAgICAgd2FybmluZ3M6IFsuLi53YXJuaW5ncywgLi4udG9vbFdhcm5pbmdzXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY2FzZSBcIm9iamVjdC1qc29uXCI6IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhcmdzOiB7XG4gICAgICAgICAgICBnZW5lcmF0aW9uQ29uZmlnOiB7XG4gICAgICAgICAgICAgIC4uLmdlbmVyYXRpb25Db25maWcsXG4gICAgICAgICAgICAgIHJlc3BvbnNlTWltZVR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICByZXNwb25zZVNjaGVtYTogbW9kZS5zY2hlbWEgIT0gbnVsbCAmJiAvLyBHb29nbGUgR2VuQUkgZG9lcyBub3Qgc3VwcG9ydCBhbGwgT3BlbkFQSSBTY2hlbWEgZmVhdHVyZXMsXG4gICAgICAgICAgICAgIC8vIHNvIHRoaXMgaXMgbmVlZGVkIGFzIGFuIGVzY2FwZSBoYXRjaDpcbiAgICAgICAgICAgICAgdGhpcy5zdXBwb3J0c1N0cnVjdHVyZWRPdXRwdXRzID8gY29udmVydEpTT05TY2hlbWFUb09wZW5BUElTY2hlbWEobW9kZS5zY2hlbWEpIDogdm9pZCAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGVudHMsXG4gICAgICAgICAgICBzeXN0ZW1JbnN0cnVjdGlvbixcbiAgICAgICAgICAgIHNhZmV0eVNldHRpbmdzOiB0aGlzLnNldHRpbmdzLnNhZmV0eVNldHRpbmdzLFxuICAgICAgICAgICAgY2FjaGVkQ29udGVudDogdGhpcy5zZXR0aW5ncy5jYWNoZWRDb250ZW50XG4gICAgICAgICAgfSxcbiAgICAgICAgICB3YXJuaW5nc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY2FzZSBcIm9iamVjdC10b29sXCI6IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhcmdzOiB7XG4gICAgICAgICAgICBnZW5lcmF0aW9uQ29uZmlnLFxuICAgICAgICAgICAgY29udGVudHMsXG4gICAgICAgICAgICBzeXN0ZW1JbnN0cnVjdGlvbixcbiAgICAgICAgICAgIHRvb2xzOiB7XG4gICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgbmFtZTogbW9kZS50b29sLm5hbWUsXG4gICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogKF9jID0gbW9kZS50b29sLmRlc2NyaXB0aW9uKSAhPSBudWxsID8gX2MgOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyczogY29udmVydEpTT05TY2hlbWFUb09wZW5BUElTY2hlbWEoXG4gICAgICAgICAgICAgICAgICAgIG1vZGUudG9vbC5wYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9vbENvbmZpZzogeyBmdW5jdGlvbkNhbGxpbmdDb25maWc6IHsgbW9kZTogXCJBTllcIiB9IH0sXG4gICAgICAgICAgICBzYWZldHlTZXR0aW5nczogdGhpcy5zZXR0aW5ncy5zYWZldHlTZXR0aW5ncyxcbiAgICAgICAgICAgIGNhY2hlZENvbnRlbnQ6IHRoaXMuc2V0dGluZ3MuY2FjaGVkQ29udGVudFxuICAgICAgICAgIH0sXG4gICAgICAgICAgd2FybmluZ3NcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IHR5cGU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdXBwb3J0c1VybCh1cmwpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuaXNTdXBwb3J0ZWRVcmwodXJsKTtcbiAgfVxuICBhc3luYyBkb0dlbmVyYXRlKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgIGNvbnN0IHsgYXJncywgd2FybmluZ3MgfSA9IGF3YWl0IHRoaXMuZ2V0QXJncyhvcHRpb25zKTtcbiAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoYXJncyk7XG4gICAgY29uc3QgbWVyZ2VkSGVhZGVycyA9IGNvbWJpbmVIZWFkZXJzKFxuICAgICAgYXdhaXQgcmVzb2x2ZSh0aGlzLmNvbmZpZy5oZWFkZXJzKSxcbiAgICAgIG9wdGlvbnMuaGVhZGVyc1xuICAgICk7XG4gICAgY29uc3Qge1xuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgdmFsdWU6IHJlc3BvbnNlLFxuICAgICAgcmF3VmFsdWU6IHJhd1Jlc3BvbnNlXG4gICAgfSA9IGF3YWl0IHBvc3RKc29uVG9BcGkoe1xuICAgICAgdXJsOiBgJHt0aGlzLmNvbmZpZy5iYXNlVVJMfS8ke2dldE1vZGVsUGF0aChcbiAgICAgICAgdGhpcy5tb2RlbElkXG4gICAgICApfTpnZW5lcmF0ZUNvbnRlbnRgLFxuICAgICAgaGVhZGVyczogbWVyZ2VkSGVhZGVycyxcbiAgICAgIGJvZHk6IGFyZ3MsXG4gICAgICBmYWlsZWRSZXNwb25zZUhhbmRsZXI6IGdvb2dsZUZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgICAgIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXI6IGNyZWF0ZUpzb25SZXNwb25zZUhhbmRsZXIocmVzcG9uc2VTY2hlbWEpLFxuICAgICAgYWJvcnRTaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWwsXG4gICAgICBmZXRjaDogdGhpcy5jb25maWcuZmV0Y2hcbiAgICB9KTtcbiAgICBjb25zdCB7IGNvbnRlbnRzOiByYXdQcm9tcHQsIC4uLnJhd1NldHRpbmdzIH0gPSBhcmdzO1xuICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHJlc3BvbnNlLmNhbmRpZGF0ZXNbMF07XG4gICAgY29uc3QgcGFydHMgPSBjYW5kaWRhdGUuY29udGVudCA9PSBudWxsIHx8IHR5cGVvZiBjYW5kaWRhdGUuY29udGVudCAhPT0gXCJvYmplY3RcIiB8fCAhKFwicGFydHNcIiBpbiBjYW5kaWRhdGUuY29udGVudCkgPyBbXSA6IGNhbmRpZGF0ZS5jb250ZW50LnBhcnRzO1xuICAgIGNvbnN0IHRvb2xDYWxscyA9IGdldFRvb2xDYWxsc0Zyb21QYXJ0cyh7XG4gICAgICBwYXJ0cyxcbiAgICAgIC8vIFVzZSBjYW5kaWRhdGVQYXJ0c1xuICAgICAgZ2VuZXJhdGVJZDogdGhpcy5jb25maWcuZ2VuZXJhdGVJZFxuICAgIH0pO1xuICAgIGNvbnN0IHVzYWdlTWV0YWRhdGEgPSByZXNwb25zZS51c2FnZU1ldGFkYXRhO1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0OiBnZXRUZXh0RnJvbVBhcnRzKHBhcnRzKSxcbiAgICAgIHJlYXNvbmluZzogZ2V0UmVhc29uaW5nRGV0YWlsc0Zyb21QYXJ0cyhwYXJ0cyksXG4gICAgICBmaWxlczogKF9hID0gZ2V0SW5saW5lRGF0YVBhcnRzKHBhcnRzKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm1hcCgocGFydCkgPT4gKHtcbiAgICAgICAgZGF0YTogcGFydC5pbmxpbmVEYXRhLmRhdGEsXG4gICAgICAgIG1pbWVUeXBlOiBwYXJ0LmlubGluZURhdGEubWltZVR5cGVcbiAgICAgIH0pKSxcbiAgICAgIHRvb2xDYWxscyxcbiAgICAgIGZpbmlzaFJlYXNvbjogbWFwR29vZ2xlR2VuZXJhdGl2ZUFJRmluaXNoUmVhc29uKHtcbiAgICAgICAgZmluaXNoUmVhc29uOiBjYW5kaWRhdGUuZmluaXNoUmVhc29uLFxuICAgICAgICBoYXNUb29sQ2FsbHM6IHRvb2xDYWxscyAhPSBudWxsICYmIHRvb2xDYWxscy5sZW5ndGggPiAwXG4gICAgICB9KSxcbiAgICAgIHVzYWdlOiB7XG4gICAgICAgIHByb21wdFRva2VuczogKF9iID0gdXNhZ2VNZXRhZGF0YSA9PSBudWxsID8gdm9pZCAwIDogdXNhZ2VNZXRhZGF0YS5wcm9tcHRUb2tlbkNvdW50KSAhPSBudWxsID8gX2IgOiBOYU4sXG4gICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IChfYyA9IHVzYWdlTWV0YWRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IHVzYWdlTWV0YWRhdGEuY2FuZGlkYXRlc1Rva2VuQ291bnQpICE9IG51bGwgPyBfYyA6IE5hTlxuICAgICAgfSxcbiAgICAgIHJhd0NhbGw6IHsgcmF3UHJvbXB0LCByYXdTZXR0aW5ncyB9LFxuICAgICAgcmF3UmVzcG9uc2U6IHsgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLCBib2R5OiByYXdSZXNwb25zZSB9LFxuICAgICAgd2FybmluZ3MsXG4gICAgICBwcm92aWRlck1ldGFkYXRhOiB7XG4gICAgICAgIGdvb2dsZToge1xuICAgICAgICAgIGdyb3VuZGluZ01ldGFkYXRhOiAoX2QgPSBjYW5kaWRhdGUuZ3JvdW5kaW5nTWV0YWRhdGEpICE9IG51bGwgPyBfZCA6IG51bGwsXG4gICAgICAgICAgc2FmZXR5UmF0aW5nczogKF9lID0gY2FuZGlkYXRlLnNhZmV0eVJhdGluZ3MpICE9IG51bGwgPyBfZSA6IG51bGxcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNvdXJjZXM6IGV4dHJhY3RTb3VyY2VzKHtcbiAgICAgICAgZ3JvdW5kaW5nTWV0YWRhdGE6IGNhbmRpZGF0ZS5ncm91bmRpbmdNZXRhZGF0YSxcbiAgICAgICAgZ2VuZXJhdGVJZDogdGhpcy5jb25maWcuZ2VuZXJhdGVJZFxuICAgICAgfSksXG4gICAgICByZXF1ZXN0OiB7IGJvZHkgfVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZG9TdHJlYW0ob3B0aW9ucykge1xuICAgIGNvbnN0IHsgYXJncywgd2FybmluZ3MgfSA9IGF3YWl0IHRoaXMuZ2V0QXJncyhvcHRpb25zKTtcbiAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoYXJncyk7XG4gICAgY29uc3QgaGVhZGVycyA9IGNvbWJpbmVIZWFkZXJzKFxuICAgICAgYXdhaXQgcmVzb2x2ZSh0aGlzLmNvbmZpZy5oZWFkZXJzKSxcbiAgICAgIG9wdGlvbnMuaGVhZGVyc1xuICAgICk7XG4gICAgY29uc3QgeyByZXNwb25zZUhlYWRlcnMsIHZhbHVlOiByZXNwb25zZSB9ID0gYXdhaXQgcG9zdEpzb25Ub0FwaSh7XG4gICAgICB1cmw6IGAke3RoaXMuY29uZmlnLmJhc2VVUkx9LyR7Z2V0TW9kZWxQYXRoKFxuICAgICAgICB0aGlzLm1vZGVsSWRcbiAgICAgICl9OnN0cmVhbUdlbmVyYXRlQ29udGVudD9hbHQ9c3NlYCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5OiBhcmdzLFxuICAgICAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyOiBnb29nbGVGYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gICAgICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyOiBjcmVhdGVFdmVudFNvdXJjZVJlc3BvbnNlSGFuZGxlcihjaHVua1NjaGVtYSksXG4gICAgICBhYm9ydFNpZ25hbDogb3B0aW9ucy5hYm9ydFNpZ25hbCxcbiAgICAgIGZldGNoOiB0aGlzLmNvbmZpZy5mZXRjaFxuICAgIH0pO1xuICAgIGNvbnN0IHsgY29udGVudHM6IHJhd1Byb21wdCwgLi4ucmF3U2V0dGluZ3MgfSA9IGFyZ3M7XG4gICAgbGV0IGZpbmlzaFJlYXNvbiA9IFwidW5rbm93blwiO1xuICAgIGxldCB1c2FnZSA9IHtcbiAgICAgIHByb21wdFRva2VuczogTnVtYmVyLk5hTixcbiAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IE51bWJlci5OYU5cbiAgICB9O1xuICAgIGxldCBwcm92aWRlck1ldGFkYXRhID0gdm9pZCAwO1xuICAgIGNvbnN0IGdlbmVyYXRlSWQyID0gdGhpcy5jb25maWcuZ2VuZXJhdGVJZDtcbiAgICBsZXQgaGFzVG9vbENhbGxzID0gZmFsc2U7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cmVhbTogcmVzcG9uc2UucGlwZVRocm91Z2goXG4gICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgICAgICBpZiAoIWNodW5rLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJlcnJvclwiLCBlcnJvcjogY2h1bmsuZXJyb3IgfSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY2h1bmsudmFsdWU7XG4gICAgICAgICAgICBjb25zdCB1c2FnZU1ldGFkYXRhID0gdmFsdWUudXNhZ2VNZXRhZGF0YTtcbiAgICAgICAgICAgIGlmICh1c2FnZU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgdXNhZ2UgPSB7XG4gICAgICAgICAgICAgICAgcHJvbXB0VG9rZW5zOiAoX2EgPSB1c2FnZU1ldGFkYXRhLnByb21wdFRva2VuQ291bnQpICE9IG51bGwgPyBfYSA6IE5hTixcbiAgICAgICAgICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiAoX2IgPSB1c2FnZU1ldGFkYXRhLmNhbmRpZGF0ZXNUb2tlbkNvdW50KSAhPSBudWxsID8gX2IgOiBOYU5cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IChfYyA9IHZhbHVlLmNhbmRpZGF0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBfY1swXTtcbiAgICAgICAgICAgIGlmIChjYW5kaWRhdGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gY2FuZGlkYXRlLmNvbnRlbnQ7XG4gICAgICAgICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRlbHRhVGV4dCA9IGdldFRleHRGcm9tUGFydHMoY29udGVudC5wYXJ0cyk7XG4gICAgICAgICAgICAgIGlmIChkZWx0YVRleHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHQtZGVsdGFcIixcbiAgICAgICAgICAgICAgICAgIHRleHREZWx0YTogZGVsdGFUZXh0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgcmVhc29uaW5nRGVsdGFUZXh0ID0gZ2V0UmVhc29uaW5nRGV0YWlsc0Zyb21QYXJ0cyhcbiAgICAgICAgICAgICAgICBjb250ZW50LnBhcnRzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmIChyZWFzb25pbmdEZWx0YVRleHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFydCBvZiByZWFzb25pbmdEZWx0YVRleHQpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgIHRleHREZWx0YTogcGFydC50ZXh0XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgaW5saW5lRGF0YVBhcnRzID0gZ2V0SW5saW5lRGF0YVBhcnRzKGNvbnRlbnQucGFydHMpO1xuICAgICAgICAgICAgICBpZiAoaW5saW5lRGF0YVBhcnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgaW5saW5lRGF0YVBhcnRzKSB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IHBhcnQuaW5saW5lRGF0YS5taW1lVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogcGFydC5pbmxpbmVEYXRhLmRhdGFcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCB0b29sQ2FsbERlbHRhcyA9IGdldFRvb2xDYWxsc0Zyb21QYXJ0cyh7XG4gICAgICAgICAgICAgICAgcGFydHM6IGNvbnRlbnQucGFydHMsXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmICh0b29sQ2FsbERlbHRhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0b29sQ2FsbCBvZiB0b29sQ2FsbERlbHRhcykge1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGwtZGVsdGFcIixcbiAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxUeXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYXJnc1RleHREZWx0YTogdG9vbENhbGwuYXJnc1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtY2FsbFwiLFxuICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbFR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiB0b29sQ2FsbC5hcmdzXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGhhc1Rvb2xDYWxscyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FuZGlkYXRlLmZpbmlzaFJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGZpbmlzaFJlYXNvbiA9IG1hcEdvb2dsZUdlbmVyYXRpdmVBSUZpbmlzaFJlYXNvbih7XG4gICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBjYW5kaWRhdGUuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgIGhhc1Rvb2xDYWxsc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3Qgc291cmNlcyA9IChfZCA9IGV4dHJhY3RTb3VyY2VzKHtcbiAgICAgICAgICAgICAgICBncm91bmRpbmdNZXRhZGF0YTogY2FuZGlkYXRlLmdyb3VuZGluZ01ldGFkYXRhLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQyXG4gICAgICAgICAgICAgIH0pKSAhPSBudWxsID8gX2QgOiBbXTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBzb3VyY2Ugb2Ygc291cmNlcykge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwic291cmNlXCIsIHNvdXJjZSB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhID0ge1xuICAgICAgICAgICAgICAgIGdvb2dsZToge1xuICAgICAgICAgICAgICAgICAgZ3JvdW5kaW5nTWV0YWRhdGE6IChfZSA9IGNhbmRpZGF0ZS5ncm91bmRpbmdNZXRhZGF0YSkgIT0gbnVsbCA/IF9lIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHNhZmV0eVJhdGluZ3M6IChfZiA9IGNhbmRpZGF0ZS5zYWZldHlSYXRpbmdzKSAhPSBudWxsID8gX2YgOiBudWxsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJmaW5pc2hcIixcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICB1c2FnZSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIHJhd0NhbGw6IHsgcmF3UHJvbXB0LCByYXdTZXR0aW5ncyB9LFxuICAgICAgcmF3UmVzcG9uc2U6IHsgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzIH0sXG4gICAgICB3YXJuaW5ncyxcbiAgICAgIHJlcXVlc3Q6IHsgYm9keSB9XG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldFRvb2xDYWxsc0Zyb21QYXJ0cyh7XG4gIHBhcnRzLFxuICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMlxufSkge1xuICBjb25zdCBmdW5jdGlvbkNhbGxQYXJ0cyA9IHBhcnRzID09IG51bGwgPyB2b2lkIDAgOiBwYXJ0cy5maWx0ZXIoXG4gICAgKHBhcnQpID0+IFwiZnVuY3Rpb25DYWxsXCIgaW4gcGFydFxuICApO1xuICByZXR1cm4gZnVuY3Rpb25DYWxsUGFydHMgPT0gbnVsbCB8fCBmdW5jdGlvbkNhbGxQYXJ0cy5sZW5ndGggPT09IDAgPyB2b2lkIDAgOiBmdW5jdGlvbkNhbGxQYXJ0cy5tYXAoKHBhcnQpID0+ICh7XG4gICAgdG9vbENhbGxUeXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgdG9vbENhbGxJZDogZ2VuZXJhdGVJZDIoKSxcbiAgICB0b29sTmFtZTogcGFydC5mdW5jdGlvbkNhbGwubmFtZSxcbiAgICBhcmdzOiBKU09OLnN0cmluZ2lmeShwYXJ0LmZ1bmN0aW9uQ2FsbC5hcmdzKVxuICB9KSk7XG59XG5mdW5jdGlvbiBnZXRUZXh0RnJvbVBhcnRzKHBhcnRzKSB7XG4gIGNvbnN0IHRleHRQYXJ0cyA9IHBhcnRzID09IG51bGwgPyB2b2lkIDAgOiBwYXJ0cy5maWx0ZXIoXG4gICAgKHBhcnQpID0+IFwidGV4dFwiIGluIHBhcnQgJiYgcGFydC50aG91Z2h0ICE9PSB0cnVlXG4gICk7XG4gIHJldHVybiB0ZXh0UGFydHMgPT0gbnVsbCB8fCB0ZXh0UGFydHMubGVuZ3RoID09PSAwID8gdm9pZCAwIDogdGV4dFBhcnRzLm1hcCgocGFydCkgPT4gcGFydC50ZXh0KS5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gZ2V0UmVhc29uaW5nRGV0YWlsc0Zyb21QYXJ0cyhwYXJ0cykge1xuICBjb25zdCByZWFzb25pbmdQYXJ0cyA9IHBhcnRzID09IG51bGwgPyB2b2lkIDAgOiBwYXJ0cy5maWx0ZXIoXG4gICAgKHBhcnQpID0+IFwidGV4dFwiIGluIHBhcnQgJiYgcGFydC50aG91Z2h0ID09PSB0cnVlICYmIHBhcnQudGV4dCAhPSBudWxsXG4gICk7XG4gIHJldHVybiByZWFzb25pbmdQYXJ0cyA9PSBudWxsIHx8IHJlYXNvbmluZ1BhcnRzLmxlbmd0aCA9PT0gMCA/IHZvaWQgMCA6IHJlYXNvbmluZ1BhcnRzLm1hcCgocGFydCkgPT4gKHsgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IHBhcnQudGV4dCB9KSk7XG59XG5mdW5jdGlvbiBnZXRJbmxpbmVEYXRhUGFydHMocGFydHMpIHtcbiAgcmV0dXJuIHBhcnRzID09IG51bGwgPyB2b2lkIDAgOiBwYXJ0cy5maWx0ZXIoXG4gICAgKHBhcnQpID0+IFwiaW5saW5lRGF0YVwiIGluIHBhcnRcbiAgKTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RTb3VyY2VzKHtcbiAgZ3JvdW5kaW5nTWV0YWRhdGEsXG4gIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQyXG59KSB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIChfYSA9IGdyb3VuZGluZ01ldGFkYXRhID09IG51bGwgPyB2b2lkIDAgOiBncm91bmRpbmdNZXRhZGF0YS5ncm91bmRpbmdDaHVua3MpID09IG51bGwgPyB2b2lkIDAgOiBfYS5maWx0ZXIoXG4gICAgKGNodW5rKSA9PiBjaHVuay53ZWIgIT0gbnVsbFxuICApLm1hcCgoY2h1bmspID0+ICh7XG4gICAgc291cmNlVHlwZTogXCJ1cmxcIixcbiAgICBpZDogZ2VuZXJhdGVJZDIoKSxcbiAgICB1cmw6IGNodW5rLndlYi51cmksXG4gICAgdGl0bGU6IGNodW5rLndlYi50aXRsZVxuICB9KSk7XG59XG52YXIgY29udGVudFNjaGVtYSA9IHoyLm9iamVjdCh7XG4gIHBhcnRzOiB6Mi5hcnJheShcbiAgICB6Mi51bmlvbihbXG4gICAgICAvLyBub3RlOiBvcmRlciBtYXR0ZXJzIHNpbmNlIHRleHQgY2FuIGJlIGZ1bGx5IGVtcHR5XG4gICAgICB6Mi5vYmplY3Qoe1xuICAgICAgICBmdW5jdGlvbkNhbGw6IHoyLm9iamVjdCh7XG4gICAgICAgICAgbmFtZTogejIuc3RyaW5nKCksXG4gICAgICAgICAgYXJnczogejIudW5rbm93bigpXG4gICAgICAgIH0pXG4gICAgICB9KSxcbiAgICAgIHoyLm9iamVjdCh7XG4gICAgICAgIGlubGluZURhdGE6IHoyLm9iamVjdCh7XG4gICAgICAgICAgbWltZVR5cGU6IHoyLnN0cmluZygpLFxuICAgICAgICAgIGRhdGE6IHoyLnN0cmluZygpXG4gICAgICAgIH0pXG4gICAgICB9KSxcbiAgICAgIHoyLm9iamVjdCh7XG4gICAgICAgIHRleHQ6IHoyLnN0cmluZygpLm51bGxpc2goKSxcbiAgICAgICAgdGhvdWdodDogejIuYm9vbGVhbigpLm51bGxpc2goKVxuICAgICAgfSlcbiAgICBdKVxuICApLm51bGxpc2goKVxufSk7XG52YXIgZ3JvdW5kaW5nQ2h1bmtTY2hlbWEgPSB6Mi5vYmplY3Qoe1xuICB3ZWI6IHoyLm9iamVjdCh7IHVyaTogejIuc3RyaW5nKCksIHRpdGxlOiB6Mi5zdHJpbmcoKSB9KS5udWxsaXNoKCksXG4gIHJldHJpZXZlZENvbnRleHQ6IHoyLm9iamVjdCh7IHVyaTogejIuc3RyaW5nKCksIHRpdGxlOiB6Mi5zdHJpbmcoKSB9KS5udWxsaXNoKClcbn0pO1xudmFyIGdyb3VuZGluZ01ldGFkYXRhU2NoZW1hID0gejIub2JqZWN0KHtcbiAgd2ViU2VhcmNoUXVlcmllczogejIuYXJyYXkoejIuc3RyaW5nKCkpLm51bGxpc2goKSxcbiAgcmV0cmlldmFsUXVlcmllczogejIuYXJyYXkoejIuc3RyaW5nKCkpLm51bGxpc2goKSxcbiAgc2VhcmNoRW50cnlQb2ludDogejIub2JqZWN0KHsgcmVuZGVyZWRDb250ZW50OiB6Mi5zdHJpbmcoKSB9KS5udWxsaXNoKCksXG4gIGdyb3VuZGluZ0NodW5rczogejIuYXJyYXkoZ3JvdW5kaW5nQ2h1bmtTY2hlbWEpLm51bGxpc2goKSxcbiAgZ3JvdW5kaW5nU3VwcG9ydHM6IHoyLmFycmF5KFxuICAgIHoyLm9iamVjdCh7XG4gICAgICBzZWdtZW50OiB6Mi5vYmplY3Qoe1xuICAgICAgICBzdGFydEluZGV4OiB6Mi5udW1iZXIoKS5udWxsaXNoKCksXG4gICAgICAgIGVuZEluZGV4OiB6Mi5udW1iZXIoKS5udWxsaXNoKCksXG4gICAgICAgIHRleHQ6IHoyLnN0cmluZygpLm51bGxpc2goKVxuICAgICAgfSksXG4gICAgICBzZWdtZW50X3RleHQ6IHoyLnN0cmluZygpLm51bGxpc2goKSxcbiAgICAgIGdyb3VuZGluZ0NodW5rSW5kaWNlczogejIuYXJyYXkoejIubnVtYmVyKCkpLm51bGxpc2goKSxcbiAgICAgIHN1cHBvcnRDaHVua0luZGljZXM6IHoyLmFycmF5KHoyLm51bWJlcigpKS5udWxsaXNoKCksXG4gICAgICBjb25maWRlbmNlU2NvcmVzOiB6Mi5hcnJheSh6Mi5udW1iZXIoKSkubnVsbGlzaCgpLFxuICAgICAgY29uZmlkZW5jZVNjb3JlOiB6Mi5hcnJheSh6Mi5udW1iZXIoKSkubnVsbGlzaCgpXG4gICAgfSlcbiAgKS5udWxsaXNoKCksXG4gIHJldHJpZXZhbE1ldGFkYXRhOiB6Mi51bmlvbihbXG4gICAgejIub2JqZWN0KHtcbiAgICAgIHdlYkR5bmFtaWNSZXRyaWV2YWxTY29yZTogejIubnVtYmVyKClcbiAgICB9KSxcbiAgICB6Mi5vYmplY3Qoe30pXG4gIF0pLm51bGxpc2goKVxufSk7XG52YXIgc2FmZXR5UmF0aW5nU2NoZW1hID0gejIub2JqZWN0KHtcbiAgY2F0ZWdvcnk6IHoyLnN0cmluZygpLm51bGxpc2goKSxcbiAgcHJvYmFiaWxpdHk6IHoyLnN0cmluZygpLm51bGxpc2goKSxcbiAgcHJvYmFiaWxpdHlTY29yZTogejIubnVtYmVyKCkubnVsbGlzaCgpLFxuICBzZXZlcml0eTogejIuc3RyaW5nKCkubnVsbGlzaCgpLFxuICBzZXZlcml0eVNjb3JlOiB6Mi5udW1iZXIoKS5udWxsaXNoKCksXG4gIGJsb2NrZWQ6IHoyLmJvb2xlYW4oKS5udWxsaXNoKClcbn0pO1xudmFyIHJlc3BvbnNlU2NoZW1hID0gejIub2JqZWN0KHtcbiAgY2FuZGlkYXRlczogejIuYXJyYXkoXG4gICAgejIub2JqZWN0KHtcbiAgICAgIGNvbnRlbnQ6IGNvbnRlbnRTY2hlbWEubnVsbGlzaCgpLm9yKHoyLm9iamVjdCh7fSkuc3RyaWN0KCkpLFxuICAgICAgZmluaXNoUmVhc29uOiB6Mi5zdHJpbmcoKS5udWxsaXNoKCksXG4gICAgICBzYWZldHlSYXRpbmdzOiB6Mi5hcnJheShzYWZldHlSYXRpbmdTY2hlbWEpLm51bGxpc2goKSxcbiAgICAgIGdyb3VuZGluZ01ldGFkYXRhOiBncm91bmRpbmdNZXRhZGF0YVNjaGVtYS5udWxsaXNoKClcbiAgICB9KVxuICApLFxuICB1c2FnZU1ldGFkYXRhOiB6Mi5vYmplY3Qoe1xuICAgIHByb21wdFRva2VuQ291bnQ6IHoyLm51bWJlcigpLm51bGxpc2goKSxcbiAgICBjYW5kaWRhdGVzVG9rZW5Db3VudDogejIubnVtYmVyKCkubnVsbGlzaCgpLFxuICAgIHRvdGFsVG9rZW5Db3VudDogejIubnVtYmVyKCkubnVsbGlzaCgpXG4gIH0pLm51bGxpc2goKVxufSk7XG52YXIgY2h1bmtTY2hlbWEgPSB6Mi5vYmplY3Qoe1xuICBjYW5kaWRhdGVzOiB6Mi5hcnJheShcbiAgICB6Mi5vYmplY3Qoe1xuICAgICAgY29udGVudDogY29udGVudFNjaGVtYS5udWxsaXNoKCksXG4gICAgICBmaW5pc2hSZWFzb246IHoyLnN0cmluZygpLm51bGxpc2goKSxcbiAgICAgIHNhZmV0eVJhdGluZ3M6IHoyLmFycmF5KHNhZmV0eVJhdGluZ1NjaGVtYSkubnVsbGlzaCgpLFxuICAgICAgZ3JvdW5kaW5nTWV0YWRhdGE6IGdyb3VuZGluZ01ldGFkYXRhU2NoZW1hLm51bGxpc2goKVxuICAgIH0pXG4gICkubnVsbGlzaCgpLFxuICB1c2FnZU1ldGFkYXRhOiB6Mi5vYmplY3Qoe1xuICAgIHByb21wdFRva2VuQ291bnQ6IHoyLm51bWJlcigpLm51bGxpc2goKSxcbiAgICBjYW5kaWRhdGVzVG9rZW5Db3VudDogejIubnVtYmVyKCkubnVsbGlzaCgpLFxuICAgIHRvdGFsVG9rZW5Db3VudDogejIubnVtYmVyKCkubnVsbGlzaCgpXG4gIH0pLm51bGxpc2goKVxufSk7XG52YXIgZ29vZ2xlR2VuZXJhdGl2ZUFJUHJvdmlkZXJPcHRpb25zU2NoZW1hID0gejIub2JqZWN0KHtcbiAgcmVzcG9uc2VNb2RhbGl0aWVzOiB6Mi5hcnJheSh6Mi5lbnVtKFtcIlRFWFRcIiwgXCJJTUFHRVwiXSkpLm51bGxpc2goKSxcbiAgdGhpbmtpbmdDb25maWc6IHoyLm9iamVjdCh7XG4gICAgdGhpbmtpbmdCdWRnZXQ6IHoyLm51bWJlcigpLm51bGxpc2goKSxcbiAgICBpbmNsdWRlVGhvdWdodHM6IHoyLmJvb2xlYW4oKS5udWxsaXNoKClcbiAgfSkubnVsbGlzaCgpXG59KTtcblxuLy8gc3JjL2dvb2dsZS1nZW5lcmF0aXZlLWFpLWVtYmVkZGluZy1tb2RlbC50c1xuaW1wb3J0IHtcbiAgVG9vTWFueUVtYmVkZGluZ1ZhbHVlc0ZvckNhbGxFcnJvclxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHtcbiAgY29tYmluZUhlYWRlcnMgYXMgY29tYmluZUhlYWRlcnMyLFxuICBjcmVhdGVKc29uUmVzcG9uc2VIYW5kbGVyIGFzIGNyZWF0ZUpzb25SZXNwb25zZUhhbmRsZXIyLFxuICBwb3N0SnNvblRvQXBpIGFzIHBvc3RKc29uVG9BcGkyLFxuICByZXNvbHZlIGFzIHJlc29sdmUyXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgeyB6IGFzIHozIH0gZnJvbSBcInpvZFwiO1xudmFyIEdvb2dsZUdlbmVyYXRpdmVBSUVtYmVkZGluZ01vZGVsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihtb2RlbElkLCBzZXR0aW5ncywgY29uZmlnKSB7XG4gICAgdGhpcy5zcGVjaWZpY2F0aW9uVmVyc2lvbiA9IFwidjFcIjtcbiAgICB0aGlzLm1vZGVsSWQgPSBtb2RlbElkO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxuICBnZXQgcHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnByb3ZpZGVyO1xuICB9XG4gIGdldCBtYXhFbWJlZGRpbmdzUGVyQ2FsbCgpIHtcbiAgICByZXR1cm4gMjA0ODtcbiAgfVxuICBnZXQgc3VwcG9ydHNQYXJhbGxlbENhbGxzKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGFzeW5jIGRvRW1iZWQoe1xuICAgIHZhbHVlcyxcbiAgICBoZWFkZXJzLFxuICAgIGFib3J0U2lnbmFsXG4gIH0pIHtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCA+IHRoaXMubWF4RW1iZWRkaW5nc1BlckNhbGwpIHtcbiAgICAgIHRocm93IG5ldyBUb29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yKHtcbiAgICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXIsXG4gICAgICAgIG1vZGVsSWQ6IHRoaXMubW9kZWxJZCxcbiAgICAgICAgbWF4RW1iZWRkaW5nc1BlckNhbGw6IHRoaXMubWF4RW1iZWRkaW5nc1BlckNhbGwsXG4gICAgICAgIHZhbHVlc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1lcmdlZEhlYWRlcnMgPSBjb21iaW5lSGVhZGVyczIoXG4gICAgICBhd2FpdCByZXNvbHZlMih0aGlzLmNvbmZpZy5oZWFkZXJzKSxcbiAgICAgIGhlYWRlcnNcbiAgICApO1xuICAgIGNvbnN0IHsgcmVzcG9uc2VIZWFkZXJzLCB2YWx1ZTogcmVzcG9uc2UgfSA9IGF3YWl0IHBvc3RKc29uVG9BcGkyKHtcbiAgICAgIHVybDogYCR7dGhpcy5jb25maWcuYmFzZVVSTH0vbW9kZWxzLyR7dGhpcy5tb2RlbElkfTpiYXRjaEVtYmVkQ29udGVudHNgLFxuICAgICAgaGVhZGVyczogbWVyZ2VkSGVhZGVycyxcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgcmVxdWVzdHM6IHZhbHVlcy5tYXAoKHZhbHVlKSA9PiAoe1xuICAgICAgICAgIG1vZGVsOiBgbW9kZWxzLyR7dGhpcy5tb2RlbElkfWAsXG4gICAgICAgICAgY29udGVudDogeyByb2xlOiBcInVzZXJcIiwgcGFydHM6IFt7IHRleHQ6IHZhbHVlIH1dIH0sXG4gICAgICAgICAgb3V0cHV0RGltZW5zaW9uYWxpdHk6IHRoaXMuc2V0dGluZ3Mub3V0cHV0RGltZW5zaW9uYWxpdHksXG4gICAgICAgICAgdGFza1R5cGU6IHRoaXMuc2V0dGluZ3MudGFza1R5cGVcbiAgICAgICAgfSkpXG4gICAgICB9LFxuICAgICAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyOiBnb29nbGVGYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gICAgICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyOiBjcmVhdGVKc29uUmVzcG9uc2VIYW5kbGVyMihcbiAgICAgICAgZ29vZ2xlR2VuZXJhdGl2ZUFJVGV4dEVtYmVkZGluZ1Jlc3BvbnNlU2NoZW1hXG4gICAgICApLFxuICAgICAgYWJvcnRTaWduYWwsXG4gICAgICBmZXRjaDogdGhpcy5jb25maWcuZmV0Y2hcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZW1iZWRkaW5nczogcmVzcG9uc2UuZW1iZWRkaW5ncy5tYXAoKGl0ZW0pID0+IGl0ZW0udmFsdWVzKSxcbiAgICAgIHVzYWdlOiB2b2lkIDAsXG4gICAgICByYXdSZXNwb25zZTogeyBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMgfVxuICAgIH07XG4gIH1cbn07XG52YXIgZ29vZ2xlR2VuZXJhdGl2ZUFJVGV4dEVtYmVkZGluZ1Jlc3BvbnNlU2NoZW1hID0gejMub2JqZWN0KHtcbiAgZW1iZWRkaW5nczogejMuYXJyYXkoejMub2JqZWN0KHsgdmFsdWVzOiB6My5hcnJheSh6My5udW1iZXIoKSkgfSkpXG59KTtcblxuLy8gc3JjL2dvb2dsZS1zdXBwb3J0ZWQtZmlsZS11cmwudHNcbmZ1bmN0aW9uIGlzU3VwcG9ydGVkRmlsZVVybCh1cmwpIHtcbiAgcmV0dXJuIHVybC50b1N0cmluZygpLnN0YXJ0c1dpdGgoXCJodHRwczovL2dlbmVyYXRpdmVsYW5ndWFnZS5nb29nbGVhcGlzLmNvbS92MWJldGEvZmlsZXMvXCIpO1xufVxuXG4vLyBzcmMvZ29vZ2xlLXByb3ZpZGVyLnRzXG5mdW5jdGlvbiBjcmVhdGVHb29nbGVHZW5lcmF0aXZlQUkob3B0aW9ucyA9IHt9KSB7XG4gIHZhciBfYTtcbiAgY29uc3QgYmFzZVVSTCA9IChfYSA9IHdpdGhvdXRUcmFpbGluZ1NsYXNoKG9wdGlvbnMuYmFzZVVSTCkpICE9IG51bGwgPyBfYSA6IFwiaHR0cHM6Ly9nZW5lcmF0aXZlbGFuZ3VhZ2UuZ29vZ2xlYXBpcy5jb20vdjFiZXRhXCI7XG4gIGNvbnN0IGdldEhlYWRlcnMgPSAoKSA9PiAoe1xuICAgIFwieC1nb29nLWFwaS1rZXlcIjogbG9hZEFwaUtleSh7XG4gICAgICBhcGlLZXk6IG9wdGlvbnMuYXBpS2V5LFxuICAgICAgZW52aXJvbm1lbnRWYXJpYWJsZU5hbWU6IFwiR09PR0xFX0dFTkVSQVRJVkVfQUlfQVBJX0tFWVwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiR29vZ2xlIEdlbmVyYXRpdmUgQUlcIlxuICAgIH0pLFxuICAgIC4uLm9wdGlvbnMuaGVhZGVyc1xuICB9KTtcbiAgY29uc3QgY3JlYXRlQ2hhdE1vZGVsID0gKG1vZGVsSWQsIHNldHRpbmdzID0ge30pID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIHJldHVybiBuZXcgR29vZ2xlR2VuZXJhdGl2ZUFJTGFuZ3VhZ2VNb2RlbChtb2RlbElkLCBzZXR0aW5ncywge1xuICAgICAgcHJvdmlkZXI6IFwiZ29vZ2xlLmdlbmVyYXRpdmUtYWlcIixcbiAgICAgIGJhc2VVUkwsXG4gICAgICBoZWFkZXJzOiBnZXRIZWFkZXJzLFxuICAgICAgZ2VuZXJhdGVJZDogKF9hMiA9IG9wdGlvbnMuZ2VuZXJhdGVJZCkgIT0gbnVsbCA/IF9hMiA6IGdlbmVyYXRlSWQsXG4gICAgICBpc1N1cHBvcnRlZFVybDogaXNTdXBwb3J0ZWRGaWxlVXJsLFxuICAgICAgZmV0Y2g6IG9wdGlvbnMuZmV0Y2hcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgY3JlYXRlRW1iZWRkaW5nTW9kZWwgPSAobW9kZWxJZCwgc2V0dGluZ3MgPSB7fSkgPT4gbmV3IEdvb2dsZUdlbmVyYXRpdmVBSUVtYmVkZGluZ01vZGVsKG1vZGVsSWQsIHNldHRpbmdzLCB7XG4gICAgcHJvdmlkZXI6IFwiZ29vZ2xlLmdlbmVyYXRpdmUtYWlcIixcbiAgICBiYXNlVVJMLFxuICAgIGhlYWRlcnM6IGdldEhlYWRlcnMsXG4gICAgZmV0Y2g6IG9wdGlvbnMuZmV0Y2hcbiAgfSk7XG4gIGNvbnN0IHByb3ZpZGVyID0gZnVuY3Rpb24obW9kZWxJZCwgc2V0dGluZ3MpIHtcbiAgICBpZiAobmV3LnRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlRoZSBHb29nbGUgR2VuZXJhdGl2ZSBBSSBtb2RlbCBmdW5jdGlvbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBrZXl3b3JkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhdE1vZGVsKG1vZGVsSWQsIHNldHRpbmdzKTtcbiAgfTtcbiAgcHJvdmlkZXIubGFuZ3VhZ2VNb2RlbCA9IGNyZWF0ZUNoYXRNb2RlbDtcbiAgcHJvdmlkZXIuY2hhdCA9IGNyZWF0ZUNoYXRNb2RlbDtcbiAgcHJvdmlkZXIuZ2VuZXJhdGl2ZUFJID0gY3JlYXRlQ2hhdE1vZGVsO1xuICBwcm92aWRlci5lbWJlZGRpbmcgPSBjcmVhdGVFbWJlZGRpbmdNb2RlbDtcbiAgcHJvdmlkZXIudGV4dEVtYmVkZGluZyA9IGNyZWF0ZUVtYmVkZGluZ01vZGVsO1xuICBwcm92aWRlci50ZXh0RW1iZWRkaW5nTW9kZWwgPSBjcmVhdGVFbWJlZGRpbmdNb2RlbDtcbiAgcmV0dXJuIHByb3ZpZGVyO1xufVxudmFyIGdvb2dsZSA9IGNyZWF0ZUdvb2dsZUdlbmVyYXRpdmVBSSgpO1xuZXhwb3J0IHtcbiAgY3JlYXRlR29vZ2xlR2VuZXJhdGl2ZUFJLFxuICBnb29nbGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ai-sdk/google/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@ai-sdk/provider-utils/dist/index.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   asValidator: () => (/* binding */ asValidator),\n/* harmony export */   combineHeaders: () => (/* binding */ combineHeaders),\n/* harmony export */   convertAsyncIteratorToReadableStream: () => (/* binding */ convertAsyncIteratorToReadableStream),\n/* harmony export */   convertBase64ToUint8Array: () => (/* binding */ convertBase64ToUint8Array),\n/* harmony export */   convertUint8ArrayToBase64: () => (/* binding */ convertUint8ArrayToBase64),\n/* harmony export */   createBinaryResponseHandler: () => (/* binding */ createBinaryResponseHandler),\n/* harmony export */   createEventSourceParserStream: () => (/* binding */ createEventSourceParserStream),\n/* harmony export */   createEventSourceResponseHandler: () => (/* binding */ createEventSourceResponseHandler),\n/* harmony export */   createIdGenerator: () => (/* binding */ createIdGenerator),\n/* harmony export */   createJsonErrorResponseHandler: () => (/* binding */ createJsonErrorResponseHandler),\n/* harmony export */   createJsonResponseHandler: () => (/* binding */ createJsonResponseHandler),\n/* harmony export */   createJsonStreamResponseHandler: () => (/* binding */ createJsonStreamResponseHandler),\n/* harmony export */   createStatusCodeErrorResponseHandler: () => (/* binding */ createStatusCodeErrorResponseHandler),\n/* harmony export */   delay: () => (/* binding */ delay),\n/* harmony export */   extractResponseHeaders: () => (/* binding */ extractResponseHeaders),\n/* harmony export */   generateId: () => (/* binding */ generateId),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   getFromApi: () => (/* binding */ getFromApi),\n/* harmony export */   isAbortError: () => (/* binding */ isAbortError),\n/* harmony export */   isParsableJson: () => (/* binding */ isParsableJson),\n/* harmony export */   isValidator: () => (/* binding */ isValidator),\n/* harmony export */   loadApiKey: () => (/* binding */ loadApiKey),\n/* harmony export */   loadOptionalSetting: () => (/* binding */ loadOptionalSetting),\n/* harmony export */   loadSetting: () => (/* binding */ loadSetting),\n/* harmony export */   parseJSON: () => (/* binding */ parseJSON),\n/* harmony export */   parseProviderOptions: () => (/* binding */ parseProviderOptions),\n/* harmony export */   postFormDataToApi: () => (/* binding */ postFormDataToApi),\n/* harmony export */   postJsonToApi: () => (/* binding */ postJsonToApi),\n/* harmony export */   postToApi: () => (/* binding */ postToApi),\n/* harmony export */   removeUndefinedEntries: () => (/* binding */ removeUndefinedEntries),\n/* harmony export */   resolve: () => (/* binding */ resolve),\n/* harmony export */   safeParseJSON: () => (/* binding */ safeParseJSON),\n/* harmony export */   safeValidateTypes: () => (/* binding */ safeValidateTypes),\n/* harmony export */   validateTypes: () => (/* binding */ validateTypes),\n/* harmony export */   validator: () => (/* binding */ validator),\n/* harmony export */   validatorSymbol: () => (/* binding */ validatorSymbol),\n/* harmony export */   withoutTrailingSlash: () => (/* binding */ withoutTrailingSlash),\n/* harmony export */   zodValidator: () => (/* binding */ zodValidator)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nanoid/non-secure */ \"(rsc)/./node_modules/nanoid/non-secure/index.js\");\n/* harmony import */ var secure_json_parse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! secure-json-parse */ \"(rsc)/./node_modules/secure-json-parse/index.js\");\n// src/combine-headers.ts\nfunction combineHeaders(...headers) {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => ({\n      ...combinedHeaders,\n      ...currentHeaders != null ? currentHeaders : {}\n    }),\n    {}\n  );\n}\n\n// src/convert-async-iterator-to-readable-stream.ts\nfunction convertAsyncIteratorToReadableStream(iterator) {\n  return new ReadableStream({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      try {\n        const { value, done } = await iterator.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    cancel() {\n    }\n  });\n}\n\n// src/delay.ts\nasync function delay(delayInMs) {\n  return delayInMs == null ? Promise.resolve() : new Promise((resolve2) => setTimeout(resolve2, delayInMs));\n}\n\n// src/event-source-parser-stream.ts\nfunction createEventSourceParserStream() {\n  let buffer = \"\";\n  let event = void 0;\n  let data = [];\n  let lastEventId = void 0;\n  let retry = void 0;\n  function parseLine(line, controller) {\n    if (line === \"\") {\n      dispatchEvent(controller);\n      return;\n    }\n    if (line.startsWith(\":\")) {\n      return;\n    }\n    const colonIndex = line.indexOf(\":\");\n    if (colonIndex === -1) {\n      handleField(line, \"\");\n      return;\n    }\n    const field = line.slice(0, colonIndex);\n    const valueStart = colonIndex + 1;\n    const value = valueStart < line.length && line[valueStart] === \" \" ? line.slice(valueStart + 1) : line.slice(valueStart);\n    handleField(field, value);\n  }\n  function dispatchEvent(controller) {\n    if (data.length > 0) {\n      controller.enqueue({\n        event,\n        data: data.join(\"\\n\"),\n        id: lastEventId,\n        retry\n      });\n      data = [];\n      event = void 0;\n      retry = void 0;\n    }\n  }\n  function handleField(field, value) {\n    switch (field) {\n      case \"event\":\n        event = value;\n        break;\n      case \"data\":\n        data.push(value);\n        break;\n      case \"id\":\n        lastEventId = value;\n        break;\n      case \"retry\":\n        const parsedRetry = parseInt(value, 10);\n        if (!isNaN(parsedRetry)) {\n          retry = parsedRetry;\n        }\n        break;\n    }\n  }\n  return new TransformStream({\n    transform(chunk, controller) {\n      const { lines, incompleteLine } = splitLines(buffer, chunk);\n      buffer = incompleteLine;\n      for (let i = 0; i < lines.length; i++) {\n        parseLine(lines[i], controller);\n      }\n    },\n    flush(controller) {\n      parseLine(buffer, controller);\n      dispatchEvent(controller);\n    }\n  });\n}\nfunction splitLines(buffer, chunk) {\n  const lines = [];\n  let currentLine = buffer;\n  for (let i = 0; i < chunk.length; ) {\n    const char = chunk[i++];\n    if (char === \"\\n\") {\n      lines.push(currentLine);\n      currentLine = \"\";\n    } else if (char === \"\\r\") {\n      lines.push(currentLine);\n      currentLine = \"\";\n      if (chunk[i] === \"\\n\") {\n        i++;\n      }\n    } else {\n      currentLine += char;\n    }\n  }\n  return { lines, incompleteLine: currentLine };\n}\n\n// src/extract-response-headers.ts\nfunction extractResponseHeaders(response) {\n  const headers = {};\n  response.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\n\n// src/generate-id.ts\n\n\nvar createIdGenerator = ({\n  prefix,\n  size: defaultSize = 16,\n  alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  separator = \"-\"\n} = {}) => {\n  const generator = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_0__.customAlphabet)(alphabet, defaultSize);\n  if (prefix == null) {\n    return generator;\n  }\n  if (alphabet.includes(separator)) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n      argument: \"separator\",\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`\n    });\n  }\n  return (size) => `${prefix}${separator}${generator(size)}`;\n};\nvar generateId = createIdGenerator();\n\n// src/get-error-message.ts\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\n\n// src/get-from-api.ts\n\n\n// src/remove-undefined-entries.ts\nfunction removeUndefinedEntries(record) {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null)\n  );\n}\n\n// src/is-abort-error.ts\nfunction isAbortError(error) {\n  return error instanceof Error && (error.name === \"AbortError\" || error.name === \"TimeoutError\");\n}\n\n// src/get-from-api.ts\nvar getOriginalFetch = () => globalThis.fetch;\nvar getFromApi = async ({\n  url,\n  headers = {},\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch()\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: \"GET\",\n      headers: removeUndefinedEntries(headers),\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: {}\n        });\n      } catch (error) {\n        if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isInstance(error)) {\n          throw error;\n        }\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n          message: \"Failed to process error response\",\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: {}\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: {}\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n        message: \"Failed to process successful response\",\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: {}\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n    if (error instanceof TypeError && error.message === \"fetch failed\") {\n      const cause = error.cause;\n      if (cause != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          isRetryable: true,\n          requestBodyValues: {}\n        });\n      }\n    }\n    throw error;\n  }\n};\n\n// src/load-api-key.ts\n\nfunction loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = \"apiKey\",\n  description\n}) {\n  if (typeof apiKey === \"string\") {\n    return apiKey;\n  }\n  if (apiKey != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n      message: `${description} API key must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  apiKey = process.env[environmentVariableName];\n  if (apiKey == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof apiKey !== \"string\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return apiKey;\n}\n\n// src/load-optional-setting.ts\nfunction loadOptionalSetting({\n  settingValue,\n  environmentVariableName\n}) {\n  if (typeof settingValue === \"string\") {\n    return settingValue;\n  }\n  if (settingValue != null || typeof process === \"undefined\") {\n    return void 0;\n  }\n  settingValue = process.env[environmentVariableName];\n  if (settingValue == null || typeof settingValue !== \"string\") {\n    return void 0;\n  }\n  return settingValue;\n}\n\n// src/load-setting.ts\n\nfunction loadSetting({\n  settingValue,\n  environmentVariableName,\n  settingName,\n  description\n}) {\n  if (typeof settingValue === \"string\") {\n    return settingValue;\n  }\n  if (settingValue != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n      message: `${description} setting must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  settingValue = process.env[environmentVariableName];\n  if (settingValue == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof settingValue !== \"string\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n      message: `${description} setting must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return settingValue;\n}\n\n// src/parse-json.ts\n\n\n\n// src/validate-types.ts\n\n\n// src/validator.ts\nvar validatorSymbol = Symbol.for(\"vercel.ai.validator\");\nfunction validator(validate) {\n  return { [validatorSymbol]: true, validate };\n}\nfunction isValidator(value) {\n  return typeof value === \"object\" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && \"validate\" in value;\n}\nfunction asValidator(value) {\n  return isValidator(value) ? value : zodValidator(value);\n}\nfunction zodValidator(zodSchema) {\n  return validator((value) => {\n    const result = zodSchema.safeParse(value);\n    return result.success ? { success: true, value: result.data } : { success: false, error: result.error };\n  });\n}\n\n// src/validate-types.ts\nfunction validateTypes({\n  value,\n  schema: inputSchema\n}) {\n  const result = safeValidateTypes({ value, schema: inputSchema });\n  if (!result.success) {\n    throw _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.wrap({ value, cause: result.error });\n  }\n  return result.value;\n}\nfunction safeValidateTypes({\n  value,\n  schema\n}) {\n  const validator2 = asValidator(schema);\n  try {\n    if (validator2.validate == null) {\n      return { success: true, value };\n    }\n    const result = validator2.validate(value);\n    if (result.success) {\n      return result;\n    }\n    return {\n      success: false,\n      error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.wrap({ value, cause: result.error })\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.wrap({ value, cause: error })\n    };\n  }\n}\n\n// src/parse-json.ts\nfunction parseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secure_json_parse__WEBPACK_IMPORTED_MODULE_2__.parse(text);\n    if (schema == null) {\n      return value;\n    }\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError.isInstance(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.isInstance(error)) {\n      throw error;\n    }\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError({ text, cause: error });\n  }\n}\nfunction safeParseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secure_json_parse__WEBPACK_IMPORTED_MODULE_2__.parse(text);\n    if (schema == null) {\n      return { success: true, value, rawValue: value };\n    }\n    const validationResult = safeValidateTypes({ value, schema });\n    return validationResult.success ? { ...validationResult, rawValue: value } : validationResult;\n  } catch (error) {\n    return {\n      success: false,\n      error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError.isInstance(error) ? error : new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError({ text, cause: error })\n    };\n  }\n}\nfunction isParsableJson(input) {\n  try {\n    secure_json_parse__WEBPACK_IMPORTED_MODULE_2__.parse(input);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n// src/parse-provider-options.ts\n\nfunction parseProviderOptions({\n  provider,\n  providerOptions,\n  schema\n}) {\n  if ((providerOptions == null ? void 0 : providerOptions[provider]) == null) {\n    return void 0;\n  }\n  const parsedProviderOptions = safeValidateTypes({\n    value: providerOptions[provider],\n    schema\n  });\n  if (!parsedProviderOptions.success) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n      argument: \"providerOptions\",\n      message: `invalid ${provider} provider options`,\n      cause: parsedProviderOptions.error\n    });\n  }\n  return parsedProviderOptions.value;\n}\n\n// src/post-to-api.ts\n\nvar getOriginalFetch2 = () => globalThis.fetch;\nvar postJsonToApi = async ({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n}) => postToApi({\n  url,\n  headers: {\n    \"Content-Type\": \"application/json\",\n    ...headers\n  },\n  body: {\n    content: JSON.stringify(body),\n    values: body\n  },\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n});\nvar postFormDataToApi = async ({\n  url,\n  headers,\n  formData,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n}) => postToApi({\n  url,\n  headers,\n  body: {\n    content: formData,\n    values: Object.fromEntries(formData.entries())\n  },\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n});\nvar postToApi = async ({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch2()\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: removeUndefinedEntries(headers),\n      body: body.content,\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values\n        });\n      } catch (error) {\n        if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isInstance(error)) {\n          throw error;\n        }\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n          message: \"Failed to process error response\",\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n        message: \"Failed to process successful response\",\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n    if (error instanceof TypeError && error.message === \"fetch failed\") {\n      const cause = error.cause;\n      if (cause != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          requestBodyValues: body.values,\n          isRetryable: true\n          // retry when network error\n        });\n      }\n    }\n    throw error;\n  }\n};\n\n// src/resolve.ts\nasync function resolve(value) {\n  if (typeof value === \"function\") {\n    value = value();\n  }\n  return Promise.resolve(value);\n}\n\n// src/response-handler.ts\n\nvar createJsonErrorResponseHandler = ({\n  errorSchema,\n  errorToMessage,\n  isRetryable\n}) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const responseHeaders = extractResponseHeaders(response);\n  if (responseBody.trim() === \"\") {\n    return {\n      responseHeaders,\n      value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n  try {\n    const parsedError = parseJSON({\n      text: responseBody,\n      schema: errorSchema\n    });\n    return {\n      responseHeaders,\n      value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n        message: errorToMessage(parsedError),\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        data: parsedError,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)\n      })\n    };\n  } catch (parseError) {\n    return {\n      responseHeaders,\n      value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n};\nvar createEventSourceResponseHandler = (chunkSchema) => async ({ response }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.EmptyResponseBodyError({});\n  }\n  return {\n    responseHeaders,\n    value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(createEventSourceParserStream()).pipeThrough(\n      new TransformStream({\n        transform({ data }, controller) {\n          if (data === \"[DONE]\") {\n            return;\n          }\n          controller.enqueue(\n            safeParseJSON({\n              text: data,\n              schema: chunkSchema\n            })\n          );\n        }\n      })\n    )\n  };\n};\nvar createJsonStreamResponseHandler = (chunkSchema) => async ({ response }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.EmptyResponseBodyError({});\n  }\n  let buffer = \"\";\n  return {\n    responseHeaders,\n    value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(\n      new TransformStream({\n        transform(chunkText, controller) {\n          if (chunkText.endsWith(\"\\n\")) {\n            controller.enqueue(\n              safeParseJSON({\n                text: buffer + chunkText,\n                schema: chunkSchema\n              })\n            );\n            buffer = \"\";\n          } else {\n            buffer += chunkText;\n          }\n        }\n      })\n    )\n  };\n};\nvar createJsonResponseHandler = (responseSchema) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const parsedResult = safeParseJSON({\n    text: responseBody,\n    schema: responseSchema\n  });\n  const responseHeaders = extractResponseHeaders(response);\n  if (!parsedResult.success) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n      message: \"Invalid JSON response\",\n      cause: parsedResult.error,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody,\n      url,\n      requestBodyValues\n    });\n  }\n  return {\n    responseHeaders,\n    value: parsedResult.value,\n    rawValue: parsedResult.rawValue\n  };\n};\nvar createBinaryResponseHandler = () => async ({ response, url, requestBodyValues }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (!response.body) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n      message: \"Response body is empty\",\n      url,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody: void 0\n    });\n  }\n  try {\n    const buffer = await response.arrayBuffer();\n    return {\n      responseHeaders,\n      value: new Uint8Array(buffer)\n    };\n  } catch (error) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n      message: \"Failed to read response as array buffer\",\n      url,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody: void 0,\n      cause: error\n    });\n  }\n};\nvar createStatusCodeErrorResponseHandler = () => async ({ response, url, requestBodyValues }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  const responseBody = await response.text();\n  return {\n    responseHeaders,\n    value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n      message: response.statusText,\n      url,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody\n    })\n  };\n};\n\n// src/uint8-utils.ts\nvar { btoa, atob } = globalThis;\nfunction convertBase64ToUint8Array(base64String) {\n  const base64Url = base64String.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const latin1string = atob(base64Url);\n  return Uint8Array.from(latin1string, (byte) => byte.codePointAt(0));\n}\nfunction convertUint8ArrayToBase64(array) {\n  let latin1string = \"\";\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n  return btoa(latin1string);\n}\n\n// src/without-trailing-slash.ts\nfunction withoutTrailingSlash(url) {\n  return url == null ? void 0 : url.replace(/\\/$/, \"\");\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9wcm92aWRlci11dGlscy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQSxpREFBaUQsa0NBQWtDO0FBQ25GO0FBQ0E7QUFDQSxjQUFjLDBEQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixjQUFjLDBEQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwwREFBMEQsa0NBQWtDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwREFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLE1BQU0sYUFBYTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUF3Q0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsZWV0Zmxvdy8uL25vZGVfbW9kdWxlcy9AYWktc2RrL3Byb3ZpZGVyLXV0aWxzL2Rpc3QvaW5kZXgubWpzPzAxODgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2NvbWJpbmUtaGVhZGVycy50c1xuZnVuY3Rpb24gY29tYmluZUhlYWRlcnMoLi4uaGVhZGVycykge1xuICByZXR1cm4gaGVhZGVycy5yZWR1Y2UoXG4gICAgKGNvbWJpbmVkSGVhZGVycywgY3VycmVudEhlYWRlcnMpID0+ICh7XG4gICAgICAuLi5jb21iaW5lZEhlYWRlcnMsXG4gICAgICAuLi5jdXJyZW50SGVhZGVycyAhPSBudWxsID8gY3VycmVudEhlYWRlcnMgOiB7fVxuICAgIH0pLFxuICAgIHt9XG4gICk7XG59XG5cbi8vIHNyYy9jb252ZXJ0LWFzeW5jLWl0ZXJhdG9yLXRvLXJlYWRhYmxlLXN0cmVhbS50c1xuZnVuY3Rpb24gY29udmVydEFzeW5jSXRlcmF0b3JUb1JlYWRhYmxlU3RyZWFtKGl0ZXJhdG9yKSB7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb25zdW1lciB3YW50cyB0byBwdWxsIG1vcmUgZGF0YSBmcm9tIHRoZSBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8VD59IGNvbnRyb2xsZXIgLSBUaGUgY29udHJvbGxlciB0byBlbnF1ZXVlIGRhdGEgaW50byB0aGUgc3RyZWFtLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb25zdW1lciBjYW5jZWxzIHRoZSBzdHJlYW0uXG4gICAgICovXG4gICAgY2FuY2VsKCkge1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9kZWxheS50c1xuYXN5bmMgZnVuY3Rpb24gZGVsYXkoZGVsYXlJbk1zKSB7XG4gIHJldHVybiBkZWxheUluTXMgPT0gbnVsbCA/IFByb21pc2UucmVzb2x2ZSgpIDogbmV3IFByb21pc2UoKHJlc29sdmUyKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUyLCBkZWxheUluTXMpKTtcbn1cblxuLy8gc3JjL2V2ZW50LXNvdXJjZS1wYXJzZXItc3RyZWFtLnRzXG5mdW5jdGlvbiBjcmVhdGVFdmVudFNvdXJjZVBhcnNlclN0cmVhbSgpIHtcbiAgbGV0IGJ1ZmZlciA9IFwiXCI7XG4gIGxldCBldmVudCA9IHZvaWQgMDtcbiAgbGV0IGRhdGEgPSBbXTtcbiAgbGV0IGxhc3RFdmVudElkID0gdm9pZCAwO1xuICBsZXQgcmV0cnkgPSB2b2lkIDA7XG4gIGZ1bmN0aW9uIHBhcnNlTGluZShsaW5lLCBjb250cm9sbGVyKSB7XG4gICAgaWYgKGxpbmUgPT09IFwiXCIpIHtcbiAgICAgIGRpc3BhdGNoRXZlbnQoY29udHJvbGxlcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoXCI6XCIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbG9uSW5kZXggPSBsaW5lLmluZGV4T2YoXCI6XCIpO1xuICAgIGlmIChjb2xvbkluZGV4ID09PSAtMSkge1xuICAgICAgaGFuZGxlRmllbGQobGluZSwgXCJcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZpZWxkID0gbGluZS5zbGljZSgwLCBjb2xvbkluZGV4KTtcbiAgICBjb25zdCB2YWx1ZVN0YXJ0ID0gY29sb25JbmRleCArIDE7XG4gICAgY29uc3QgdmFsdWUgPSB2YWx1ZVN0YXJ0IDwgbGluZS5sZW5ndGggJiYgbGluZVt2YWx1ZVN0YXJ0XSA9PT0gXCIgXCIgPyBsaW5lLnNsaWNlKHZhbHVlU3RhcnQgKyAxKSA6IGxpbmUuc2xpY2UodmFsdWVTdGFydCk7XG4gICAgaGFuZGxlRmllbGQoZmllbGQsIHZhbHVlKTtcbiAgfVxuICBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGNvbnRyb2xsZXIpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICBldmVudCxcbiAgICAgICAgZGF0YTogZGF0YS5qb2luKFwiXFxuXCIpLFxuICAgICAgICBpZDogbGFzdEV2ZW50SWQsXG4gICAgICAgIHJldHJ5XG4gICAgICB9KTtcbiAgICAgIGRhdGEgPSBbXTtcbiAgICAgIGV2ZW50ID0gdm9pZCAwO1xuICAgICAgcmV0cnkgPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZUZpZWxkKGZpZWxkLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAoZmllbGQpIHtcbiAgICAgIGNhc2UgXCJldmVudFwiOlxuICAgICAgICBldmVudCA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgIGRhdGEucHVzaCh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImlkXCI6XG4gICAgICAgIGxhc3RFdmVudElkID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJldHJ5XCI6XG4gICAgICAgIGNvbnN0IHBhcnNlZFJldHJ5ID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgICAgaWYgKCFpc05hTihwYXJzZWRSZXRyeSkpIHtcbiAgICAgICAgICByZXRyeSA9IHBhcnNlZFJldHJ5O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCB7IGxpbmVzLCBpbmNvbXBsZXRlTGluZSB9ID0gc3BsaXRMaW5lcyhidWZmZXIsIGNodW5rKTtcbiAgICAgIGJ1ZmZlciA9IGluY29tcGxldGVMaW5lO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXJzZUxpbmUobGluZXNbaV0sIGNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgcGFyc2VMaW5lKGJ1ZmZlciwgY29udHJvbGxlcik7XG4gICAgICBkaXNwYXRjaEV2ZW50KGNvbnRyb2xsZXIpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBzcGxpdExpbmVzKGJ1ZmZlciwgY2h1bmspIHtcbiAgY29uc3QgbGluZXMgPSBbXTtcbiAgbGV0IGN1cnJlbnRMaW5lID0gYnVmZmVyO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rLmxlbmd0aDsgKSB7XG4gICAgY29uc3QgY2hhciA9IGNodW5rW2krK107XG4gICAgaWYgKGNoYXIgPT09IFwiXFxuXCIpIHtcbiAgICAgIGxpbmVzLnB1c2goY3VycmVudExpbmUpO1xuICAgICAgY3VycmVudExpbmUgPSBcIlwiO1xuICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gXCJcXHJcIikge1xuICAgICAgbGluZXMucHVzaChjdXJyZW50TGluZSk7XG4gICAgICBjdXJyZW50TGluZSA9IFwiXCI7XG4gICAgICBpZiAoY2h1bmtbaV0gPT09IFwiXFxuXCIpIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50TGluZSArPSBjaGFyO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBsaW5lcywgaW5jb21wbGV0ZUxpbmU6IGN1cnJlbnRMaW5lIH07XG59XG5cbi8vIHNyYy9leHRyYWN0LXJlc3BvbnNlLWhlYWRlcnMudHNcbmZ1bmN0aW9uIGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpIHtcbiAgY29uc3QgaGVhZGVycyA9IHt9O1xuICByZXNwb25zZS5oZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICBoZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiBoZWFkZXJzO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtaWQudHNcbmltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IGN1c3RvbUFscGhhYmV0IH0gZnJvbSBcIm5hbm9pZC9ub24tc2VjdXJlXCI7XG52YXIgY3JlYXRlSWRHZW5lcmF0b3IgPSAoe1xuICBwcmVmaXgsXG4gIHNpemU6IGRlZmF1bHRTaXplID0gMTYsXG4gIGFscGhhYmV0ID0gXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiLFxuICBzZXBhcmF0b3IgPSBcIi1cIlxufSA9IHt9KSA9PiB7XG4gIGNvbnN0IGdlbmVyYXRvciA9IGN1c3RvbUFscGhhYmV0KGFscGhhYmV0LCBkZWZhdWx0U2l6ZSk7XG4gIGlmIChwcmVmaXggPT0gbnVsbCkge1xuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgaWYgKGFscGhhYmV0LmluY2x1ZGVzKHNlcGFyYXRvcikpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgYXJndW1lbnQ6IFwic2VwYXJhdG9yXCIsXG4gICAgICBtZXNzYWdlOiBgVGhlIHNlcGFyYXRvciBcIiR7c2VwYXJhdG9yfVwiIG11c3Qgbm90IGJlIHBhcnQgb2YgdGhlIGFscGhhYmV0IFwiJHthbHBoYWJldH1cIi5gXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIChzaXplKSA9PiBgJHtwcmVmaXh9JHtzZXBhcmF0b3J9JHtnZW5lcmF0b3Ioc2l6ZSl9YDtcbn07XG52YXIgZ2VuZXJhdGVJZCA9IGNyZWF0ZUlkR2VuZXJhdG9yKCk7XG5cbi8vIHNyYy9nZXQtZXJyb3ItbWVzc2FnZS50c1xuZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlKGVycm9yKSB7XG4gIGlmIChlcnJvciA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFwidW5rbm93biBlcnJvclwiO1xuICB9XG4gIGlmICh0eXBlb2YgZXJyb3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZXJyb3IpO1xufVxuXG4vLyBzcmMvZ2V0LWZyb20tYXBpLnRzXG5pbXBvcnQgeyBBUElDYWxsRXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuXG4vLyBzcmMvcmVtb3ZlLXVuZGVmaW5lZC1lbnRyaWVzLnRzXG5mdW5jdGlvbiByZW1vdmVVbmRlZmluZWRFbnRyaWVzKHJlY29yZCkge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKHJlY29yZCkuZmlsdGVyKChbX2tleSwgdmFsdWVdKSA9PiB2YWx1ZSAhPSBudWxsKVxuICApO1xufVxuXG4vLyBzcmMvaXMtYWJvcnQtZXJyb3IudHNcbmZ1bmN0aW9uIGlzQWJvcnRFcnJvcihlcnJvcikge1xuICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAoZXJyb3IubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIgfHwgZXJyb3IubmFtZSA9PT0gXCJUaW1lb3V0RXJyb3JcIik7XG59XG5cbi8vIHNyYy9nZXQtZnJvbS1hcGkudHNcbnZhciBnZXRPcmlnaW5hbEZldGNoID0gKCkgPT4gZ2xvYmFsVGhpcy5mZXRjaDtcbnZhciBnZXRGcm9tQXBpID0gYXN5bmMgKHtcbiAgdXJsLFxuICBoZWFkZXJzID0ge30sXG4gIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXIsXG4gIGZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgYWJvcnRTaWduYWwsXG4gIGZldGNoID0gZ2V0T3JpZ2luYWxGZXRjaCgpXG59KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgIGhlYWRlcnM6IHJlbW92ZVVuZGVmaW5lZEVudHJpZXMoaGVhZGVycyksXG4gICAgICBzaWduYWw6IGFib3J0U2lnbmFsXG4gICAgfSk7XG4gICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgbGV0IGVycm9ySW5mb3JtYXRpb247XG4gICAgICB0cnkge1xuICAgICAgICBlcnJvckluZm9ybWF0aW9uID0gYXdhaXQgZmFpbGVkUmVzcG9uc2VIYW5kbGVyKHtcbiAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IHt9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikgfHwgQVBJQ2FsbEVycm9yLmlzSW5zdGFuY2UoZXJyb3IpKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEFQSUNhbGxFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogXCJGYWlsZWQgdG8gcHJvY2VzcyBlcnJvciByZXNwb25zZVwiLFxuICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgICByZXF1ZXN0Qm9keVZhbHVlczoge31cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvckluZm9ybWF0aW9uLnZhbHVlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXIoe1xuICAgICAgICByZXNwb25zZSxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXF1ZXN0Qm9keVZhbHVlczoge31cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBpZiAoaXNBYm9ydEVycm9yKGVycm9yKSB8fCBBUElDYWxsRXJyb3IuaXNJbnN0YW5jZShlcnJvcikpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEFQSUNhbGxFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIHByb2Nlc3Mgc3VjY2Vzc2Z1bCByZXNwb25zZVwiLFxuICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiB7fVxuICAgICAgfSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIGVycm9yLm1lc3NhZ2UgPT09IFwiZmV0Y2ggZmFpbGVkXCIpIHtcbiAgICAgIGNvbnN0IGNhdXNlID0gZXJyb3IuY2F1c2U7XG4gICAgICBpZiAoY2F1c2UgIT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgQVBJQ2FsbEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBgQ2Fubm90IGNvbm5lY3QgdG8gQVBJOiAke2NhdXNlLm1lc3NhZ2V9YCxcbiAgICAgICAgICBjYXVzZSxcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgaXNSZXRyeWFibGU6IHRydWUsXG4gICAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IHt9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuLy8gc3JjL2xvYWQtYXBpLWtleS50c1xuaW1wb3J0IHsgTG9hZEFQSUtleUVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmZ1bmN0aW9uIGxvYWRBcGlLZXkoe1xuICBhcGlLZXksXG4gIGVudmlyb25tZW50VmFyaWFibGVOYW1lLFxuICBhcGlLZXlQYXJhbWV0ZXJOYW1lID0gXCJhcGlLZXlcIixcbiAgZGVzY3JpcHRpb25cbn0pIHtcbiAgaWYgKHR5cGVvZiBhcGlLZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gYXBpS2V5O1xuICB9XG4gIGlmIChhcGlLZXkgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBMb2FkQVBJS2V5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IEFQSSBrZXkgbXVzdCBiZSBhIHN0cmluZy5gXG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IExvYWRBUElLZXlFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgJHtkZXNjcmlwdGlvbn0gQVBJIGtleSBpcyBtaXNzaW5nLiBQYXNzIGl0IHVzaW5nIHRoZSAnJHthcGlLZXlQYXJhbWV0ZXJOYW1lfScgcGFyYW1ldGVyLiBFbnZpcm9ubWVudCB2YXJpYWJsZXMgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50LmBcbiAgICB9KTtcbiAgfVxuICBhcGlLZXkgPSBwcm9jZXNzLmVudltlbnZpcm9ubWVudFZhcmlhYmxlTmFtZV07XG4gIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBMb2FkQVBJS2V5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IEFQSSBrZXkgaXMgbWlzc2luZy4gUGFzcyBpdCB1c2luZyB0aGUgJyR7YXBpS2V5UGFyYW1ldGVyTmFtZX0nIHBhcmFtZXRlciBvciB0aGUgJHtlbnZpcm9ubWVudFZhcmlhYmxlTmFtZX0gZW52aXJvbm1lbnQgdmFyaWFibGUuYFxuICAgIH0pO1xuICB9XG4gIGlmICh0eXBlb2YgYXBpS2V5ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IExvYWRBUElLZXlFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgJHtkZXNjcmlwdGlvbn0gQVBJIGtleSBtdXN0IGJlIGEgc3RyaW5nLiBUaGUgdmFsdWUgb2YgdGhlICR7ZW52aXJvbm1lbnRWYXJpYWJsZU5hbWV9IGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG5vdCBhIHN0cmluZy5gXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGFwaUtleTtcbn1cblxuLy8gc3JjL2xvYWQtb3B0aW9uYWwtc2V0dGluZy50c1xuZnVuY3Rpb24gbG9hZE9wdGlvbmFsU2V0dGluZyh7XG4gIHNldHRpbmdWYWx1ZSxcbiAgZW52aXJvbm1lbnRWYXJpYWJsZU5hbWVcbn0pIHtcbiAgaWYgKHR5cGVvZiBzZXR0aW5nVmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gc2V0dGluZ1ZhbHVlO1xuICB9XG4gIGlmIChzZXR0aW5nVmFsdWUgIT0gbnVsbCB8fCB0eXBlb2YgcHJvY2VzcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgc2V0dGluZ1ZhbHVlID0gcHJvY2Vzcy5lbnZbZW52aXJvbm1lbnRWYXJpYWJsZU5hbWVdO1xuICBpZiAoc2V0dGluZ1ZhbHVlID09IG51bGwgfHwgdHlwZW9mIHNldHRpbmdWYWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIHNldHRpbmdWYWx1ZTtcbn1cblxuLy8gc3JjL2xvYWQtc2V0dGluZy50c1xuaW1wb3J0IHsgTG9hZFNldHRpbmdFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5mdW5jdGlvbiBsb2FkU2V0dGluZyh7XG4gIHNldHRpbmdWYWx1ZSxcbiAgZW52aXJvbm1lbnRWYXJpYWJsZU5hbWUsXG4gIHNldHRpbmdOYW1lLFxuICBkZXNjcmlwdGlvblxufSkge1xuICBpZiAodHlwZW9mIHNldHRpbmdWYWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBzZXR0aW5nVmFsdWU7XG4gIH1cbiAgaWYgKHNldHRpbmdWYWx1ZSAhPSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IExvYWRTZXR0aW5nRXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IHNldHRpbmcgbXVzdCBiZSBhIHN0cmluZy5gXG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IExvYWRTZXR0aW5nRXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IHNldHRpbmcgaXMgbWlzc2luZy4gUGFzcyBpdCB1c2luZyB0aGUgJyR7c2V0dGluZ05hbWV9JyBwYXJhbWV0ZXIuIEVudmlyb25tZW50IHZhcmlhYmxlcyBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQuYFxuICAgIH0pO1xuICB9XG4gIHNldHRpbmdWYWx1ZSA9IHByb2Nlc3MuZW52W2Vudmlyb25tZW50VmFyaWFibGVOYW1lXTtcbiAgaWYgKHNldHRpbmdWYWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IExvYWRTZXR0aW5nRXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IHNldHRpbmcgaXMgbWlzc2luZy4gUGFzcyBpdCB1c2luZyB0aGUgJyR7c2V0dGluZ05hbWV9JyBwYXJhbWV0ZXIgb3IgdGhlICR7ZW52aXJvbm1lbnRWYXJpYWJsZU5hbWV9IGVudmlyb25tZW50IHZhcmlhYmxlLmBcbiAgICB9KTtcbiAgfVxuICBpZiAodHlwZW9mIHNldHRpbmdWYWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBMb2FkU2V0dGluZ0Vycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBzZXR0aW5nIG11c3QgYmUgYSBzdHJpbmcuIFRoZSB2YWx1ZSBvZiB0aGUgJHtlbnZpcm9ubWVudFZhcmlhYmxlTmFtZX0gZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbm90IGEgc3RyaW5nLmBcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gc2V0dGluZ1ZhbHVlO1xufVxuXG4vLyBzcmMvcGFyc2UtanNvbi50c1xuaW1wb3J0IHtcbiAgSlNPTlBhcnNlRXJyb3IsXG4gIFR5cGVWYWxpZGF0aW9uRXJyb3IgYXMgVHlwZVZhbGlkYXRpb25FcnJvcjJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCBTZWN1cmVKU09OIGZyb20gXCJzZWN1cmUtanNvbi1wYXJzZVwiO1xuXG4vLyBzcmMvdmFsaWRhdGUtdHlwZXMudHNcbmltcG9ydCB7IFR5cGVWYWxpZGF0aW9uRXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuXG4vLyBzcmMvdmFsaWRhdG9yLnRzXG52YXIgdmFsaWRhdG9yU3ltYm9sID0gU3ltYm9sLmZvcihcInZlcmNlbC5haS52YWxpZGF0b3JcIik7XG5mdW5jdGlvbiB2YWxpZGF0b3IodmFsaWRhdGUpIHtcbiAgcmV0dXJuIHsgW3ZhbGlkYXRvclN5bWJvbF06IHRydWUsIHZhbGlkYXRlIH07XG59XG5mdW5jdGlvbiBpc1ZhbGlkYXRvcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsICYmIHZhbGlkYXRvclN5bWJvbCBpbiB2YWx1ZSAmJiB2YWx1ZVt2YWxpZGF0b3JTeW1ib2xdID09PSB0cnVlICYmIFwidmFsaWRhdGVcIiBpbiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGFzVmFsaWRhdG9yKHZhbHVlKSB7XG4gIHJldHVybiBpc1ZhbGlkYXRvcih2YWx1ZSkgPyB2YWx1ZSA6IHpvZFZhbGlkYXRvcih2YWx1ZSk7XG59XG5mdW5jdGlvbiB6b2RWYWxpZGF0b3Ioem9kU2NoZW1hKSB7XG4gIHJldHVybiB2YWxpZGF0b3IoKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gem9kU2NoZW1hLnNhZmVQYXJzZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdC5zdWNjZXNzID8geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogcmVzdWx0LmRhdGEgfSA6IHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiByZXN1bHQuZXJyb3IgfTtcbiAgfSk7XG59XG5cbi8vIHNyYy92YWxpZGF0ZS10eXBlcy50c1xuZnVuY3Rpb24gdmFsaWRhdGVUeXBlcyh7XG4gIHZhbHVlLFxuICBzY2hlbWE6IGlucHV0U2NoZW1hXG59KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHNhZmVWYWxpZGF0ZVR5cGVzKHsgdmFsdWUsIHNjaGVtYTogaW5wdXRTY2hlbWEgfSk7XG4gIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICB0aHJvdyBUeXBlVmFsaWRhdGlvbkVycm9yLndyYXAoeyB2YWx1ZSwgY2F1c2U6IHJlc3VsdC5lcnJvciB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LnZhbHVlO1xufVxuZnVuY3Rpb24gc2FmZVZhbGlkYXRlVHlwZXMoe1xuICB2YWx1ZSxcbiAgc2NoZW1hXG59KSB7XG4gIGNvbnN0IHZhbGlkYXRvcjIgPSBhc1ZhbGlkYXRvcihzY2hlbWEpO1xuICB0cnkge1xuICAgIGlmICh2YWxpZGF0b3IyLnZhbGlkYXRlID09IG51bGwpIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlIH07XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRvcjIudmFsaWRhdGUodmFsdWUpO1xuICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IFR5cGVWYWxpZGF0aW9uRXJyb3Iud3JhcCh7IHZhbHVlLCBjYXVzZTogcmVzdWx0LmVycm9yIH0pXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogVHlwZVZhbGlkYXRpb25FcnJvci53cmFwKHsgdmFsdWUsIGNhdXNlOiBlcnJvciB9KVxuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL3BhcnNlLWpzb24udHNcbmZ1bmN0aW9uIHBhcnNlSlNPTih7XG4gIHRleHQsXG4gIHNjaGVtYVxufSkge1xuICB0cnkge1xuICAgIGNvbnN0IHZhbHVlID0gU2VjdXJlSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkYXRlVHlwZXMoeyB2YWx1ZSwgc2NoZW1hIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChKU09OUGFyc2VFcnJvci5pc0luc3RhbmNlKGVycm9yKSB8fCBUeXBlVmFsaWRhdGlvbkVycm9yMi5pc0luc3RhbmNlKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHRocm93IG5ldyBKU09OUGFyc2VFcnJvcih7IHRleHQsIGNhdXNlOiBlcnJvciB9KTtcbiAgfVxufVxuZnVuY3Rpb24gc2FmZVBhcnNlSlNPTih7XG4gIHRleHQsXG4gIHNjaGVtYVxufSkge1xuICB0cnkge1xuICAgIGNvbnN0IHZhbHVlID0gU2VjdXJlSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlLCByYXdWYWx1ZTogdmFsdWUgfTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IHNhZmVWYWxpZGF0ZVR5cGVzKHsgdmFsdWUsIHNjaGVtYSB9KTtcbiAgICByZXR1cm4gdmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzID8geyAuLi52YWxpZGF0aW9uUmVzdWx0LCByYXdWYWx1ZTogdmFsdWUgfSA6IHZhbGlkYXRpb25SZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IEpTT05QYXJzZUVycm9yLmlzSW5zdGFuY2UoZXJyb3IpID8gZXJyb3IgOiBuZXcgSlNPTlBhcnNlRXJyb3IoeyB0ZXh0LCBjYXVzZTogZXJyb3IgfSlcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBpc1BhcnNhYmxlSnNvbihpbnB1dCkge1xuICB0cnkge1xuICAgIFNlY3VyZUpTT04ucGFyc2UoaW5wdXQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIHNyYy9wYXJzZS1wcm92aWRlci1vcHRpb25zLnRzXG5pbXBvcnQgeyBJbnZhbGlkQXJndW1lbnRFcnJvciBhcyBJbnZhbGlkQXJndW1lbnRFcnJvcjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuZnVuY3Rpb24gcGFyc2VQcm92aWRlck9wdGlvbnMoe1xuICBwcm92aWRlcixcbiAgcHJvdmlkZXJPcHRpb25zLFxuICBzY2hlbWFcbn0pIHtcbiAgaWYgKChwcm92aWRlck9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IHByb3ZpZGVyT3B0aW9uc1twcm92aWRlcl0pID09IG51bGwpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IHBhcnNlZFByb3ZpZGVyT3B0aW9ucyA9IHNhZmVWYWxpZGF0ZVR5cGVzKHtcbiAgICB2YWx1ZTogcHJvdmlkZXJPcHRpb25zW3Byb3ZpZGVyXSxcbiAgICBzY2hlbWFcbiAgfSk7XG4gIGlmICghcGFyc2VkUHJvdmlkZXJPcHRpb25zLnN1Y2Nlc3MpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IyKHtcbiAgICAgIGFyZ3VtZW50OiBcInByb3ZpZGVyT3B0aW9uc1wiLFxuICAgICAgbWVzc2FnZTogYGludmFsaWQgJHtwcm92aWRlcn0gcHJvdmlkZXIgb3B0aW9uc2AsXG4gICAgICBjYXVzZTogcGFyc2VkUHJvdmlkZXJPcHRpb25zLmVycm9yXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlZFByb3ZpZGVyT3B0aW9ucy52YWx1ZTtcbn1cblxuLy8gc3JjL3Bvc3QtdG8tYXBpLnRzXG5pbXBvcnQgeyBBUElDYWxsRXJyb3IgYXMgQVBJQ2FsbEVycm9yMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgZ2V0T3JpZ2luYWxGZXRjaDIgPSAoKSA9PiBnbG9iYWxUaGlzLmZldGNoO1xudmFyIHBvc3RKc29uVG9BcGkgPSBhc3luYyAoe1xuICB1cmwsXG4gIGhlYWRlcnMsXG4gIGJvZHksXG4gIGZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcixcbiAgYWJvcnRTaWduYWwsXG4gIGZldGNoXG59KSA9PiBwb3N0VG9BcGkoe1xuICB1cmwsXG4gIGhlYWRlcnM6IHtcbiAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAuLi5oZWFkZXJzXG4gIH0sXG4gIGJvZHk6IHtcbiAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICB2YWx1ZXM6IGJvZHlcbiAgfSxcbiAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyLFxuICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyLFxuICBhYm9ydFNpZ25hbCxcbiAgZmV0Y2hcbn0pO1xudmFyIHBvc3RGb3JtRGF0YVRvQXBpID0gYXN5bmMgKHtcbiAgdXJsLFxuICBoZWFkZXJzLFxuICBmb3JtRGF0YSxcbiAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyLFxuICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyLFxuICBhYm9ydFNpZ25hbCxcbiAgZmV0Y2hcbn0pID0+IHBvc3RUb0FwaSh7XG4gIHVybCxcbiAgaGVhZGVycyxcbiAgYm9keToge1xuICAgIGNvbnRlbnQ6IGZvcm1EYXRhLFxuICAgIHZhbHVlczogT2JqZWN0LmZyb21FbnRyaWVzKGZvcm1EYXRhLmVudHJpZXMoKSlcbiAgfSxcbiAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyLFxuICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyLFxuICBhYm9ydFNpZ25hbCxcbiAgZmV0Y2hcbn0pO1xudmFyIHBvc3RUb0FwaSA9IGFzeW5jICh7XG4gIHVybCxcbiAgaGVhZGVycyA9IHt9LFxuICBib2R5LFxuICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyLFxuICBmYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gIGFib3J0U2lnbmFsLFxuICBmZXRjaCA9IGdldE9yaWdpbmFsRmV0Y2gyKClcbn0pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHJlbW92ZVVuZGVmaW5lZEVudHJpZXMoaGVhZGVycyksXG4gICAgICBib2R5OiBib2R5LmNvbnRlbnQsXG4gICAgICBzaWduYWw6IGFib3J0U2lnbmFsXG4gICAgfSk7XG4gICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgbGV0IGVycm9ySW5mb3JtYXRpb247XG4gICAgICB0cnkge1xuICAgICAgICBlcnJvckluZm9ybWF0aW9uID0gYXdhaXQgZmFpbGVkUmVzcG9uc2VIYW5kbGVyKHtcbiAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IGJvZHkudmFsdWVzXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikgfHwgQVBJQ2FsbEVycm9yMi5pc0luc3RhbmNlKGVycm9yKSkge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBBUElDYWxsRXJyb3IyKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byBwcm9jZXNzIGVycm9yIHJlc3BvbnNlXCIsXG4gICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9ySW5mb3JtYXRpb24udmFsdWU7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcih7XG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlc1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpIHx8IEFQSUNhbGxFcnJvcjIuaXNJbnN0YW5jZShlcnJvcikpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEFQSUNhbGxFcnJvcjIoe1xuICAgICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byBwcm9jZXNzIHN1Y2Nlc3NmdWwgcmVzcG9uc2VcIixcbiAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICByZXF1ZXN0Qm9keVZhbHVlczogYm9keS52YWx1ZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoaXNBYm9ydEVycm9yKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvciAmJiBlcnJvci5tZXNzYWdlID09PSBcImZldGNoIGZhaWxlZFwiKSB7XG4gICAgICBjb25zdCBjYXVzZSA9IGVycm9yLmNhdXNlO1xuICAgICAgaWYgKGNhdXNlICE9IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFQSUNhbGxFcnJvcjIoe1xuICAgICAgICAgIG1lc3NhZ2U6IGBDYW5ub3QgY29ubmVjdCB0byBBUEk6ICR7Y2F1c2UubWVzc2FnZX1gLFxuICAgICAgICAgIGNhdXNlLFxuICAgICAgICAgIHVybCxcbiAgICAgICAgICByZXF1ZXN0Qm9keVZhbHVlczogYm9keS52YWx1ZXMsXG4gICAgICAgICAgaXNSZXRyeWFibGU6IHRydWVcbiAgICAgICAgICAvLyByZXRyeSB3aGVuIG5ldHdvcmsgZXJyb3JcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG4vLyBzcmMvcmVzb2x2ZS50c1xuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gIH1cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSk7XG59XG5cbi8vIHNyYy9yZXNwb25zZS1oYW5kbGVyLnRzXG5pbXBvcnQgeyBBUElDYWxsRXJyb3IgYXMgQVBJQ2FsbEVycm9yMywgRW1wdHlSZXNwb25zZUJvZHlFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgY3JlYXRlSnNvbkVycm9yUmVzcG9uc2VIYW5kbGVyID0gKHtcbiAgZXJyb3JTY2hlbWEsXG4gIGVycm9yVG9NZXNzYWdlLFxuICBpc1JldHJ5YWJsZVxufSkgPT4gYXN5bmMgKHsgcmVzcG9uc2UsIHVybCwgcmVxdWVzdEJvZHlWYWx1ZXMgfSkgPT4ge1xuICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICBpZiAocmVzcG9uc2VCb2R5LnRyaW0oKSA9PT0gXCJcIikge1xuICAgIHJldHVybiB7XG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICB2YWx1ZTogbmV3IEFQSUNhbGxFcnJvcjMoe1xuICAgICAgICBtZXNzYWdlOiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgcmVzcG9uc2VCb2R5LFxuICAgICAgICBpc1JldHJ5YWJsZTogaXNSZXRyeWFibGUgPT0gbnVsbCA/IHZvaWQgMCA6IGlzUmV0cnlhYmxlKHJlc3BvbnNlKVxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgcGFyc2VkRXJyb3IgPSBwYXJzZUpTT04oe1xuICAgICAgdGV4dDogcmVzcG9uc2VCb2R5LFxuICAgICAgc2NoZW1hOiBlcnJvclNjaGVtYVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICB2YWx1ZTogbmV3IEFQSUNhbGxFcnJvcjMoe1xuICAgICAgICBtZXNzYWdlOiBlcnJvclRvTWVzc2FnZShwYXJzZWRFcnJvciksXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICByZXNwb25zZUJvZHksXG4gICAgICAgIGRhdGE6IHBhcnNlZEVycm9yLFxuICAgICAgICBpc1JldHJ5YWJsZTogaXNSZXRyeWFibGUgPT0gbnVsbCA/IHZvaWQgMCA6IGlzUmV0cnlhYmxlKHJlc3BvbnNlLCBwYXJzZWRFcnJvcilcbiAgICAgIH0pXG4gICAgfTtcbiAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICB2YWx1ZTogbmV3IEFQSUNhbGxFcnJvcjMoe1xuICAgICAgICBtZXNzYWdlOiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgcmVzcG9uc2VCb2R5LFxuICAgICAgICBpc1JldHJ5YWJsZTogaXNSZXRyeWFibGUgPT0gbnVsbCA/IHZvaWQgMCA6IGlzUmV0cnlhYmxlKHJlc3BvbnNlKVxuICAgICAgfSlcbiAgICB9O1xuICB9XG59O1xudmFyIGNyZWF0ZUV2ZW50U291cmNlUmVzcG9uc2VIYW5kbGVyID0gKGNodW5rU2NoZW1hKSA9PiBhc3luYyAoeyByZXNwb25zZSB9KSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICBpZiAocmVzcG9uc2UuYm9keSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVtcHR5UmVzcG9uc2VCb2R5RXJyb3Ioe30pO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgIHZhbHVlOiByZXNwb25zZS5ib2R5LnBpcGVUaHJvdWdoKG5ldyBUZXh0RGVjb2RlclN0cmVhbSgpKS5waXBlVGhyb3VnaChjcmVhdGVFdmVudFNvdXJjZVBhcnNlclN0cmVhbSgpKS5waXBlVGhyb3VnaChcbiAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICB0cmFuc2Zvcm0oeyBkYXRhIH0sIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBpZiAoZGF0YSA9PT0gXCJbRE9ORV1cIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICBzYWZlUGFyc2VKU09OKHtcbiAgICAgICAgICAgICAgdGV4dDogZGF0YSxcbiAgICAgICAgICAgICAgc2NoZW1hOiBjaHVua1NjaGVtYVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIClcbiAgfTtcbn07XG52YXIgY3JlYXRlSnNvblN0cmVhbVJlc3BvbnNlSGFuZGxlciA9IChjaHVua1NjaGVtYSkgPT4gYXN5bmMgKHsgcmVzcG9uc2UgfSkgPT4ge1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgaWYgKHJlc3BvbnNlLmJvZHkgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFbXB0eVJlc3BvbnNlQm9keUVycm9yKHt9KTtcbiAgfVxuICBsZXQgYnVmZmVyID0gXCJcIjtcbiAgcmV0dXJuIHtcbiAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgdmFsdWU6IHJlc3BvbnNlLmJvZHkucGlwZVRocm91Z2gobmV3IFRleHREZWNvZGVyU3RyZWFtKCkpLnBpcGVUaHJvdWdoKFxuICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgIHRyYW5zZm9ybShjaHVua1RleHQsIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBpZiAoY2h1bmtUZXh0LmVuZHNXaXRoKFwiXFxuXCIpKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIHNhZmVQYXJzZUpTT04oe1xuICAgICAgICAgICAgICAgIHRleHQ6IGJ1ZmZlciArIGNodW5rVGV4dCxcbiAgICAgICAgICAgICAgICBzY2hlbWE6IGNodW5rU2NoZW1hXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnVmZmVyID0gXCJcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmZmVyICs9IGNodW5rVGV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKVxuICB9O1xufTtcbnZhciBjcmVhdGVKc29uUmVzcG9uc2VIYW5kbGVyID0gKHJlc3BvbnNlU2NoZW1hKSA9PiBhc3luYyAoeyByZXNwb25zZSwgdXJsLCByZXF1ZXN0Qm9keVZhbHVlcyB9KSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgY29uc3QgcGFyc2VkUmVzdWx0ID0gc2FmZVBhcnNlSlNPTih7XG4gICAgdGV4dDogcmVzcG9uc2VCb2R5LFxuICAgIHNjaGVtYTogcmVzcG9uc2VTY2hlbWFcbiAgfSk7XG4gIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICBpZiAoIXBhcnNlZFJlc3VsdC5zdWNjZXNzKSB7XG4gICAgdGhyb3cgbmV3IEFQSUNhbGxFcnJvcjMoe1xuICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIEpTT04gcmVzcG9uc2VcIixcbiAgICAgIGNhdXNlOiBwYXJzZWRSZXN1bHQuZXJyb3IsXG4gICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICByZXNwb25zZUJvZHksXG4gICAgICB1cmwsXG4gICAgICByZXF1ZXN0Qm9keVZhbHVlc1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgIHZhbHVlOiBwYXJzZWRSZXN1bHQudmFsdWUsXG4gICAgcmF3VmFsdWU6IHBhcnNlZFJlc3VsdC5yYXdWYWx1ZVxuICB9O1xufTtcbnZhciBjcmVhdGVCaW5hcnlSZXNwb25zZUhhbmRsZXIgPSAoKSA9PiBhc3luYyAoeyByZXNwb25zZSwgdXJsLCByZXF1ZXN0Qm9keVZhbHVlcyB9KSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICB0aHJvdyBuZXcgQVBJQ2FsbEVycm9yMyh7XG4gICAgICBtZXNzYWdlOiBcIlJlc3BvbnNlIGJvZHkgaXMgZW1wdHlcIixcbiAgICAgIHVybCxcbiAgICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgcmVzcG9uc2VCb2R5OiB2b2lkIDBcbiAgICB9KTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIHZhbHVlOiBuZXcgVWludDhBcnJheShidWZmZXIpXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgQVBJQ2FsbEVycm9yMyh7XG4gICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byByZWFkIHJlc3BvbnNlIGFzIGFycmF5IGJ1ZmZlclwiLFxuICAgICAgdXJsLFxuICAgICAgcmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICByZXNwb25zZUJvZHk6IHZvaWQgMCxcbiAgICAgIGNhdXNlOiBlcnJvclxuICAgIH0pO1xuICB9XG59O1xudmFyIGNyZWF0ZVN0YXR1c0NvZGVFcnJvclJlc3BvbnNlSGFuZGxlciA9ICgpID0+IGFzeW5jICh7IHJlc3BvbnNlLCB1cmwsIHJlcXVlc3RCb2R5VmFsdWVzIH0pID0+IHtcbiAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgcmV0dXJuIHtcbiAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgdmFsdWU6IG5ldyBBUElDYWxsRXJyb3IzKHtcbiAgICAgIG1lc3NhZ2U6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICB1cmwsXG4gICAgICByZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIHJlc3BvbnNlQm9keVxuICAgIH0pXG4gIH07XG59O1xuXG4vLyBzcmMvdWludDgtdXRpbHMudHNcbnZhciB7IGJ0b2EsIGF0b2IgfSA9IGdsb2JhbFRoaXM7XG5mdW5jdGlvbiBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5KGJhc2U2NFN0cmluZykge1xuICBjb25zdCBiYXNlNjRVcmwgPSBiYXNlNjRTdHJpbmcucmVwbGFjZSgvLS9nLCBcIitcIikucmVwbGFjZSgvXy9nLCBcIi9cIik7XG4gIGNvbnN0IGxhdGluMXN0cmluZyA9IGF0b2IoYmFzZTY0VXJsKTtcbiAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShsYXRpbjFzdHJpbmcsIChieXRlKSA9PiBieXRlLmNvZGVQb2ludEF0KDApKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQoYXJyYXkpIHtcbiAgbGV0IGxhdGluMXN0cmluZyA9IFwiXCI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBsYXRpbjFzdHJpbmcgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQoYXJyYXlbaV0pO1xuICB9XG4gIHJldHVybiBidG9hKGxhdGluMXN0cmluZyk7XG59XG5cbi8vIHNyYy93aXRob3V0LXRyYWlsaW5nLXNsYXNoLnRzXG5mdW5jdGlvbiB3aXRob3V0VHJhaWxpbmdTbGFzaCh1cmwpIHtcbiAgcmV0dXJuIHVybCA9PSBudWxsID8gdm9pZCAwIDogdXJsLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcbn1cbmV4cG9ydCB7XG4gIGFzVmFsaWRhdG9yLFxuICBjb21iaW5lSGVhZGVycyxcbiAgY29udmVydEFzeW5jSXRlcmF0b3JUb1JlYWRhYmxlU3RyZWFtLFxuICBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5LFxuICBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0LFxuICBjcmVhdGVCaW5hcnlSZXNwb25zZUhhbmRsZXIsXG4gIGNyZWF0ZUV2ZW50U291cmNlUGFyc2VyU3RyZWFtLFxuICBjcmVhdGVFdmVudFNvdXJjZVJlc3BvbnNlSGFuZGxlcixcbiAgY3JlYXRlSWRHZW5lcmF0b3IsXG4gIGNyZWF0ZUpzb25FcnJvclJlc3BvbnNlSGFuZGxlcixcbiAgY3JlYXRlSnNvblJlc3BvbnNlSGFuZGxlcixcbiAgY3JlYXRlSnNvblN0cmVhbVJlc3BvbnNlSGFuZGxlcixcbiAgY3JlYXRlU3RhdHVzQ29kZUVycm9yUmVzcG9uc2VIYW5kbGVyLFxuICBkZWxheSxcbiAgZXh0cmFjdFJlc3BvbnNlSGVhZGVycyxcbiAgZ2VuZXJhdGVJZCxcbiAgZ2V0RXJyb3JNZXNzYWdlLFxuICBnZXRGcm9tQXBpLFxuICBpc0Fib3J0RXJyb3IsXG4gIGlzUGFyc2FibGVKc29uLFxuICBpc1ZhbGlkYXRvcixcbiAgbG9hZEFwaUtleSxcbiAgbG9hZE9wdGlvbmFsU2V0dGluZyxcbiAgbG9hZFNldHRpbmcsXG4gIHBhcnNlSlNPTixcbiAgcGFyc2VQcm92aWRlck9wdGlvbnMsXG4gIHBvc3RGb3JtRGF0YVRvQXBpLFxuICBwb3N0SnNvblRvQXBpLFxuICBwb3N0VG9BcGksXG4gIHJlbW92ZVVuZGVmaW5lZEVudHJpZXMsXG4gIHJlc29sdmUsXG4gIHNhZmVQYXJzZUpTT04sXG4gIHNhZmVWYWxpZGF0ZVR5cGVzLFxuICB2YWxpZGF0ZVR5cGVzLFxuICB2YWxpZGF0b3IsXG4gIHZhbGlkYXRvclN5bWJvbCxcbiAgd2l0aG91dFRyYWlsaW5nU2xhc2gsXG4gIHpvZFZhbGlkYXRvclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ai-sdk/provider/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@ai-sdk/provider/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISDKError: () => (/* binding */ AISDKError),\n/* harmony export */   APICallError: () => (/* binding */ APICallError),\n/* harmony export */   EmptyResponseBodyError: () => (/* binding */ EmptyResponseBodyError),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidPromptError: () => (/* binding */ InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* binding */ InvalidResponseDataError),\n/* harmony export */   JSONParseError: () => (/* binding */ JSONParseError),\n/* harmony export */   LoadAPIKeyError: () => (/* binding */ LoadAPIKeyError),\n/* harmony export */   LoadSettingError: () => (/* binding */ LoadSettingError),\n/* harmony export */   NoContentGeneratedError: () => (/* binding */ NoContentGeneratedError),\n/* harmony export */   NoSuchModelError: () => (/* binding */ NoSuchModelError),\n/* harmony export */   TooManyEmbeddingValuesForCallError: () => (/* binding */ TooManyEmbeddingValuesForCallError),\n/* harmony export */   TypeValidationError: () => (/* binding */ TypeValidationError),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* binding */ UnsupportedFunctionalityError),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   isJSONArray: () => (/* binding */ isJSONArray),\n/* harmony export */   isJSONObject: () => (/* binding */ isJSONObject),\n/* harmony export */   isJSONValue: () => (/* binding */ isJSONValue)\n/* harmony export */ });\n// src/errors/ai-sdk-error.ts\nvar marker = \"vercel.ai.error\";\nvar symbol = Symbol.for(marker);\nvar _a;\nvar _AISDKError = class _AISDKError extends Error {\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name: name14,\n    message,\n    cause\n  }) {\n    super(message);\n    this[_a] = true;\n    this.name = name14;\n    this.cause = cause;\n  }\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error) {\n    return _AISDKError.hasMarker(error, marker);\n  }\n  static hasMarker(error, marker15) {\n    const markerSymbol = Symbol.for(marker15);\n    return error != null && typeof error === \"object\" && markerSymbol in error && typeof error[markerSymbol] === \"boolean\" && error[markerSymbol] === true;\n  }\n};\n_a = symbol;\nvar AISDKError = _AISDKError;\n\n// src/errors/api-call-error.ts\nvar name = \"AI_APICallError\";\nvar marker2 = `vercel.ai.error.${name}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar APICallError = class extends AISDKError {\n  constructor({\n    message,\n    url,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null && (statusCode === 408 || // request timeout\n    statusCode === 409 || // conflict\n    statusCode === 429 || // too many requests\n    statusCode >= 500),\n    // server error\n    data\n  }) {\n    super({ name, message, cause });\n    this[_a2] = true;\n    this.url = url;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker2);\n  }\n};\n_a2 = symbol2;\n\n// src/errors/empty-response-body-error.ts\nvar name2 = \"AI_EmptyResponseBodyError\";\nvar marker3 = `vercel.ai.error.${name2}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar EmptyResponseBodyError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message = \"Empty response body\" } = {}) {\n    super({ name: name2, message });\n    this[_a3] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker3);\n  }\n};\n_a3 = symbol3;\n\n// src/errors/get-error-message.ts\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\n\n// src/errors/invalid-argument-error.ts\nvar name3 = \"AI_InvalidArgumentError\";\nvar marker4 = `vercel.ai.error.${name3}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidArgumentError = class extends AISDKError {\n  constructor({\n    message,\n    cause,\n    argument\n  }) {\n    super({ name: name3, message, cause });\n    this[_a4] = true;\n    this.argument = argument;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker4);\n  }\n};\n_a4 = symbol4;\n\n// src/errors/invalid-prompt-error.ts\nvar name4 = \"AI_InvalidPromptError\";\nvar marker5 = `vercel.ai.error.${name4}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar InvalidPromptError = class extends AISDKError {\n  constructor({\n    prompt,\n    message,\n    cause\n  }) {\n    super({ name: name4, message: `Invalid prompt: ${message}`, cause });\n    this[_a5] = true;\n    this.prompt = prompt;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker5);\n  }\n};\n_a5 = symbol5;\n\n// src/errors/invalid-response-data-error.ts\nvar name5 = \"AI_InvalidResponseDataError\";\nvar marker6 = `vercel.ai.error.${name5}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar InvalidResponseDataError = class extends AISDKError {\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`\n  }) {\n    super({ name: name5, message });\n    this[_a6] = true;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker6);\n  }\n};\n_a6 = symbol6;\n\n// src/errors/json-parse-error.ts\nvar name6 = \"AI_JSONParseError\";\nvar marker7 = `vercel.ai.error.${name6}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar JSONParseError = class extends AISDKError {\n  constructor({ text, cause }) {\n    super({\n      name: name6,\n      message: `JSON parsing failed: Text: ${text}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a7] = true;\n    this.text = text;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker7);\n  }\n};\n_a7 = symbol7;\n\n// src/errors/load-api-key-error.ts\nvar name7 = \"AI_LoadAPIKeyError\";\nvar marker8 = `vercel.ai.error.${name7}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar LoadAPIKeyError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message }) {\n    super({ name: name7, message });\n    this[_a8] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker8);\n  }\n};\n_a8 = symbol8;\n\n// src/errors/load-setting-error.ts\nvar name8 = \"AI_LoadSettingError\";\nvar marker9 = `vercel.ai.error.${name8}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar LoadSettingError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message }) {\n    super({ name: name8, message });\n    this[_a9] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker9);\n  }\n};\n_a9 = symbol9;\n\n// src/errors/no-content-generated-error.ts\nvar name9 = \"AI_NoContentGeneratedError\";\nvar marker10 = `vercel.ai.error.${name9}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar NoContentGeneratedError = class extends AISDKError {\n  // used in isInstance\n  constructor({\n    message = \"No content generated.\"\n  } = {}) {\n    super({ name: name9, message });\n    this[_a10] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker10);\n  }\n};\n_a10 = symbol10;\n\n// src/errors/no-such-model-error.ts\nvar name10 = \"AI_NoSuchModelError\";\nvar marker11 = `vercel.ai.error.${name10}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\nvar NoSuchModelError = class extends AISDKError {\n  constructor({\n    errorName = name10,\n    modelId,\n    modelType,\n    message = `No such ${modelType}: ${modelId}`\n  }) {\n    super({ name: errorName, message });\n    this[_a11] = true;\n    this.modelId = modelId;\n    this.modelType = modelType;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker11);\n  }\n};\n_a11 = symbol11;\n\n// src/errors/too-many-embedding-values-for-call-error.ts\nvar name11 = \"AI_TooManyEmbeddingValuesForCallError\";\nvar marker12 = `vercel.ai.error.${name11}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\nvar TooManyEmbeddingValuesForCallError = class extends AISDKError {\n  constructor(options) {\n    super({\n      name: name11,\n      message: `Too many values for a single embedding call. The ${options.provider} model \"${options.modelId}\" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`\n    });\n    this[_a12] = true;\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n    this.values = options.values;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker12);\n  }\n};\n_a12 = symbol12;\n\n// src/errors/type-validation-error.ts\nvar name12 = \"AI_TypeValidationError\";\nvar marker13 = `vercel.ai.error.${name12}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13;\nvar _TypeValidationError = class _TypeValidationError extends AISDKError {\n  constructor({ value, cause }) {\n    super({\n      name: name12,\n      message: `Type validation failed: Value: ${JSON.stringify(value)}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a13] = true;\n    this.value = value;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker13);\n  }\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause\n  }) {\n    return _TypeValidationError.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError({ value, cause });\n  }\n};\n_a13 = symbol13;\nvar TypeValidationError = _TypeValidationError;\n\n// src/errors/unsupported-functionality-error.ts\nvar name13 = \"AI_UnsupportedFunctionalityError\";\nvar marker14 = `vercel.ai.error.${name13}`;\nvar symbol14 = Symbol.for(marker14);\nvar _a14;\nvar UnsupportedFunctionalityError = class extends AISDKError {\n  constructor({\n    functionality,\n    message = `'${functionality}' functionality not supported.`\n  }) {\n    super({ name: name13, message });\n    this[_a14] = true;\n    this.functionality = functionality;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker14);\n  }\n};\n_a14 = symbol14;\n\n// src/json-value/is-json.ts\nfunction isJSONValue(value) {\n  if (value === null || typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n    return true;\n  }\n  if (Array.isArray(value)) {\n    return value.every(isJSONValue);\n  }\n  if (typeof value === \"object\") {\n    return Object.entries(value).every(\n      ([key, val]) => typeof key === \"string\" && isJSONValue(val)\n    );\n  }\n  return false;\n}\nfunction isJSONArray(value) {\n  return Array.isArray(value) && value.every(isJSONValue);\n}\nfunction isJSONObject(value) {\n  return value != null && typeof value === \"object\" && Object.entries(value).every(\n    ([key, val]) => typeof key === \"string\" && isJSONValue(val)\n  );\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9wcm92aWRlci9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxLQUFLO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0NBQWtDLElBQUk7QUFDdEQsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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cy9AYWktc2RrL3Byb3ZpZGVyL2Rpc3QvaW5kZXgubWpzPzQxYjUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2Vycm9ycy9haS1zZGstZXJyb3IudHNcbnZhciBtYXJrZXIgPSBcInZlcmNlbC5haS5lcnJvclwiO1xudmFyIHN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyKTtcbnZhciBfYTtcbnZhciBfQUlTREtFcnJvciA9IGNsYXNzIF9BSVNES0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBBSSBTREsgRXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY3JlYXRpbmcgdGhlIGVycm9yLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXJyb3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMubWVzc2FnZSAtIFRoZSBlcnJvciBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge3Vua25vd259IFtwYXJhbXMuY2F1c2VdIC0gVGhlIHVuZGVybHlpbmcgY2F1c2Ugb2YgdGhlIGVycm9yLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIG5hbWU6IG5hbWUxNCxcbiAgICBtZXNzYWdlLFxuICAgIGNhdXNlXG4gIH0pIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzW19hXSA9IHRydWU7XG4gICAgdGhpcy5uYW1lID0gbmFtZTE0O1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBlcnJvciBpcyBhbiBBSSBTREsgRXJyb3IuXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gZXJyb3IgLSBUaGUgZXJyb3IgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBlcnJvciBpcyBhbiBBSSBTREsgRXJyb3IsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIF9BSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyKTtcbiAgfVxuICBzdGF0aWMgaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxNSkge1xuICAgIGNvbnN0IG1hcmtlclN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyMTUpO1xuICAgIHJldHVybiBlcnJvciAhPSBudWxsICYmIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJiBtYXJrZXJTeW1ib2wgaW4gZXJyb3IgJiYgdHlwZW9mIGVycm9yW21hcmtlclN5bWJvbF0gPT09IFwiYm9vbGVhblwiICYmIGVycm9yW21hcmtlclN5bWJvbF0gPT09IHRydWU7XG4gIH1cbn07XG5fYSA9IHN5bWJvbDtcbnZhciBBSVNES0Vycm9yID0gX0FJU0RLRXJyb3I7XG5cbi8vIHNyYy9lcnJvcnMvYXBpLWNhbGwtZXJyb3IudHNcbnZhciBuYW1lID0gXCJBSV9BUElDYWxsRXJyb3JcIjtcbnZhciBtYXJrZXIyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWV9YDtcbnZhciBzeW1ib2wyID0gU3ltYm9sLmZvcihtYXJrZXIyKTtcbnZhciBfYTI7XG52YXIgQVBJQ2FsbEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UsXG4gICAgdXJsLFxuICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgIHN0YXR1c0NvZGUsXG4gICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgIHJlc3BvbnNlQm9keSxcbiAgICBjYXVzZSxcbiAgICBpc1JldHJ5YWJsZSA9IHN0YXR1c0NvZGUgIT0gbnVsbCAmJiAoc3RhdHVzQ29kZSA9PT0gNDA4IHx8IC8vIHJlcXVlc3QgdGltZW91dFxuICAgIHN0YXR1c0NvZGUgPT09IDQwOSB8fCAvLyBjb25mbGljdFxuICAgIHN0YXR1c0NvZGUgPT09IDQyOSB8fCAvLyB0b28gbWFueSByZXF1ZXN0c1xuICAgIHN0YXR1c0NvZGUgPj0gNTAwKSxcbiAgICAvLyBzZXJ2ZXIgZXJyb3JcbiAgICBkYXRhXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWUsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2EyXSA9IHRydWU7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5yZXF1ZXN0Qm9keVZhbHVlcyA9IHJlcXVlc3RCb2R5VmFsdWVzO1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgdGhpcy5yZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnM7XG4gICAgdGhpcy5yZXNwb25zZUJvZHkgPSByZXNwb25zZUJvZHk7XG4gICAgdGhpcy5pc1JldHJ5YWJsZSA9IGlzUmV0cnlhYmxlO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjIpO1xuICB9XG59O1xuX2EyID0gc3ltYm9sMjtcblxuLy8gc3JjL2Vycm9ycy9lbXB0eS1yZXNwb25zZS1ib2R5LWVycm9yLnRzXG52YXIgbmFtZTIgPSBcIkFJX0VtcHR5UmVzcG9uc2VCb2R5RXJyb3JcIjtcbnZhciBtYXJrZXIzID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUyfWA7XG52YXIgc3ltYm9sMyA9IFN5bWJvbC5mb3IobWFya2VyMyk7XG52YXIgX2EzO1xudmFyIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICAvLyB1c2VkIGluIGlzSW5zdGFuY2VcbiAgY29uc3RydWN0b3IoeyBtZXNzYWdlID0gXCJFbXB0eSByZXNwb25zZSBib2R5XCIgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMiwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hM10gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIzKTtcbiAgfVxufTtcbl9hMyA9IHN5bWJvbDM7XG5cbi8vIHNyYy9lcnJvcnMvZ2V0LWVycm9yLW1lc3NhZ2UudHNcbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShlcnJvcikge1xuICBpZiAoZXJyb3IgPT0gbnVsbCkge1xuICAgIHJldHVybiBcInVua25vd24gZXJyb3JcIjtcbiAgfVxuICBpZiAodHlwZW9mIGVycm9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gIH1cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbn1cblxuLy8gc3JjL2Vycm9ycy9pbnZhbGlkLWFyZ3VtZW50LWVycm9yLnRzXG52YXIgbmFtZTMgPSBcIkFJX0ludmFsaWRBcmd1bWVudEVycm9yXCI7XG52YXIgbWFya2VyNCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lM31gO1xudmFyIHN5bWJvbDQgPSBTeW1ib2wuZm9yKG1hcmtlcjQpO1xudmFyIF9hNDtcbnZhciBJbnZhbGlkQXJndW1lbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlLFxuICAgIGNhdXNlLFxuICAgIGFyZ3VtZW50XG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUzLCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hNF0gPSB0cnVlO1xuICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyNCk7XG4gIH1cbn07XG5fYTQgPSBzeW1ib2w0O1xuXG4vLyBzcmMvZXJyb3JzL2ludmFsaWQtcHJvbXB0LWVycm9yLnRzXG52YXIgbmFtZTQgPSBcIkFJX0ludmFsaWRQcm9tcHRFcnJvclwiO1xudmFyIG1hcmtlcjUgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTR9YDtcbnZhciBzeW1ib2w1ID0gU3ltYm9sLmZvcihtYXJrZXI1KTtcbnZhciBfYTU7XG52YXIgSW52YWxpZFByb21wdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHByb21wdCxcbiAgICBtZXNzYWdlLFxuICAgIGNhdXNlXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU0LCBtZXNzYWdlOiBgSW52YWxpZCBwcm9tcHQ6ICR7bWVzc2FnZX1gLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hNV0gPSB0cnVlO1xuICAgIHRoaXMucHJvbXB0ID0gcHJvbXB0O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI1KTtcbiAgfVxufTtcbl9hNSA9IHN5bWJvbDU7XG5cbi8vIHNyYy9lcnJvcnMvaW52YWxpZC1yZXNwb25zZS1kYXRhLWVycm9yLnRzXG52YXIgbmFtZTUgPSBcIkFJX0ludmFsaWRSZXNwb25zZURhdGFFcnJvclwiO1xudmFyIG1hcmtlcjYgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTV9YDtcbnZhciBzeW1ib2w2ID0gU3ltYm9sLmZvcihtYXJrZXI2KTtcbnZhciBfYTY7XG52YXIgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGRhdGEsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIHJlc3BvbnNlIGRhdGE6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSl9LmBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTUsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTZdID0gdHJ1ZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI2KTtcbiAgfVxufTtcbl9hNiA9IHN5bWJvbDY7XG5cbi8vIHNyYy9lcnJvcnMvanNvbi1wYXJzZS1lcnJvci50c1xudmFyIG5hbWU2ID0gXCJBSV9KU09OUGFyc2VFcnJvclwiO1xudmFyIG1hcmtlcjcgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTZ9YDtcbnZhciBzeW1ib2w3ID0gU3ltYm9sLmZvcihtYXJrZXI3KTtcbnZhciBfYTc7XG52YXIgSlNPTlBhcnNlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7IHRleHQsIGNhdXNlIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBuYW1lNixcbiAgICAgIG1lc3NhZ2U6IGBKU09OIHBhcnNpbmcgZmFpbGVkOiBUZXh0OiAke3RleHR9LlxuRXJyb3IgbWVzc2FnZTogJHtnZXRFcnJvck1lc3NhZ2UoY2F1c2UpfWAsXG4gICAgICBjYXVzZVxuICAgIH0pO1xuICAgIHRoaXNbX2E3XSA9IHRydWU7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyNyk7XG4gIH1cbn07XG5fYTcgPSBzeW1ib2w3O1xuXG4vLyBzcmMvZXJyb3JzL2xvYWQtYXBpLWtleS1lcnJvci50c1xudmFyIG5hbWU3ID0gXCJBSV9Mb2FkQVBJS2V5RXJyb3JcIjtcbnZhciBtYXJrZXI4ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU3fWA7XG52YXIgc3ltYm9sOCA9IFN5bWJvbC5mb3IobWFya2VyOCk7XG52YXIgX2E4O1xudmFyIExvYWRBUElLZXlFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTcsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYThdID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyOCk7XG4gIH1cbn07XG5fYTggPSBzeW1ib2w4O1xuXG4vLyBzcmMvZXJyb3JzL2xvYWQtc2V0dGluZy1lcnJvci50c1xudmFyIG5hbWU4ID0gXCJBSV9Mb2FkU2V0dGluZ0Vycm9yXCI7XG52YXIgbWFya2VyOSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lOH1gO1xudmFyIHN5bWJvbDkgPSBTeW1ib2wuZm9yKG1hcmtlcjkpO1xudmFyIF9hOTtcbnZhciBMb2FkU2V0dGluZ0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lOCwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hOV0gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI5KTtcbiAgfVxufTtcbl9hOSA9IHN5bWJvbDk7XG5cbi8vIHNyYy9lcnJvcnMvbm8tY29udGVudC1nZW5lcmF0ZWQtZXJyb3IudHNcbnZhciBuYW1lOSA9IFwiQUlfTm9Db250ZW50R2VuZXJhdGVkRXJyb3JcIjtcbnZhciBtYXJrZXIxMCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lOX1gO1xudmFyIHN5bWJvbDEwID0gU3ltYm9sLmZvcihtYXJrZXIxMCk7XG52YXIgX2ExMDtcbnZhciBOb0NvbnRlbnRHZW5lcmF0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSA9IFwiTm8gY29udGVudCBnZW5lcmF0ZWQuXCJcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lOSwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hMTBdID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTApO1xuICB9XG59O1xuX2ExMCA9IHN5bWJvbDEwO1xuXG4vLyBzcmMvZXJyb3JzL25vLXN1Y2gtbW9kZWwtZXJyb3IudHNcbnZhciBuYW1lMTAgPSBcIkFJX05vU3VjaE1vZGVsRXJyb3JcIjtcbnZhciBtYXJrZXIxMSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTB9YDtcbnZhciBzeW1ib2wxMSA9IFN5bWJvbC5mb3IobWFya2VyMTEpO1xudmFyIF9hMTE7XG52YXIgTm9TdWNoTW9kZWxFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBlcnJvck5hbWUgPSBuYW1lMTAsXG4gICAgbW9kZWxJZCxcbiAgICBtb2RlbFR5cGUsXG4gICAgbWVzc2FnZSA9IGBObyBzdWNoICR7bW9kZWxUeXBlfTogJHttb2RlbElkfWBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogZXJyb3JOYW1lLCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2ExMV0gPSB0cnVlO1xuICAgIHRoaXMubW9kZWxJZCA9IG1vZGVsSWQ7XG4gICAgdGhpcy5tb2RlbFR5cGUgPSBtb2RlbFR5cGU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjExKTtcbiAgfVxufTtcbl9hMTEgPSBzeW1ib2wxMTtcblxuLy8gc3JjL2Vycm9ycy90b28tbWFueS1lbWJlZGRpbmctdmFsdWVzLWZvci1jYWxsLWVycm9yLnRzXG52YXIgbmFtZTExID0gXCJBSV9Ub29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yXCI7XG52YXIgbWFya2VyMTIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTExfWA7XG52YXIgc3ltYm9sMTIgPSBTeW1ib2wuZm9yKG1hcmtlcjEyKTtcbnZhciBfYTEyO1xudmFyIFRvb01hbnlFbWJlZGRpbmdWYWx1ZXNGb3JDYWxsRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogbmFtZTExLFxuICAgICAgbWVzc2FnZTogYFRvbyBtYW55IHZhbHVlcyBmb3IgYSBzaW5nbGUgZW1iZWRkaW5nIGNhbGwuIFRoZSAke29wdGlvbnMucHJvdmlkZXJ9IG1vZGVsIFwiJHtvcHRpb25zLm1vZGVsSWR9XCIgY2FuIG9ubHkgZW1iZWQgdXAgdG8gJHtvcHRpb25zLm1heEVtYmVkZGluZ3NQZXJDYWxsfSB2YWx1ZXMgcGVyIGNhbGwsIGJ1dCAke29wdGlvbnMudmFsdWVzLmxlbmd0aH0gdmFsdWVzIHdlcmUgcHJvdmlkZWQuYFxuICAgIH0pO1xuICAgIHRoaXNbX2ExMl0gPSB0cnVlO1xuICAgIHRoaXMucHJvdmlkZXIgPSBvcHRpb25zLnByb3ZpZGVyO1xuICAgIHRoaXMubW9kZWxJZCA9IG9wdGlvbnMubW9kZWxJZDtcbiAgICB0aGlzLm1heEVtYmVkZGluZ3NQZXJDYWxsID0gb3B0aW9ucy5tYXhFbWJlZGRpbmdzUGVyQ2FsbDtcbiAgICB0aGlzLnZhbHVlcyA9IG9wdGlvbnMudmFsdWVzO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMik7XG4gIH1cbn07XG5fYTEyID0gc3ltYm9sMTI7XG5cbi8vIHNyYy9lcnJvcnMvdHlwZS12YWxpZGF0aW9uLWVycm9yLnRzXG52YXIgbmFtZTEyID0gXCJBSV9UeXBlVmFsaWRhdGlvbkVycm9yXCI7XG52YXIgbWFya2VyMTMgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTEyfWA7XG52YXIgc3ltYm9sMTMgPSBTeW1ib2wuZm9yKG1hcmtlcjEzKTtcbnZhciBfYTEzO1xudmFyIF9UeXBlVmFsaWRhdGlvbkVycm9yID0gY2xhc3MgX1R5cGVWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3IoeyB2YWx1ZSwgY2F1c2UgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IG5hbWUxMixcbiAgICAgIG1lc3NhZ2U6IGBUeXBlIHZhbGlkYXRpb24gZmFpbGVkOiBWYWx1ZTogJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9LlxuRXJyb3IgbWVzc2FnZTogJHtnZXRFcnJvck1lc3NhZ2UoY2F1c2UpfWAsXG4gICAgICBjYXVzZVxuICAgIH0pO1xuICAgIHRoaXNbX2ExM10gPSB0cnVlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTMpO1xuICB9XG4gIC8qKlxuICAgKiBXcmFwcyBhbiBlcnJvciBpbnRvIGEgVHlwZVZhbGlkYXRpb25FcnJvci5cbiAgICogSWYgdGhlIGNhdXNlIGlzIGFscmVhZHkgYSBUeXBlVmFsaWRhdGlvbkVycm9yIHdpdGggdGhlIHNhbWUgdmFsdWUsIGl0IHJldHVybnMgdGhlIGNhdXNlLlxuICAgKiBPdGhlcndpc2UsIGl0IGNyZWF0ZXMgYSBuZXcgVHlwZVZhbGlkYXRpb25FcnJvci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB3cmFwcGluZyB0aGUgZXJyb3IuXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gcGFyYW1zLnZhbHVlIC0gVGhlIHZhbHVlIHRoYXQgZmFpbGVkIHZhbGlkYXRpb24uXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gcGFyYW1zLmNhdXNlIC0gVGhlIG9yaWdpbmFsIGVycm9yIG9yIGNhdXNlIG9mIHRoZSB2YWxpZGF0aW9uIGZhaWx1cmUuXG4gICAqIEByZXR1cm5zIHtUeXBlVmFsaWRhdGlvbkVycm9yfSBBIFR5cGVWYWxpZGF0aW9uRXJyb3IgaW5zdGFuY2UuXG4gICAqL1xuICBzdGF0aWMgd3JhcCh7XG4gICAgdmFsdWUsXG4gICAgY2F1c2VcbiAgfSkge1xuICAgIHJldHVybiBfVHlwZVZhbGlkYXRpb25FcnJvci5pc0luc3RhbmNlKGNhdXNlKSAmJiBjYXVzZS52YWx1ZSA9PT0gdmFsdWUgPyBjYXVzZSA6IG5ldyBfVHlwZVZhbGlkYXRpb25FcnJvcih7IHZhbHVlLCBjYXVzZSB9KTtcbiAgfVxufTtcbl9hMTMgPSBzeW1ib2wxMztcbnZhciBUeXBlVmFsaWRhdGlvbkVycm9yID0gX1R5cGVWYWxpZGF0aW9uRXJyb3I7XG5cbi8vIHNyYy9lcnJvcnMvdW5zdXBwb3J0ZWQtZnVuY3Rpb25hbGl0eS1lcnJvci50c1xudmFyIG5hbWUxMyA9IFwiQUlfVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3JcIjtcbnZhciBtYXJrZXIxNCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTN9YDtcbnZhciBzeW1ib2wxNCA9IFN5bWJvbC5mb3IobWFya2VyMTQpO1xudmFyIF9hMTQ7XG52YXIgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZnVuY3Rpb25hbGl0eSxcbiAgICBtZXNzYWdlID0gYCcke2Z1bmN0aW9uYWxpdHl9JyBmdW5jdGlvbmFsaXR5IG5vdCBzdXBwb3J0ZWQuYFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMTMsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTE0XSA9IHRydWU7XG4gICAgdGhpcy5mdW5jdGlvbmFsaXR5ID0gZnVuY3Rpb25hbGl0eTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTQpO1xuICB9XG59O1xuX2ExNCA9IHN5bWJvbDE0O1xuXG4vLyBzcmMvanNvbi12YWx1ZS9pcy1qc29uLnRzXG5mdW5jdGlvbiBpc0pTT05WYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGlzSlNPTlZhbHVlKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5ldmVyeShcbiAgICAgIChba2V5LCB2YWxdKSA9PiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICYmIGlzSlNPTlZhbHVlKHZhbClcbiAgICApO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzSlNPTkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeShpc0pTT05WYWx1ZSk7XG59XG5mdW5jdGlvbiBpc0pTT05PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5ldmVyeShcbiAgICAoW2tleSwgdmFsXSkgPT4gdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiAmJiBpc0pTT05WYWx1ZSh2YWwpXG4gICk7XG59XG5leHBvcnQge1xuICBBSVNES0Vycm9yLFxuICBBUElDYWxsRXJyb3IsXG4gIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IsXG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBJbnZhbGlkUHJvbXB0RXJyb3IsXG4gIEludmFsaWRSZXNwb25zZURhdGFFcnJvcixcbiAgSlNPTlBhcnNlRXJyb3IsXG4gIExvYWRBUElLZXlFcnJvcixcbiAgTG9hZFNldHRpbmdFcnJvcixcbiAgTm9Db250ZW50R2VuZXJhdGVkRXJyb3IsXG4gIE5vU3VjaE1vZGVsRXJyb3IsXG4gIFRvb01hbnlFbWJlZGRpbmdWYWx1ZXNGb3JDYWxsRXJyb3IsXG4gIFR5cGVWYWxpZGF0aW9uRXJyb3IsXG4gIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yLFxuICBnZXRFcnJvck1lc3NhZ2UsXG4gIGlzSlNPTkFycmF5LFxuICBpc0pTT05PYmplY3QsXG4gIGlzSlNPTlZhbHVlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ai-sdk/provider/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ai-sdk/ui-utils/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@ai-sdk/ui-utils/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   asSchema: () => (/* binding */ asSchema),\n/* harmony export */   callChatApi: () => (/* binding */ callChatApi),\n/* harmony export */   callCompletionApi: () => (/* binding */ callCompletionApi),\n/* harmony export */   extractMaxToolInvocationStep: () => (/* binding */ extractMaxToolInvocationStep),\n/* harmony export */   fillMessageParts: () => (/* binding */ fillMessageParts),\n/* harmony export */   formatAssistantStreamPart: () => (/* binding */ formatAssistantStreamPart),\n/* harmony export */   formatDataStreamPart: () => (/* binding */ formatDataStreamPart),\n/* harmony export */   generateId: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.generateId),\n/* harmony export */   getMessageParts: () => (/* binding */ getMessageParts),\n/* harmony export */   getTextFromDataUrl: () => (/* binding */ getTextFromDataUrl),\n/* harmony export */   isAssistantMessageWithCompletedToolCalls: () => (/* binding */ isAssistantMessageWithCompletedToolCalls),\n/* harmony export */   isDeepEqualData: () => (/* binding */ isDeepEqualData),\n/* harmony export */   jsonSchema: () => (/* binding */ jsonSchema),\n/* harmony export */   parseAssistantStreamPart: () => (/* binding */ parseAssistantStreamPart),\n/* harmony export */   parseDataStreamPart: () => (/* binding */ parseDataStreamPart),\n/* harmony export */   parsePartialJson: () => (/* binding */ parsePartialJson),\n/* harmony export */   prepareAttachmentsForRequest: () => (/* binding */ prepareAttachmentsForRequest),\n/* harmony export */   processAssistantStream: () => (/* binding */ processAssistantStream),\n/* harmony export */   processDataStream: () => (/* binding */ processDataStream),\n/* harmony export */   processTextStream: () => (/* binding */ processTextStream),\n/* harmony export */   shouldResubmitMessages: () => (/* binding */ shouldResubmitMessages),\n/* harmony export */   updateToolCallResult: () => (/* binding */ updateToolCallResult),\n/* harmony export */   zodSchema: () => (/* binding */ zodSchema)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zod-to-json-schema */ \"(rsc)/./node_modules/zod-to-json-schema/dist/esm/index.js\");\n// src/index.ts\n\n\n// src/assistant-stream-parts.ts\nvar textStreamPart = {\n  code: \"0\",\n  name: \"text\",\n  parse: (value) => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"text\" parts expect a string value.');\n    }\n    return { type: \"text\", value };\n  }\n};\nvar errorStreamPart = {\n  code: \"3\",\n  name: \"error\",\n  parse: (value) => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"error\" parts expect a string value.');\n    }\n    return { type: \"error\", value };\n  }\n};\nvar assistantMessageStreamPart = {\n  code: \"4\",\n  name: \"assistant_message\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every(\n      (item) => item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\"\n    )) {\n      throw new Error(\n        '\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.'\n      );\n    }\n    return {\n      type: \"assistant_message\",\n      value\n    };\n  }\n};\nvar assistantControlDataStreamPart = {\n  code: \"5\",\n  name: \"assistant_control_data\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n      throw new Error(\n        '\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.'\n      );\n    }\n    return {\n      type: \"assistant_control_data\",\n      value: {\n        threadId: value.threadId,\n        messageId: value.messageId\n      }\n    };\n  }\n};\nvar dataMessageStreamPart = {\n  code: \"6\",\n  name: \"data_message\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"role\" in value) || !(\"data\" in value) || typeof value.role !== \"string\" || value.role !== \"data\") {\n      throw new Error(\n        '\"data_message\" parts expect an object with a \"role\" and \"data\" property.'\n      );\n    }\n    return {\n      type: \"data_message\",\n      value\n    };\n  }\n};\nvar assistantStreamParts = [\n  textStreamPart,\n  errorStreamPart,\n  assistantMessageStreamPart,\n  assistantControlDataStreamPart,\n  dataMessageStreamPart\n];\nvar assistantStreamPartsByCode = {\n  [textStreamPart.code]: textStreamPart,\n  [errorStreamPart.code]: errorStreamPart,\n  [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n  [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n  [dataMessageStreamPart.code]: dataMessageStreamPart\n};\nvar StreamStringPrefixes = {\n  [textStreamPart.name]: textStreamPart.code,\n  [errorStreamPart.name]: errorStreamPart.code,\n  [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n  [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n  [dataMessageStreamPart.name]: dataMessageStreamPart.code\n};\nvar validCodes = assistantStreamParts.map((part) => part.code);\nvar parseAssistantStreamPart = (line) => {\n  const firstSeparatorIndex = line.indexOf(\":\");\n  if (firstSeparatorIndex === -1) {\n    throw new Error(\"Failed to parse stream string. No separator found.\");\n  }\n  const prefix = line.slice(0, firstSeparatorIndex);\n  if (!validCodes.includes(prefix)) {\n    throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n  }\n  const code = prefix;\n  const textValue = line.slice(firstSeparatorIndex + 1);\n  const jsonValue = JSON.parse(textValue);\n  return assistantStreamPartsByCode[code].parse(jsonValue);\n};\nfunction formatAssistantStreamPart(type, value) {\n  const streamPart = assistantStreamParts.find((part) => part.name === type);\n  if (!streamPart) {\n    throw new Error(`Invalid stream part type: ${type}`);\n  }\n  return `${streamPart.code}:${JSON.stringify(value)}\n`;\n}\n\n// src/process-chat-response.ts\n\n\n// src/duplicated/usage.ts\nfunction calculateLanguageModelUsage({\n  promptTokens,\n  completionTokens\n}) {\n  return {\n    promptTokens,\n    completionTokens,\n    totalTokens: promptTokens + completionTokens\n  };\n}\n\n// src/parse-partial-json.ts\n\n\n// src/fix-json.ts\nfunction fixJson(input) {\n  const stack = [\"ROOT\"];\n  let lastValidIndex = -1;\n  let literalStart = null;\n  function processValueStart(char, i, swapState) {\n    {\n      switch (char) {\n        case '\"': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_STRING\");\n          break;\n        }\n        case \"f\":\n        case \"t\":\n        case \"n\": {\n          lastValidIndex = i;\n          literalStart = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_LITERAL\");\n          break;\n        }\n        case \"-\": {\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n          break;\n        }\n        case \"0\":\n        case \"1\":\n        case \"2\":\n        case \"3\":\n        case \"4\":\n        case \"5\":\n        case \"6\":\n        case \"7\":\n        case \"8\":\n        case \"9\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n          break;\n        }\n        case \"{\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_OBJECT_START\");\n          break;\n        }\n        case \"[\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_ARRAY_START\");\n          break;\n        }\n      }\n    }\n  }\n  function processAfterObjectValue(char, i) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_OBJECT_AFTER_COMMA\");\n        break;\n      }\n      case \"}\": {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  function processAfterArrayValue(char, i) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n        break;\n      }\n      case \"]\": {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    const currentState = stack[stack.length - 1];\n    switch (currentState) {\n      case \"ROOT\":\n        processValueStart(char, i, \"FINISH\");\n        break;\n      case \"INSIDE_OBJECT_START\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            break;\n          }\n          case \"}\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_COMMA\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_KEY\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_AFTER_KEY\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_KEY\": {\n        switch (char) {\n          case \":\": {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_BEFORE_VALUE\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_BEFORE_VALUE\": {\n        processValueStart(char, i, \"INSIDE_OBJECT_AFTER_VALUE\");\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        processAfterObjectValue(char, i);\n        break;\n      }\n      case \"INSIDE_STRING\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            lastValidIndex = i;\n            break;\n          }\n          case \"\\\\\": {\n            stack.push(\"INSIDE_STRING_ESCAPE\");\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_START\": {\n        switch (char) {\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n            processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        switch (char) {\n          case \",\": {\n            stack.pop();\n            stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n            break;\n          }\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_AFTER_COMMA\": {\n        processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n        break;\n      }\n      case \"INSIDE_STRING_ESCAPE\": {\n        stack.pop();\n        lastValidIndex = i;\n        break;\n      }\n      case \"INSIDE_NUMBER\": {\n        switch (char) {\n          case \"0\":\n          case \"1\":\n          case \"2\":\n          case \"3\":\n          case \"4\":\n          case \"5\":\n          case \"6\":\n          case \"7\":\n          case \"8\":\n          case \"9\": {\n            lastValidIndex = i;\n            break;\n          }\n          case \"e\":\n          case \"E\":\n          case \"-\":\n          case \".\": {\n            break;\n          }\n          case \",\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n            break;\n          }\n          case \"}\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n            break;\n          }\n          case \"]\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n            break;\n          }\n          default: {\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart, i + 1);\n        if (!\"false\".startsWith(partialLiteral) && !\"true\".startsWith(partialLiteral) && !\"null\".startsWith(partialLiteral)) {\n          stack.pop();\n          if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n            processAfterObjectValue(char, i);\n          } else if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n            processAfterArrayValue(char, i);\n          }\n        } else {\n          lastValidIndex = i;\n        }\n        break;\n      }\n    }\n  }\n  let result = input.slice(0, lastValidIndex + 1);\n  for (let i = stack.length - 1; i >= 0; i--) {\n    const state = stack[i];\n    switch (state) {\n      case \"INSIDE_STRING\": {\n        result += '\"';\n        break;\n      }\n      case \"INSIDE_OBJECT_KEY\":\n      case \"INSIDE_OBJECT_AFTER_KEY\":\n      case \"INSIDE_OBJECT_AFTER_COMMA\":\n      case \"INSIDE_OBJECT_START\":\n      case \"INSIDE_OBJECT_BEFORE_VALUE\":\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        result += \"}\";\n        break;\n      }\n      case \"INSIDE_ARRAY_START\":\n      case \"INSIDE_ARRAY_AFTER_COMMA\":\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        result += \"]\";\n        break;\n      }\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart, input.length);\n        if (\"true\".startsWith(partialLiteral)) {\n          result += \"true\".slice(partialLiteral.length);\n        } else if (\"false\".startsWith(partialLiteral)) {\n          result += \"false\".slice(partialLiteral.length);\n        } else if (\"null\".startsWith(partialLiteral)) {\n          result += \"null\".slice(partialLiteral.length);\n        }\n      }\n    }\n  }\n  return result;\n}\n\n// src/parse-partial-json.ts\nfunction parsePartialJson(jsonText) {\n  if (jsonText === void 0) {\n    return { value: void 0, state: \"undefined-input\" };\n  }\n  let result = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)({ text: jsonText });\n  if (result.success) {\n    return { value: result.value, state: \"successful-parse\" };\n  }\n  result = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)({ text: fixJson(jsonText) });\n  if (result.success) {\n    return { value: result.value, state: \"repaired-parse\" };\n  }\n  return { value: void 0, state: \"failed-parse\" };\n}\n\n// src/data-stream-parts.ts\nvar textStreamPart2 = {\n  code: \"0\",\n  name: \"text\",\n  parse: (value) => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"text\" parts expect a string value.');\n    }\n    return { type: \"text\", value };\n  }\n};\nvar dataStreamPart = {\n  code: \"2\",\n  name: \"data\",\n  parse: (value) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"data\" parts expect an array value.');\n    }\n    return { type: \"data\", value };\n  }\n};\nvar errorStreamPart2 = {\n  code: \"3\",\n  name: \"error\",\n  parse: (value) => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"error\" parts expect a string value.');\n    }\n    return { type: \"error\", value };\n  }\n};\nvar messageAnnotationsStreamPart = {\n  code: \"8\",\n  name: \"message_annotations\",\n  parse: (value) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"message_annotations\" parts expect an array value.');\n    }\n    return { type: \"message_annotations\", value };\n  }\n};\nvar toolCallStreamPart = {\n  code: \"9\",\n  name: \"tool_call\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"toolName\" in value) || typeof value.toolName !== \"string\" || !(\"args\" in value) || typeof value.args !== \"object\") {\n      throw new Error(\n        '\"tool_call\" parts expect an object with a \"toolCallId\", \"toolName\", and \"args\" property.'\n      );\n    }\n    return {\n      type: \"tool_call\",\n      value\n    };\n  }\n};\nvar toolResultStreamPart = {\n  code: \"a\",\n  name: \"tool_result\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"result\" in value)) {\n      throw new Error(\n        '\"tool_result\" parts expect an object with a \"toolCallId\" and a \"result\" property.'\n      );\n    }\n    return {\n      type: \"tool_result\",\n      value\n    };\n  }\n};\nvar toolCallStreamingStartStreamPart = {\n  code: \"b\",\n  name: \"tool_call_streaming_start\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"toolName\" in value) || typeof value.toolName !== \"string\") {\n      throw new Error(\n        '\"tool_call_streaming_start\" parts expect an object with a \"toolCallId\" and \"toolName\" property.'\n      );\n    }\n    return {\n      type: \"tool_call_streaming_start\",\n      value\n    };\n  }\n};\nvar toolCallDeltaStreamPart = {\n  code: \"c\",\n  name: \"tool_call_delta\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"argsTextDelta\" in value) || typeof value.argsTextDelta !== \"string\") {\n      throw new Error(\n        '\"tool_call_delta\" parts expect an object with a \"toolCallId\" and \"argsTextDelta\" property.'\n      );\n    }\n    return {\n      type: \"tool_call_delta\",\n      value\n    };\n  }\n};\nvar finishMessageStreamPart = {\n  code: \"d\",\n  name: \"finish_message\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"finishReason\" in value) || typeof value.finishReason !== \"string\") {\n      throw new Error(\n        '\"finish_message\" parts expect an object with a \"finishReason\" property.'\n      );\n    }\n    const result = {\n      finishReason: value.finishReason\n    };\n    if (\"usage\" in value && value.usage != null && typeof value.usage === \"object\" && \"promptTokens\" in value.usage && \"completionTokens\" in value.usage) {\n      result.usage = {\n        promptTokens: typeof value.usage.promptTokens === \"number\" ? value.usage.promptTokens : Number.NaN,\n        completionTokens: typeof value.usage.completionTokens === \"number\" ? value.usage.completionTokens : Number.NaN\n      };\n    }\n    return {\n      type: \"finish_message\",\n      value: result\n    };\n  }\n};\nvar finishStepStreamPart = {\n  code: \"e\",\n  name: \"finish_step\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"finishReason\" in value) || typeof value.finishReason !== \"string\") {\n      throw new Error(\n        '\"finish_step\" parts expect an object with a \"finishReason\" property.'\n      );\n    }\n    const result = {\n      finishReason: value.finishReason,\n      isContinued: false\n    };\n    if (\"usage\" in value && value.usage != null && typeof value.usage === \"object\" && \"promptTokens\" in value.usage && \"completionTokens\" in value.usage) {\n      result.usage = {\n        promptTokens: typeof value.usage.promptTokens === \"number\" ? value.usage.promptTokens : Number.NaN,\n        completionTokens: typeof value.usage.completionTokens === \"number\" ? value.usage.completionTokens : Number.NaN\n      };\n    }\n    if (\"isContinued\" in value && typeof value.isContinued === \"boolean\") {\n      result.isContinued = value.isContinued;\n    }\n    return {\n      type: \"finish_step\",\n      value: result\n    };\n  }\n};\nvar startStepStreamPart = {\n  code: \"f\",\n  name: \"start_step\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"messageId\" in value) || typeof value.messageId !== \"string\") {\n      throw new Error(\n        '\"start_step\" parts expect an object with an \"id\" property.'\n      );\n    }\n    return {\n      type: \"start_step\",\n      value: {\n        messageId: value.messageId\n      }\n    };\n  }\n};\nvar reasoningStreamPart = {\n  code: \"g\",\n  name: \"reasoning\",\n  parse: (value) => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"reasoning\" parts expect a string value.');\n    }\n    return { type: \"reasoning\", value };\n  }\n};\nvar sourcePart = {\n  code: \"h\",\n  name: \"source\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\") {\n      throw new Error('\"source\" parts expect a Source object.');\n    }\n    return {\n      type: \"source\",\n      value\n    };\n  }\n};\nvar redactedReasoningStreamPart = {\n  code: \"i\",\n  name: \"redacted_reasoning\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"data\" in value) || typeof value.data !== \"string\") {\n      throw new Error(\n        '\"redacted_reasoning\" parts expect an object with a \"data\" property.'\n      );\n    }\n    return { type: \"redacted_reasoning\", value: { data: value.data } };\n  }\n};\nvar reasoningSignatureStreamPart = {\n  code: \"j\",\n  name: \"reasoning_signature\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"signature\" in value) || typeof value.signature !== \"string\") {\n      throw new Error(\n        '\"reasoning_signature\" parts expect an object with a \"signature\" property.'\n      );\n    }\n    return {\n      type: \"reasoning_signature\",\n      value: { signature: value.signature }\n    };\n  }\n};\nvar fileStreamPart = {\n  code: \"k\",\n  name: \"file\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"data\" in value) || typeof value.data !== \"string\" || !(\"mimeType\" in value) || typeof value.mimeType !== \"string\") {\n      throw new Error(\n        '\"file\" parts expect an object with a \"data\" and \"mimeType\" property.'\n      );\n    }\n    return { type: \"file\", value };\n  }\n};\nvar dataStreamParts = [\n  textStreamPart2,\n  dataStreamPart,\n  errorStreamPart2,\n  messageAnnotationsStreamPart,\n  toolCallStreamPart,\n  toolResultStreamPart,\n  toolCallStreamingStartStreamPart,\n  toolCallDeltaStreamPart,\n  finishMessageStreamPart,\n  finishStepStreamPart,\n  startStepStreamPart,\n  reasoningStreamPart,\n  sourcePart,\n  redactedReasoningStreamPart,\n  reasoningSignatureStreamPart,\n  fileStreamPart\n];\nvar dataStreamPartsByCode = Object.fromEntries(\n  dataStreamParts.map((part) => [part.code, part])\n);\nvar DataStreamStringPrefixes = Object.fromEntries(\n  dataStreamParts.map((part) => [part.name, part.code])\n);\nvar validCodes2 = dataStreamParts.map((part) => part.code);\nvar parseDataStreamPart = (line) => {\n  const firstSeparatorIndex = line.indexOf(\":\");\n  if (firstSeparatorIndex === -1) {\n    throw new Error(\"Failed to parse stream string. No separator found.\");\n  }\n  const prefix = line.slice(0, firstSeparatorIndex);\n  if (!validCodes2.includes(prefix)) {\n    throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n  }\n  const code = prefix;\n  const textValue = line.slice(firstSeparatorIndex + 1);\n  const jsonValue = JSON.parse(textValue);\n  return dataStreamPartsByCode[code].parse(jsonValue);\n};\nfunction formatDataStreamPart(type, value) {\n  const streamPart = dataStreamParts.find((part) => part.name === type);\n  if (!streamPart) {\n    throw new Error(`Invalid stream part type: ${type}`);\n  }\n  return `${streamPart.code}:${JSON.stringify(value)}\n`;\n}\n\n// src/process-data-stream.ts\nvar NEWLINE = \"\\n\".charCodeAt(0);\nfunction concatChunks(chunks, totalLength) {\n  const concatenatedChunks = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const chunk of chunks) {\n    concatenatedChunks.set(chunk, offset);\n    offset += chunk.length;\n  }\n  chunks.length = 0;\n  return concatenatedChunks;\n}\nasync function processDataStream({\n  stream,\n  onTextPart,\n  onReasoningPart,\n  onReasoningSignaturePart,\n  onRedactedReasoningPart,\n  onSourcePart,\n  onFilePart,\n  onDataPart,\n  onErrorPart,\n  onToolCallStreamingStartPart,\n  onToolCallDeltaPart,\n  onToolCallPart,\n  onToolResultPart,\n  onMessageAnnotationsPart,\n  onFinishMessagePart,\n  onFinishStepPart,\n  onStartStepPart\n}) {\n  const reader = stream.getReader();\n  const decoder = new TextDecoder();\n  const chunks = [];\n  let totalLength = 0;\n  while (true) {\n    const { value } = await reader.read();\n    if (value) {\n      chunks.push(value);\n      totalLength += value.length;\n      if (value[value.length - 1] !== NEWLINE) {\n        continue;\n      }\n    }\n    if (chunks.length === 0) {\n      break;\n    }\n    const concatenatedChunks = concatChunks(chunks, totalLength);\n    totalLength = 0;\n    const streamParts = decoder.decode(concatenatedChunks, { stream: true }).split(\"\\n\").filter((line) => line !== \"\").map(parseDataStreamPart);\n    for (const { type, value: value2 } of streamParts) {\n      switch (type) {\n        case \"text\":\n          await (onTextPart == null ? void 0 : onTextPart(value2));\n          break;\n        case \"reasoning\":\n          await (onReasoningPart == null ? void 0 : onReasoningPart(value2));\n          break;\n        case \"reasoning_signature\":\n          await (onReasoningSignaturePart == null ? void 0 : onReasoningSignaturePart(value2));\n          break;\n        case \"redacted_reasoning\":\n          await (onRedactedReasoningPart == null ? void 0 : onRedactedReasoningPart(value2));\n          break;\n        case \"file\":\n          await (onFilePart == null ? void 0 : onFilePart(value2));\n          break;\n        case \"source\":\n          await (onSourcePart == null ? void 0 : onSourcePart(value2));\n          break;\n        case \"data\":\n          await (onDataPart == null ? void 0 : onDataPart(value2));\n          break;\n        case \"error\":\n          await (onErrorPart == null ? void 0 : onErrorPart(value2));\n          break;\n        case \"message_annotations\":\n          await (onMessageAnnotationsPart == null ? void 0 : onMessageAnnotationsPart(value2));\n          break;\n        case \"tool_call_streaming_start\":\n          await (onToolCallStreamingStartPart == null ? void 0 : onToolCallStreamingStartPart(value2));\n          break;\n        case \"tool_call_delta\":\n          await (onToolCallDeltaPart == null ? void 0 : onToolCallDeltaPart(value2));\n          break;\n        case \"tool_call\":\n          await (onToolCallPart == null ? void 0 : onToolCallPart(value2));\n          break;\n        case \"tool_result\":\n          await (onToolResultPart == null ? void 0 : onToolResultPart(value2));\n          break;\n        case \"finish_message\":\n          await (onFinishMessagePart == null ? void 0 : onFinishMessagePart(value2));\n          break;\n        case \"finish_step\":\n          await (onFinishStepPart == null ? void 0 : onFinishStepPart(value2));\n          break;\n        case \"start_step\":\n          await (onStartStepPart == null ? void 0 : onStartStepPart(value2));\n          break;\n        default: {\n          const exhaustiveCheck = type;\n          throw new Error(`Unknown stream part type: ${exhaustiveCheck}`);\n        }\n      }\n    }\n  }\n}\n\n// src/process-chat-response.ts\nasync function processChatResponse({\n  stream,\n  update,\n  onToolCall,\n  onFinish,\n  generateId: generateId2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.generateId,\n  getCurrentDate = () => /* @__PURE__ */ new Date(),\n  lastMessage\n}) {\n  var _a, _b;\n  const replaceLastMessage = (lastMessage == null ? void 0 : lastMessage.role) === \"assistant\";\n  let step = replaceLastMessage ? 1 + // find max step in existing tool invocations:\n  ((_b = (_a = lastMessage.toolInvocations) == null ? void 0 : _a.reduce((max, toolInvocation) => {\n    var _a2;\n    return Math.max(max, (_a2 = toolInvocation.step) != null ? _a2 : 0);\n  }, 0)) != null ? _b : 0) : 0;\n  const message = replaceLastMessage ? structuredClone(lastMessage) : {\n    id: generateId2(),\n    createdAt: getCurrentDate(),\n    role: \"assistant\",\n    content: \"\",\n    parts: []\n  };\n  let currentTextPart = void 0;\n  let currentReasoningPart = void 0;\n  let currentReasoningTextDetail = void 0;\n  function updateToolInvocationPart(toolCallId, invocation) {\n    const part = message.parts.find(\n      (part2) => part2.type === \"tool-invocation\" && part2.toolInvocation.toolCallId === toolCallId\n    );\n    if (part != null) {\n      part.toolInvocation = invocation;\n    } else {\n      message.parts.push({\n        type: \"tool-invocation\",\n        toolInvocation: invocation\n      });\n    }\n  }\n  const data = [];\n  let messageAnnotations = replaceLastMessage ? lastMessage == null ? void 0 : lastMessage.annotations : void 0;\n  const partialToolCalls = {};\n  let usage = {\n    completionTokens: NaN,\n    promptTokens: NaN,\n    totalTokens: NaN\n  };\n  let finishReason = \"unknown\";\n  function execUpdate() {\n    const copiedData = [...data];\n    if (messageAnnotations == null ? void 0 : messageAnnotations.length) {\n      message.annotations = messageAnnotations;\n    }\n    const copiedMessage = {\n      // deep copy the message to ensure that deep changes (msg attachments) are updated\n      // with SolidJS. SolidJS uses referential integration of sub-objects to detect changes.\n      ...structuredClone(message),\n      // add a revision id to ensure that the message is updated with SWR. SWR uses a\n      // hashing approach by default to detect changes, but it only works for shallow\n      // changes. This is why we need to add a revision id to ensure that the message\n      // is updated with SWR (without it, the changes get stuck in SWR and are not\n      // forwarded to rendering):\n      revisionId: generateId2()\n    };\n    update({\n      message: copiedMessage,\n      data: copiedData,\n      replaceLastMessage\n    });\n  }\n  await processDataStream({\n    stream,\n    onTextPart(value) {\n      if (currentTextPart == null) {\n        currentTextPart = {\n          type: \"text\",\n          text: value\n        };\n        message.parts.push(currentTextPart);\n      } else {\n        currentTextPart.text += value;\n      }\n      message.content += value;\n      execUpdate();\n    },\n    onReasoningPart(value) {\n      var _a2;\n      if (currentReasoningTextDetail == null) {\n        currentReasoningTextDetail = { type: \"text\", text: value };\n        if (currentReasoningPart != null) {\n          currentReasoningPart.details.push(currentReasoningTextDetail);\n        }\n      } else {\n        currentReasoningTextDetail.text += value;\n      }\n      if (currentReasoningPart == null) {\n        currentReasoningPart = {\n          type: \"reasoning\",\n          reasoning: value,\n          details: [currentReasoningTextDetail]\n        };\n        message.parts.push(currentReasoningPart);\n      } else {\n        currentReasoningPart.reasoning += value;\n      }\n      message.reasoning = ((_a2 = message.reasoning) != null ? _a2 : \"\") + value;\n      execUpdate();\n    },\n    onReasoningSignaturePart(value) {\n      if (currentReasoningTextDetail != null) {\n        currentReasoningTextDetail.signature = value.signature;\n      }\n    },\n    onRedactedReasoningPart(value) {\n      if (currentReasoningPart == null) {\n        currentReasoningPart = {\n          type: \"reasoning\",\n          reasoning: \"\",\n          details: []\n        };\n        message.parts.push(currentReasoningPart);\n      }\n      currentReasoningPart.details.push({\n        type: \"redacted\",\n        data: value.data\n      });\n      currentReasoningTextDetail = void 0;\n      execUpdate();\n    },\n    onFilePart(value) {\n      message.parts.push({\n        type: \"file\",\n        mimeType: value.mimeType,\n        data: value.data\n      });\n      execUpdate();\n    },\n    onSourcePart(value) {\n      message.parts.push({\n        type: \"source\",\n        source: value\n      });\n      execUpdate();\n    },\n    onToolCallStreamingStartPart(value) {\n      if (message.toolInvocations == null) {\n        message.toolInvocations = [];\n      }\n      partialToolCalls[value.toolCallId] = {\n        text: \"\",\n        step,\n        toolName: value.toolName,\n        index: message.toolInvocations.length\n      };\n      const invocation = {\n        state: \"partial-call\",\n        step,\n        toolCallId: value.toolCallId,\n        toolName: value.toolName,\n        args: void 0\n      };\n      message.toolInvocations.push(invocation);\n      updateToolInvocationPart(value.toolCallId, invocation);\n      execUpdate();\n    },\n    onToolCallDeltaPart(value) {\n      const partialToolCall = partialToolCalls[value.toolCallId];\n      partialToolCall.text += value.argsTextDelta;\n      const { value: partialArgs } = parsePartialJson(partialToolCall.text);\n      const invocation = {\n        state: \"partial-call\",\n        step: partialToolCall.step,\n        toolCallId: value.toolCallId,\n        toolName: partialToolCall.toolName,\n        args: partialArgs\n      };\n      message.toolInvocations[partialToolCall.index] = invocation;\n      updateToolInvocationPart(value.toolCallId, invocation);\n      execUpdate();\n    },\n    async onToolCallPart(value) {\n      const invocation = {\n        state: \"call\",\n        step,\n        ...value\n      };\n      if (partialToolCalls[value.toolCallId] != null) {\n        message.toolInvocations[partialToolCalls[value.toolCallId].index] = invocation;\n      } else {\n        if (message.toolInvocations == null) {\n          message.toolInvocations = [];\n        }\n        message.toolInvocations.push(invocation);\n      }\n      updateToolInvocationPart(value.toolCallId, invocation);\n      execUpdate();\n      if (onToolCall) {\n        const result = await onToolCall({ toolCall: value });\n        if (result != null) {\n          const invocation2 = {\n            state: \"result\",\n            step,\n            ...value,\n            result\n          };\n          message.toolInvocations[message.toolInvocations.length - 1] = invocation2;\n          updateToolInvocationPart(value.toolCallId, invocation2);\n          execUpdate();\n        }\n      }\n    },\n    onToolResultPart(value) {\n      const toolInvocations = message.toolInvocations;\n      if (toolInvocations == null) {\n        throw new Error(\"tool_result must be preceded by a tool_call\");\n      }\n      const toolInvocationIndex = toolInvocations.findIndex(\n        (invocation2) => invocation2.toolCallId === value.toolCallId\n      );\n      if (toolInvocationIndex === -1) {\n        throw new Error(\n          \"tool_result must be preceded by a tool_call with the same toolCallId\"\n        );\n      }\n      const invocation = {\n        ...toolInvocations[toolInvocationIndex],\n        state: \"result\",\n        ...value\n      };\n      toolInvocations[toolInvocationIndex] = invocation;\n      updateToolInvocationPart(value.toolCallId, invocation);\n      execUpdate();\n    },\n    onDataPart(value) {\n      data.push(...value);\n      execUpdate();\n    },\n    onMessageAnnotationsPart(value) {\n      if (messageAnnotations == null) {\n        messageAnnotations = [...value];\n      } else {\n        messageAnnotations.push(...value);\n      }\n      execUpdate();\n    },\n    onFinishStepPart(value) {\n      step += 1;\n      currentTextPart = value.isContinued ? currentTextPart : void 0;\n      currentReasoningPart = void 0;\n      currentReasoningTextDetail = void 0;\n    },\n    onStartStepPart(value) {\n      if (!replaceLastMessage) {\n        message.id = value.messageId;\n      }\n      message.parts.push({ type: \"step-start\" });\n      execUpdate();\n    },\n    onFinishMessagePart(value) {\n      finishReason = value.finishReason;\n      if (value.usage != null) {\n        usage = calculateLanguageModelUsage(value.usage);\n      }\n    },\n    onErrorPart(error) {\n      throw new Error(error);\n    }\n  });\n  onFinish == null ? void 0 : onFinish({ message, finishReason, usage });\n}\n\n// src/process-chat-text-response.ts\n\n\n// src/process-text-stream.ts\nasync function processTextStream({\n  stream,\n  onTextPart\n}) {\n  const reader = stream.pipeThrough(new TextDecoderStream()).getReader();\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    await onTextPart(value);\n  }\n}\n\n// src/process-chat-text-response.ts\nasync function processChatTextResponse({\n  stream,\n  update,\n  onFinish,\n  getCurrentDate = () => /* @__PURE__ */ new Date(),\n  generateId: generateId2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.generateId\n}) {\n  const textPart = { type: \"text\", text: \"\" };\n  const resultMessage = {\n    id: generateId2(),\n    createdAt: getCurrentDate(),\n    role: \"assistant\",\n    content: \"\",\n    parts: [textPart]\n  };\n  await processTextStream({\n    stream,\n    onTextPart: (chunk) => {\n      resultMessage.content += chunk;\n      textPart.text += chunk;\n      update({\n        message: { ...resultMessage },\n        data: [],\n        replaceLastMessage: false\n      });\n    }\n  });\n  onFinish == null ? void 0 : onFinish(resultMessage, {\n    usage: { completionTokens: NaN, promptTokens: NaN, totalTokens: NaN },\n    finishReason: \"unknown\"\n  });\n}\n\n// src/call-chat-api.ts\nvar getOriginalFetch = () => fetch;\nasync function callChatApi({\n  api,\n  body,\n  streamProtocol = \"data\",\n  credentials,\n  headers,\n  abortController,\n  restoreMessagesOnFailure,\n  onResponse,\n  onUpdate,\n  onFinish,\n  onToolCall,\n  generateId: generateId2,\n  fetch: fetch2 = getOriginalFetch(),\n  lastMessage,\n  requestType = \"generate\"\n}) {\n  var _a, _b, _c;\n  const request = requestType === \"resume\" ? fetch2(`${api}?chatId=${body.id}`, {\n    method: \"GET\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...headers\n    },\n    signal: (_a = abortController == null ? void 0 : abortController()) == null ? void 0 : _a.signal,\n    credentials\n  }) : fetch2(api, {\n    method: \"POST\",\n    body: JSON.stringify(body),\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...headers\n    },\n    signal: (_b = abortController == null ? void 0 : abortController()) == null ? void 0 : _b.signal,\n    credentials\n  });\n  const response = await request.catch((err) => {\n    restoreMessagesOnFailure();\n    throw err;\n  });\n  if (onResponse) {\n    try {\n      await onResponse(response);\n    } catch (err) {\n      throw err;\n    }\n  }\n  if (!response.ok) {\n    restoreMessagesOnFailure();\n    throw new Error(\n      (_c = await response.text()) != null ? _c : \"Failed to fetch the chat response.\"\n    );\n  }\n  if (!response.body) {\n    throw new Error(\"The response body is empty.\");\n  }\n  switch (streamProtocol) {\n    case \"text\": {\n      await processChatTextResponse({\n        stream: response.body,\n        update: onUpdate,\n        onFinish,\n        generateId: generateId2\n      });\n      return;\n    }\n    case \"data\": {\n      await processChatResponse({\n        stream: response.body,\n        update: onUpdate,\n        lastMessage,\n        onToolCall,\n        onFinish({ message, finishReason, usage }) {\n          if (onFinish && message != null) {\n            onFinish(message, { usage, finishReason });\n          }\n        },\n        generateId: generateId2\n      });\n      return;\n    }\n    default: {\n      const exhaustiveCheck = streamProtocol;\n      throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n    }\n  }\n}\n\n// src/call-completion-api.ts\nvar getOriginalFetch2 = () => fetch;\nasync function callCompletionApi({\n  api,\n  prompt,\n  credentials,\n  headers,\n  body,\n  streamProtocol = \"data\",\n  setCompletion,\n  setLoading,\n  setError,\n  setAbortController,\n  onResponse,\n  onFinish,\n  onError,\n  onData,\n  fetch: fetch2 = getOriginalFetch2()\n}) {\n  var _a;\n  try {\n    setLoading(true);\n    setError(void 0);\n    const abortController = new AbortController();\n    setAbortController(abortController);\n    setCompletion(\"\");\n    const response = await fetch2(api, {\n      method: \"POST\",\n      body: JSON.stringify({\n        prompt,\n        ...body\n      }),\n      credentials,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...headers\n      },\n      signal: abortController.signal\n    }).catch((err) => {\n      throw err;\n    });\n    if (onResponse) {\n      try {\n        await onResponse(response);\n      } catch (err) {\n        throw err;\n      }\n    }\n    if (!response.ok) {\n      throw new Error(\n        (_a = await response.text()) != null ? _a : \"Failed to fetch the chat response.\"\n      );\n    }\n    if (!response.body) {\n      throw new Error(\"The response body is empty.\");\n    }\n    let result = \"\";\n    switch (streamProtocol) {\n      case \"text\": {\n        await processTextStream({\n          stream: response.body,\n          onTextPart: (chunk) => {\n            result += chunk;\n            setCompletion(result);\n          }\n        });\n        break;\n      }\n      case \"data\": {\n        await processDataStream({\n          stream: response.body,\n          onTextPart(value) {\n            result += value;\n            setCompletion(result);\n          },\n          onDataPart(value) {\n            onData == null ? void 0 : onData(value);\n          },\n          onErrorPart(value) {\n            throw new Error(value);\n          }\n        });\n        break;\n      }\n      default: {\n        const exhaustiveCheck = streamProtocol;\n        throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n      }\n    }\n    if (onFinish) {\n      onFinish(prompt, result);\n    }\n    setAbortController(null);\n    return result;\n  } catch (err) {\n    if (err.name === \"AbortError\") {\n      setAbortController(null);\n      return null;\n    }\n    if (err instanceof Error) {\n      if (onError) {\n        onError(err);\n      }\n    }\n    setError(err);\n  } finally {\n    setLoading(false);\n  }\n}\n\n// src/data-url.ts\nfunction getTextFromDataUrl(dataUrl) {\n  const [header, base64Content] = dataUrl.split(\",\");\n  const mimeType = header.split(\";\")[0].split(\":\")[1];\n  if (mimeType == null || base64Content == null) {\n    throw new Error(\"Invalid data URL format\");\n  }\n  try {\n    return window.atob(base64Content);\n  } catch (error) {\n    throw new Error(`Error decoding data URL`);\n  }\n}\n\n// src/extract-max-tool-invocation-step.ts\nfunction extractMaxToolInvocationStep(toolInvocations) {\n  return toolInvocations == null ? void 0 : toolInvocations.reduce((max, toolInvocation) => {\n    var _a;\n    return Math.max(max, (_a = toolInvocation.step) != null ? _a : 0);\n  }, 0);\n}\n\n// src/get-message-parts.ts\nfunction getMessageParts(message) {\n  var _a;\n  return (_a = message.parts) != null ? _a : [\n    ...message.toolInvocations ? message.toolInvocations.map((toolInvocation) => ({\n      type: \"tool-invocation\",\n      toolInvocation\n    })) : [],\n    ...message.reasoning ? [\n      {\n        type: \"reasoning\",\n        reasoning: message.reasoning,\n        details: [{ type: \"text\", text: message.reasoning }]\n      }\n    ] : [],\n    ...message.content ? [{ type: \"text\", text: message.content }] : []\n  ];\n}\n\n// src/fill-message-parts.ts\nfunction fillMessageParts(messages) {\n  return messages.map((message) => ({\n    ...message,\n    parts: getMessageParts(message)\n  }));\n}\n\n// src/is-deep-equal-data.ts\nfunction isDeepEqualData(obj1, obj2) {\n  if (obj1 === obj2)\n    return true;\n  if (obj1 == null || obj2 == null)\n    return false;\n  if (typeof obj1 !== \"object\" && typeof obj2 !== \"object\")\n    return obj1 === obj2;\n  if (obj1.constructor !== obj2.constructor)\n    return false;\n  if (obj1 instanceof Date && obj2 instanceof Date) {\n    return obj1.getTime() === obj2.getTime();\n  }\n  if (Array.isArray(obj1)) {\n    if (obj1.length !== obj2.length)\n      return false;\n    for (let i = 0; i < obj1.length; i++) {\n      if (!isDeepEqualData(obj1[i], obj2[i]))\n        return false;\n    }\n    return true;\n  }\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n  if (keys1.length !== keys2.length)\n    return false;\n  for (const key of keys1) {\n    if (!keys2.includes(key))\n      return false;\n    if (!isDeepEqualData(obj1[key], obj2[key]))\n      return false;\n  }\n  return true;\n}\n\n// src/prepare-attachments-for-request.ts\nasync function prepareAttachmentsForRequest(attachmentsFromOptions) {\n  if (!attachmentsFromOptions) {\n    return [];\n  }\n  if (globalThis.FileList && attachmentsFromOptions instanceof globalThis.FileList) {\n    return Promise.all(\n      Array.from(attachmentsFromOptions).map(async (attachment) => {\n        const { name, type } = attachment;\n        const dataUrl = await new Promise((resolve, reject) => {\n          const reader = new FileReader();\n          reader.onload = (readerEvent) => {\n            var _a;\n            resolve((_a = readerEvent.target) == null ? void 0 : _a.result);\n          };\n          reader.onerror = (error) => reject(error);\n          reader.readAsDataURL(attachment);\n        });\n        return {\n          name,\n          contentType: type,\n          url: dataUrl\n        };\n      })\n    );\n  }\n  if (Array.isArray(attachmentsFromOptions)) {\n    return attachmentsFromOptions;\n  }\n  throw new Error(\"Invalid attachments type\");\n}\n\n// src/process-assistant-stream.ts\nvar NEWLINE2 = \"\\n\".charCodeAt(0);\nfunction concatChunks2(chunks, totalLength) {\n  const concatenatedChunks = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const chunk of chunks) {\n    concatenatedChunks.set(chunk, offset);\n    offset += chunk.length;\n  }\n  chunks.length = 0;\n  return concatenatedChunks;\n}\nasync function processAssistantStream({\n  stream,\n  onTextPart,\n  onErrorPart,\n  onAssistantMessagePart,\n  onAssistantControlDataPart,\n  onDataMessagePart\n}) {\n  const reader = stream.getReader();\n  const decoder = new TextDecoder();\n  const chunks = [];\n  let totalLength = 0;\n  while (true) {\n    const { value } = await reader.read();\n    if (value) {\n      chunks.push(value);\n      totalLength += value.length;\n      if (value[value.length - 1] !== NEWLINE2) {\n        continue;\n      }\n    }\n    if (chunks.length === 0) {\n      break;\n    }\n    const concatenatedChunks = concatChunks2(chunks, totalLength);\n    totalLength = 0;\n    const streamParts = decoder.decode(concatenatedChunks, { stream: true }).split(\"\\n\").filter((line) => line !== \"\").map(parseAssistantStreamPart);\n    for (const { type, value: value2 } of streamParts) {\n      switch (type) {\n        case \"text\":\n          await (onTextPart == null ? void 0 : onTextPart(value2));\n          break;\n        case \"error\":\n          await (onErrorPart == null ? void 0 : onErrorPart(value2));\n          break;\n        case \"assistant_message\":\n          await (onAssistantMessagePart == null ? void 0 : onAssistantMessagePart(value2));\n          break;\n        case \"assistant_control_data\":\n          await (onAssistantControlDataPart == null ? void 0 : onAssistantControlDataPart(value2));\n          break;\n        case \"data_message\":\n          await (onDataMessagePart == null ? void 0 : onDataMessagePart(value2));\n          break;\n        default: {\n          const exhaustiveCheck = type;\n          throw new Error(`Unknown stream part type: ${exhaustiveCheck}`);\n        }\n      }\n    }\n  }\n}\n\n// src/schema.ts\n\n\n// src/zod-schema.ts\n\nfunction zodSchema(zodSchema2, options) {\n  var _a;\n  const useReferences = (_a = options == null ? void 0 : options.useReferences) != null ? _a : false;\n  return jsonSchema(\n    (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(zodSchema2, {\n      $refStrategy: useReferences ? \"root\" : \"none\",\n      target: \"jsonSchema7\"\n      // note: openai mode breaks various gemini conversions\n    }),\n    {\n      validate: (value) => {\n        const result = zodSchema2.safeParse(value);\n        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };\n      }\n    }\n  );\n}\n\n// src/schema.ts\nvar schemaSymbol = Symbol.for(\"vercel.ai.schema\");\nfunction jsonSchema(jsonSchema2, {\n  validate\n} = {}) {\n  return {\n    [schemaSymbol]: true,\n    _type: void 0,\n    // should never be used directly\n    [_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.validatorSymbol]: true,\n    jsonSchema: jsonSchema2,\n    validate\n  };\n}\nfunction isSchema(value) {\n  return typeof value === \"object\" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && \"jsonSchema\" in value && \"validate\" in value;\n}\nfunction asSchema(schema) {\n  return isSchema(schema) ? schema : zodSchema(schema);\n}\n\n// src/should-resubmit-messages.ts\nfunction shouldResubmitMessages({\n  originalMaxToolInvocationStep,\n  originalMessageCount,\n  maxSteps,\n  messages\n}) {\n  var _a;\n  const lastMessage = messages[messages.length - 1];\n  return (\n    // check if the feature is enabled:\n    maxSteps > 1 && // ensure there is a last message:\n    lastMessage != null && // ensure we actually have new steps (to prevent infinite loops in case of errors):\n    (messages.length > originalMessageCount || extractMaxToolInvocationStep(lastMessage.toolInvocations) !== originalMaxToolInvocationStep) && // check that next step is possible:\n    isAssistantMessageWithCompletedToolCalls(lastMessage) && // limit the number of automatic steps:\n    ((_a = extractMaxToolInvocationStep(lastMessage.toolInvocations)) != null ? _a : 0) < maxSteps\n  );\n}\nfunction isAssistantMessageWithCompletedToolCalls(message) {\n  if (message.role !== \"assistant\") {\n    return false;\n  }\n  const lastStepStartIndex = message.parts.reduce((lastIndex, part, index) => {\n    return part.type === \"step-start\" ? index : lastIndex;\n  }, -1);\n  const lastStepToolInvocations = message.parts.slice(lastStepStartIndex + 1).filter((part) => part.type === \"tool-invocation\");\n  return lastStepToolInvocations.length > 0 && lastStepToolInvocations.every((part) => \"result\" in part.toolInvocation);\n}\n\n// src/update-tool-call-result.ts\nfunction updateToolCallResult({\n  messages,\n  toolCallId,\n  toolResult: result\n}) {\n  var _a;\n  const lastMessage = messages[messages.length - 1];\n  const invocationPart = lastMessage.parts.find(\n    (part) => part.type === \"tool-invocation\" && part.toolInvocation.toolCallId === toolCallId\n  );\n  if (invocationPart == null) {\n    return;\n  }\n  const toolResult = {\n    ...invocationPart.toolInvocation,\n    state: \"result\",\n    result\n  };\n  invocationPart.toolInvocation = toolResult;\n  lastMessage.toolInvocations = (_a = lastMessage.toolInvocations) == null ? void 0 : _a.map(\n    (toolInvocation) => toolInvocation.toolCallId === toolCallId ? toolResult : toolInvocation\n  );\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFpLXNkay91aS11dGlscy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDb0Q7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxPQUFPO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxLQUFLO0FBQ3REO0FBQ0EsWUFBWSxnQkFBZ0IsR0FBRztBQUMvQjtBQUNBOztBQUVBO0FBQzBFOztBQUUxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDdUQ7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGVBQWUscUVBQWEsR0FBRyxnQkFBZ0I7QUFDL0M7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXLHFFQUFhLEdBQUcseUJBQXlCO0FBQ3BEO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUNBQXFDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxPQUFPO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxLQUFLO0FBQ3REO0FBQ0EsWUFBWSxnQkFBZ0IsR0FBRztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGdCQUFnQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4REFBa0I7QUFDOUM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFCQUFxQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsaUJBQWlCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFH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QyxJQUFJO0FBQzFFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLG1FQUFlO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXlCRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmxlZXRmbG93Ly4vbm9kZV9tb2R1bGVzL0BhaS1zZGsvdWktdXRpbHMvZGlzdC9pbmRleC5tanM/NWQ2MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW5kZXgudHNcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvYXNzaXN0YW50LXN0cmVhbS1wYXJ0cy50c1xudmFyIHRleHRTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjBcIixcbiAgbmFtZTogXCJ0ZXh0XCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1widGV4dFwiIHBhcnRzIGV4cGVjdCBhIHN0cmluZyB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgZXJyb3JTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjNcIixcbiAgbmFtZTogXCJlcnJvclwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImVycm9yXCIgcGFydHMgZXhwZWN0IGEgc3RyaW5nIHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiNFwiLFxuICBuYW1lOiBcImFzc2lzdGFudF9tZXNzYWdlXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcImlkXCIgaW4gdmFsdWUpIHx8ICEoXCJyb2xlXCIgaW4gdmFsdWUpIHx8ICEoXCJjb250ZW50XCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5pZCAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUucm9sZSAhPT0gXCJzdHJpbmdcIiB8fCB2YWx1ZS5yb2xlICE9PSBcImFzc2lzdGFudFwiIHx8ICFBcnJheS5pc0FycmF5KHZhbHVlLmNvbnRlbnQpIHx8ICF2YWx1ZS5jb250ZW50LmV2ZXJ5KFxuICAgICAgKGl0ZW0pID0+IGl0ZW0gIT0gbnVsbCAmJiB0eXBlb2YgaXRlbSA9PT0gXCJvYmplY3RcIiAmJiBcInR5cGVcIiBpbiBpdGVtICYmIGl0ZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiYgXCJ0ZXh0XCIgaW4gaXRlbSAmJiBpdGVtLnRleHQgIT0gbnVsbCAmJiB0eXBlb2YgaXRlbS50ZXh0ID09PSBcIm9iamVjdFwiICYmIFwidmFsdWVcIiBpbiBpdGVtLnRleHQgJiYgdHlwZW9mIGl0ZW0udGV4dC52YWx1ZSA9PT0gXCJzdHJpbmdcIlxuICAgICkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiYXNzaXN0YW50X21lc3NhZ2VcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYW4gXCJpZFwiLCBcInJvbGVcIiwgYW5kIFwiY29udGVudFwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImFzc2lzdGFudF9tZXNzYWdlXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjVcIixcbiAgbmFtZTogXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcInRocmVhZElkXCIgaW4gdmFsdWUpIHx8ICEoXCJtZXNzYWdlSWRcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnRocmVhZElkICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZS5tZXNzYWdlSWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwidGhyZWFkSWRcIiBhbmQgXCJtZXNzYWdlSWRcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIsXG4gICAgICB2YWx1ZToge1xuICAgICAgICB0aHJlYWRJZDogdmFsdWUudGhyZWFkSWQsXG4gICAgICAgIG1lc3NhZ2VJZDogdmFsdWUubWVzc2FnZUlkXG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbnZhciBkYXRhTWVzc2FnZVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiNlwiLFxuICBuYW1lOiBcImRhdGFfbWVzc2FnZVwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJyb2xlXCIgaW4gdmFsdWUpIHx8ICEoXCJkYXRhXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5yb2xlICE9PSBcInN0cmluZ1wiIHx8IHZhbHVlLnJvbGUgIT09IFwiZGF0YVwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImRhdGFfbWVzc2FnZVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwicm9sZVwiIGFuZCBcImRhdGFcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJkYXRhX21lc3NhZ2VcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxufTtcbnZhciBhc3Npc3RhbnRTdHJlYW1QYXJ0cyA9IFtcbiAgdGV4dFN0cmVhbVBhcnQsXG4gIGVycm9yU3RyZWFtUGFydCxcbiAgYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQsXG4gIGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCxcbiAgZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0XG5dO1xudmFyIGFzc2lzdGFudFN0cmVhbVBhcnRzQnlDb2RlID0ge1xuICBbdGV4dFN0cmVhbVBhcnQuY29kZV06IHRleHRTdHJlYW1QYXJ0LFxuICBbZXJyb3JTdHJlYW1QYXJ0LmNvZGVdOiBlcnJvclN0cmVhbVBhcnQsXG4gIFthc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5jb2RlXTogYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQsXG4gIFthc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQuY29kZV06IGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCxcbiAgW2RhdGFNZXNzYWdlU3RyZWFtUGFydC5jb2RlXTogZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0XG59O1xudmFyIFN0cmVhbVN0cmluZ1ByZWZpeGVzID0ge1xuICBbdGV4dFN0cmVhbVBhcnQubmFtZV06IHRleHRTdHJlYW1QYXJ0LmNvZGUsXG4gIFtlcnJvclN0cmVhbVBhcnQubmFtZV06IGVycm9yU3RyZWFtUGFydC5jb2RlLFxuICBbYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQubmFtZV06IGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LmNvZGUsXG4gIFthc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQubmFtZV06IGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydC5jb2RlLFxuICBbZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0Lm5hbWVdOiBkYXRhTWVzc2FnZVN0cmVhbVBhcnQuY29kZVxufTtcbnZhciB2YWxpZENvZGVzID0gYXNzaXN0YW50U3RyZWFtUGFydHMubWFwKChwYXJ0KSA9PiBwYXJ0LmNvZGUpO1xudmFyIHBhcnNlQXNzaXN0YW50U3RyZWFtUGFydCA9IChsaW5lKSA9PiB7XG4gIGNvbnN0IGZpcnN0U2VwYXJhdG9ySW5kZXggPSBsaW5lLmluZGV4T2YoXCI6XCIpO1xuICBpZiAoZmlyc3RTZXBhcmF0b3JJbmRleCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcGFyc2Ugc3RyZWFtIHN0cmluZy4gTm8gc2VwYXJhdG9yIGZvdW5kLlwiKTtcbiAgfVxuICBjb25zdCBwcmVmaXggPSBsaW5lLnNsaWNlKDAsIGZpcnN0U2VwYXJhdG9ySW5kZXgpO1xuICBpZiAoIXZhbGlkQ29kZXMuaW5jbHVkZXMocHJlZml4KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHN0cmVhbSBzdHJpbmcuIEludmFsaWQgY29kZSAke3ByZWZpeH0uYCk7XG4gIH1cbiAgY29uc3QgY29kZSA9IHByZWZpeDtcbiAgY29uc3QgdGV4dFZhbHVlID0gbGluZS5zbGljZShmaXJzdFNlcGFyYXRvckluZGV4ICsgMSk7XG4gIGNvbnN0IGpzb25WYWx1ZSA9IEpTT04ucGFyc2UodGV4dFZhbHVlKTtcbiAgcmV0dXJuIGFzc2lzdGFudFN0cmVhbVBhcnRzQnlDb2RlW2NvZGVdLnBhcnNlKGpzb25WYWx1ZSk7XG59O1xuZnVuY3Rpb24gZm9ybWF0QXNzaXN0YW50U3RyZWFtUGFydCh0eXBlLCB2YWx1ZSkge1xuICBjb25zdCBzdHJlYW1QYXJ0ID0gYXNzaXN0YW50U3RyZWFtUGFydHMuZmluZCgocGFydCkgPT4gcGFydC5uYW1lID09PSB0eXBlKTtcbiAgaWYgKCFzdHJlYW1QYXJ0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0cmVhbSBwYXJ0IHR5cGU6ICR7dHlwZX1gKTtcbiAgfVxuICByZXR1cm4gYCR7c3RyZWFtUGFydC5jb2RlfToke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1cbmA7XG59XG5cbi8vIHNyYy9wcm9jZXNzLWNoYXQtcmVzcG9uc2UudHNcbmltcG9ydCB7IGdlbmVyYXRlSWQgYXMgZ2VuZXJhdGVJZEZ1bmN0aW9uIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL2R1cGxpY2F0ZWQvdXNhZ2UudHNcbmZ1bmN0aW9uIGNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZSh7XG4gIHByb21wdFRva2VucyxcbiAgY29tcGxldGlvblRva2Vuc1xufSkge1xuICByZXR1cm4ge1xuICAgIHByb21wdFRva2VucyxcbiAgICBjb21wbGV0aW9uVG9rZW5zLFxuICAgIHRvdGFsVG9rZW5zOiBwcm9tcHRUb2tlbnMgKyBjb21wbGV0aW9uVG9rZW5zXG4gIH07XG59XG5cbi8vIHNyYy9wYXJzZS1wYXJ0aWFsLWpzb24udHNcbmltcG9ydCB7IHNhZmVQYXJzZUpTT04gfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvZml4LWpzb24udHNcbmZ1bmN0aW9uIGZpeEpzb24oaW5wdXQpIHtcbiAgY29uc3Qgc3RhY2sgPSBbXCJST09UXCJdO1xuICBsZXQgbGFzdFZhbGlkSW5kZXggPSAtMTtcbiAgbGV0IGxpdGVyYWxTdGFydCA9IG51bGw7XG4gIGZ1bmN0aW9uIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIHN3YXBTdGF0ZSkge1xuICAgIHtcbiAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICBjYXNlICdcIic6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfU1RSSU5HXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJmXCI6XG4gICAgICAgIGNhc2UgXCJ0XCI6XG4gICAgICAgIGNhc2UgXCJuXCI6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgbGl0ZXJhbFN0YXJ0ID0gaTtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBzdGFjay5wdXNoKHN3YXBTdGF0ZSk7XG4gICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9MSVRFUkFMXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCItXCI6IHtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBzdGFjay5wdXNoKHN3YXBTdGF0ZSk7XG4gICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9OVU1CRVJcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIjBcIjpcbiAgICAgICAgY2FzZSBcIjFcIjpcbiAgICAgICAgY2FzZSBcIjJcIjpcbiAgICAgICAgY2FzZSBcIjNcIjpcbiAgICAgICAgY2FzZSBcIjRcIjpcbiAgICAgICAgY2FzZSBcIjVcIjpcbiAgICAgICAgY2FzZSBcIjZcIjpcbiAgICAgICAgY2FzZSBcIjdcIjpcbiAgICAgICAgY2FzZSBcIjhcIjpcbiAgICAgICAgY2FzZSBcIjlcIjoge1xuICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBzdGFjay5wdXNoKHN3YXBTdGF0ZSk7XG4gICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9OVU1CRVJcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIntcIjoge1xuICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBzdGFjay5wdXNoKHN3YXBTdGF0ZSk7XG4gICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfU1RBUlRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIltcIjoge1xuICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBzdGFjay5wdXNoKHN3YXBTdGF0ZSk7XG4gICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9BUlJBWV9TVEFSVFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwcm9jZXNzQWZ0ZXJPYmplY3RWYWx1ZShjaGFyLCBpKSB7XG4gICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICBjYXNlIFwiLFwiOiB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX09CSkVDVF9BRlRFUl9DT01NQVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwifVwiOiB7XG4gICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwcm9jZXNzQWZ0ZXJBcnJheVZhbHVlKGNoYXIsIGkpIHtcbiAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgIGNhc2UgXCIsXCI6IHtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfQVJSQVlfQUZURVJfQ09NTUFcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIl1cIjoge1xuICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoYXIgPSBpbnB1dFtpXTtcbiAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICBzd2l0Y2ggKGN1cnJlbnRTdGF0ZSkge1xuICAgICAgY2FzZSBcIlJPT1RcIjpcbiAgICAgICAgcHJvY2Vzc1ZhbHVlU3RhcnQoY2hhciwgaSwgXCJGSU5JU0hcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfU1RBUlRcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlICdcIic6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfS0VZXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ9XCI6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQUZURVJfQ09NTUFcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlICdcIic6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfS0VZXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfS0VZXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0FGVEVSX0tFWVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX0tFWVwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgXCI6XCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfQkVGT1JFX1ZBTFVFXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQkVGT1JFX1ZBTFVFXCI6IHtcbiAgICAgICAgcHJvY2Vzc1ZhbHVlU3RhcnQoY2hhciwgaSwgXCJJTlNJREVfT0JKRUNUX0FGVEVSX1ZBTFVFXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX1ZBTFVFXCI6IHtcbiAgICAgICAgcHJvY2Vzc0FmdGVyT2JqZWN0VmFsdWUoY2hhciwgaSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9TVFJJTkdcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlICdcIic6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJcXFxcXCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfU1RSSU5HX0VTQ0FQRVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9BUlJBWV9TVEFSVFwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgXCJdXCI6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgXCIsXCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9BUlJBWV9BRlRFUl9DT01NQVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiXVwiOiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX0FGVEVSX0NPTU1BXCI6IHtcbiAgICAgICAgcHJvY2Vzc1ZhbHVlU3RhcnQoY2hhciwgaSwgXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9TVFJJTkdfRVNDQVBFXCI6IHtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX05VTUJFUlwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgXCIwXCI6XG4gICAgICAgICAgY2FzZSBcIjFcIjpcbiAgICAgICAgICBjYXNlIFwiMlwiOlxuICAgICAgICAgIGNhc2UgXCIzXCI6XG4gICAgICAgICAgY2FzZSBcIjRcIjpcbiAgICAgICAgICBjYXNlIFwiNVwiOlxuICAgICAgICAgIGNhc2UgXCI2XCI6XG4gICAgICAgICAgY2FzZSBcIjdcIjpcbiAgICAgICAgICBjYXNlIFwiOFwiOlxuICAgICAgICAgIGNhc2UgXCI5XCI6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiZVwiOlxuICAgICAgICAgIGNhc2UgXCJFXCI6XG4gICAgICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgICBjYXNlIFwiLlwiOiB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIixcIjoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCIpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzc0FmdGVyQXJyYXlWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJJTlNJREVfT0JKRUNUX0FGVEVSX1ZBTFVFXCIpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzc0FmdGVyT2JqZWN0VmFsdWUoY2hhciwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIn1cIjoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3NBZnRlck9iamVjdFZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJdXCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3NBZnRlckFycmF5VmFsdWUoY2hhciwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX0xJVEVSQUxcIjoge1xuICAgICAgICBjb25zdCBwYXJ0aWFsTGl0ZXJhbCA9IGlucHV0LnN1YnN0cmluZyhsaXRlcmFsU3RhcnQsIGkgKyAxKTtcbiAgICAgICAgaWYgKCFcImZhbHNlXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkgJiYgIVwidHJ1ZVwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpICYmICFcIm51bGxcIi5zdGFydHNXaXRoKHBhcnRpYWxMaXRlcmFsKSkge1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJJTlNJREVfT0JKRUNUX0FGVEVSX1ZBTFVFXCIpIHtcbiAgICAgICAgICAgIHByb2Nlc3NBZnRlck9iamVjdFZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCIpIHtcbiAgICAgICAgICAgIHByb2Nlc3NBZnRlckFycmF5VmFsdWUoY2hhciwgaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IHJlc3VsdCA9IGlucHV0LnNsaWNlKDAsIGxhc3RWYWxpZEluZGV4ICsgMSk7XG4gIGZvciAobGV0IGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IHN0YXRlID0gc3RhY2tbaV07XG4gICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgY2FzZSBcIklOU0lERV9TVFJJTkdcIjoge1xuICAgICAgICByZXN1bHQgKz0gJ1wiJztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9LRVlcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX0tFWVwiOlxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQUZURVJfQ09NTUFcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX1NUQVJUXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9CRUZPUkVfVkFMVUVcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX1ZBTFVFXCI6IHtcbiAgICAgICAgcmVzdWx0ICs9IFwifVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfU1RBUlRcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfQUZURVJfQ09NTUFcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIjoge1xuICAgICAgICByZXN1bHQgKz0gXCJdXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9MSVRFUkFMXCI6IHtcbiAgICAgICAgY29uc3QgcGFydGlhbExpdGVyYWwgPSBpbnB1dC5zdWJzdHJpbmcobGl0ZXJhbFN0YXJ0LCBpbnB1dC5sZW5ndGgpO1xuICAgICAgICBpZiAoXCJ0cnVlXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkpIHtcbiAgICAgICAgICByZXN1bHQgKz0gXCJ0cnVlXCIuc2xpY2UocGFydGlhbExpdGVyYWwubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmIChcImZhbHNlXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkpIHtcbiAgICAgICAgICByZXN1bHQgKz0gXCJmYWxzZVwiLnNsaWNlKHBhcnRpYWxMaXRlcmFsLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoXCJudWxsXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkpIHtcbiAgICAgICAgICByZXN1bHQgKz0gXCJudWxsXCIuc2xpY2UocGFydGlhbExpdGVyYWwubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBzcmMvcGFyc2UtcGFydGlhbC1qc29uLnRzXG5mdW5jdGlvbiBwYXJzZVBhcnRpYWxKc29uKGpzb25UZXh0KSB7XG4gIGlmIChqc29uVGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHZvaWQgMCwgc3RhdGU6IFwidW5kZWZpbmVkLWlucHV0XCIgfTtcbiAgfVxuICBsZXQgcmVzdWx0ID0gc2FmZVBhcnNlSlNPTih7IHRleHQ6IGpzb25UZXh0IH0pO1xuICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogcmVzdWx0LnZhbHVlLCBzdGF0ZTogXCJzdWNjZXNzZnVsLXBhcnNlXCIgfTtcbiAgfVxuICByZXN1bHQgPSBzYWZlUGFyc2VKU09OKHsgdGV4dDogZml4SnNvbihqc29uVGV4dCkgfSk7XG4gIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgIHJldHVybiB7IHZhbHVlOiByZXN1bHQudmFsdWUsIHN0YXRlOiBcInJlcGFpcmVkLXBhcnNlXCIgfTtcbiAgfVxuICByZXR1cm4geyB2YWx1ZTogdm9pZCAwLCBzdGF0ZTogXCJmYWlsZWQtcGFyc2VcIiB9O1xufVxuXG4vLyBzcmMvZGF0YS1zdHJlYW0tcGFydHMudHNcbnZhciB0ZXh0U3RyZWFtUGFydDIgPSB7XG4gIGNvZGU6IFwiMFwiLFxuICBuYW1lOiBcInRleHRcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJ0ZXh0XCIgcGFydHMgZXhwZWN0IGEgc3RyaW5nIHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcInRleHRcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBkYXRhU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCIyXCIsXG4gIG5hbWU6IFwiZGF0YVwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImRhdGFcIiBwYXJ0cyBleHBlY3QgYW4gYXJyYXkgdmFsdWUuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwiZGF0YVwiLCB2YWx1ZSB9O1xuICB9XG59O1xudmFyIGVycm9yU3RyZWFtUGFydDIgPSB7XG4gIGNvZGU6IFwiM1wiLFxuICBuYW1lOiBcImVycm9yXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiZXJyb3JcIiBwYXJ0cyBleHBlY3QgYSBzdHJpbmcgdmFsdWUuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjhcIixcbiAgbmFtZTogXCJtZXNzYWdlX2Fubm90YXRpb25zXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wibWVzc2FnZV9hbm5vdGF0aW9uc1wiIHBhcnRzIGV4cGVjdCBhbiBhcnJheSB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJtZXNzYWdlX2Fubm90YXRpb25zXCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgdG9vbENhbGxTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjlcIixcbiAgbmFtZTogXCJ0b29sX2NhbGxcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwidG9vbENhbGxJZFwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUudG9vbENhbGxJZCAhPT0gXCJzdHJpbmdcIiB8fCAhKFwidG9vbE5hbWVcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnRvb2xOYW1lICE9PSBcInN0cmluZ1wiIHx8ICEoXCJhcmdzXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5hcmdzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcInRvb2xfY2FsbFwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwidG9vbENhbGxJZFwiLCBcInRvb2xOYW1lXCIsIGFuZCBcImFyZ3NcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0b29sX2NhbGxcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxufTtcbnZhciB0b29sUmVzdWx0U3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCJhXCIsXG4gIG5hbWU6IFwidG9vbF9yZXN1bHRcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwidG9vbENhbGxJZFwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUudG9vbENhbGxJZCAhPT0gXCJzdHJpbmdcIiB8fCAhKFwicmVzdWx0XCIgaW4gdmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcInRvb2xfcmVzdWx0XCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJ0b29sQ2FsbElkXCIgYW5kIGEgXCJyZXN1bHRcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0b29sX3Jlc3VsdFwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIHRvb2xDYWxsU3RyZWFtaW5nU3RhcnRTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcImJcIixcbiAgbmFtZTogXCJ0b29sX2NhbGxfc3RyZWFtaW5nX3N0YXJ0XCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcInRvb2xDYWxsSWRcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnRvb2xDYWxsSWQgIT09IFwic3RyaW5nXCIgfHwgIShcInRvb2xOYW1lXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS50b29sTmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJ0b29sX2NhbGxfc3RyZWFtaW5nX3N0YXJ0XCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJ0b29sQ2FsbElkXCIgYW5kIFwidG9vbE5hbWVcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0b29sX2NhbGxfc3RyZWFtaW5nX3N0YXJ0XCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgdG9vbENhbGxEZWx0YVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiY1wiLFxuICBuYW1lOiBcInRvb2xfY2FsbF9kZWx0YVwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJ0b29sQ2FsbElkXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS50b29sQ2FsbElkICE9PSBcInN0cmluZ1wiIHx8ICEoXCJhcmdzVGV4dERlbHRhXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5hcmdzVGV4dERlbHRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcInRvb2xfY2FsbF9kZWx0YVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwidG9vbENhbGxJZFwiIGFuZCBcImFyZ3NUZXh0RGVsdGFcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0b29sX2NhbGxfZGVsdGFcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxufTtcbnZhciBmaW5pc2hNZXNzYWdlU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCJkXCIsXG4gIG5hbWU6IFwiZmluaXNoX21lc3NhZ2VcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwiZmluaXNoUmVhc29uXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5maW5pc2hSZWFzb24gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiZmluaXNoX21lc3NhZ2VcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcImZpbmlzaFJlYXNvblwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIGZpbmlzaFJlYXNvbjogdmFsdWUuZmluaXNoUmVhc29uXG4gICAgfTtcbiAgICBpZiAoXCJ1c2FnZVwiIGluIHZhbHVlICYmIHZhbHVlLnVzYWdlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnVzYWdlID09PSBcIm9iamVjdFwiICYmIFwicHJvbXB0VG9rZW5zXCIgaW4gdmFsdWUudXNhZ2UgJiYgXCJjb21wbGV0aW9uVG9rZW5zXCIgaW4gdmFsdWUudXNhZ2UpIHtcbiAgICAgIHJlc3VsdC51c2FnZSA9IHtcbiAgICAgICAgcHJvbXB0VG9rZW5zOiB0eXBlb2YgdmFsdWUudXNhZ2UucHJvbXB0VG9rZW5zID09PSBcIm51bWJlclwiID8gdmFsdWUudXNhZ2UucHJvbXB0VG9rZW5zIDogTnVtYmVyLk5hTixcbiAgICAgICAgY29tcGxldGlvblRva2VuczogdHlwZW9mIHZhbHVlLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnMgPT09IFwibnVtYmVyXCIgPyB2YWx1ZS51c2FnZS5jb21wbGV0aW9uVG9rZW5zIDogTnVtYmVyLk5hTlxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZmluaXNoX21lc3NhZ2VcIixcbiAgICAgIHZhbHVlOiByZXN1bHRcbiAgICB9O1xuICB9XG59O1xudmFyIGZpbmlzaFN0ZXBTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcImVcIixcbiAgbmFtZTogXCJmaW5pc2hfc3RlcFwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJmaW5pc2hSZWFzb25cIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmZpbmlzaFJlYXNvbiAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJmaW5pc2hfc3RlcFwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwiZmluaXNoUmVhc29uXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgZmluaXNoUmVhc29uOiB2YWx1ZS5maW5pc2hSZWFzb24sXG4gICAgICBpc0NvbnRpbnVlZDogZmFsc2VcbiAgICB9O1xuICAgIGlmIChcInVzYWdlXCIgaW4gdmFsdWUgJiYgdmFsdWUudXNhZ2UgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudXNhZ2UgPT09IFwib2JqZWN0XCIgJiYgXCJwcm9tcHRUb2tlbnNcIiBpbiB2YWx1ZS51c2FnZSAmJiBcImNvbXBsZXRpb25Ub2tlbnNcIiBpbiB2YWx1ZS51c2FnZSkge1xuICAgICAgcmVzdWx0LnVzYWdlID0ge1xuICAgICAgICBwcm9tcHRUb2tlbnM6IHR5cGVvZiB2YWx1ZS51c2FnZS5wcm9tcHRUb2tlbnMgPT09IFwibnVtYmVyXCIgPyB2YWx1ZS51c2FnZS5wcm9tcHRUb2tlbnMgOiBOdW1iZXIuTmFOLFxuICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiB0eXBlb2YgdmFsdWUudXNhZ2UuY29tcGxldGlvblRva2VucyA9PT0gXCJudW1iZXJcIiA/IHZhbHVlLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnMgOiBOdW1iZXIuTmFOXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoXCJpc0NvbnRpbnVlZFwiIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5pc0NvbnRpbnVlZCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJlc3VsdC5pc0NvbnRpbnVlZCA9IHZhbHVlLmlzQ29udGludWVkO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJmaW5pc2hfc3RlcFwiLFxuICAgICAgdmFsdWU6IHJlc3VsdFxuICAgIH07XG4gIH1cbn07XG52YXIgc3RhcnRTdGVwU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCJmXCIsXG4gIG5hbWU6IFwic3RhcnRfc3RlcFwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJtZXNzYWdlSWRcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLm1lc3NhZ2VJZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJzdGFydF9zdGVwXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGFuIFwiaWRcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzdGFydF9zdGVwXCIsXG4gICAgICB2YWx1ZToge1xuICAgICAgICBtZXNzYWdlSWQ6IHZhbHVlLm1lc3NhZ2VJZFxuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG52YXIgcmVhc29uaW5nU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCJnXCIsXG4gIG5hbWU6IFwicmVhc29uaW5nXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wicmVhc29uaW5nXCIgcGFydHMgZXhwZWN0IGEgc3RyaW5nIHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcInJlYXNvbmluZ1wiLCB2YWx1ZSB9O1xuICB9XG59O1xudmFyIHNvdXJjZVBhcnQgPSB7XG4gIGNvZGU6IFwiaFwiLFxuICBuYW1lOiBcInNvdXJjZVwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wic291cmNlXCIgcGFydHMgZXhwZWN0IGEgU291cmNlIG9iamVjdC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic291cmNlXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgcmVkYWN0ZWRSZWFzb25pbmdTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcImlcIixcbiAgbmFtZTogXCJyZWRhY3RlZF9yZWFzb25pbmdcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwiZGF0YVwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUuZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJyZWRhY3RlZF9yZWFzb25pbmdcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcImRhdGFcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcInJlZGFjdGVkX3JlYXNvbmluZ1wiLCB2YWx1ZTogeyBkYXRhOiB2YWx1ZS5kYXRhIH0gfTtcbiAgfVxufTtcbnZhciByZWFzb25pbmdTaWduYXR1cmVTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcImpcIixcbiAgbmFtZTogXCJyZWFzb25pbmdfc2lnbmF0dXJlXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcInNpZ25hdHVyZVwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUuc2lnbmF0dXJlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcInJlYXNvbmluZ19zaWduYXR1cmVcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcInNpZ25hdHVyZVwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInJlYXNvbmluZ19zaWduYXR1cmVcIixcbiAgICAgIHZhbHVlOiB7IHNpZ25hdHVyZTogdmFsdWUuc2lnbmF0dXJlIH1cbiAgICB9O1xuICB9XG59O1xudmFyIGZpbGVTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcImtcIixcbiAgbmFtZTogXCJmaWxlXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcImRhdGFcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmRhdGEgIT09IFwic3RyaW5nXCIgfHwgIShcIm1pbWVUeXBlXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5taW1lVHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJmaWxlXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJkYXRhXCIgYW5kIFwibWltZVR5cGVcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcImZpbGVcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBkYXRhU3RyZWFtUGFydHMgPSBbXG4gIHRleHRTdHJlYW1QYXJ0MixcbiAgZGF0YVN0cmVhbVBhcnQsXG4gIGVycm9yU3RyZWFtUGFydDIsXG4gIG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQsXG4gIHRvb2xDYWxsU3RyZWFtUGFydCxcbiAgdG9vbFJlc3VsdFN0cmVhbVBhcnQsXG4gIHRvb2xDYWxsU3RyZWFtaW5nU3RhcnRTdHJlYW1QYXJ0LFxuICB0b29sQ2FsbERlbHRhU3RyZWFtUGFydCxcbiAgZmluaXNoTWVzc2FnZVN0cmVhbVBhcnQsXG4gIGZpbmlzaFN0ZXBTdHJlYW1QYXJ0LFxuICBzdGFydFN0ZXBTdHJlYW1QYXJ0LFxuICByZWFzb25pbmdTdHJlYW1QYXJ0LFxuICBzb3VyY2VQYXJ0LFxuICByZWRhY3RlZFJlYXNvbmluZ1N0cmVhbVBhcnQsXG4gIHJlYXNvbmluZ1NpZ25hdHVyZVN0cmVhbVBhcnQsXG4gIGZpbGVTdHJlYW1QYXJ0XG5dO1xudmFyIGRhdGFTdHJlYW1QYXJ0c0J5Q29kZSA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgZGF0YVN0cmVhbVBhcnRzLm1hcCgocGFydCkgPT4gW3BhcnQuY29kZSwgcGFydF0pXG4pO1xudmFyIERhdGFTdHJlYW1TdHJpbmdQcmVmaXhlcyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgZGF0YVN0cmVhbVBhcnRzLm1hcCgocGFydCkgPT4gW3BhcnQubmFtZSwgcGFydC5jb2RlXSlcbik7XG52YXIgdmFsaWRDb2RlczIgPSBkYXRhU3RyZWFtUGFydHMubWFwKChwYXJ0KSA9PiBwYXJ0LmNvZGUpO1xudmFyIHBhcnNlRGF0YVN0cmVhbVBhcnQgPSAobGluZSkgPT4ge1xuICBjb25zdCBmaXJzdFNlcGFyYXRvckluZGV4ID0gbGluZS5pbmRleE9mKFwiOlwiKTtcbiAgaWYgKGZpcnN0U2VwYXJhdG9ySW5kZXggPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIHN0cmVhbSBzdHJpbmcuIE5vIHNlcGFyYXRvciBmb3VuZC5cIik7XG4gIH1cbiAgY29uc3QgcHJlZml4ID0gbGluZS5zbGljZSgwLCBmaXJzdFNlcGFyYXRvckluZGV4KTtcbiAgaWYgKCF2YWxpZENvZGVzMi5pbmNsdWRlcyhwcmVmaXgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2Ugc3RyZWFtIHN0cmluZy4gSW52YWxpZCBjb2RlICR7cHJlZml4fS5gKTtcbiAgfVxuICBjb25zdCBjb2RlID0gcHJlZml4O1xuICBjb25zdCB0ZXh0VmFsdWUgPSBsaW5lLnNsaWNlKGZpcnN0U2VwYXJhdG9ySW5kZXggKyAxKTtcbiAgY29uc3QganNvblZhbHVlID0gSlNPTi5wYXJzZSh0ZXh0VmFsdWUpO1xuICByZXR1cm4gZGF0YVN0cmVhbVBhcnRzQnlDb2RlW2NvZGVdLnBhcnNlKGpzb25WYWx1ZSk7XG59O1xuZnVuY3Rpb24gZm9ybWF0RGF0YVN0cmVhbVBhcnQodHlwZSwgdmFsdWUpIHtcbiAgY29uc3Qgc3RyZWFtUGFydCA9IGRhdGFTdHJlYW1QYXJ0cy5maW5kKChwYXJ0KSA9PiBwYXJ0Lm5hbWUgPT09IHR5cGUpO1xuICBpZiAoIXN0cmVhbVBhcnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3RyZWFtIHBhcnQgdHlwZTogJHt0eXBlfWApO1xuICB9XG4gIHJldHVybiBgJHtzdHJlYW1QYXJ0LmNvZGV9OiR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfVxuYDtcbn1cblxuLy8gc3JjL3Byb2Nlc3MtZGF0YS1zdHJlYW0udHNcbnZhciBORVdMSU5FID0gXCJcXG5cIi5jaGFyQ29kZUF0KDApO1xuZnVuY3Rpb24gY29uY2F0Q2h1bmtzKGNodW5rcywgdG90YWxMZW5ndGgpIHtcbiAgY29uc3QgY29uY2F0ZW5hdGVkQ2h1bmtzID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICBjb25jYXRlbmF0ZWRDaHVua3Muc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBjaHVuay5sZW5ndGg7XG4gIH1cbiAgY2h1bmtzLmxlbmd0aCA9IDA7XG4gIHJldHVybiBjb25jYXRlbmF0ZWRDaHVua3M7XG59XG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzRGF0YVN0cmVhbSh7XG4gIHN0cmVhbSxcbiAgb25UZXh0UGFydCxcbiAgb25SZWFzb25pbmdQYXJ0LFxuICBvblJlYXNvbmluZ1NpZ25hdHVyZVBhcnQsXG4gIG9uUmVkYWN0ZWRSZWFzb25pbmdQYXJ0LFxuICBvblNvdXJjZVBhcnQsXG4gIG9uRmlsZVBhcnQsXG4gIG9uRGF0YVBhcnQsXG4gIG9uRXJyb3JQYXJ0LFxuICBvblRvb2xDYWxsU3RyZWFtaW5nU3RhcnRQYXJ0LFxuICBvblRvb2xDYWxsRGVsdGFQYXJ0LFxuICBvblRvb2xDYWxsUGFydCxcbiAgb25Ub29sUmVzdWx0UGFydCxcbiAgb25NZXNzYWdlQW5ub3RhdGlvbnNQYXJ0LFxuICBvbkZpbmlzaE1lc3NhZ2VQYXJ0LFxuICBvbkZpbmlzaFN0ZXBQYXJ0LFxuICBvblN0YXJ0U3RlcFBhcnRcbn0pIHtcbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGNvbnN0IGNodW5rcyA9IFtdO1xuICBsZXQgdG90YWxMZW5ndGggPSAwO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHsgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBjaHVua3MucHVzaCh2YWx1ZSk7XG4gICAgICB0b3RhbExlbmd0aCArPSB2YWx1ZS5sZW5ndGg7XG4gICAgICBpZiAodmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gIT09IE5FV0xJTkUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgY29uY2F0ZW5hdGVkQ2h1bmtzID0gY29uY2F0Q2h1bmtzKGNodW5rcywgdG90YWxMZW5ndGgpO1xuICAgIHRvdGFsTGVuZ3RoID0gMDtcbiAgICBjb25zdCBzdHJlYW1QYXJ0cyA9IGRlY29kZXIuZGVjb2RlKGNvbmNhdGVuYXRlZENodW5rcywgeyBzdHJlYW06IHRydWUgfSkuc3BsaXQoXCJcXG5cIikuZmlsdGVyKChsaW5lKSA9PiBsaW5lICE9PSBcIlwiKS5tYXAocGFyc2VEYXRhU3RyZWFtUGFydCk7XG4gICAgZm9yIChjb25zdCB7IHR5cGUsIHZhbHVlOiB2YWx1ZTIgfSBvZiBzdHJlYW1QYXJ0cykge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgICAgYXdhaXQgKG9uVGV4dFBhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uVGV4dFBhcnQodmFsdWUyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZWFzb25pbmdcIjpcbiAgICAgICAgICBhd2FpdCAob25SZWFzb25pbmdQYXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvblJlYXNvbmluZ1BhcnQodmFsdWUyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZWFzb25pbmdfc2lnbmF0dXJlXCI6XG4gICAgICAgICAgYXdhaXQgKG9uUmVhc29uaW5nU2lnbmF0dXJlUGFydCA9PSBudWxsID8gdm9pZCAwIDogb25SZWFzb25pbmdTaWduYXR1cmVQYXJ0KHZhbHVlMikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmVkYWN0ZWRfcmVhc29uaW5nXCI6XG4gICAgICAgICAgYXdhaXQgKG9uUmVkYWN0ZWRSZWFzb25pbmdQYXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvblJlZGFjdGVkUmVhc29uaW5nUGFydCh2YWx1ZTIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImZpbGVcIjpcbiAgICAgICAgICBhd2FpdCAob25GaWxlUGFydCA9PSBudWxsID8gdm9pZCAwIDogb25GaWxlUGFydCh2YWx1ZTIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNvdXJjZVwiOlxuICAgICAgICAgIGF3YWl0IChvblNvdXJjZVBhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uU291cmNlUGFydCh2YWx1ZTIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgICBhd2FpdCAob25EYXRhUGFydCA9PSBudWxsID8gdm9pZCAwIDogb25EYXRhUGFydCh2YWx1ZTIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgYXdhaXQgKG9uRXJyb3JQYXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvbkVycm9yUGFydCh2YWx1ZTIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIjpcbiAgICAgICAgICBhd2FpdCAob25NZXNzYWdlQW5ub3RhdGlvbnNQYXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvbk1lc3NhZ2VBbm5vdGF0aW9uc1BhcnQodmFsdWUyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0b29sX2NhbGxfc3RyZWFtaW5nX3N0YXJ0XCI6XG4gICAgICAgICAgYXdhaXQgKG9uVG9vbENhbGxTdHJlYW1pbmdTdGFydFBhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uVG9vbENhbGxTdHJlYW1pbmdTdGFydFBhcnQodmFsdWUyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0b29sX2NhbGxfZGVsdGFcIjpcbiAgICAgICAgICBhd2FpdCAob25Ub29sQ2FsbERlbHRhUGFydCA9PSBudWxsID8gdm9pZCAwIDogb25Ub29sQ2FsbERlbHRhUGFydCh2YWx1ZTIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRvb2xfY2FsbFwiOlxuICAgICAgICAgIGF3YWl0IChvblRvb2xDYWxsUGFydCA9PSBudWxsID8gdm9pZCAwIDogb25Ub29sQ2FsbFBhcnQodmFsdWUyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0b29sX3Jlc3VsdFwiOlxuICAgICAgICAgIGF3YWl0IChvblRvb2xSZXN1bHRQYXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvblRvb2xSZXN1bHRQYXJ0KHZhbHVlMikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZmluaXNoX21lc3NhZ2VcIjpcbiAgICAgICAgICBhd2FpdCAob25GaW5pc2hNZXNzYWdlUGFydCA9PSBudWxsID8gdm9pZCAwIDogb25GaW5pc2hNZXNzYWdlUGFydCh2YWx1ZTIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImZpbmlzaF9zdGVwXCI6XG4gICAgICAgICAgYXdhaXQgKG9uRmluaXNoU3RlcFBhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRmluaXNoU3RlcFBhcnQodmFsdWUyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzdGFydF9zdGVwXCI6XG4gICAgICAgICAgYXdhaXQgKG9uU3RhcnRTdGVwUGFydCA9PSBudWxsID8gdm9pZCAwIDogb25TdGFydFN0ZXBQYXJ0KHZhbHVlMikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gdHlwZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc3RyZWFtIHBhcnQgdHlwZTogJHtleGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gc3JjL3Byb2Nlc3MtY2hhdC1yZXNwb25zZS50c1xuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0NoYXRSZXNwb25zZSh7XG4gIHN0cmVhbSxcbiAgdXBkYXRlLFxuICBvblRvb2xDYWxsLFxuICBvbkZpbmlzaCxcbiAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDIgPSBnZW5lcmF0ZUlkRnVuY3Rpb24sXG4gIGdldEN1cnJlbnREYXRlID0gKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gIGxhc3RNZXNzYWdlXG59KSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHJlcGxhY2VMYXN0TWVzc2FnZSA9IChsYXN0TWVzc2FnZSA9PSBudWxsID8gdm9pZCAwIDogbGFzdE1lc3NhZ2Uucm9sZSkgPT09IFwiYXNzaXN0YW50XCI7XG4gIGxldCBzdGVwID0gcmVwbGFjZUxhc3RNZXNzYWdlID8gMSArIC8vIGZpbmQgbWF4IHN0ZXAgaW4gZXhpc3RpbmcgdG9vbCBpbnZvY2F0aW9uczpcbiAgKChfYiA9IChfYSA9IGxhc3RNZXNzYWdlLnRvb2xJbnZvY2F0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnJlZHVjZSgobWF4LCB0b29sSW52b2NhdGlvbikgPT4ge1xuICAgIHZhciBfYTI7XG4gICAgcmV0dXJuIE1hdGgubWF4KG1heCwgKF9hMiA9IHRvb2xJbnZvY2F0aW9uLnN0ZXApICE9IG51bGwgPyBfYTIgOiAwKTtcbiAgfSwgMCkpICE9IG51bGwgPyBfYiA6IDApIDogMDtcbiAgY29uc3QgbWVzc2FnZSA9IHJlcGxhY2VMYXN0TWVzc2FnZSA/IHN0cnVjdHVyZWRDbG9uZShsYXN0TWVzc2FnZSkgOiB7XG4gICAgaWQ6IGdlbmVyYXRlSWQyKCksXG4gICAgY3JlYXRlZEF0OiBnZXRDdXJyZW50RGF0ZSgpLFxuICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgY29udGVudDogXCJcIixcbiAgICBwYXJ0czogW11cbiAgfTtcbiAgbGV0IGN1cnJlbnRUZXh0UGFydCA9IHZvaWQgMDtcbiAgbGV0IGN1cnJlbnRSZWFzb25pbmdQYXJ0ID0gdm9pZCAwO1xuICBsZXQgY3VycmVudFJlYXNvbmluZ1RleHREZXRhaWwgPSB2b2lkIDA7XG4gIGZ1bmN0aW9uIHVwZGF0ZVRvb2xJbnZvY2F0aW9uUGFydCh0b29sQ2FsbElkLCBpbnZvY2F0aW9uKSB7XG4gICAgY29uc3QgcGFydCA9IG1lc3NhZ2UucGFydHMuZmluZChcbiAgICAgIChwYXJ0MikgPT4gcGFydDIudHlwZSA9PT0gXCJ0b29sLWludm9jYXRpb25cIiAmJiBwYXJ0Mi50b29sSW52b2NhdGlvbi50b29sQ2FsbElkID09PSB0b29sQ2FsbElkXG4gICAgKTtcbiAgICBpZiAocGFydCAhPSBudWxsKSB7XG4gICAgICBwYXJ0LnRvb2xJbnZvY2F0aW9uID0gaW52b2NhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZS5wYXJ0cy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJ0b29sLWludm9jYXRpb25cIixcbiAgICAgICAgdG9vbEludm9jYXRpb246IGludm9jYXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb25zdCBkYXRhID0gW107XG4gIGxldCBtZXNzYWdlQW5ub3RhdGlvbnMgPSByZXBsYWNlTGFzdE1lc3NhZ2UgPyBsYXN0TWVzc2FnZSA9PSBudWxsID8gdm9pZCAwIDogbGFzdE1lc3NhZ2UuYW5ub3RhdGlvbnMgOiB2b2lkIDA7XG4gIGNvbnN0IHBhcnRpYWxUb29sQ2FsbHMgPSB7fTtcbiAgbGV0IHVzYWdlID0ge1xuICAgIGNvbXBsZXRpb25Ub2tlbnM6IE5hTixcbiAgICBwcm9tcHRUb2tlbnM6IE5hTixcbiAgICB0b3RhbFRva2VuczogTmFOXG4gIH07XG4gIGxldCBmaW5pc2hSZWFzb24gPSBcInVua25vd25cIjtcbiAgZnVuY3Rpb24gZXhlY1VwZGF0ZSgpIHtcbiAgICBjb25zdCBjb3BpZWREYXRhID0gWy4uLmRhdGFdO1xuICAgIGlmIChtZXNzYWdlQW5ub3RhdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG1lc3NhZ2VBbm5vdGF0aW9ucy5sZW5ndGgpIHtcbiAgICAgIG1lc3NhZ2UuYW5ub3RhdGlvbnMgPSBtZXNzYWdlQW5ub3RhdGlvbnM7XG4gICAgfVxuICAgIGNvbnN0IGNvcGllZE1lc3NhZ2UgPSB7XG4gICAgICAvLyBkZWVwIGNvcHkgdGhlIG1lc3NhZ2UgdG8gZW5zdXJlIHRoYXQgZGVlcCBjaGFuZ2VzIChtc2cgYXR0YWNobWVudHMpIGFyZSB1cGRhdGVkXG4gICAgICAvLyB3aXRoIFNvbGlkSlMuIFNvbGlkSlMgdXNlcyByZWZlcmVudGlhbCBpbnRlZ3JhdGlvbiBvZiBzdWItb2JqZWN0cyB0byBkZXRlY3QgY2hhbmdlcy5cbiAgICAgIC4uLnN0cnVjdHVyZWRDbG9uZShtZXNzYWdlKSxcbiAgICAgIC8vIGFkZCBhIHJldmlzaW9uIGlkIHRvIGVuc3VyZSB0aGF0IHRoZSBtZXNzYWdlIGlzIHVwZGF0ZWQgd2l0aCBTV1IuIFNXUiB1c2VzIGFcbiAgICAgIC8vIGhhc2hpbmcgYXBwcm9hY2ggYnkgZGVmYXVsdCB0byBkZXRlY3QgY2hhbmdlcywgYnV0IGl0IG9ubHkgd29ya3MgZm9yIHNoYWxsb3dcbiAgICAgIC8vIGNoYW5nZXMuIFRoaXMgaXMgd2h5IHdlIG5lZWQgdG8gYWRkIGEgcmV2aXNpb24gaWQgdG8gZW5zdXJlIHRoYXQgdGhlIG1lc3NhZ2VcbiAgICAgIC8vIGlzIHVwZGF0ZWQgd2l0aCBTV1IgKHdpdGhvdXQgaXQsIHRoZSBjaGFuZ2VzIGdldCBzdHVjayBpbiBTV1IgYW5kIGFyZSBub3RcbiAgICAgIC8vIGZvcndhcmRlZCB0byByZW5kZXJpbmcpOlxuICAgICAgcmV2aXNpb25JZDogZ2VuZXJhdGVJZDIoKVxuICAgIH07XG4gICAgdXBkYXRlKHtcbiAgICAgIG1lc3NhZ2U6IGNvcGllZE1lc3NhZ2UsXG4gICAgICBkYXRhOiBjb3BpZWREYXRhLFxuICAgICAgcmVwbGFjZUxhc3RNZXNzYWdlXG4gICAgfSk7XG4gIH1cbiAgYXdhaXQgcHJvY2Vzc0RhdGFTdHJlYW0oe1xuICAgIHN0cmVhbSxcbiAgICBvblRleHRQYXJ0KHZhbHVlKSB7XG4gICAgICBpZiAoY3VycmVudFRleHRQYXJ0ID09IG51bGwpIHtcbiAgICAgICAgY3VycmVudFRleHRQYXJ0ID0ge1xuICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgIHRleHQ6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICAgIG1lc3NhZ2UucGFydHMucHVzaChjdXJyZW50VGV4dFBhcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudFRleHRQYXJ0LnRleHQgKz0gdmFsdWU7XG4gICAgICB9XG4gICAgICBtZXNzYWdlLmNvbnRlbnQgKz0gdmFsdWU7XG4gICAgICBleGVjVXBkYXRlKCk7XG4gICAgfSxcbiAgICBvblJlYXNvbmluZ1BhcnQodmFsdWUpIHtcbiAgICAgIHZhciBfYTI7XG4gICAgICBpZiAoY3VycmVudFJlYXNvbmluZ1RleHREZXRhaWwgPT0gbnVsbCkge1xuICAgICAgICBjdXJyZW50UmVhc29uaW5nVGV4dERldGFpbCA9IHsgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IHZhbHVlIH07XG4gICAgICAgIGlmIChjdXJyZW50UmVhc29uaW5nUGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgY3VycmVudFJlYXNvbmluZ1BhcnQuZGV0YWlscy5wdXNoKGN1cnJlbnRSZWFzb25pbmdUZXh0RGV0YWlsKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudFJlYXNvbmluZ1RleHREZXRhaWwudGV4dCArPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50UmVhc29uaW5nUGFydCA9PSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnRSZWFzb25pbmdQYXJ0ID0ge1xuICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nXCIsXG4gICAgICAgICAgcmVhc29uaW5nOiB2YWx1ZSxcbiAgICAgICAgICBkZXRhaWxzOiBbY3VycmVudFJlYXNvbmluZ1RleHREZXRhaWxdXG4gICAgICAgIH07XG4gICAgICAgIG1lc3NhZ2UucGFydHMucHVzaChjdXJyZW50UmVhc29uaW5nUGFydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50UmVhc29uaW5nUGFydC5yZWFzb25pbmcgKz0gdmFsdWU7XG4gICAgICB9XG4gICAgICBtZXNzYWdlLnJlYXNvbmluZyA9ICgoX2EyID0gbWVzc2FnZS5yZWFzb25pbmcpICE9IG51bGwgPyBfYTIgOiBcIlwiKSArIHZhbHVlO1xuICAgICAgZXhlY1VwZGF0ZSgpO1xuICAgIH0sXG4gICAgb25SZWFzb25pbmdTaWduYXR1cmVQYXJ0KHZhbHVlKSB7XG4gICAgICBpZiAoY3VycmVudFJlYXNvbmluZ1RleHREZXRhaWwgIT0gbnVsbCkge1xuICAgICAgICBjdXJyZW50UmVhc29uaW5nVGV4dERldGFpbC5zaWduYXR1cmUgPSB2YWx1ZS5zaWduYXR1cmU7XG4gICAgICB9XG4gICAgfSxcbiAgICBvblJlZGFjdGVkUmVhc29uaW5nUGFydCh2YWx1ZSkge1xuICAgICAgaWYgKGN1cnJlbnRSZWFzb25pbmdQYXJ0ID09IG51bGwpIHtcbiAgICAgICAgY3VycmVudFJlYXNvbmluZ1BhcnQgPSB7XG4gICAgICAgICAgdHlwZTogXCJyZWFzb25pbmdcIixcbiAgICAgICAgICByZWFzb25pbmc6IFwiXCIsXG4gICAgICAgICAgZGV0YWlsczogW11cbiAgICAgICAgfTtcbiAgICAgICAgbWVzc2FnZS5wYXJ0cy5wdXNoKGN1cnJlbnRSZWFzb25pbmdQYXJ0KTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRSZWFzb25pbmdQYXJ0LmRldGFpbHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwicmVkYWN0ZWRcIixcbiAgICAgICAgZGF0YTogdmFsdWUuZGF0YVxuICAgICAgfSk7XG4gICAgICBjdXJyZW50UmVhc29uaW5nVGV4dERldGFpbCA9IHZvaWQgMDtcbiAgICAgIGV4ZWNVcGRhdGUoKTtcbiAgICB9LFxuICAgIG9uRmlsZVBhcnQodmFsdWUpIHtcbiAgICAgIG1lc3NhZ2UucGFydHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICBtaW1lVHlwZTogdmFsdWUubWltZVR5cGUsXG4gICAgICAgIGRhdGE6IHZhbHVlLmRhdGFcbiAgICAgIH0pO1xuICAgICAgZXhlY1VwZGF0ZSgpO1xuICAgIH0sXG4gICAgb25Tb3VyY2VQYXJ0KHZhbHVlKSB7XG4gICAgICBtZXNzYWdlLnBhcnRzLnB1c2goe1xuICAgICAgICB0eXBlOiBcInNvdXJjZVwiLFxuICAgICAgICBzb3VyY2U6IHZhbHVlXG4gICAgICB9KTtcbiAgICAgIGV4ZWNVcGRhdGUoKTtcbiAgICB9LFxuICAgIG9uVG9vbENhbGxTdHJlYW1pbmdTdGFydFBhcnQodmFsdWUpIHtcbiAgICAgIGlmIChtZXNzYWdlLnRvb2xJbnZvY2F0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIG1lc3NhZ2UudG9vbEludm9jYXRpb25zID0gW107XG4gICAgICB9XG4gICAgICBwYXJ0aWFsVG9vbENhbGxzW3ZhbHVlLnRvb2xDYWxsSWRdID0ge1xuICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICBzdGVwLFxuICAgICAgICB0b29sTmFtZTogdmFsdWUudG9vbE5hbWUsXG4gICAgICAgIGluZGV4OiBtZXNzYWdlLnRvb2xJbnZvY2F0aW9ucy5sZW5ndGhcbiAgICAgIH07XG4gICAgICBjb25zdCBpbnZvY2F0aW9uID0ge1xuICAgICAgICBzdGF0ZTogXCJwYXJ0aWFsLWNhbGxcIixcbiAgICAgICAgc3RlcCxcbiAgICAgICAgdG9vbENhbGxJZDogdmFsdWUudG9vbENhbGxJZCxcbiAgICAgICAgdG9vbE5hbWU6IHZhbHVlLnRvb2xOYW1lLFxuICAgICAgICBhcmdzOiB2b2lkIDBcbiAgICAgIH07XG4gICAgICBtZXNzYWdlLnRvb2xJbnZvY2F0aW9ucy5wdXNoKGludm9jYXRpb24pO1xuICAgICAgdXBkYXRlVG9vbEludm9jYXRpb25QYXJ0KHZhbHVlLnRvb2xDYWxsSWQsIGludm9jYXRpb24pO1xuICAgICAgZXhlY1VwZGF0ZSgpO1xuICAgIH0sXG4gICAgb25Ub29sQ2FsbERlbHRhUGFydCh2YWx1ZSkge1xuICAgICAgY29uc3QgcGFydGlhbFRvb2xDYWxsID0gcGFydGlhbFRvb2xDYWxsc1t2YWx1ZS50b29sQ2FsbElkXTtcbiAgICAgIHBhcnRpYWxUb29sQ2FsbC50ZXh0ICs9IHZhbHVlLmFyZ3NUZXh0RGVsdGE7XG4gICAgICBjb25zdCB7IHZhbHVlOiBwYXJ0aWFsQXJncyB9ID0gcGFyc2VQYXJ0aWFsSnNvbihwYXJ0aWFsVG9vbENhbGwudGV4dCk7XG4gICAgICBjb25zdCBpbnZvY2F0aW9uID0ge1xuICAgICAgICBzdGF0ZTogXCJwYXJ0aWFsLWNhbGxcIixcbiAgICAgICAgc3RlcDogcGFydGlhbFRvb2xDYWxsLnN0ZXAsXG4gICAgICAgIHRvb2xDYWxsSWQ6IHZhbHVlLnRvb2xDYWxsSWQsXG4gICAgICAgIHRvb2xOYW1lOiBwYXJ0aWFsVG9vbENhbGwudG9vbE5hbWUsXG4gICAgICAgIGFyZ3M6IHBhcnRpYWxBcmdzXG4gICAgICB9O1xuICAgICAgbWVzc2FnZS50b29sSW52b2NhdGlvbnNbcGFydGlhbFRvb2xDYWxsLmluZGV4XSA9IGludm9jYXRpb247XG4gICAgICB1cGRhdGVUb29sSW52b2NhdGlvblBhcnQodmFsdWUudG9vbENhbGxJZCwgaW52b2NhdGlvbik7XG4gICAgICBleGVjVXBkYXRlKCk7XG4gICAgfSxcbiAgICBhc3luYyBvblRvb2xDYWxsUGFydCh2YWx1ZSkge1xuICAgICAgY29uc3QgaW52b2NhdGlvbiA9IHtcbiAgICAgICAgc3RhdGU6IFwiY2FsbFwiLFxuICAgICAgICBzdGVwLFxuICAgICAgICAuLi52YWx1ZVxuICAgICAgfTtcbiAgICAgIGlmIChwYXJ0aWFsVG9vbENhbGxzW3ZhbHVlLnRvb2xDYWxsSWRdICE9IG51bGwpIHtcbiAgICAgICAgbWVzc2FnZS50b29sSW52b2NhdGlvbnNbcGFydGlhbFRvb2xDYWxsc1t2YWx1ZS50b29sQ2FsbElkXS5pbmRleF0gPSBpbnZvY2F0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudG9vbEludm9jYXRpb25zID09IG51bGwpIHtcbiAgICAgICAgICBtZXNzYWdlLnRvb2xJbnZvY2F0aW9ucyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UudG9vbEludm9jYXRpb25zLnB1c2goaW52b2NhdGlvbik7XG4gICAgICB9XG4gICAgICB1cGRhdGVUb29sSW52b2NhdGlvblBhcnQodmFsdWUudG9vbENhbGxJZCwgaW52b2NhdGlvbik7XG4gICAgICBleGVjVXBkYXRlKCk7XG4gICAgICBpZiAob25Ub29sQ2FsbCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBvblRvb2xDYWxsKHsgdG9vbENhbGw6IHZhbHVlIH0pO1xuICAgICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBpbnZvY2F0aW9uMiA9IHtcbiAgICAgICAgICAgIHN0YXRlOiBcInJlc3VsdFwiLFxuICAgICAgICAgICAgc3RlcCxcbiAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgfTtcbiAgICAgICAgICBtZXNzYWdlLnRvb2xJbnZvY2F0aW9uc1ttZXNzYWdlLnRvb2xJbnZvY2F0aW9ucy5sZW5ndGggLSAxXSA9IGludm9jYXRpb24yO1xuICAgICAgICAgIHVwZGF0ZVRvb2xJbnZvY2F0aW9uUGFydCh2YWx1ZS50b29sQ2FsbElkLCBpbnZvY2F0aW9uMik7XG4gICAgICAgICAgZXhlY1VwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBvblRvb2xSZXN1bHRQYXJ0KHZhbHVlKSB7XG4gICAgICBjb25zdCB0b29sSW52b2NhdGlvbnMgPSBtZXNzYWdlLnRvb2xJbnZvY2F0aW9ucztcbiAgICAgIGlmICh0b29sSW52b2NhdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0b29sX3Jlc3VsdCBtdXN0IGJlIHByZWNlZGVkIGJ5IGEgdG9vbF9jYWxsXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgdG9vbEludm9jYXRpb25JbmRleCA9IHRvb2xJbnZvY2F0aW9ucy5maW5kSW5kZXgoXG4gICAgICAgIChpbnZvY2F0aW9uMikgPT4gaW52b2NhdGlvbjIudG9vbENhbGxJZCA9PT0gdmFsdWUudG9vbENhbGxJZFxuICAgICAgKTtcbiAgICAgIGlmICh0b29sSW52b2NhdGlvbkluZGV4ID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJ0b29sX3Jlc3VsdCBtdXN0IGJlIHByZWNlZGVkIGJ5IGEgdG9vbF9jYWxsIHdpdGggdGhlIHNhbWUgdG9vbENhbGxJZFwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBpbnZvY2F0aW9uID0ge1xuICAgICAgICAuLi50b29sSW52b2NhdGlvbnNbdG9vbEludm9jYXRpb25JbmRleF0sXG4gICAgICAgIHN0YXRlOiBcInJlc3VsdFwiLFxuICAgICAgICAuLi52YWx1ZVxuICAgICAgfTtcbiAgICAgIHRvb2xJbnZvY2F0aW9uc1t0b29sSW52b2NhdGlvbkluZGV4XSA9IGludm9jYXRpb247XG4gICAgICB1cGRhdGVUb29sSW52b2NhdGlvblBhcnQodmFsdWUudG9vbENhbGxJZCwgaW52b2NhdGlvbik7XG4gICAgICBleGVjVXBkYXRlKCk7XG4gICAgfSxcbiAgICBvbkRhdGFQYXJ0KHZhbHVlKSB7XG4gICAgICBkYXRhLnB1c2goLi4udmFsdWUpO1xuICAgICAgZXhlY1VwZGF0ZSgpO1xuICAgIH0sXG4gICAgb25NZXNzYWdlQW5ub3RhdGlvbnNQYXJ0KHZhbHVlKSB7XG4gICAgICBpZiAobWVzc2FnZUFubm90YXRpb25zID09IG51bGwpIHtcbiAgICAgICAgbWVzc2FnZUFubm90YXRpb25zID0gWy4uLnZhbHVlXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lc3NhZ2VBbm5vdGF0aW9ucy5wdXNoKC4uLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGV4ZWNVcGRhdGUoKTtcbiAgICB9LFxuICAgIG9uRmluaXNoU3RlcFBhcnQodmFsdWUpIHtcbiAgICAgIHN0ZXAgKz0gMTtcbiAgICAgIGN1cnJlbnRUZXh0UGFydCA9IHZhbHVlLmlzQ29udGludWVkID8gY3VycmVudFRleHRQYXJ0IDogdm9pZCAwO1xuICAgICAgY3VycmVudFJlYXNvbmluZ1BhcnQgPSB2b2lkIDA7XG4gICAgICBjdXJyZW50UmVhc29uaW5nVGV4dERldGFpbCA9IHZvaWQgMDtcbiAgICB9LFxuICAgIG9uU3RhcnRTdGVwUGFydCh2YWx1ZSkge1xuICAgICAgaWYgKCFyZXBsYWNlTGFzdE1lc3NhZ2UpIHtcbiAgICAgICAgbWVzc2FnZS5pZCA9IHZhbHVlLm1lc3NhZ2VJZDtcbiAgICAgIH1cbiAgICAgIG1lc3NhZ2UucGFydHMucHVzaCh7IHR5cGU6IFwic3RlcC1zdGFydFwiIH0pO1xuICAgICAgZXhlY1VwZGF0ZSgpO1xuICAgIH0sXG4gICAgb25GaW5pc2hNZXNzYWdlUGFydCh2YWx1ZSkge1xuICAgICAgZmluaXNoUmVhc29uID0gdmFsdWUuZmluaXNoUmVhc29uO1xuICAgICAgaWYgKHZhbHVlLnVzYWdlICE9IG51bGwpIHtcbiAgICAgICAgdXNhZ2UgPSBjYWxjdWxhdGVMYW5ndWFnZU1vZGVsVXNhZ2UodmFsdWUudXNhZ2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25FcnJvclBhcnQoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG4gICAgfVxuICB9KTtcbiAgb25GaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uRmluaXNoKHsgbWVzc2FnZSwgZmluaXNoUmVhc29uLCB1c2FnZSB9KTtcbn1cblxuLy8gc3JjL3Byb2Nlc3MtY2hhdC10ZXh0LXJlc3BvbnNlLnRzXG5pbXBvcnQgeyBnZW5lcmF0ZUlkIGFzIGdlbmVyYXRlSWRGdW5jdGlvbjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvcHJvY2Vzcy10ZXh0LXN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1RleHRTdHJlYW0oe1xuICBzdHJlYW0sXG4gIG9uVGV4dFBhcnRcbn0pIHtcbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RGVjb2RlclN0cmVhbSgpKS5nZXRSZWFkZXIoKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgYXdhaXQgb25UZXh0UGFydCh2YWx1ZSk7XG4gIH1cbn1cblxuLy8gc3JjL3Byb2Nlc3MtY2hhdC10ZXh0LXJlc3BvbnNlLnRzXG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzQ2hhdFRleHRSZXNwb25zZSh7XG4gIHN0cmVhbSxcbiAgdXBkYXRlLFxuICBvbkZpbmlzaCxcbiAgZ2V0Q3VycmVudERhdGUgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDIgPSBnZW5lcmF0ZUlkRnVuY3Rpb24yXG59KSB7XG4gIGNvbnN0IHRleHRQYXJ0ID0geyB0eXBlOiBcInRleHRcIiwgdGV4dDogXCJcIiB9O1xuICBjb25zdCByZXN1bHRNZXNzYWdlID0ge1xuICAgIGlkOiBnZW5lcmF0ZUlkMigpLFxuICAgIGNyZWF0ZWRBdDogZ2V0Q3VycmVudERhdGUoKSxcbiAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgcGFydHM6IFt0ZXh0UGFydF1cbiAgfTtcbiAgYXdhaXQgcHJvY2Vzc1RleHRTdHJlYW0oe1xuICAgIHN0cmVhbSxcbiAgICBvblRleHRQYXJ0OiAoY2h1bmspID0+IHtcbiAgICAgIHJlc3VsdE1lc3NhZ2UuY29udGVudCArPSBjaHVuaztcbiAgICAgIHRleHRQYXJ0LnRleHQgKz0gY2h1bms7XG4gICAgICB1cGRhdGUoe1xuICAgICAgICBtZXNzYWdlOiB7IC4uLnJlc3VsdE1lc3NhZ2UgfSxcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIHJlcGxhY2VMYXN0TWVzc2FnZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIG9uRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvbkZpbmlzaChyZXN1bHRNZXNzYWdlLCB7XG4gICAgdXNhZ2U6IHsgY29tcGxldGlvblRva2VuczogTmFOLCBwcm9tcHRUb2tlbnM6IE5hTiwgdG90YWxUb2tlbnM6IE5hTiB9LFxuICAgIGZpbmlzaFJlYXNvbjogXCJ1bmtub3duXCJcbiAgfSk7XG59XG5cbi8vIHNyYy9jYWxsLWNoYXQtYXBpLnRzXG52YXIgZ2V0T3JpZ2luYWxGZXRjaCA9ICgpID0+IGZldGNoO1xuYXN5bmMgZnVuY3Rpb24gY2FsbENoYXRBcGkoe1xuICBhcGksXG4gIGJvZHksXG4gIHN0cmVhbVByb3RvY29sID0gXCJkYXRhXCIsXG4gIGNyZWRlbnRpYWxzLFxuICBoZWFkZXJzLFxuICBhYm9ydENvbnRyb2xsZXIsXG4gIHJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSxcbiAgb25SZXNwb25zZSxcbiAgb25VcGRhdGUsXG4gIG9uRmluaXNoLFxuICBvblRvb2xDYWxsLFxuICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMixcbiAgZmV0Y2g6IGZldGNoMiA9IGdldE9yaWdpbmFsRmV0Y2goKSxcbiAgbGFzdE1lc3NhZ2UsXG4gIHJlcXVlc3RUeXBlID0gXCJnZW5lcmF0ZVwiXG59KSB7XG4gIHZhciBfYSwgX2IsIF9jO1xuICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdFR5cGUgPT09IFwicmVzdW1lXCIgPyBmZXRjaDIoYCR7YXBpfT9jaGF0SWQ9JHtib2R5LmlkfWAsIHtcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAuLi5oZWFkZXJzXG4gICAgfSxcbiAgICBzaWduYWw6IChfYSA9IGFib3J0Q29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogYWJvcnRDb250cm9sbGVyKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zaWduYWwsXG4gICAgY3JlZGVudGlhbHNcbiAgfSkgOiBmZXRjaDIoYXBpLCB7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIC4uLmhlYWRlcnNcbiAgICB9LFxuICAgIHNpZ25hbDogKF9iID0gYWJvcnRDb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXIoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnNpZ25hbCxcbiAgICBjcmVkZW50aWFsc1xuICB9KTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0LmNhdGNoKChlcnIpID0+IHtcbiAgICByZXN0b3JlTWVzc2FnZXNPbkZhaWx1cmUoKTtcbiAgICB0aHJvdyBlcnI7XG4gIH0pO1xuICBpZiAob25SZXNwb25zZSkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBvblJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIHJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSgpO1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIChfYyA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKSkgIT0gbnVsbCA/IF9jIDogXCJGYWlsZWQgdG8gZmV0Y2ggdGhlIGNoYXQgcmVzcG9uc2UuXCJcbiAgICApO1xuICB9XG4gIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByZXNwb25zZSBib2R5IGlzIGVtcHR5LlwiKTtcbiAgfVxuICBzd2l0Y2ggKHN0cmVhbVByb3RvY29sKSB7XG4gICAgY2FzZSBcInRleHRcIjoge1xuICAgICAgYXdhaXQgcHJvY2Vzc0NoYXRUZXh0UmVzcG9uc2Uoe1xuICAgICAgICBzdHJlYW06IHJlc3BvbnNlLmJvZHksXG4gICAgICAgIHVwZGF0ZTogb25VcGRhdGUsXG4gICAgICAgIG9uRmluaXNoLFxuICAgICAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMlxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhc2UgXCJkYXRhXCI6IHtcbiAgICAgIGF3YWl0IHByb2Nlc3NDaGF0UmVzcG9uc2Uoe1xuICAgICAgICBzdHJlYW06IHJlc3BvbnNlLmJvZHksXG4gICAgICAgIHVwZGF0ZTogb25VcGRhdGUsXG4gICAgICAgIGxhc3RNZXNzYWdlLFxuICAgICAgICBvblRvb2xDYWxsLFxuICAgICAgICBvbkZpbmlzaCh7IG1lc3NhZ2UsIGZpbmlzaFJlYXNvbiwgdXNhZ2UgfSkge1xuICAgICAgICAgIGlmIChvbkZpbmlzaCAmJiBtZXNzYWdlICE9IG51bGwpIHtcbiAgICAgICAgICAgIG9uRmluaXNoKG1lc3NhZ2UsIHsgdXNhZ2UsIGZpbmlzaFJlYXNvbiB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQyXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gc3RyZWFtUHJvdG9jb2w7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc3RyZWFtIHByb3RvY29sOiAke2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gc3JjL2NhbGwtY29tcGxldGlvbi1hcGkudHNcbnZhciBnZXRPcmlnaW5hbEZldGNoMiA9ICgpID0+IGZldGNoO1xuYXN5bmMgZnVuY3Rpb24gY2FsbENvbXBsZXRpb25BcGkoe1xuICBhcGksXG4gIHByb21wdCxcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGJvZHksXG4gIHN0cmVhbVByb3RvY29sID0gXCJkYXRhXCIsXG4gIHNldENvbXBsZXRpb24sXG4gIHNldExvYWRpbmcsXG4gIHNldEVycm9yLFxuICBzZXRBYm9ydENvbnRyb2xsZXIsXG4gIG9uUmVzcG9uc2UsXG4gIG9uRmluaXNoLFxuICBvbkVycm9yLFxuICBvbkRhdGEsXG4gIGZldGNoOiBmZXRjaDIgPSBnZXRPcmlnaW5hbEZldGNoMigpXG59KSB7XG4gIHZhciBfYTtcbiAgdHJ5IHtcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKHZvaWQgMCk7XG4gICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHNldEFib3J0Q29udHJvbGxlcihhYm9ydENvbnRyb2xsZXIpO1xuICAgIHNldENvbXBsZXRpb24oXCJcIik7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaDIoYXBpLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBwcm9tcHQsXG4gICAgICAgIC4uLmJvZHlcbiAgICAgIH0pLFxuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAuLi5oZWFkZXJzXG4gICAgICB9LFxuICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xuICAgIGlmIChvblJlc3BvbnNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBvblJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgKF9hID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpKSAhPSBudWxsID8gX2EgOiBcIkZhaWxlZCB0byBmZXRjaCB0aGUgY2hhdCByZXNwb25zZS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcmVzcG9uc2UgYm9keSBpcyBlbXB0eS5cIik7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIHN3aXRjaCAoc3RyZWFtUHJvdG9jb2wpIHtcbiAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgYXdhaXQgcHJvY2Vzc1RleHRTdHJlYW0oe1xuICAgICAgICAgIHN0cmVhbTogcmVzcG9uc2UuYm9keSxcbiAgICAgICAgICBvblRleHRQYXJ0OiAoY2h1bmspID0+IHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBjaHVuaztcbiAgICAgICAgICAgIHNldENvbXBsZXRpb24ocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkYXRhXCI6IHtcbiAgICAgICAgYXdhaXQgcHJvY2Vzc0RhdGFTdHJlYW0oe1xuICAgICAgICAgIHN0cmVhbTogcmVzcG9uc2UuYm9keSxcbiAgICAgICAgICBvblRleHRQYXJ0KHZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdmFsdWU7XG4gICAgICAgICAgICBzZXRDb21wbGV0aW9uKHJlc3VsdCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkRhdGFQYXJ0KHZhbHVlKSB7XG4gICAgICAgICAgICBvbkRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRGF0YSh2YWx1ZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkVycm9yUGFydCh2YWx1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gc3RyZWFtUHJvdG9jb2w7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzdHJlYW0gcHJvdG9jb2w6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob25GaW5pc2gpIHtcbiAgICAgIG9uRmluaXNoKHByb21wdCwgcmVzdWx0KTtcbiAgICB9XG4gICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgIHNldEFib3J0Q29udHJvbGxlcihudWxsKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0RXJyb3IoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgfVxufVxuXG4vLyBzcmMvZGF0YS11cmwudHNcbmZ1bmN0aW9uIGdldFRleHRGcm9tRGF0YVVybChkYXRhVXJsKSB7XG4gIGNvbnN0IFtoZWFkZXIsIGJhc2U2NENvbnRlbnRdID0gZGF0YVVybC5zcGxpdChcIixcIik7XG4gIGNvbnN0IG1pbWVUeXBlID0gaGVhZGVyLnNwbGl0KFwiO1wiKVswXS5zcGxpdChcIjpcIilbMV07XG4gIGlmIChtaW1lVHlwZSA9PSBudWxsIHx8IGJhc2U2NENvbnRlbnQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSBVUkwgZm9ybWF0XCIpO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5hdG9iKGJhc2U2NENvbnRlbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZGVjb2RpbmcgZGF0YSBVUkxgKTtcbiAgfVxufVxuXG4vLyBzcmMvZXh0cmFjdC1tYXgtdG9vbC1pbnZvY2F0aW9uLXN0ZXAudHNcbmZ1bmN0aW9uIGV4dHJhY3RNYXhUb29sSW52b2NhdGlvblN0ZXAodG9vbEludm9jYXRpb25zKSB7XG4gIHJldHVybiB0b29sSW52b2NhdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xJbnZvY2F0aW9ucy5yZWR1Y2UoKG1heCwgdG9vbEludm9jYXRpb24pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIE1hdGgubWF4KG1heCwgKF9hID0gdG9vbEludm9jYXRpb24uc3RlcCkgIT0gbnVsbCA/IF9hIDogMCk7XG4gIH0sIDApO1xufVxuXG4vLyBzcmMvZ2V0LW1lc3NhZ2UtcGFydHMudHNcbmZ1bmN0aW9uIGdldE1lc3NhZ2VQYXJ0cyhtZXNzYWdlKSB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIChfYSA9IG1lc3NhZ2UucGFydHMpICE9IG51bGwgPyBfYSA6IFtcbiAgICAuLi5tZXNzYWdlLnRvb2xJbnZvY2F0aW9ucyA/IG1lc3NhZ2UudG9vbEludm9jYXRpb25zLm1hcCgodG9vbEludm9jYXRpb24pID0+ICh7XG4gICAgICB0eXBlOiBcInRvb2wtaW52b2NhdGlvblwiLFxuICAgICAgdG9vbEludm9jYXRpb25cbiAgICB9KSkgOiBbXSxcbiAgICAuLi5tZXNzYWdlLnJlYXNvbmluZyA/IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJyZWFzb25pbmdcIixcbiAgICAgICAgcmVhc29uaW5nOiBtZXNzYWdlLnJlYXNvbmluZyxcbiAgICAgICAgZGV0YWlsczogW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IG1lc3NhZ2UucmVhc29uaW5nIH1dXG4gICAgICB9XG4gICAgXSA6IFtdLFxuICAgIC4uLm1lc3NhZ2UuY29udGVudCA/IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBtZXNzYWdlLmNvbnRlbnQgfV0gOiBbXVxuICBdO1xufVxuXG4vLyBzcmMvZmlsbC1tZXNzYWdlLXBhcnRzLnRzXG5mdW5jdGlvbiBmaWxsTWVzc2FnZVBhcnRzKG1lc3NhZ2VzKSB7XG4gIHJldHVybiBtZXNzYWdlcy5tYXAoKG1lc3NhZ2UpID0+ICh7XG4gICAgLi4ubWVzc2FnZSxcbiAgICBwYXJ0czogZ2V0TWVzc2FnZVBhcnRzKG1lc3NhZ2UpXG4gIH0pKTtcbn1cblxuLy8gc3JjL2lzLWRlZXAtZXF1YWwtZGF0YS50c1xuZnVuY3Rpb24gaXNEZWVwRXF1YWxEYXRhKG9iajEsIG9iajIpIHtcbiAgaWYgKG9iajEgPT09IG9iajIpXG4gICAgcmV0dXJuIHRydWU7XG4gIGlmIChvYmoxID09IG51bGwgfHwgb2JqMiA9PSBudWxsKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBvYmoxICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmoyICE9PSBcIm9iamVjdFwiKVxuICAgIHJldHVybiBvYmoxID09PSBvYmoyO1xuICBpZiAob2JqMS5jb25zdHJ1Y3RvciAhPT0gb2JqMi5jb25zdHJ1Y3RvcilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChvYmoxIGluc3RhbmNlb2YgRGF0ZSAmJiBvYmoyIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBvYmoxLmdldFRpbWUoKSA9PT0gb2JqMi5nZXRUaW1lKCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqMSkpIHtcbiAgICBpZiAob2JqMS5sZW5ndGggIT09IG9iajIubGVuZ3RoKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqMS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFpc0RlZXBFcXVhbERhdGEob2JqMVtpXSwgb2JqMltpXSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3Qga2V5czEgPSBPYmplY3Qua2V5cyhvYmoxKTtcbiAgY29uc3Qga2V5czIgPSBPYmplY3Qua2V5cyhvYmoyKTtcbiAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5czEpIHtcbiAgICBpZiAoIWtleXMyLmluY2x1ZGVzKGtleSkpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFpc0RlZXBFcXVhbERhdGEob2JqMVtrZXldLCBvYmoyW2tleV0pKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBzcmMvcHJlcGFyZS1hdHRhY2htZW50cy1mb3ItcmVxdWVzdC50c1xuYXN5bmMgZnVuY3Rpb24gcHJlcGFyZUF0dGFjaG1lbnRzRm9yUmVxdWVzdChhdHRhY2htZW50c0Zyb21PcHRpb25zKSB7XG4gIGlmICghYXR0YWNobWVudHNGcm9tT3B0aW9ucykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoZ2xvYmFsVGhpcy5GaWxlTGlzdCAmJiBhdHRhY2htZW50c0Zyb21PcHRpb25zIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5GaWxlTGlzdCkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgIEFycmF5LmZyb20oYXR0YWNobWVudHNGcm9tT3B0aW9ucykubWFwKGFzeW5jIChhdHRhY2htZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgdHlwZSB9ID0gYXR0YWNobWVudDtcbiAgICAgICAgY29uc3QgZGF0YVVybCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSAocmVhZGVyRXZlbnQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJlc29sdmUoKF9hID0gcmVhZGVyRXZlbnQudGFyZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVzdWx0KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJlYWRlci5vbmVycm9yID0gKGVycm9yKSA9PiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGF0dGFjaG1lbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGNvbnRlbnRUeXBlOiB0eXBlLFxuICAgICAgICAgIHVybDogZGF0YVVybFxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICApO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGF0dGFjaG1lbnRzRnJvbU9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIGF0dGFjaG1lbnRzRnJvbU9wdGlvbnM7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhdHRhY2htZW50cyB0eXBlXCIpO1xufVxuXG4vLyBzcmMvcHJvY2Vzcy1hc3Npc3RhbnQtc3RyZWFtLnRzXG52YXIgTkVXTElORTIgPSBcIlxcblwiLmNoYXJDb2RlQXQoMCk7XG5mdW5jdGlvbiBjb25jYXRDaHVua3MyKGNodW5rcywgdG90YWxMZW5ndGgpIHtcbiAgY29uc3QgY29uY2F0ZW5hdGVkQ2h1bmtzID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICBjb25jYXRlbmF0ZWRDaHVua3Muc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBjaHVuay5sZW5ndGg7XG4gIH1cbiAgY2h1bmtzLmxlbmd0aCA9IDA7XG4gIHJldHVybiBjb25jYXRlbmF0ZWRDaHVua3M7XG59XG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzQXNzaXN0YW50U3RyZWFtKHtcbiAgc3RyZWFtLFxuICBvblRleHRQYXJ0LFxuICBvbkVycm9yUGFydCxcbiAgb25Bc3Npc3RhbnRNZXNzYWdlUGFydCxcbiAgb25Bc3Npc3RhbnRDb250cm9sRGF0YVBhcnQsXG4gIG9uRGF0YU1lc3NhZ2VQYXJ0XG59KSB7XG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBjb25zdCBjaHVua3MgPSBbXTtcbiAgbGV0IHRvdGFsTGVuZ3RoID0gMDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgY2h1bmtzLnB1c2godmFsdWUpO1xuICAgICAgdG90YWxMZW5ndGggKz0gdmFsdWUubGVuZ3RoO1xuICAgICAgaWYgKHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdICE9PSBORVdMSU5FMikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBjb25jYXRlbmF0ZWRDaHVua3MgPSBjb25jYXRDaHVua3MyKGNodW5rcywgdG90YWxMZW5ndGgpO1xuICAgIHRvdGFsTGVuZ3RoID0gMDtcbiAgICBjb25zdCBzdHJlYW1QYXJ0cyA9IGRlY29kZXIuZGVjb2RlKGNvbmNhdGVuYXRlZENodW5rcywgeyBzdHJlYW06IHRydWUgfSkuc3BsaXQoXCJcXG5cIikuZmlsdGVyKChsaW5lKSA9PiBsaW5lICE9PSBcIlwiKS5tYXAocGFyc2VBc3Npc3RhbnRTdHJlYW1QYXJ0KTtcbiAgICBmb3IgKGNvbnN0IHsgdHlwZSwgdmFsdWU6IHZhbHVlMiB9IG9mIHN0cmVhbVBhcnRzKSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgICBhd2FpdCAob25UZXh0UGFydCA9PSBudWxsID8gdm9pZCAwIDogb25UZXh0UGFydCh2YWx1ZTIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgYXdhaXQgKG9uRXJyb3JQYXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvbkVycm9yUGFydCh2YWx1ZTIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImFzc2lzdGFudF9tZXNzYWdlXCI6XG4gICAgICAgICAgYXdhaXQgKG9uQXNzaXN0YW50TWVzc2FnZVBhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQXNzaXN0YW50TWVzc2FnZVBhcnQodmFsdWUyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCI6XG4gICAgICAgICAgYXdhaXQgKG9uQXNzaXN0YW50Q29udHJvbERhdGFQYXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvbkFzc2lzdGFudENvbnRyb2xEYXRhUGFydCh2YWx1ZTIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRhdGFfbWVzc2FnZVwiOlxuICAgICAgICAgIGF3YWl0IChvbkRhdGFNZXNzYWdlUGFydCA9PSBudWxsID8gdm9pZCAwIDogb25EYXRhTWVzc2FnZVBhcnQodmFsdWUyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2sgPSB0eXBlO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzdHJlYW0gcGFydCB0eXBlOiAke2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvc2NoZW1hLnRzXG5pbXBvcnQgeyB2YWxpZGF0b3JTeW1ib2wgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvem9kLXNjaGVtYS50c1xuaW1wb3J0IHpvZFRvSnNvblNjaGVtYSBmcm9tIFwiem9kLXRvLWpzb24tc2NoZW1hXCI7XG5mdW5jdGlvbiB6b2RTY2hlbWEoem9kU2NoZW1hMiwgb3B0aW9ucykge1xuICB2YXIgX2E7XG4gIGNvbnN0IHVzZVJlZmVyZW5jZXMgPSAoX2EgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnVzZVJlZmVyZW5jZXMpICE9IG51bGwgPyBfYSA6IGZhbHNlO1xuICByZXR1cm4ganNvblNjaGVtYShcbiAgICB6b2RUb0pzb25TY2hlbWEoem9kU2NoZW1hMiwge1xuICAgICAgJHJlZlN0cmF0ZWd5OiB1c2VSZWZlcmVuY2VzID8gXCJyb290XCIgOiBcIm5vbmVcIixcbiAgICAgIHRhcmdldDogXCJqc29uU2NoZW1hN1wiXG4gICAgICAvLyBub3RlOiBvcGVuYWkgbW9kZSBicmVha3MgdmFyaW91cyBnZW1pbmkgY29udmVyc2lvbnNcbiAgICB9KSxcbiAgICB7XG4gICAgICB2YWxpZGF0ZTogKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHpvZFNjaGVtYTIuc2FmZVBhcnNlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zdWNjZXNzID8geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogcmVzdWx0LmRhdGEgfSA6IHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiByZXN1bHQuZXJyb3IgfTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5cbi8vIHNyYy9zY2hlbWEudHNcbnZhciBzY2hlbWFTeW1ib2wgPSBTeW1ib2wuZm9yKFwidmVyY2VsLmFpLnNjaGVtYVwiKTtcbmZ1bmN0aW9uIGpzb25TY2hlbWEoanNvblNjaGVtYTIsIHtcbiAgdmFsaWRhdGVcbn0gPSB7fSkge1xuICByZXR1cm4ge1xuICAgIFtzY2hlbWFTeW1ib2xdOiB0cnVlLFxuICAgIF90eXBlOiB2b2lkIDAsXG4gICAgLy8gc2hvdWxkIG5ldmVyIGJlIHVzZWQgZGlyZWN0bHlcbiAgICBbdmFsaWRhdG9yU3ltYm9sXTogdHJ1ZSxcbiAgICBqc29uU2NoZW1hOiBqc29uU2NoZW1hMixcbiAgICB2YWxpZGF0ZVxuICB9O1xufVxuZnVuY3Rpb24gaXNTY2hlbWEodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiBzY2hlbWFTeW1ib2wgaW4gdmFsdWUgJiYgdmFsdWVbc2NoZW1hU3ltYm9sXSA9PT0gdHJ1ZSAmJiBcImpzb25TY2hlbWFcIiBpbiB2YWx1ZSAmJiBcInZhbGlkYXRlXCIgaW4gdmFsdWU7XG59XG5mdW5jdGlvbiBhc1NjaGVtYShzY2hlbWEpIHtcbiAgcmV0dXJuIGlzU2NoZW1hKHNjaGVtYSkgPyBzY2hlbWEgOiB6b2RTY2hlbWEoc2NoZW1hKTtcbn1cblxuLy8gc3JjL3Nob3VsZC1yZXN1Ym1pdC1tZXNzYWdlcy50c1xuZnVuY3Rpb24gc2hvdWxkUmVzdWJtaXRNZXNzYWdlcyh7XG4gIG9yaWdpbmFsTWF4VG9vbEludm9jYXRpb25TdGVwLFxuICBvcmlnaW5hbE1lc3NhZ2VDb3VudCxcbiAgbWF4U3RlcHMsXG4gIG1lc3NhZ2VzXG59KSB7XG4gIHZhciBfYTtcbiAgY29uc3QgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIChcbiAgICAvLyBjaGVjayBpZiB0aGUgZmVhdHVyZSBpcyBlbmFibGVkOlxuICAgIG1heFN0ZXBzID4gMSAmJiAvLyBlbnN1cmUgdGhlcmUgaXMgYSBsYXN0IG1lc3NhZ2U6XG4gICAgbGFzdE1lc3NhZ2UgIT0gbnVsbCAmJiAvLyBlbnN1cmUgd2UgYWN0dWFsbHkgaGF2ZSBuZXcgc3RlcHMgKHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMgaW4gY2FzZSBvZiBlcnJvcnMpOlxuICAgIChtZXNzYWdlcy5sZW5ndGggPiBvcmlnaW5hbE1lc3NhZ2VDb3VudCB8fCBleHRyYWN0TWF4VG9vbEludm9jYXRpb25TdGVwKGxhc3RNZXNzYWdlLnRvb2xJbnZvY2F0aW9ucykgIT09IG9yaWdpbmFsTWF4VG9vbEludm9jYXRpb25TdGVwKSAmJiAvLyBjaGVjayB0aGF0IG5leHQgc3RlcCBpcyBwb3NzaWJsZTpcbiAgICBpc0Fzc2lzdGFudE1lc3NhZ2VXaXRoQ29tcGxldGVkVG9vbENhbGxzKGxhc3RNZXNzYWdlKSAmJiAvLyBsaW1pdCB0aGUgbnVtYmVyIG9mIGF1dG9tYXRpYyBzdGVwczpcbiAgICAoKF9hID0gZXh0cmFjdE1heFRvb2xJbnZvY2F0aW9uU3RlcChsYXN0TWVzc2FnZS50b29sSW52b2NhdGlvbnMpKSAhPSBudWxsID8gX2EgOiAwKSA8IG1heFN0ZXBzXG4gICk7XG59XG5mdW5jdGlvbiBpc0Fzc2lzdGFudE1lc3NhZ2VXaXRoQ29tcGxldGVkVG9vbENhbGxzKG1lc3NhZ2UpIHtcbiAgaWYgKG1lc3NhZ2Uucm9sZSAhPT0gXCJhc3Npc3RhbnRcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBsYXN0U3RlcFN0YXJ0SW5kZXggPSBtZXNzYWdlLnBhcnRzLnJlZHVjZSgobGFzdEluZGV4LCBwYXJ0LCBpbmRleCkgPT4ge1xuICAgIHJldHVybiBwYXJ0LnR5cGUgPT09IFwic3RlcC1zdGFydFwiID8gaW5kZXggOiBsYXN0SW5kZXg7XG4gIH0sIC0xKTtcbiAgY29uc3QgbGFzdFN0ZXBUb29sSW52b2NhdGlvbnMgPSBtZXNzYWdlLnBhcnRzLnNsaWNlKGxhc3RTdGVwU3RhcnRJbmRleCArIDEpLmZpbHRlcigocGFydCkgPT4gcGFydC50eXBlID09PSBcInRvb2wtaW52b2NhdGlvblwiKTtcbiAgcmV0dXJuIGxhc3RTdGVwVG9vbEludm9jYXRpb25zLmxlbmd0aCA+IDAgJiYgbGFzdFN0ZXBUb29sSW52b2NhdGlvbnMuZXZlcnkoKHBhcnQpID0+IFwicmVzdWx0XCIgaW4gcGFydC50b29sSW52b2NhdGlvbik7XG59XG5cbi8vIHNyYy91cGRhdGUtdG9vbC1jYWxsLXJlc3VsdC50c1xuZnVuY3Rpb24gdXBkYXRlVG9vbENhbGxSZXN1bHQoe1xuICBtZXNzYWdlcyxcbiAgdG9vbENhbGxJZCxcbiAgdG9vbFJlc3VsdDogcmVzdWx0XG59KSB7XG4gIHZhciBfYTtcbiAgY29uc3QgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgY29uc3QgaW52b2NhdGlvblBhcnQgPSBsYXN0TWVzc2FnZS5wYXJ0cy5maW5kKFxuICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwidG9vbC1pbnZvY2F0aW9uXCIgJiYgcGFydC50b29sSW52b2NhdGlvbi50b29sQ2FsbElkID09PSB0b29sQ2FsbElkXG4gICk7XG4gIGlmIChpbnZvY2F0aW9uUGFydCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHRvb2xSZXN1bHQgPSB7XG4gICAgLi4uaW52b2NhdGlvblBhcnQudG9vbEludm9jYXRpb24sXG4gICAgc3RhdGU6IFwicmVzdWx0XCIsXG4gICAgcmVzdWx0XG4gIH07XG4gIGludm9jYXRpb25QYXJ0LnRvb2xJbnZvY2F0aW9uID0gdG9vbFJlc3VsdDtcbiAgbGFzdE1lc3NhZ2UudG9vbEludm9jYXRpb25zID0gKF9hID0gbGFzdE1lc3NhZ2UudG9vbEludm9jYXRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2EubWFwKFxuICAgICh0b29sSW52b2NhdGlvbikgPT4gdG9vbEludm9jYXRpb24udG9vbENhbGxJZCA9PT0gdG9vbENhbGxJZCA/IHRvb2xSZXN1bHQgOiB0b29sSW52b2NhdGlvblxuICApO1xufVxuZXhwb3J0IHtcbiAgYXNTY2hlbWEsXG4gIGNhbGxDaGF0QXBpLFxuICBjYWxsQ29tcGxldGlvbkFwaSxcbiAgZXh0cmFjdE1heFRvb2xJbnZvY2F0aW9uU3RlcCxcbiAgZmlsbE1lc3NhZ2VQYXJ0cyxcbiAgZm9ybWF0QXNzaXN0YW50U3RyZWFtUGFydCxcbiAgZm9ybWF0RGF0YVN0cmVhbVBhcnQsXG4gIGdlbmVyYXRlSWQsXG4gIGdldE1lc3NhZ2VQYXJ0cyxcbiAgZ2V0VGV4dEZyb21EYXRhVXJsLFxuICBpc0Fzc2lzdGFudE1lc3NhZ2VXaXRoQ29tcGxldGVkVG9vbENhbGxzLFxuICBpc0RlZXBFcXVhbERhdGEsXG4gIGpzb25TY2hlbWEsXG4gIHBhcnNlQXNzaXN0YW50U3RyZWFtUGFydCxcbiAgcGFyc2VEYXRhU3RyZWFtUGFydCxcbiAgcGFyc2VQYXJ0aWFsSnNvbixcbiAgcHJlcGFyZUF0dGFjaG1lbnRzRm9yUmVxdWVzdCxcbiAgcHJvY2Vzc0Fzc2lzdGFudFN0cmVhbSxcbiAgcHJvY2Vzc0RhdGFTdHJlYW0sXG4gIHByb2Nlc3NUZXh0U3RyZWFtLFxuICBzaG91bGRSZXN1Ym1pdE1lc3NhZ2VzLFxuICB1cGRhdGVUb29sQ2FsbFJlc3VsdCxcbiAgem9kU2NoZW1hXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ai-sdk/ui-utils/dist/index.mjs\n");

/***/ })

};
;